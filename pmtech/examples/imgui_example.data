{
    "cmdline": "../third_party/pmbuild/scripts/jsn/jsn -i assets/configs/shadows.jsn -o build/web/data/configs/shadows.jsn -I ../assets/configs assets/configs ",
    "files": {
        "build/web/data/configs/shadows.jsn": [
            {
                "name": "/Users/alex.dixon/dev/pmtech/examples/assets/configs/shadows.jsn",
                "timestamp": 1608572066.9972663,
                "data_file": "data/configs/shadows.jsn"
            }
        ]
    }
}{
    "views": {
        "view_geom": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "clear_colour": [
                0.8,
                1.0,
                1.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "no_cull",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "pmfx_shader": "forward_render",
            "technique": "forward_lit",
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "main_view_no_clear": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "main_view": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "main_view_basic": {
            "raster_state": "default",
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "pmfx_shader": "forward_render",
            "technique": "simple_lighting",
            "sampler_bindings": [
                {
                    "texture": "single_shadow_map",
                    "unit": 7,
                    "state": "shadow_compare",
                    "shader": "ps"
                }
            ],
            "target": [
                "main_colour",
                "main_depth"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "main_view_alpha_blended": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "colour_write_mask": 15,
            "blend_state": "alpha_blend",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit",
                "alpha_blended"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear_lod",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "multiple_shadow_views": {
            "target": [
                "shadow_map"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "front_face_cull",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "zonly",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_shadow_maps"
            ],
            "render_flags": [
                "shadow_map"
            ]
        },
        "single_shadow_view": {
            "target": [
                "single_shadow_map"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "front_face_cull",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "zonly",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_shadow_maps"
            ],
            "render_flags": [
                "shadow_map"
            ]
        },
        "multiple_colour_shadow_views": {
            "target": [
                "colour_shadow_map",
                "colour_shadow_map_depth"
            ],
            "clear_colour": [
                0.0,
                1.0,
                1.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "back_face_cull",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "pmfx_shader": "forward_render",
            "technique": "gi",
            "scene_views": [
                "ecs_render_shadow_maps"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "multiple_omni_shadow_views": {
            "target": [
                "omni_shadow_map"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "front_face_cull",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "omni_shadow",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_omni_shadow_maps"
            ],
            "render_flags": [
                "shadow_map"
            ]
        },
        "multiple_area_light_views": {
            "target": [
                "area_light_textures"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "zonly",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_area_light_textures"
            ],
            "render_flags": [
                "area_light_textures"
            ],
            "generate_mip_maps": true
        },
        "main_view_post_processed": {
            "target": [
                "post_process_colour",
                "post_process_depth"
            ],
            "post_process": "editor_default",
            "resolve": [
                "average_4x",
                "max_4x"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "main_view_temporal_aa": {
            "target": [
                "taa_colour",
                "taa_depth"
            ],
            "post_process": "taa_resolve",
            "jitter": true,
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "velocity_buffer": {
            "target": [
                "velocity_buffer"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "pmfx_shader": "forward_render",
            "technique": "per_pixel_velocity",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "editor_main": {
            "raster_state": "default",
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "target": [
                "main_colour",
                "main_depth"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "editor_main_basic": {
            "raster_state": "default",
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "pmfx_shader": "forward_render",
            "technique": "simple_lighting",
            "sampler_bindings": [
                {
                    "texture": "single_shadow_map",
                    "unit": 7,
                    "state": "shadow_compare",
                    "shader": "ps"
                }
            ],
            "target": [
                "main_colour",
                "main_depth"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "editor_main_gi": {
            "raster_state": "default",
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "volume_gi",
                    "unit": 9,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ],
            "target": [
                "taa_colour",
                "taa_depth"
            ],
            "post_process": "taa_resolve",
            "jitter": true,
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "editor_view": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "wireframe",
            "depth_stencil_state": "default",
            "pmfx_shader": "pmfx_utility",
            "technique": "constant_colour",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_editor"
            ]
        },
        "picking_view": {
            "target": [
                "picking",
                "picking_ds"
            ],
            "clear": {
                "picking": {
                    "clear_colour_u": [
                        -1,
                        -1,
                        -1,
                        -1
                    ]
                }
            },
            "clear_depth": 1.0,
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "blend_state": "disabled",
            "raster_state": "default",
            "depth_stencil_state": "default",
            "pmfx_shader": "pmfx_utility",
            "technique": "picking",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ]
        },
        "volume_rasteriser": {
            "target": [
                "volume_raster",
                "volume_raster_ds"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "volume_raster",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "volume_rasteriser_camera",
            "pmfx_shader": "pmfx_utility",
            "technique": "volume_raster_albedo",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "wrap_linear",
                    "shader": "ps"
                }
            ]
        },
        "volume_gi_compute": {
            "type": "compute",
            "target": [
                "volume_gi"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "pmfx_shader": "compute",
            "technique": "volume_gi",
            "scene": "main_scene",
            "scene_views": [
                "ecs_compute_volume_gi"
            ],
            "generate_mip_maps": true
        },
        "gbuffer_view": {
            "target": [
                "gbuffer_albedo",
                "gbuffer_normals",
                "gbuffer_world_pos",
                "gbuffer_depth"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "clear_depth": 1.0,
            "clear": {
                "gbuffer_albedo": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                },
                "gbuffer_normals": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                },
                "gbuffer_world_pos": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                }
            },
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "blend_state": "disabled",
            "raster_state": "default",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "gbuffer",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ]
        },
        "deferred_lights_view": {
            "target": [
                "main_colour"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "additive",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "depth_always_no_write",
            "shader": "deferred_render",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_light_volumes"
            ],
            "sampler_bindings": [
                {
                    "texture": "gbuffer_albedo",
                    "unit": 0,
                    "state": "wrap_linear"
                },
                {
                    "texture": "gbuffer_normals",
                    "unit": 1,
                    "state": "wrap_linear"
                },
                {
                    "texture": "gbuffer_world_pos",
                    "unit": 2,
                    "state": "wrap_linear"
                },
                {
                    "texture": "gbuffer_depth",
                    "unit": 4,
                    "state": "wrap_linear"
                }
            ]
        },
        "gbuffer_view_msaa": {
            "target": [
                "gbuffer_albedo_msaa",
                "gbuffer_normals_msaa",
                "gbuffer_world_pos_msaa",
                "gbuffer_depth_msaa"
            ],
            "resolve": [
                "average_4x",
                "average_4x",
                "average_4x",
                "max_4x"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "clear_depth": 1.0,
            "clear": {
                "gbuffer_albedo": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                },
                "gbuffer_normals": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                },
                "gbuffer_world_pos": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                }
            },
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "blend_state": "disabled",
            "raster_state": "default",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "gbuffer",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ]
        },
        "deferred_lights_view_msaa": {
            "sampler_bindings": [
                {
                    "texture": "gbuffer_albedo_msaa",
                    "unit": 4,
                    "state": "wrap_linear",
                    "bind_flags": [
                        "ps",
                        "msaa"
                    ]
                },
                {
                    "texture": "gbuffer_normals_msaa",
                    "unit": 5,
                    "state": "wrap_linear",
                    "bind_flags": [
                        "ps",
                        "msaa"
                    ]
                },
                {
                    "texture": "gbuffer_world_pos_msaa",
                    "unit": 6,
                    "state": "wrap_linear",
                    "bind_flags": [
                        "ps",
                        "msaa"
                    ]
                },
                {
                    "texture": "gbuffer_depth_msaa",
                    "unit": 7,
                    "state": "wrap_linear",
                    "bind_flags": [
                        "ps",
                        "msaa"
                    ]
                }
            ],
            "permutation": 2,
            "target": [
                "main_colour"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "additive",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "depth_always_no_write",
            "shader": "deferred_render",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_light_volumes"
            ]
        },
        "blit": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "depth_always_no_write",
            "pmfx_shader": "post_process",
            "technique": "blit"
        },
        "blit_depth": {
            "clear_depth": 1.0,
            "colour_write_mask": 0,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "depth_always",
            "pmfx_shader": "post_process",
            "technique": "blit_depth"
        },
        "blit_colour_depth": {
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "depth_always",
            "pmfx_shader": "post_process",
            "technique": "blit_colour_depth"
        },
        "colour_lut": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "colour_lut"
        },
        "high_pass": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "high_pass"
        },
        "filter": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "filter"
        },
        "downsample_2x2": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "downsample_2x2"
        },
        "downsample_average": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "downsample_average"
        },
        "bloom_upsample": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "bloom_upsample"
        },
        "depth_of_field": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "depth_of_field",
            "camera": "model_viewer_camera"
        },
        "menger_sponge": {
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "depth_always",
            "pmfx_shader": "post_process",
            "technique": "menger_sponge",
            "camera": "model_viewer_camera"
        },
        "crt": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "crt",
            "camera": "model_viewer_camera"
        },
        "taa_resolve": {
            "colour_write_mask": 15,
            "clear_colour": [
                0.0,
                1.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "taa_resolve"
        }
    },
    "view_sets": {
        "geom": [
            "multiple_shadow_views",
            "multiple_area_light_views",
            "multiple_omni_shadow_views",
            "picking_view",
            "view_geom",
            "editor_view"
        ],
        "editor": [
            "multiple_shadow_views",
            "multiple_area_light_views",
            "multiple_omni_shadow_views",
            "picking_view",
            "editor_main",
            "editor_view"
        ],
        "editor_basic": [
            "single_shadow_view",
            "editor_main_basic",
            "editor_view"
        ],
        "editor_gi": [
            "multiple_shadow_views",
            "multiple_colour_shadow_views",
            "multiple_area_light_views",
            "multiple_omni_shadow_views",
            "volume_gi_compute",
            "picking_view",
            "editor_main_gi",
            "editor_view"
        ],
        "editor_post_processed": [
            "picking_view",
            "main_view_post_processed",
            "editor_view",
            "volume_rasteriser"
        ],
        "deferred_render": [
            "gbuffer_view",
            "deferred_lights_view"
        ],
        "deferred_render_msaa": [
            "gbuffer_view_msaa",
            "deferred_lights_view_msaa"
        ]
    },
    "view_set": "geom",
    "blend_states": {
        "disabled": {
            "blend_enable": false
        },
        "additive": {
            "blend_enable": true,
            "src_blend": "one",
            "dest_blend": "one"
        },
        "alpha_blend": {
            "blend_enable": true,
            "src_blend": "src_alpha",
            "dest_blend": "inv_src_alpha"
        }
    },
    "sampler_states": {
        "wrap_linear": {
            "filter": "linear",
            "address": "wrap"
        },
        "wrap_point": {
            "filter": "point",
            "address": "wrap"
        },
        "clamp_linear": {
            "filter": "linear",
            "address": "clamp"
        },
        "clamp_point": {
            "filter": "point",
            "address": "clamp"
        },
        "clamp_linear_lod": {
            "filter": "linear_lod",
            "address": "clamp"
        },
        "shadow_compare": {
            "filter": "linear",
            "address": "clamp",
            "comparison_func": "less"
        }
    },
    "depth_stencil_states": {
        "disabled": {
            "depth_enable": false
        },
        "default": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "less"
        },
        "depth_never": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "never"
        },
        "depth_always": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "always"
        },
        "depth_equal": {
            "depth_enable": true,
            "depth_write": false,
            "depth_func": "equal"
        },
        "depth_always_no_write": {
            "depth_enable": true,
            "depth_write": false,
            "depth_func": "always"
        },
        "stencil_test": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "always",
            "stencil_enable": true,
            "stencil_write_mask": 255,
            "stencil_read_mask": 255,
            "stencil_op": {
                "stencil_fail": "keep",
                "depth_fail": "keep",
                "stencil_pass": "replace",
                "stencil_func": "equal"
            }
        }
    },
    "raster_states": {
        "default": {
            "cull_mode": "back"
        },
        "wireframe": {
            "cull_mode": "none",
            "fill_mode": "wireframe"
        },
        "front_face_cull": {
            "cull_mode": "front",
            "fill_mode": "solid"
        },
        "volume_raster": {
            "cull_mode": "back"
        },
        "post_process": {
            "cull_mode": "none"
        },
        "no_cull": {
            "cull_mode": "none"
        },
        "disabled": {
            "cull_mode": "none"
        }
    },
    "render_targets": {
        "single_shadow_map": {
            "size": [
                2048,
                2048
            ],
            "format": "d32f"
        },
        "shadow_map": {
            "size": [
                2048,
                2048
            ],
            "format": "d32f",
            "type": "array"
        },
        "omni_shadow_map": {
            "size": [
                512,
                512
            ],
            "format": "d24s8",
            "type": "cube_array"
        },
        "colour_shadow_map": {
            "size": [
                512,
                512
            ],
            "format": "rgba8",
            "type": "array"
        },
        "colour_shadow_map_depth": {
            "size": [
                512,
                512
            ],
            "format": "d24s8",
            "type": "array"
        },
        "area_light_textures": {
            "size": [
                640,
                480
            ],
            "format": "rgba8",
            "type": "array",
            "mips": true
        },
        "taa_history": {
            "format": "rgba8",
            "size": "equal"
        },
        "taa_colour": {
            "format": "rgba8",
            "size": "equal"
        },
        "taa_depth": {
            "format": "d24s8",
            "size": "equal"
        },
        "velocity_buffer": {
            "format": "r32f",
            "size": "equal"
        },
        "picking": {
            "size": "equal",
            "format": "r32u",
            "cpu_read": true
        },
        "picking_ds": {
            "size": "equal",
            "format": "d24s8"
        },
        "volume_raster": {
            "size": [
                128,
                128
            ],
            "format": "rgba8",
            "cpu_read": true
        },
        "volume_raster_ds": {
            "size": [
                128,
                128
            ],
            "format": "d24s8"
        },
        "volume_gi": {
            "size": [
                256,
                256,
                256
            ],
            "format": "rgba8",
            "gpu_write": true,
            "mips": true
        },
        "gbuffer_depth": {
            "size": "equal",
            "format": "d24s8"
        },
        "gbuffer_albedo": {
            "size": "equal",
            "format": "rgba8"
        },
        "gbuffer_normals": {
            "size": "equal",
            "format": "rgba32f"
        },
        "gbuffer_world_pos": {
            "size": "equal",
            "format": "rgba32f"
        },
        "gbuffer_depth_msaa": {
            "size": "equal",
            "format": "d24s8",
            "samples": 4
        },
        "gbuffer_albedo_msaa": {
            "size": "equal",
            "format": "rgba8",
            "samples": 4
        },
        "gbuffer_normals_msaa": {
            "size": "equal",
            "format": "rgba32f",
            "samples": 4
        },
        "gbuffer_world_pos_msaa": {
            "size": "equal",
            "format": "rgba32f",
            "samples": 4
        },
        "post_process_colour": {
            "size": "equal",
            "samples": 4,
            "format": "rgba8"
        },
        "post_process_depth": {
            "size": "equal",
            "samples": 4,
            "format": "d24s8"
        },
        "pp_output_full": {
            "size": "equal",
            "format": "rgba8",
            "pp": "write",
            "init_read": "post_process_colour"
        },
        "pp_output_half": {
            "size": "half",
            "format": "rgba8",
            "pp": "write"
        },
        "pp_output_quarter": {
            "size": "quarter",
            "format": "rgba8",
            "pp": "write"
        },
        "pp_output_eighth": {
            "size": "eighth",
            "format": "rgba8",
            "pp": "write"
        }
    },
    "filter_kernels": {
        "gauss_5_1": {
            "weights": [
                0.06136,
                0.24477,
                0.38774,
                0.24477,
                0.06136
            ],
            "offsets": [
                -2.0,
                -1.0,
                0.0,
                1.0,
                2.0
            ]
        },
        "gauss_7_1": {
            "weights": [
                0.00598,
                0.060626,
                0.241843,
                0.383103,
                0.241843,
                0.060626,
                0.00598
            ],
            "offsets": [
                -3.0,
                -2.0,
                -1.0,
                0.0,
                1.0,
                2.0,
                3.0
            ]
        },
        "gauss_9_1": {
            "weights": [
                0.000229,
                0.005977,
                0.060598,
                0.241732,
                0.382928,
                0.241732,
                0.060598,
                0.005977,
                0.000229
            ],
            "offsets": [
                -4.0,
                -3.0,
                -2.0,
                -1.0,
                0.0,
                1.0,
                2.0,
                3.0,
                4.0
            ]
        },
        "poisson_disc_16": {
            "offsets_xy": [
                0.2069841,
                0.2245269,
                0.525808,
                -0.2310817,
                0.1383943,
                0.9056122,
                0.6633009,
                0.5129843,
                -0.4002792,
                0.3727058,
                0.07912822,
                -0.6512921,
                -0.7726067,
                -0.5151217,
                -0.3843193,
                -0.1494132,
                -0.9107782,
                0.2500633,
                0.6940153,
                -0.7098927,
                -0.1964669,
                -0.379389,
                -0.4769286,
                0.1840863,
                -0.247328,
                -0.8798459,
                0.4206541,
                -0.714772,
                0.5829348,
                -0.09794202,
                0.3691838,
                0.4140642
            ]
        },
        "unjitter": {
            "offsets": [],
            "weights": []
        }
    },
    "post_processes": {
        "bloom": [
            {
                "inherit": "high_pass",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal"
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical"
            },
            {
                "inherit": "downsample_average",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_half",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal"
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_half",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical"
            },
            {
                "inherit": "downsample_average",
                "target": [
                    "pp_output_quarter"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_half",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_quarter"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_quarter",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal"
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_quarter"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_quarter",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical"
            },
            {
                "inherit": "downsample_average",
                "target": [
                    "pp_output_eighth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_quarter",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_eighth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_eighth",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal"
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_eighth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_eighth",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical"
            },
            {
                "inherit": "bloom_upsample",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "post_process_colour",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_full",
                        "unit": 1,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_half",
                        "unit": 2,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_quarter",
                        "unit": 3,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_eighth",
                        "unit": 4,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "depth_of_field": [
            {
                "inherit": "downsample_2x2",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_half",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal"
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_half",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical"
            },
            {
                "inherit": "depth_of_field",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "post_process_depth",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_full",
                        "unit": 1,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_half",
                        "unit": 2,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "colour_lut": [
            {
                "inherit": "colour_lut",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "blit_depth": [
            {
                "inherit": "blit_depth",
                "target": [
                    "main_depth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "post_process_depth",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "blit_taa_depth": [
            {
                "inherit": "blit_depth",
                "technique": "blit_depth_unjittered",
                "target": [
                    "main_depth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "taa_depth",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "blit_post_process": [
            {
                "inherit": "blit",
                "target": [
                    "main_colour"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "blit_colour_depth": [
            {
                "inherit": "blit_colour_depth",
                "target": [
                    "main_colour",
                    "main_depth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "post_process_colour",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "post_process_depth",
                        "unit": 1,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "menger_sponge": [
            {
                "inherit": "menger_sponge",
                "target": [
                    "post_process_colour",
                    "post_process_depth"
                ],
                "pp_write_non_aux": true,
                "technique": "menger_sponge",
                "camera": "model_viewer_camera",
                "resolve": [
                    "average_4x",
                    "max_4x"
                ]
            }
        ],
        "crt": [
            {
                "inherit": "crt",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "sss_reflectance": [
            {
                "inherit": "filter",
                "target": [
                    "pp_output_full"
                ],
                "technique": "sss_reflectance",
                "camera": "model_viewer_camera",
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "post_process_depth",
                        "unit": 1,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_full"
                ],
                "technique": "sss_reflectance",
                "camera": "model_viewer_camera",
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "post_process_depth",
                        "unit": 1,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "taa_resolve": [
            {
                "inherit": "taa_resolve",
                "target": [
                    "pp_output_full"
                ],
                "technique": "taa_resolve",
                "camera": "model_viewer_camera",
                "scene_views": [
                    "ecs_taa_resolve"
                ],
                "sampler_bindings": [
                    {
                        "texture": "taa_colour",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "taa_depth",
                        "unit": 1,
                        "state": "clamp_point",
                        "shader": "ps"
                    },
                    {
                        "texture": "taa_history",
                        "unit": 2,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "blit",
                "target": [
                    "taa_history"
                ],
                "pp_write_non_aux": true,
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ]
    },
    "post_process_sets": {
        "blit_only": {
            "chain": [
                "blit_colour_depth"
            ]
        },
        "editor_default": {
            "chain": [
                "blit_depth",
                "blit_post_process"
            ]
        },
        "taa_resolve": {
            "chain": [
                "taa_resolve",
                "blit_taa_depth",
                "blit_post_process"
            ]
        }
    }
}{
    "cmdline": "../third_party/pmbuild/scripts/jsn/jsn -i ../assets/configs/common.jsn -o build/web/data/configs/common.jsn -I ../assets/configs assets/configs ",
    "files": {
        "build/web/data/configs/common.jsn": [
            {
                "name": "/Users/alex.dixon/dev/pmtech/assets/configs/common.jsn",
                "timestamp": 1608572066.9988992,
                "data_file": "data/configs/common.jsn"
            }
        ]
    }
}{
    "views": {
        "forward_render_main": {
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "target": [
                "main_colour",
                "main_depth"
            ],
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "zprepass": {
            "clear_depth": 1.0,
            "technique": "zonly",
            "target": [
                "main_colour",
                "main_depth"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "forward_render_zequal": {
            "clear_depth": false,
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "depth_stencil_state": "depth_equal",
            "target": [
                "main_colour",
                "main_depth"
            ],
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "main_view_no_clear": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "main_view": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "main_view_basic": {
            "raster_state": "default",
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "pmfx_shader": "forward_render",
            "technique": "simple_lighting",
            "sampler_bindings": [
                {
                    "texture": "single_shadow_map",
                    "unit": 7,
                    "state": "shadow_compare",
                    "shader": "ps"
                }
            ],
            "target": [
                "main_colour",
                "main_depth"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "main_view_alpha_blended": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "colour_write_mask": 15,
            "blend_state": "alpha_blend",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit",
                "alpha_blended"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear_lod",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "multiple_shadow_views": {
            "target": [
                "shadow_map"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "front_face_cull",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "zonly",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_shadow_maps"
            ],
            "render_flags": [
                "shadow_map"
            ]
        },
        "single_shadow_view": {
            "target": [
                "single_shadow_map"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "front_face_cull",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "zonly",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_shadow_maps"
            ],
            "render_flags": [
                "shadow_map"
            ]
        },
        "multiple_colour_shadow_views": {
            "target": [
                "colour_shadow_map",
                "colour_shadow_map_depth"
            ],
            "clear_colour": [
                0.0,
                1.0,
                1.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "back_face_cull",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "pmfx_shader": "forward_render",
            "technique": "gi",
            "scene_views": [
                "ecs_render_shadow_maps"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "multiple_omni_shadow_views": {
            "target": [
                "omni_shadow_map"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "front_face_cull",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "omni_shadow",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_omni_shadow_maps"
            ],
            "render_flags": [
                "shadow_map"
            ]
        },
        "multiple_area_light_views": {
            "target": [
                "area_light_textures"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "zonly",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_area_light_textures"
            ],
            "render_flags": [
                "area_light_textures"
            ],
            "generate_mip_maps": true
        },
        "main_view_post_processed": {
            "target": [
                "post_process_colour",
                "post_process_depth"
            ],
            "post_process": "editor_default",
            "resolve": [
                "average_4x",
                "max_4x"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "main_view_temporal_aa": {
            "target": [
                "taa_colour",
                "taa_depth"
            ],
            "post_process": "taa_resolve",
            "jitter": true,
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "velocity_buffer": {
            "target": [
                "velocity_buffer"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "pmfx_shader": "forward_render",
            "technique": "per_pixel_velocity",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "editor_main": {
            "raster_state": "default",
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "target": [
                "main_colour",
                "main_depth"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "editor_main_basic": {
            "raster_state": "default",
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "pmfx_shader": "forward_render",
            "technique": "simple_lighting",
            "sampler_bindings": [
                {
                    "texture": "single_shadow_map",
                    "unit": 7,
                    "state": "shadow_compare",
                    "shader": "ps"
                }
            ],
            "target": [
                "main_colour",
                "main_depth"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "editor_main_gi": {
            "raster_state": "default",
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "volume_gi",
                    "unit": 9,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ],
            "target": [
                "taa_colour",
                "taa_depth"
            ],
            "post_process": "taa_resolve",
            "jitter": true,
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "editor_view": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "wireframe",
            "depth_stencil_state": "default",
            "pmfx_shader": "pmfx_utility",
            "technique": "constant_colour",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_editor"
            ]
        },
        "picking_view": {
            "target": [
                "picking",
                "picking_ds"
            ],
            "clear": {
                "picking": {
                    "clear_colour_u": [
                        -1,
                        -1,
                        -1,
                        -1
                    ]
                }
            },
            "clear_depth": 1.0,
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "blend_state": "disabled",
            "raster_state": "default",
            "depth_stencil_state": "default",
            "pmfx_shader": "pmfx_utility",
            "technique": "picking",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ]
        },
        "volume_rasteriser": {
            "target": [
                "volume_raster",
                "volume_raster_ds"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "volume_raster",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "volume_rasteriser_camera",
            "pmfx_shader": "pmfx_utility",
            "technique": "volume_raster_albedo",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "wrap_linear",
                    "shader": "ps"
                }
            ]
        },
        "volume_gi_compute": {
            "type": "compute",
            "target": [
                "volume_gi"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "pmfx_shader": "compute",
            "technique": "volume_gi",
            "scene": "main_scene",
            "scene_views": [
                "ecs_compute_volume_gi"
            ],
            "generate_mip_maps": true
        },
        "gbuffer_view": {
            "target": [
                "gbuffer_albedo",
                "gbuffer_normals",
                "gbuffer_world_pos",
                "gbuffer_depth"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "clear_depth": 1.0,
            "clear": {
                "gbuffer_albedo": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                },
                "gbuffer_normals": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                },
                "gbuffer_world_pos": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                }
            },
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "blend_state": "disabled",
            "raster_state": "default",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "gbuffer",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ]
        },
        "deferred_lights_view": {
            "target": [
                "main_colour"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "additive",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "depth_always_no_write",
            "shader": "deferred_render",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_light_volumes"
            ],
            "sampler_bindings": [
                {
                    "texture": "gbuffer_albedo",
                    "unit": 0,
                    "state": "wrap_linear"
                },
                {
                    "texture": "gbuffer_normals",
                    "unit": 1,
                    "state": "wrap_linear"
                },
                {
                    "texture": "gbuffer_world_pos",
                    "unit": 2,
                    "state": "wrap_linear"
                },
                {
                    "texture": "gbuffer_depth",
                    "unit": 4,
                    "state": "wrap_linear"
                }
            ]
        },
        "gbuffer_view_msaa": {
            "target": [
                "gbuffer_albedo_msaa",
                "gbuffer_normals_msaa",
                "gbuffer_world_pos_msaa",
                "gbuffer_depth_msaa"
            ],
            "resolve": [
                "average_4x",
                "average_4x",
                "average_4x",
                "max_4x"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "clear_depth": 1.0,
            "clear": {
                "gbuffer_albedo": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                },
                "gbuffer_normals": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                },
                "gbuffer_world_pos": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                }
            },
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "blend_state": "disabled",
            "raster_state": "default",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "gbuffer",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ]
        },
        "deferred_lights_view_msaa": {
            "sampler_bindings": [
                {
                    "texture": "gbuffer_albedo_msaa",
                    "unit": 4,
                    "state": "wrap_linear",
                    "bind_flags": [
                        "ps",
                        "msaa"
                    ]
                },
                {
                    "texture": "gbuffer_normals_msaa",
                    "unit": 5,
                    "state": "wrap_linear",
                    "bind_flags": [
                        "ps",
                        "msaa"
                    ]
                },
                {
                    "texture": "gbuffer_world_pos_msaa",
                    "unit": 6,
                    "state": "wrap_linear",
                    "bind_flags": [
                        "ps",
                        "msaa"
                    ]
                },
                {
                    "texture": "gbuffer_depth_msaa",
                    "unit": 7,
                    "state": "wrap_linear",
                    "bind_flags": [
                        "ps",
                        "msaa"
                    ]
                }
            ],
            "permutation": 2,
            "target": [
                "main_colour"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "additive",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "depth_always_no_write",
            "shader": "deferred_render",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_light_volumes"
            ]
        },
        "blit": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "depth_always_no_write",
            "pmfx_shader": "post_process",
            "technique": "blit"
        },
        "blit_depth": {
            "clear_depth": 1.0,
            "colour_write_mask": 0,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "depth_always",
            "pmfx_shader": "post_process",
            "technique": "blit_depth"
        },
        "blit_colour_depth": {
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "depth_always",
            "pmfx_shader": "post_process",
            "technique": "blit_colour_depth"
        },
        "colour_lut": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "colour_lut"
        },
        "high_pass": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "high_pass"
        },
        "filter": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "filter"
        },
        "downsample_2x2": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "downsample_2x2"
        },
        "downsample_average": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "downsample_average"
        },
        "bloom_upsample": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "bloom_upsample"
        },
        "depth_of_field": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "depth_of_field",
            "camera": "model_viewer_camera"
        },
        "menger_sponge": {
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "depth_always",
            "pmfx_shader": "post_process",
            "technique": "menger_sponge",
            "camera": "model_viewer_camera"
        },
        "crt": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "crt",
            "camera": "model_viewer_camera"
        },
        "taa_resolve": {
            "colour_write_mask": 15,
            "clear_colour": [
                0.0,
                1.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "taa_resolve"
        }
    },
    "view_sets": {
        "forward_render": [
            "forward_render_main"
        ],
        "forward_render_zprepass": [
            "zprepass",
            "forward_render_zequal"
        ],
        "editor": [
            "multiple_shadow_views",
            "multiple_area_light_views",
            "multiple_omni_shadow_views",
            "picking_view",
            "editor_main",
            "editor_view"
        ],
        "editor_basic": [
            "single_shadow_view",
            "editor_main_basic",
            "editor_view"
        ],
        "editor_gi": [
            "multiple_shadow_views",
            "multiple_colour_shadow_views",
            "multiple_area_light_views",
            "multiple_omni_shadow_views",
            "volume_gi_compute",
            "picking_view",
            "editor_main_gi",
            "editor_view"
        ],
        "editor_post_processed": [
            "picking_view",
            "main_view_post_processed",
            "editor_view",
            "volume_rasteriser"
        ],
        "deferred_render": [
            "gbuffer_view",
            "deferred_lights_view"
        ],
        "deferred_render_msaa": [
            "gbuffer_view_msaa",
            "deferred_lights_view_msaa"
        ]
    },
    "view_set": "forward_render",
    "blend_states": {
        "disabled": {
            "blend_enable": false
        },
        "additive": {
            "blend_enable": true,
            "src_blend": "one",
            "dest_blend": "one"
        },
        "alpha_blend": {
            "blend_enable": true,
            "src_blend": "src_alpha",
            "dest_blend": "inv_src_alpha"
        }
    },
    "sampler_states": {
        "wrap_linear": {
            "filter": "linear",
            "address": "wrap"
        },
        "wrap_point": {
            "filter": "point",
            "address": "wrap"
        },
        "clamp_linear": {
            "filter": "linear",
            "address": "clamp"
        },
        "clamp_point": {
            "filter": "point",
            "address": "clamp"
        },
        "clamp_linear_lod": {
            "filter": "linear_lod",
            "address": "clamp"
        },
        "shadow_compare": {
            "filter": "linear",
            "address": "clamp",
            "comparison_func": "less"
        }
    },
    "depth_stencil_states": {
        "disabled": {
            "depth_enable": false
        },
        "default": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "less"
        },
        "depth_never": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "never"
        },
        "depth_always": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "always"
        },
        "depth_equal": {
            "depth_enable": true,
            "depth_write": false,
            "depth_func": "equal"
        },
        "depth_always_no_write": {
            "depth_enable": true,
            "depth_write": false,
            "depth_func": "always"
        },
        "stencil_test": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "always",
            "stencil_enable": true,
            "stencil_write_mask": 255,
            "stencil_read_mask": 255,
            "stencil_op": {
                "stencil_fail": "keep",
                "depth_fail": "keep",
                "stencil_pass": "replace",
                "stencil_func": "equal"
            }
        }
    },
    "raster_states": {
        "default": {
            "cull_mode": "back"
        },
        "wireframe": {
            "cull_mode": "none",
            "fill_mode": "wireframe"
        },
        "front_face_cull": {
            "cull_mode": "front",
            "fill_mode": "solid"
        },
        "volume_raster": {
            "cull_mode": "back"
        },
        "post_process": {
            "cull_mode": "none"
        },
        "no_cull": {
            "cull_mode": "none"
        },
        "disabled": {
            "cull_mode": "none"
        }
    },
    "render_targets": {
        "single_shadow_map": {
            "size": [
                2048,
                2048
            ],
            "format": "d32f"
        },
        "shadow_map": {
            "size": [
                2048,
                2048
            ],
            "format": "d32f",
            "type": "array"
        },
        "omni_shadow_map": {
            "size": [
                512,
                512
            ],
            "format": "d24s8",
            "type": "cube_array"
        },
        "colour_shadow_map": {
            "size": [
                512,
                512
            ],
            "format": "rgba8",
            "type": "array"
        },
        "colour_shadow_map_depth": {
            "size": [
                512,
                512
            ],
            "format": "d24s8",
            "type": "array"
        },
        "area_light_textures": {
            "size": [
                640,
                480
            ],
            "format": "rgba8",
            "type": "array",
            "mips": true
        },
        "taa_history": {
            "format": "rgba8",
            "size": "equal"
        },
        "taa_colour": {
            "format": "rgba8",
            "size": "equal"
        },
        "taa_depth": {
            "format": "d24s8",
            "size": "equal"
        },
        "velocity_buffer": {
            "format": "r32f",
            "size": "equal"
        },
        "picking": {
            "size": "equal",
            "format": "r32u",
            "cpu_read": true
        },
        "picking_ds": {
            "size": "equal",
            "format": "d24s8"
        },
        "volume_raster": {
            "size": [
                128,
                128
            ],
            "format": "rgba8",
            "cpu_read": true
        },
        "volume_raster_ds": {
            "size": [
                128,
                128
            ],
            "format": "d24s8"
        },
        "volume_gi": {
            "size": [
                256,
                256,
                256
            ],
            "format": "rgba8",
            "gpu_write": true,
            "mips": true
        },
        "gbuffer_depth": {
            "size": "equal",
            "format": "d24s8"
        },
        "gbuffer_albedo": {
            "size": "equal",
            "format": "rgba8"
        },
        "gbuffer_normals": {
            "size": "equal",
            "format": "rgba32f"
        },
        "gbuffer_world_pos": {
            "size": "equal",
            "format": "rgba32f"
        },
        "gbuffer_depth_msaa": {
            "size": "equal",
            "format": "d24s8",
            "samples": 4
        },
        "gbuffer_albedo_msaa": {
            "size": "equal",
            "format": "rgba8",
            "samples": 4
        },
        "gbuffer_normals_msaa": {
            "size": "equal",
            "format": "rgba32f",
            "samples": 4
        },
        "gbuffer_world_pos_msaa": {
            "size": "equal",
            "format": "rgba32f",
            "samples": 4
        },
        "post_process_colour": {
            "size": "equal",
            "samples": 4,
            "format": "rgba8"
        },
        "post_process_depth": {
            "size": "equal",
            "samples": 4,
            "format": "d24s8"
        },
        "pp_output_full": {
            "size": "equal",
            "format": "rgba8",
            "pp": "write",
            "init_read": "post_process_colour"
        },
        "pp_output_half": {
            "size": "half",
            "format": "rgba8",
            "pp": "write"
        },
        "pp_output_quarter": {
            "size": "quarter",
            "format": "rgba8",
            "pp": "write"
        },
        "pp_output_eighth": {
            "size": "eighth",
            "format": "rgba8",
            "pp": "write"
        }
    },
    "filter_kernels": {
        "gauss_5_1": {
            "weights": [
                0.06136,
                0.24477,
                0.38774,
                0.24477,
                0.06136
            ],
            "offsets": [
                -2.0,
                -1.0,
                0.0,
                1.0,
                2.0
            ]
        },
        "gauss_7_1": {
            "weights": [
                0.00598,
                0.060626,
                0.241843,
                0.383103,
                0.241843,
                0.060626,
                0.00598
            ],
            "offsets": [
                -3.0,
                -2.0,
                -1.0,
                0.0,
                1.0,
                2.0,
                3.0
            ]
        },
        "gauss_9_1": {
            "weights": [
                0.000229,
                0.005977,
                0.060598,
                0.241732,
                0.382928,
                0.241732,
                0.060598,
                0.005977,
                0.000229
            ],
            "offsets": [
                -4.0,
                -3.0,
                -2.0,
                -1.0,
                0.0,
                1.0,
                2.0,
                3.0,
                4.0
            ]
        },
        "poisson_disc_16": {
            "offsets_xy": [
                0.2069841,
                0.2245269,
                0.525808,
                -0.2310817,
                0.1383943,
                0.9056122,
                0.6633009,
                0.5129843,
                -0.4002792,
                0.3727058,
                0.07912822,
                -0.6512921,
                -0.7726067,
                -0.5151217,
                -0.3843193,
                -0.1494132,
                -0.9107782,
                0.2500633,
                0.6940153,
                -0.7098927,
                -0.1964669,
                -0.379389,
                -0.4769286,
                0.1840863,
                -0.247328,
                -0.8798459,
                0.4206541,
                -0.714772,
                0.5829348,
                -0.09794202,
                0.3691838,
                0.4140642
            ]
        },
        "unjitter": {
            "offsets": [],
            "weights": []
        }
    },
    "post_processes": {
        "bloom": [
            {
                "inherit": "high_pass",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal"
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical"
            },
            {
                "inherit": "downsample_average",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_half",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal"
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_half",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical"
            },
            {
                "inherit": "downsample_average",
                "target": [
                    "pp_output_quarter"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_half",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_quarter"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_quarter",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal"
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_quarter"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_quarter",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical"
            },
            {
                "inherit": "downsample_average",
                "target": [
                    "pp_output_eighth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_quarter",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_eighth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_eighth",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal"
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_eighth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_eighth",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical"
            },
            {
                "inherit": "bloom_upsample",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "post_process_colour",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_full",
                        "unit": 1,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_half",
                        "unit": 2,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_quarter",
                        "unit": 3,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_eighth",
                        "unit": 4,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "depth_of_field": [
            {
                "inherit": "downsample_2x2",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_half",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal"
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_half",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical"
            },
            {
                "inherit": "depth_of_field",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "post_process_depth",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_full",
                        "unit": 1,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_half",
                        "unit": 2,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "colour_lut": [
            {
                "inherit": "colour_lut",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "blit_depth": [
            {
                "inherit": "blit_depth",
                "target": [
                    "main_depth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "post_process_depth",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "blit_taa_depth": [
            {
                "inherit": "blit_depth",
                "technique": "blit_depth_unjittered",
                "target": [
                    "main_depth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "taa_depth",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "blit_post_process": [
            {
                "inherit": "blit",
                "target": [
                    "main_colour"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "blit_colour_depth": [
            {
                "inherit": "blit_colour_depth",
                "target": [
                    "main_colour",
                    "main_depth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "post_process_colour",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "post_process_depth",
                        "unit": 1,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "menger_sponge": [
            {
                "inherit": "menger_sponge",
                "target": [
                    "post_process_colour",
                    "post_process_depth"
                ],
                "pp_write_non_aux": true,
                "technique": "menger_sponge",
                "camera": "model_viewer_camera",
                "resolve": [
                    "average_4x",
                    "max_4x"
                ]
            }
        ],
        "crt": [
            {
                "inherit": "crt",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "sss_reflectance": [
            {
                "inherit": "filter",
                "target": [
                    "pp_output_full"
                ],
                "technique": "sss_reflectance",
                "camera": "model_viewer_camera",
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "post_process_depth",
                        "unit": 1,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_full"
                ],
                "technique": "sss_reflectance",
                "camera": "model_viewer_camera",
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "post_process_depth",
                        "unit": 1,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "taa_resolve": [
            {
                "inherit": "taa_resolve",
                "target": [
                    "pp_output_full"
                ],
                "technique": "taa_resolve",
                "camera": "model_viewer_camera",
                "scene_views": [
                    "ecs_taa_resolve"
                ],
                "sampler_bindings": [
                    {
                        "texture": "taa_colour",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "taa_depth",
                        "unit": 1,
                        "state": "clamp_point",
                        "shader": "ps"
                    },
                    {
                        "texture": "taa_history",
                        "unit": 2,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "blit",
                "target": [
                    "taa_history"
                ],
                "pp_write_non_aux": true,
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ]
    },
    "post_process_sets": {
        "blit_only": {
            "chain": [
                "blit_colour_depth"
            ]
        },
        "editor_default": {
            "chain": [
                "blit_depth",
                "blit_post_process"
            ]
        },
        "taa_resolve": {
            "chain": [
                "taa_resolve",
                "blit_taa_depth",
                "blit_post_process"
            ]
        }
    }
}{
    "render_targets": {
        "msaa_colour": {
            "size": "equal",
            "format": "rgba8",
            "samples": 4
        },
        "msaa_depth": {
            "size": "equal",
            "format": "d24s8",
            "samples": 4
        },
        "msaa_custom": {
            "size": "equal",
            "format": "rgba8",
            "samples": 4
        },
        "single_shadow_map": {
            "size": [
                2048,
                2048
            ],
            "format": "d32f"
        },
        "shadow_map": {
            "size": [
                2048,
                2048
            ],
            "format": "d32f",
            "type": "array"
        },
        "omni_shadow_map": {
            "size": [
                512,
                512
            ],
            "format": "d24s8",
            "type": "cube_array"
        },
        "colour_shadow_map": {
            "size": [
                512,
                512
            ],
            "format": "rgba8",
            "type": "array"
        },
        "colour_shadow_map_depth": {
            "size": [
                512,
                512
            ],
            "format": "d24s8",
            "type": "array"
        },
        "area_light_textures": {
            "size": [
                640,
                480
            ],
            "format": "rgba8",
            "type": "array",
            "mips": true
        },
        "taa_history": {
            "format": "rgba8",
            "size": "equal"
        },
        "taa_colour": {
            "format": "rgba8",
            "size": "equal"
        },
        "taa_depth": {
            "format": "d24s8",
            "size": "equal"
        },
        "velocity_buffer": {
            "format": "r32f",
            "size": "equal"
        }
    },
    "views": {
        "mssr": {
            "target": [
                "msaa_colour",
                "msaa_depth"
            ],
            "clear_colour": [
                0.5,
                1.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "resolve": [
                "average_4x",
                "max_4x"
            ],
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "mssc": {
            "target": [
                "msaa_custom"
            ],
            "clear_colour": [
                1.0,
                0.0,
                0.5,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "resolve": [
                "custom_4x"
            ],
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "main_view_no_clear": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "main_view": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "main_view_basic": {
            "raster_state": "default",
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "pmfx_shader": "forward_render",
            "technique": "simple_lighting",
            "sampler_bindings": [
                {
                    "texture": "single_shadow_map",
                    "unit": 7,
                    "state": "shadow_compare",
                    "shader": "ps"
                }
            ],
            "target": [
                "main_colour",
                "main_depth"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "main_view_alpha_blended": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "colour_write_mask": 15,
            "blend_state": "alpha_blend",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit",
                "alpha_blended"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear_lod",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "multiple_shadow_views": {
            "target": [
                "shadow_map"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "front_face_cull",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "zonly",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_shadow_maps"
            ],
            "render_flags": [
                "shadow_map"
            ]
        },
        "single_shadow_view": {
            "target": [
                "single_shadow_map"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "front_face_cull",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "zonly",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_shadow_maps"
            ],
            "render_flags": [
                "shadow_map"
            ]
        },
        "multiple_colour_shadow_views": {
            "target": [
                "colour_shadow_map",
                "colour_shadow_map_depth"
            ],
            "clear_colour": [
                0.0,
                1.0,
                1.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "back_face_cull",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "pmfx_shader": "forward_render",
            "technique": "gi",
            "scene_views": [
                "ecs_render_shadow_maps"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "multiple_omni_shadow_views": {
            "target": [
                "omni_shadow_map"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "front_face_cull",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "omni_shadow",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_omni_shadow_maps"
            ],
            "render_flags": [
                "shadow_map"
            ]
        },
        "multiple_area_light_views": {
            "target": [
                "area_light_textures"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "zonly",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_area_light_textures"
            ],
            "render_flags": [
                "area_light_textures"
            ],
            "generate_mip_maps": true
        },
        "main_view_post_processed": {
            "target": [
                "post_process_colour",
                "post_process_depth"
            ],
            "post_process": "editor_default",
            "resolve": [
                "average_4x",
                "max_4x"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "main_view_temporal_aa": {
            "target": [
                "taa_colour",
                "taa_depth"
            ],
            "post_process": "taa_resolve",
            "jitter": true,
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "velocity_buffer": {
            "target": [
                "velocity_buffer"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "pmfx_shader": "forward_render",
            "technique": "per_pixel_velocity",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ]
        }
    },
    "view_sets": {
        "rtmm_view_set": [
            "mssr",
            "mssc",
            "main_view"
        ]
    },
    "view_set": "rtmm_view_set",
    "blend_states": {
        "disabled": {
            "blend_enable": false
        },
        "additive": {
            "blend_enable": true,
            "src_blend": "one",
            "dest_blend": "one"
        },
        "alpha_blend": {
            "blend_enable": true,
            "src_blend": "src_alpha",
            "dest_blend": "inv_src_alpha"
        }
    },
    "sampler_states": {
        "wrap_linear": {
            "filter": "linear",
            "address": "wrap"
        },
        "wrap_point": {
            "filter": "point",
            "address": "wrap"
        },
        "clamp_linear": {
            "filter": "linear",
            "address": "clamp"
        },
        "clamp_point": {
            "filter": "point",
            "address": "clamp"
        },
        "clamp_linear_lod": {
            "filter": "linear_lod",
            "address": "clamp"
        },
        "shadow_compare": {
            "filter": "linear",
            "address": "clamp",
            "comparison_func": "less"
        }
    },
    "depth_stencil_states": {
        "disabled": {
            "depth_enable": false
        },
        "default": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "less"
        },
        "depth_never": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "never"
        },
        "depth_always": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "always"
        },
        "depth_equal": {
            "depth_enable": true,
            "depth_write": false,
            "depth_func": "equal"
        },
        "depth_always_no_write": {
            "depth_enable": true,
            "depth_write": false,
            "depth_func": "always"
        },
        "stencil_test": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "always",
            "stencil_enable": true,
            "stencil_write_mask": 255,
            "stencil_read_mask": 255,
            "stencil_op": {
                "stencil_fail": "keep",
                "depth_fail": "keep",
                "stencil_pass": "replace",
                "stencil_func": "equal"
            }
        }
    },
    "raster_states": {
        "default": {
            "cull_mode": "back"
        },
        "wireframe": {
            "cull_mode": "none",
            "fill_mode": "wireframe"
        },
        "front_face_cull": {
            "cull_mode": "front",
            "fill_mode": "solid"
        },
        "volume_raster": {
            "cull_mode": "back"
        },
        "post_process": {
            "cull_mode": "none"
        },
        "no_cull": {
            "cull_mode": "none"
        },
        "disabled": {
            "cull_mode": "none"
        }
    }
}{
    "cmdline": "../third_party/pmbuild/scripts/jsn/jsn -i assets/configs/stencil_buffer.jsn -o build/web/data/configs/stencil_buffer.jsn -I ../assets/configs assets/configs ",
    "files": {
        "build/web/data/configs/stencil_buffer.jsn": [
            {
                "name": "/Users/alex.dixon/dev/pmtech/examples/assets/configs/stencil_buffer.jsn",
                "timestamp": 1608572066.9975598,
                "data_file": "data/configs/stencil_buffer.jsn"
            }
        ]
    }
}{
    "views": {
        "pp_main_view": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "post_process": "pp_demo"
        },
        "main_view_no_clear": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "main_view": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "main_view_basic": {
            "raster_state": "default",
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "pmfx_shader": "forward_render",
            "technique": "simple_lighting",
            "sampler_bindings": [
                {
                    "texture": "single_shadow_map",
                    "unit": 7,
                    "state": "shadow_compare",
                    "shader": "ps"
                }
            ],
            "target": [
                "main_colour",
                "main_depth"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "main_view_alpha_blended": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "colour_write_mask": 15,
            "blend_state": "alpha_blend",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit",
                "alpha_blended"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear_lod",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "multiple_shadow_views": {
            "target": [
                "shadow_map"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "front_face_cull",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "zonly",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_shadow_maps"
            ],
            "render_flags": [
                "shadow_map"
            ]
        },
        "single_shadow_view": {
            "target": [
                "single_shadow_map"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "front_face_cull",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "zonly",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_shadow_maps"
            ],
            "render_flags": [
                "shadow_map"
            ]
        },
        "multiple_colour_shadow_views": {
            "target": [
                "colour_shadow_map",
                "colour_shadow_map_depth"
            ],
            "clear_colour": [
                0.0,
                1.0,
                1.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "back_face_cull",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "pmfx_shader": "forward_render",
            "technique": "gi",
            "scene_views": [
                "ecs_render_shadow_maps"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "multiple_omni_shadow_views": {
            "target": [
                "omni_shadow_map"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "front_face_cull",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "omni_shadow",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_omni_shadow_maps"
            ],
            "render_flags": [
                "shadow_map"
            ]
        },
        "multiple_area_light_views": {
            "target": [
                "area_light_textures"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "zonly",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_area_light_textures"
            ],
            "render_flags": [
                "area_light_textures"
            ],
            "generate_mip_maps": true
        },
        "main_view_post_processed": {
            "target": [
                "post_process_colour",
                "post_process_depth"
            ],
            "post_process": "editor_default",
            "resolve": [
                "average_4x",
                "max_4x"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "main_view_temporal_aa": {
            "target": [
                "taa_colour",
                "taa_depth"
            ],
            "post_process": "taa_resolve",
            "jitter": true,
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "velocity_buffer": {
            "target": [
                "velocity_buffer"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "pmfx_shader": "forward_render",
            "technique": "per_pixel_velocity",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "blit": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "depth_always_no_write",
            "pmfx_shader": "post_process",
            "technique": "blit"
        },
        "blit_depth": {
            "clear_depth": 1.0,
            "colour_write_mask": 0,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "depth_always",
            "pmfx_shader": "post_process",
            "technique": "blit_depth"
        },
        "blit_colour_depth": {
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "depth_always",
            "pmfx_shader": "post_process",
            "technique": "blit_colour_depth"
        },
        "colour_lut": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "colour_lut"
        },
        "high_pass": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "high_pass"
        },
        "filter": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "filter"
        },
        "downsample_2x2": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "downsample_2x2"
        },
        "downsample_average": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "downsample_average"
        },
        "bloom_upsample": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "bloom_upsample"
        },
        "depth_of_field": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "depth_of_field",
            "camera": "model_viewer_camera"
        },
        "menger_sponge": {
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "depth_always",
            "pmfx_shader": "post_process",
            "technique": "menger_sponge",
            "camera": "model_viewer_camera"
        },
        "crt": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "crt",
            "camera": "model_viewer_camera"
        },
        "taa_resolve": {
            "colour_write_mask": 15,
            "clear_colour": [
                0.0,
                1.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "taa_resolve"
        }
    },
    "post_process_sets": {
        "pp_demo": {
            "chain": [
                "menger_sponge",
                "bloom",
                "depth_of_field",
                "crt",
                "blit_post_process"
            ],
            "parameters": {
                "high_pass": {
                    "threshold": [
                        0.0
                    ],
                    "smoothness": [
                        0.289
                    ]
                },
                "bloom_upsample": {
                    "intensity": [
                        1.0
                    ]
                },
                "depth_of_field": {
                    "focus_centre": [
                        0.0
                    ],
                    "centre_range": [
                        0.0
                    ],
                    "focus_width": [
                        0.044
                    ],
                    "width_range": [
                        100.0
                    ]
                }
            }
        },
        "blit_only": {
            "chain": [
                "blit_colour_depth"
            ]
        },
        "editor_default": {
            "chain": [
                "blit_depth",
                "blit_post_process"
            ]
        },
        "taa_resolve": {
            "chain": [
                "taa_resolve",
                "blit_taa_depth",
                "blit_post_process"
            ]
        }
    },
    "view_sets": {
        "pp_view": [
            "pp_main_view"
        ]
    },
    "view_set": "pp_view",
    "blend_states": {
        "disabled": {
            "blend_enable": false
        },
        "additive": {
            "blend_enable": true,
            "src_blend": "one",
            "dest_blend": "one"
        },
        "alpha_blend": {
            "blend_enable": true,
            "src_blend": "src_alpha",
            "dest_blend": "inv_src_alpha"
        }
    },
    "sampler_states": {
        "wrap_linear": {
            "filter": "linear",
            "address": "wrap"
        },
        "wrap_point": {
            "filter": "point",
            "address": "wrap"
        },
        "clamp_linear": {
            "filter": "linear",
            "address": "clamp"
        },
        "clamp_point": {
            "filter": "point",
            "address": "clamp"
        },
        "clamp_linear_lod": {
            "filter": "linear_lod",
            "address": "clamp"
        },
        "shadow_compare": {
            "filter": "linear",
            "address": "clamp",
            "comparison_func": "less"
        }
    },
    "depth_stencil_states": {
        "disabled": {
            "depth_enable": false
        },
        "default": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "less"
        },
        "depth_never": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "never"
        },
        "depth_always": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "always"
        },
        "depth_equal": {
            "depth_enable": true,
            "depth_write": false,
            "depth_func": "equal"
        },
        "depth_always_no_write": {
            "depth_enable": true,
            "depth_write": false,
            "depth_func": "always"
        },
        "stencil_test": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "always",
            "stencil_enable": true,
            "stencil_write_mask": 255,
            "stencil_read_mask": 255,
            "stencil_op": {
                "stencil_fail": "keep",
                "depth_fail": "keep",
                "stencil_pass": "replace",
                "stencil_func": "equal"
            }
        }
    },
    "raster_states": {
        "default": {
            "cull_mode": "back"
        },
        "wireframe": {
            "cull_mode": "none",
            "fill_mode": "wireframe"
        },
        "front_face_cull": {
            "cull_mode": "front",
            "fill_mode": "solid"
        },
        "volume_raster": {
            "cull_mode": "back"
        },
        "post_process": {
            "cull_mode": "none"
        },
        "no_cull": {
            "cull_mode": "none"
        },
        "disabled": {
            "cull_mode": "none"
        }
    },
    "render_targets": {
        "single_shadow_map": {
            "size": [
                2048,
                2048
            ],
            "format": "d32f"
        },
        "shadow_map": {
            "size": [
                2048,
                2048
            ],
            "format": "d32f",
            "type": "array"
        },
        "omni_shadow_map": {
            "size": [
                512,
                512
            ],
            "format": "d24s8",
            "type": "cube_array"
        },
        "colour_shadow_map": {
            "size": [
                512,
                512
            ],
            "format": "rgba8",
            "type": "array"
        },
        "colour_shadow_map_depth": {
            "size": [
                512,
                512
            ],
            "format": "d24s8",
            "type": "array"
        },
        "area_light_textures": {
            "size": [
                640,
                480
            ],
            "format": "rgba8",
            "type": "array",
            "mips": true
        },
        "taa_history": {
            "format": "rgba8",
            "size": "equal"
        },
        "taa_colour": {
            "format": "rgba8",
            "size": "equal"
        },
        "taa_depth": {
            "format": "d24s8",
            "size": "equal"
        },
        "velocity_buffer": {
            "format": "r32f",
            "size": "equal"
        },
        "post_process_colour": {
            "size": "equal",
            "samples": 4,
            "format": "rgba8"
        },
        "post_process_depth": {
            "size": "equal",
            "samples": 4,
            "format": "d24s8"
        },
        "pp_output_full": {
            "size": "equal",
            "format": "rgba8",
            "pp": "write",
            "init_read": "post_process_colour"
        },
        "pp_output_half": {
            "size": "half",
            "format": "rgba8",
            "pp": "write"
        },
        "pp_output_quarter": {
            "size": "quarter",
            "format": "rgba8",
            "pp": "write"
        },
        "pp_output_eighth": {
            "size": "eighth",
            "format": "rgba8",
            "pp": "write"
        }
    },
    "filter_kernels": {
        "gauss_5_1": {
            "weights": [
                0.06136,
                0.24477,
                0.38774,
                0.24477,
                0.06136
            ],
            "offsets": [
                -2.0,
                -1.0,
                0.0,
                1.0,
                2.0
            ]
        },
        "gauss_7_1": {
            "weights": [
                0.00598,
                0.060626,
                0.241843,
                0.383103,
                0.241843,
                0.060626,
                0.00598
            ],
            "offsets": [
                -3.0,
                -2.0,
                -1.0,
                0.0,
                1.0,
                2.0,
                3.0
            ]
        },
        "gauss_9_1": {
            "weights": [
                0.000229,
                0.005977,
                0.060598,
                0.241732,
                0.382928,
                0.241732,
                0.060598,
                0.005977,
                0.000229
            ],
            "offsets": [
                -4.0,
                -3.0,
                -2.0,
                -1.0,
                0.0,
                1.0,
                2.0,
                3.0,
                4.0
            ]
        },
        "poisson_disc_16": {
            "offsets_xy": [
                0.2069841,
                0.2245269,
                0.525808,
                -0.2310817,
                0.1383943,
                0.9056122,
                0.6633009,
                0.5129843,
                -0.4002792,
                0.3727058,
                0.07912822,
                -0.6512921,
                -0.7726067,
                -0.5151217,
                -0.3843193,
                -0.1494132,
                -0.9107782,
                0.2500633,
                0.6940153,
                -0.7098927,
                -0.1964669,
                -0.379389,
                -0.4769286,
                0.1840863,
                -0.247328,
                -0.8798459,
                0.4206541,
                -0.714772,
                0.5829348,
                -0.09794202,
                0.3691838,
                0.4140642
            ]
        },
        "unjitter": {
            "offsets": [],
            "weights": []
        }
    },
    "post_processes": {
        "bloom": [
            {
                "inherit": "high_pass",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal"
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical"
            },
            {
                "inherit": "downsample_average",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_half",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal"
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_half",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical"
            },
            {
                "inherit": "downsample_average",
                "target": [
                    "pp_output_quarter"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_half",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_quarter"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_quarter",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal"
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_quarter"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_quarter",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical"
            },
            {
                "inherit": "downsample_average",
                "target": [
                    "pp_output_eighth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_quarter",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_eighth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_eighth",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal"
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_eighth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_eighth",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical"
            },
            {
                "inherit": "bloom_upsample",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "post_process_colour",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_full",
                        "unit": 1,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_half",
                        "unit": 2,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_quarter",
                        "unit": 3,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_eighth",
                        "unit": 4,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "depth_of_field": [
            {
                "inherit": "downsample_2x2",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_half",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal"
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_half",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical"
            },
            {
                "inherit": "depth_of_field",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "post_process_depth",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_full",
                        "unit": 1,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_half",
                        "unit": 2,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "colour_lut": [
            {
                "inherit": "colour_lut",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "blit_depth": [
            {
                "inherit": "blit_depth",
                "target": [
                    "main_depth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "post_process_depth",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "blit_taa_depth": [
            {
                "inherit": "blit_depth",
                "technique": "blit_depth_unjittered",
                "target": [
                    "main_depth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "taa_depth",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "blit_post_process": [
            {
                "inherit": "blit",
                "target": [
                    "main_colour"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "blit_colour_depth": [
            {
                "inherit": "blit_colour_depth",
                "target": [
                    "main_colour",
                    "main_depth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "post_process_colour",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "post_process_depth",
                        "unit": 1,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "menger_sponge": [
            {
                "inherit": "menger_sponge",
                "target": [
                    "post_process_colour",
                    "post_process_depth"
                ],
                "pp_write_non_aux": true,
                "technique": "menger_sponge",
                "camera": "model_viewer_camera",
                "resolve": [
                    "average_4x",
                    "max_4x"
                ]
            }
        ],
        "crt": [
            {
                "inherit": "crt",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "sss_reflectance": [
            {
                "inherit": "filter",
                "target": [
                    "pp_output_full"
                ],
                "technique": "sss_reflectance",
                "camera": "model_viewer_camera",
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "post_process_depth",
                        "unit": 1,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_full"
                ],
                "technique": "sss_reflectance",
                "camera": "model_viewer_camera",
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "post_process_depth",
                        "unit": 1,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "taa_resolve": [
            {
                "inherit": "taa_resolve",
                "target": [
                    "pp_output_full"
                ],
                "technique": "taa_resolve",
                "camera": "model_viewer_camera",
                "scene_views": [
                    "ecs_taa_resolve"
                ],
                "sampler_bindings": [
                    {
                        "texture": "taa_colour",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "taa_depth",
                        "unit": 1,
                        "state": "clamp_point",
                        "shader": "ps"
                    },
                    {
                        "texture": "taa_history",
                        "unit": 2,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "blit",
                "target": [
                    "taa_history"
                ],
                "pp_write_non_aux": true,
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ]
    }
}{
    "cmdline": "../third_party/pmbuild/scripts/jsn/jsn -i ../assets/configs/deferred_renderer.jsn -o build/web/data/configs/deferred_renderer.jsn -I ../assets/configs assets/configs ",
    "files": {
        "build/web/data/configs/deferred_renderer.jsn": [
            {
                "name": "/Users/alex.dixon/dev/pmtech/assets/configs/deferred_renderer.jsn",
                "timestamp": 1608572066.9990895,
                "data_file": "data/configs/deferred_renderer.jsn"
            }
        ]
    }
}{
    "cmdline": "../third_party/pmbuild/scripts/jsn/jsn -i assets/configs/stencil_shadows.jsn -o build/web/data/configs/stencil_shadows.jsn -I ../assets/configs assets/configs ",
    "files": {
        "build/web/data/configs/stencil_shadows.jsn": [
            {
                "name": "/Users/alex.dixon/dev/pmtech/examples/assets/configs/stencil_shadows.jsn",
                "timestamp": 1608572066.9978936,
                "data_file": "data/configs/stencil_shadows.jsn"
            }
        ]
    }
}{
    "cmdline": "../third_party/pmbuild/scripts/jsn/jsn -i assets/configs/mrt_example.jsn -o build/web/data/configs/mrt_example.jsn -I ../assets/configs assets/configs ",
    "files": {
        "build/web/data/configs/mrt_example.jsn": [
            {
                "name": "/Users/alex.dixon/dev/pmtech/examples/assets/configs/mrt_example.jsn",
                "timestamp": 1608572066.9964752,
                "data_file": "data/configs/mrt_example.jsn"
            }
        ]
    }
}{
    "render_targets": {
        "picking": {
            "size": "equal",
            "format": "r32u",
            "cpu_read": true
        },
        "picking_ds": {
            "size": "equal",
            "format": "d24s8"
        },
        "volume_raster": {
            "size": [
                128,
                128
            ],
            "format": "rgba8",
            "cpu_read": true
        },
        "volume_raster_ds": {
            "size": [
                128,
                128
            ],
            "format": "d24s8"
        },
        "volume_gi": {
            "size": [
                256,
                256,
                256
            ],
            "format": "rgba8",
            "gpu_write": true,
            "mips": true
        },
        "single_shadow_map": {
            "size": [
                2048,
                2048
            ],
            "format": "d32f"
        },
        "shadow_map": {
            "size": [
                2048,
                2048
            ],
            "format": "d32f",
            "type": "array"
        },
        "omni_shadow_map": {
            "size": [
                512,
                512
            ],
            "format": "d24s8",
            "type": "cube_array"
        },
        "colour_shadow_map": {
            "size": [
                512,
                512
            ],
            "format": "rgba8",
            "type": "array"
        },
        "colour_shadow_map_depth": {
            "size": [
                512,
                512
            ],
            "format": "d24s8",
            "type": "array"
        },
        "area_light_textures": {
            "size": [
                640,
                480
            ],
            "format": "rgba8",
            "type": "array",
            "mips": true
        },
        "taa_history": {
            "format": "rgba8",
            "size": "equal"
        },
        "taa_colour": {
            "format": "rgba8",
            "size": "equal"
        },
        "taa_depth": {
            "format": "d24s8",
            "size": "equal"
        },
        "velocity_buffer": {
            "format": "r32f",
            "size": "equal"
        },
        "gbuffer_depth": {
            "size": "equal",
            "format": "d24s8"
        },
        "gbuffer_albedo": {
            "size": "equal",
            "format": "rgba8"
        },
        "gbuffer_normals": {
            "size": "equal",
            "format": "rgba32f"
        },
        "gbuffer_world_pos": {
            "size": "equal",
            "format": "rgba32f"
        },
        "gbuffer_depth_msaa": {
            "size": "equal",
            "format": "d24s8",
            "samples": 4
        },
        "gbuffer_albedo_msaa": {
            "size": "equal",
            "format": "rgba8",
            "samples": 4
        },
        "gbuffer_normals_msaa": {
            "size": "equal",
            "format": "rgba32f",
            "samples": 4
        },
        "gbuffer_world_pos_msaa": {
            "size": "equal",
            "format": "rgba32f",
            "samples": 4
        },
        "post_process_colour": {
            "size": "equal",
            "samples": 4,
            "format": "rgba8"
        },
        "post_process_depth": {
            "size": "equal",
            "samples": 4,
            "format": "d24s8"
        },
        "pp_output_full": {
            "size": "equal",
            "format": "rgba8",
            "pp": "write",
            "init_read": "post_process_colour"
        },
        "pp_output_half": {
            "size": "half",
            "format": "rgba8",
            "pp": "write"
        },
        "pp_output_quarter": {
            "size": "quarter",
            "format": "rgba8",
            "pp": "write"
        },
        "pp_output_eighth": {
            "size": "eighth",
            "format": "rgba8",
            "pp": "write"
        }
    },
    "views": {
        "editor_main": {
            "raster_state": "default",
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "target": [
                "main_colour",
                "main_depth"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "editor_main_basic": {
            "raster_state": "default",
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "pmfx_shader": "forward_render",
            "technique": "simple_lighting",
            "sampler_bindings": [
                {
                    "texture": "single_shadow_map",
                    "unit": 7,
                    "state": "shadow_compare",
                    "shader": "ps"
                }
            ],
            "target": [
                "main_colour",
                "main_depth"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "editor_main_gi": {
            "raster_state": "default",
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "volume_gi",
                    "unit": 9,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ],
            "target": [
                "taa_colour",
                "taa_depth"
            ],
            "post_process": "taa_resolve",
            "jitter": true,
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "editor_view": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "wireframe",
            "depth_stencil_state": "default",
            "pmfx_shader": "pmfx_utility",
            "technique": "constant_colour",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_editor"
            ]
        },
        "picking_view": {
            "target": [
                "picking",
                "picking_ds"
            ],
            "clear": {
                "picking": {
                    "clear_colour_u": [
                        -1,
                        -1,
                        -1,
                        -1
                    ]
                }
            },
            "clear_depth": 1.0,
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "blend_state": "disabled",
            "raster_state": "default",
            "depth_stencil_state": "default",
            "pmfx_shader": "pmfx_utility",
            "technique": "picking",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ]
        },
        "volume_rasteriser": {
            "target": [
                "volume_raster",
                "volume_raster_ds"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "volume_raster",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "volume_rasteriser_camera",
            "pmfx_shader": "pmfx_utility",
            "technique": "volume_raster_albedo",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "wrap_linear",
                    "shader": "ps"
                }
            ]
        },
        "volume_gi_compute": {
            "type": "compute",
            "target": [
                "volume_gi"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "pmfx_shader": "compute",
            "technique": "volume_gi",
            "scene": "main_scene",
            "scene_views": [
                "ecs_compute_volume_gi"
            ],
            "generate_mip_maps": true
        },
        "main_view_no_clear": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "main_view": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "main_view_basic": {
            "raster_state": "default",
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "pmfx_shader": "forward_render",
            "technique": "simple_lighting",
            "sampler_bindings": [
                {
                    "texture": "single_shadow_map",
                    "unit": 7,
                    "state": "shadow_compare",
                    "shader": "ps"
                }
            ],
            "target": [
                "main_colour",
                "main_depth"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "main_view_alpha_blended": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "colour_write_mask": 15,
            "blend_state": "alpha_blend",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit",
                "alpha_blended"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear_lod",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "multiple_shadow_views": {
            "target": [
                "shadow_map"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "front_face_cull",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "zonly",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_shadow_maps"
            ],
            "render_flags": [
                "shadow_map"
            ]
        },
        "single_shadow_view": {
            "target": [
                "single_shadow_map"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "front_face_cull",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "zonly",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_shadow_maps"
            ],
            "render_flags": [
                "shadow_map"
            ]
        },
        "multiple_colour_shadow_views": {
            "target": [
                "colour_shadow_map",
                "colour_shadow_map_depth"
            ],
            "clear_colour": [
                0.0,
                1.0,
                1.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "back_face_cull",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "pmfx_shader": "forward_render",
            "technique": "gi",
            "scene_views": [
                "ecs_render_shadow_maps"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "multiple_omni_shadow_views": {
            "target": [
                "omni_shadow_map"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "front_face_cull",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "omni_shadow",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_omni_shadow_maps"
            ],
            "render_flags": [
                "shadow_map"
            ]
        },
        "multiple_area_light_views": {
            "target": [
                "area_light_textures"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "zonly",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_area_light_textures"
            ],
            "render_flags": [
                "area_light_textures"
            ],
            "generate_mip_maps": true
        },
        "main_view_post_processed": {
            "target": [
                "post_process_colour",
                "post_process_depth"
            ],
            "post_process": "editor_default",
            "resolve": [
                "average_4x",
                "max_4x"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "main_view_temporal_aa": {
            "target": [
                "taa_colour",
                "taa_depth"
            ],
            "post_process": "taa_resolve",
            "jitter": true,
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "velocity_buffer": {
            "target": [
                "velocity_buffer"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "pmfx_shader": "forward_render",
            "technique": "per_pixel_velocity",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "gbuffer_view": {
            "target": [
                "gbuffer_albedo",
                "gbuffer_normals",
                "gbuffer_world_pos",
                "gbuffer_depth"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "clear_depth": 1.0,
            "clear": {
                "gbuffer_albedo": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                },
                "gbuffer_normals": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                },
                "gbuffer_world_pos": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                }
            },
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "blend_state": "disabled",
            "raster_state": "default",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "gbuffer",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ]
        },
        "deferred_lights_view": {
            "target": [
                "main_colour"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "additive",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "depth_always_no_write",
            "shader": "deferred_render",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_light_volumes"
            ],
            "sampler_bindings": [
                {
                    "texture": "gbuffer_albedo",
                    "unit": 0,
                    "state": "wrap_linear"
                },
                {
                    "texture": "gbuffer_normals",
                    "unit": 1,
                    "state": "wrap_linear"
                },
                {
                    "texture": "gbuffer_world_pos",
                    "unit": 2,
                    "state": "wrap_linear"
                },
                {
                    "texture": "gbuffer_depth",
                    "unit": 4,
                    "state": "wrap_linear"
                }
            ]
        },
        "gbuffer_view_msaa": {
            "target": [
                "gbuffer_albedo_msaa",
                "gbuffer_normals_msaa",
                "gbuffer_world_pos_msaa",
                "gbuffer_depth_msaa"
            ],
            "resolve": [
                "average_4x",
                "average_4x",
                "average_4x",
                "max_4x"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "clear_depth": 1.0,
            "clear": {
                "gbuffer_albedo": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                },
                "gbuffer_normals": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                },
                "gbuffer_world_pos": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                }
            },
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "blend_state": "disabled",
            "raster_state": "default",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "gbuffer",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ]
        },
        "deferred_lights_view_msaa": {
            "sampler_bindings": [
                {
                    "texture": "gbuffer_albedo_msaa",
                    "unit": 4,
                    "state": "wrap_linear",
                    "bind_flags": [
                        "ps",
                        "msaa"
                    ]
                },
                {
                    "texture": "gbuffer_normals_msaa",
                    "unit": 5,
                    "state": "wrap_linear",
                    "bind_flags": [
                        "ps",
                        "msaa"
                    ]
                },
                {
                    "texture": "gbuffer_world_pos_msaa",
                    "unit": 6,
                    "state": "wrap_linear",
                    "bind_flags": [
                        "ps",
                        "msaa"
                    ]
                },
                {
                    "texture": "gbuffer_depth_msaa",
                    "unit": 7,
                    "state": "wrap_linear",
                    "bind_flags": [
                        "ps",
                        "msaa"
                    ]
                }
            ],
            "permutation": 2,
            "target": [
                "main_colour"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "additive",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "depth_always_no_write",
            "shader": "deferred_render",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_light_volumes"
            ]
        },
        "blit": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "depth_always_no_write",
            "pmfx_shader": "post_process",
            "technique": "blit"
        },
        "blit_depth": {
            "clear_depth": 1.0,
            "colour_write_mask": 0,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "depth_always",
            "pmfx_shader": "post_process",
            "technique": "blit_depth"
        },
        "blit_colour_depth": {
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "depth_always",
            "pmfx_shader": "post_process",
            "technique": "blit_colour_depth"
        },
        "colour_lut": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "colour_lut"
        },
        "high_pass": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "high_pass"
        },
        "filter": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "filter"
        },
        "downsample_2x2": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "downsample_2x2"
        },
        "downsample_average": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "downsample_average"
        },
        "bloom_upsample": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "bloom_upsample"
        },
        "depth_of_field": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "depth_of_field",
            "camera": "model_viewer_camera"
        },
        "menger_sponge": {
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "depth_always",
            "pmfx_shader": "post_process",
            "technique": "menger_sponge",
            "camera": "model_viewer_camera"
        },
        "crt": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "crt",
            "camera": "model_viewer_camera"
        },
        "taa_resolve": {
            "colour_write_mask": 15,
            "clear_colour": [
                0.0,
                1.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "taa_resolve"
        }
    },
    "view_sets": {
        "editor": [
            "multiple_shadow_views",
            "multiple_area_light_views",
            "multiple_omni_shadow_views",
            "picking_view",
            "editor_main",
            "editor_view"
        ],
        "editor_basic": [
            "single_shadow_view",
            "editor_main_basic",
            "editor_view"
        ],
        "editor_gi": [
            "multiple_shadow_views",
            "multiple_colour_shadow_views",
            "multiple_area_light_views",
            "multiple_omni_shadow_views",
            "volume_gi_compute",
            "picking_view",
            "editor_main_gi",
            "editor_view"
        ],
        "editor_post_processed": [
            "picking_view",
            "main_view_post_processed",
            "editor_view",
            "volume_rasteriser"
        ],
        "deferred_render": [
            "gbuffer_view",
            "deferred_lights_view"
        ],
        "deferred_render_msaa": [
            "gbuffer_view_msaa",
            "deferred_lights_view_msaa"
        ]
    },
    "view_set": "editor",
    "blend_states": {
        "disabled": {
            "blend_enable": false
        },
        "additive": {
            "blend_enable": true,
            "src_blend": "one",
            "dest_blend": "one"
        },
        "alpha_blend": {
            "blend_enable": true,
            "src_blend": "src_alpha",
            "dest_blend": "inv_src_alpha"
        }
    },
    "sampler_states": {
        "wrap_linear": {
            "filter": "linear",
            "address": "wrap"
        },
        "wrap_point": {
            "filter": "point",
            "address": "wrap"
        },
        "clamp_linear": {
            "filter": "linear",
            "address": "clamp"
        },
        "clamp_point": {
            "filter": "point",
            "address": "clamp"
        },
        "clamp_linear_lod": {
            "filter": "linear_lod",
            "address": "clamp"
        },
        "shadow_compare": {
            "filter": "linear",
            "address": "clamp",
            "comparison_func": "less"
        }
    },
    "depth_stencil_states": {
        "disabled": {
            "depth_enable": false
        },
        "default": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "less"
        },
        "depth_never": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "never"
        },
        "depth_always": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "always"
        },
        "depth_equal": {
            "depth_enable": true,
            "depth_write": false,
            "depth_func": "equal"
        },
        "depth_always_no_write": {
            "depth_enable": true,
            "depth_write": false,
            "depth_func": "always"
        },
        "stencil_test": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "always",
            "stencil_enable": true,
            "stencil_write_mask": 255,
            "stencil_read_mask": 255,
            "stencil_op": {
                "stencil_fail": "keep",
                "depth_fail": "keep",
                "stencil_pass": "replace",
                "stencil_func": "equal"
            }
        }
    },
    "raster_states": {
        "default": {
            "cull_mode": "back"
        },
        "wireframe": {
            "cull_mode": "none",
            "fill_mode": "wireframe"
        },
        "front_face_cull": {
            "cull_mode": "front",
            "fill_mode": "solid"
        },
        "volume_raster": {
            "cull_mode": "back"
        },
        "post_process": {
            "cull_mode": "none"
        },
        "no_cull": {
            "cull_mode": "none"
        },
        "disabled": {
            "cull_mode": "none"
        }
    },
    "filter_kernels": {
        "gauss_5_1": {
            "weights": [
                0.06136,
                0.24477,
                0.38774,
                0.24477,
                0.06136
            ],
            "offsets": [
                -2.0,
                -1.0,
                0.0,
                1.0,
                2.0
            ]
        },
        "gauss_7_1": {
            "weights": [
                0.00598,
                0.060626,
                0.241843,
                0.383103,
                0.241843,
                0.060626,
                0.00598
            ],
            "offsets": [
                -3.0,
                -2.0,
                -1.0,
                0.0,
                1.0,
                2.0,
                3.0
            ]
        },
        "gauss_9_1": {
            "weights": [
                0.000229,
                0.005977,
                0.060598,
                0.241732,
                0.382928,
                0.241732,
                0.060598,
                0.005977,
                0.000229
            ],
            "offsets": [
                -4.0,
                -3.0,
                -2.0,
                -1.0,
                0.0,
                1.0,
                2.0,
                3.0,
                4.0
            ]
        },
        "poisson_disc_16": {
            "offsets_xy": [
                0.2069841,
                0.2245269,
                0.525808,
                -0.2310817,
                0.1383943,
                0.9056122,
                0.6633009,
                0.5129843,
                -0.4002792,
                0.3727058,
                0.07912822,
                -0.6512921,
                -0.7726067,
                -0.5151217,
                -0.3843193,
                -0.1494132,
                -0.9107782,
                0.2500633,
                0.6940153,
                -0.7098927,
                -0.1964669,
                -0.379389,
                -0.4769286,
                0.1840863,
                -0.247328,
                -0.8798459,
                0.4206541,
                -0.714772,
                0.5829348,
                -0.09794202,
                0.3691838,
                0.4140642
            ]
        },
        "unjitter": {
            "offsets": [],
            "weights": []
        }
    },
    "post_processes": {
        "bloom": [
            {
                "inherit": "high_pass",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal"
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical"
            },
            {
                "inherit": "downsample_average",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_half",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal"
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_half",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical"
            },
            {
                "inherit": "downsample_average",
                "target": [
                    "pp_output_quarter"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_half",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_quarter"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_quarter",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal"
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_quarter"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_quarter",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical"
            },
            {
                "inherit": "downsample_average",
                "target": [
                    "pp_output_eighth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_quarter",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_eighth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_eighth",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal"
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_eighth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_eighth",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical"
            },
            {
                "inherit": "bloom_upsample",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "post_process_colour",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_full",
                        "unit": 1,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_half",
                        "unit": 2,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_quarter",
                        "unit": 3,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_eighth",
                        "unit": 4,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "depth_of_field": [
            {
                "inherit": "downsample_2x2",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_half",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal"
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_half",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical"
            },
            {
                "inherit": "depth_of_field",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "post_process_depth",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_full",
                        "unit": 1,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_half",
                        "unit": 2,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "colour_lut": [
            {
                "inherit": "colour_lut",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "blit_depth": [
            {
                "inherit": "blit_depth",
                "target": [
                    "main_depth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "post_process_depth",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "blit_taa_depth": [
            {
                "inherit": "blit_depth",
                "technique": "blit_depth_unjittered",
                "target": [
                    "main_depth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "taa_depth",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "blit_post_process": [
            {
                "inherit": "blit",
                "target": [
                    "main_colour"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "blit_colour_depth": [
            {
                "inherit": "blit_colour_depth",
                "target": [
                    "main_colour",
                    "main_depth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "post_process_colour",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "post_process_depth",
                        "unit": 1,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "menger_sponge": [
            {
                "inherit": "menger_sponge",
                "target": [
                    "post_process_colour",
                    "post_process_depth"
                ],
                "pp_write_non_aux": true,
                "technique": "menger_sponge",
                "camera": "model_viewer_camera",
                "resolve": [
                    "average_4x",
                    "max_4x"
                ]
            }
        ],
        "crt": [
            {
                "inherit": "crt",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "sss_reflectance": [
            {
                "inherit": "filter",
                "target": [
                    "pp_output_full"
                ],
                "technique": "sss_reflectance",
                "camera": "model_viewer_camera",
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "post_process_depth",
                        "unit": 1,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_full"
                ],
                "technique": "sss_reflectance",
                "camera": "model_viewer_camera",
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "post_process_depth",
                        "unit": 1,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "taa_resolve": [
            {
                "inherit": "taa_resolve",
                "target": [
                    "pp_output_full"
                ],
                "technique": "taa_resolve",
                "camera": "model_viewer_camera",
                "scene_views": [
                    "ecs_taa_resolve"
                ],
                "sampler_bindings": [
                    {
                        "texture": "taa_colour",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "taa_depth",
                        "unit": 1,
                        "state": "clamp_point",
                        "shader": "ps"
                    },
                    {
                        "texture": "taa_history",
                        "unit": 2,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "blit",
                "target": [
                    "taa_history"
                ],
                "pp_write_non_aux": true,
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ]
    },
    "post_process_sets": {
        "blit_only": {
            "chain": [
                "blit_colour_depth"
            ]
        },
        "editor_default": {
            "chain": [
                "blit_depth",
                "blit_post_process"
            ]
        },
        "taa_resolve": {
            "chain": [
                "taa_resolve",
                "blit_taa_depth",
                "blit_post_process"
            ]
        }
    }
}{
    "cmdline": "../third_party/pmbuild/scripts/jsn/jsn -i ../assets/configs/post_process.jsn -o build/web/data/configs/post_process.jsn -I ../assets/configs assets/configs ",
    "files": {
        "build/web/data/configs/post_process.jsn": [
            {
                "name": "/Users/alex.dixon/dev/pmtech/assets/configs/post_process.jsn",
                "timestamp": 1608572066.9987,
                "data_file": "data/configs/post_process.jsn"
            }
        ]
    }
}{
    "render_targets": {
        "chrome": {
            "size": [
                256,
                256
            ],
            "format": "rgba8",
            "type": "cube"
        },
        "chrome_depth": {
            "size": [
                256,
                256
            ],
            "format": "d24s8",
            "type": "cube"
        },
        "chrome2": {
            "size": [
                256,
                256
            ],
            "format": "rgba8",
            "type": "cube"
        },
        "chrome2_depth": {
            "size": [
                256,
                256
            ],
            "format": "d24s8",
            "type": "cube"
        },
        "single_shadow_map": {
            "size": [
                2048,
                2048
            ],
            "format": "d32f"
        },
        "shadow_map": {
            "size": [
                2048,
                2048
            ],
            "format": "d32f",
            "type": "array"
        },
        "omni_shadow_map": {
            "size": [
                512,
                512
            ],
            "format": "d24s8",
            "type": "cube_array"
        },
        "colour_shadow_map": {
            "size": [
                512,
                512
            ],
            "format": "rgba8",
            "type": "array"
        },
        "colour_shadow_map_depth": {
            "size": [
                512,
                512
            ],
            "format": "d24s8",
            "type": "array"
        },
        "area_light_textures": {
            "size": [
                640,
                480
            ],
            "format": "rgba8",
            "type": "array",
            "mips": true
        },
        "taa_history": {
            "format": "rgba8",
            "size": "equal"
        },
        "taa_colour": {
            "format": "rgba8",
            "size": "equal"
        },
        "taa_depth": {
            "format": "d24s8",
            "size": "equal"
        },
        "velocity_buffer": {
            "format": "r32f",
            "size": "equal"
        },
        "picking": {
            "size": "equal",
            "format": "r32u",
            "cpu_read": true
        },
        "picking_ds": {
            "size": "equal",
            "format": "d24s8"
        },
        "volume_raster": {
            "size": [
                128,
                128
            ],
            "format": "rgba8",
            "cpu_read": true
        },
        "volume_raster_ds": {
            "size": [
                128,
                128
            ],
            "format": "d24s8"
        },
        "volume_gi": {
            "size": [
                256,
                256,
                256
            ],
            "format": "rgba8",
            "gpu_write": true,
            "mips": true
        },
        "gbuffer_depth": {
            "size": "equal",
            "format": "d24s8"
        },
        "gbuffer_albedo": {
            "size": "equal",
            "format": "rgba8"
        },
        "gbuffer_normals": {
            "size": "equal",
            "format": "rgba32f"
        },
        "gbuffer_world_pos": {
            "size": "equal",
            "format": "rgba32f"
        },
        "gbuffer_depth_msaa": {
            "size": "equal",
            "format": "d24s8",
            "samples": 4
        },
        "gbuffer_albedo_msaa": {
            "size": "equal",
            "format": "rgba8",
            "samples": 4
        },
        "gbuffer_normals_msaa": {
            "size": "equal",
            "format": "rgba32f",
            "samples": 4
        },
        "gbuffer_world_pos_msaa": {
            "size": "equal",
            "format": "rgba32f",
            "samples": 4
        },
        "post_process_colour": {
            "size": "equal",
            "samples": 4,
            "format": "rgba8"
        },
        "post_process_depth": {
            "size": "equal",
            "samples": 4,
            "format": "d24s8"
        },
        "pp_output_full": {
            "size": "equal",
            "format": "rgba8",
            "pp": "write",
            "init_read": "post_process_colour"
        },
        "pp_output_half": {
            "size": "half",
            "format": "rgba8",
            "pp": "write"
        },
        "pp_output_quarter": {
            "size": "quarter",
            "format": "rgba8",
            "pp": "write"
        },
        "pp_output_eighth": {
            "size": "eighth",
            "format": "rgba8",
            "pp": "write"
        }
    },
    "views": {
        "demo_main": {
            "sampler_bindings": [
                {
                    "texture": "single_shadow_map",
                    "unit": 7,
                    "state": "shadow_compare",
                    "shader": "ps"
                }
            ],
            "target": [
                "main_colour",
                "main_depth"
            ],
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "sky": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "depth_always_no_write",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "pmfx_shader": "dynamic_cubemap_sky",
            "technique": "default",
            "scene_views": [
                "ecs_render_sky"
            ]
        },
        "sky_chrome1": {
            "target": [
                "chrome",
                "chrome_depth"
            ],
            "camera": "chrome_camera",
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "depth_always_no_write",
            "scene": "main_scene",
            "pmfx_shader": "dynamic_cubemap_sky",
            "technique": "default",
            "scene_views": [
                "ecs_render_sky"
            ]
        },
        "chrome1_cubemap_render": {
            "target": [
                "chrome",
                "chrome_depth"
            ],
            "camera": "chrome_camera",
            "sampler_bindings": [
                {
                    "texture": "single_shadow_map",
                    "unit": 7,
                    "state": "shadow_compare",
                    "shader": "ps"
                }
            ],
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "sky_chrome2": {
            "target": [
                "chrome2",
                "chrome2_depth"
            ],
            "camera": "chrome2_camera",
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "depth_always_no_write",
            "scene": "main_scene",
            "pmfx_shader": "dynamic_cubemap_sky",
            "technique": "default",
            "scene_views": [
                "ecs_render_sky"
            ]
        },
        "chrome2_cubemap_render": {
            "target": [
                "chrome2",
                "chrome2_depth"
            ],
            "camera": "chrome2_camera",
            "sampler_bindings": [
                {
                    "texture": "single_shadow_map",
                    "unit": 7,
                    "state": "shadow_compare",
                    "shader": "ps"
                }
            ],
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "main_view_no_clear": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "main_view": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "main_view_basic": {
            "raster_state": "default",
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "pmfx_shader": "forward_render",
            "technique": "simple_lighting",
            "sampler_bindings": [
                {
                    "texture": "single_shadow_map",
                    "unit": 7,
                    "state": "shadow_compare",
                    "shader": "ps"
                }
            ],
            "target": [
                "main_colour",
                "main_depth"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "main_view_alpha_blended": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "colour_write_mask": 15,
            "blend_state": "alpha_blend",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit",
                "alpha_blended"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear_lod",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "multiple_shadow_views": {
            "target": [
                "shadow_map"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "front_face_cull",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "zonly",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_shadow_maps"
            ],
            "render_flags": [
                "shadow_map"
            ]
        },
        "single_shadow_view": {
            "target": [
                "single_shadow_map"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "front_face_cull",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "zonly",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_shadow_maps"
            ],
            "render_flags": [
                "shadow_map"
            ]
        },
        "multiple_colour_shadow_views": {
            "target": [
                "colour_shadow_map",
                "colour_shadow_map_depth"
            ],
            "clear_colour": [
                0.0,
                1.0,
                1.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "back_face_cull",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "pmfx_shader": "forward_render",
            "technique": "gi",
            "scene_views": [
                "ecs_render_shadow_maps"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "multiple_omni_shadow_views": {
            "target": [
                "omni_shadow_map"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "front_face_cull",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "omni_shadow",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_omni_shadow_maps"
            ],
            "render_flags": [
                "shadow_map"
            ]
        },
        "multiple_area_light_views": {
            "target": [
                "area_light_textures"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "zonly",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_area_light_textures"
            ],
            "render_flags": [
                "area_light_textures"
            ],
            "generate_mip_maps": true
        },
        "main_view_post_processed": {
            "target": [
                "post_process_colour",
                "post_process_depth"
            ],
            "post_process": "editor_default",
            "resolve": [
                "average_4x",
                "max_4x"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "main_view_temporal_aa": {
            "target": [
                "taa_colour",
                "taa_depth"
            ],
            "post_process": "taa_resolve",
            "jitter": true,
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "velocity_buffer": {
            "target": [
                "velocity_buffer"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "pmfx_shader": "forward_render",
            "technique": "per_pixel_velocity",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "editor_main": {
            "raster_state": "default",
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "target": [
                "main_colour",
                "main_depth"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "editor_main_basic": {
            "raster_state": "default",
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "pmfx_shader": "forward_render",
            "technique": "simple_lighting",
            "sampler_bindings": [
                {
                    "texture": "single_shadow_map",
                    "unit": 7,
                    "state": "shadow_compare",
                    "shader": "ps"
                }
            ],
            "target": [
                "main_colour",
                "main_depth"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "editor_main_gi": {
            "raster_state": "default",
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "volume_gi",
                    "unit": 9,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ],
            "target": [
                "taa_colour",
                "taa_depth"
            ],
            "post_process": "taa_resolve",
            "jitter": true,
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "editor_view": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "wireframe",
            "depth_stencil_state": "default",
            "pmfx_shader": "pmfx_utility",
            "technique": "constant_colour",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_editor"
            ]
        },
        "picking_view": {
            "target": [
                "picking",
                "picking_ds"
            ],
            "clear": {
                "picking": {
                    "clear_colour_u": [
                        -1,
                        -1,
                        -1,
                        -1
                    ]
                }
            },
            "clear_depth": 1.0,
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "blend_state": "disabled",
            "raster_state": "default",
            "depth_stencil_state": "default",
            "pmfx_shader": "pmfx_utility",
            "technique": "picking",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ]
        },
        "volume_rasteriser": {
            "target": [
                "volume_raster",
                "volume_raster_ds"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "volume_raster",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "volume_rasteriser_camera",
            "pmfx_shader": "pmfx_utility",
            "technique": "volume_raster_albedo",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "wrap_linear",
                    "shader": "ps"
                }
            ]
        },
        "volume_gi_compute": {
            "type": "compute",
            "target": [
                "volume_gi"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "pmfx_shader": "compute",
            "technique": "volume_gi",
            "scene": "main_scene",
            "scene_views": [
                "ecs_compute_volume_gi"
            ],
            "generate_mip_maps": true
        },
        "gbuffer_view": {
            "target": [
                "gbuffer_albedo",
                "gbuffer_normals",
                "gbuffer_world_pos",
                "gbuffer_depth"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "clear_depth": 1.0,
            "clear": {
                "gbuffer_albedo": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                },
                "gbuffer_normals": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                },
                "gbuffer_world_pos": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                }
            },
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "blend_state": "disabled",
            "raster_state": "default",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "gbuffer",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ]
        },
        "deferred_lights_view": {
            "target": [
                "main_colour"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "additive",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "depth_always_no_write",
            "shader": "deferred_render",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_light_volumes"
            ],
            "sampler_bindings": [
                {
                    "texture": "gbuffer_albedo",
                    "unit": 0,
                    "state": "wrap_linear"
                },
                {
                    "texture": "gbuffer_normals",
                    "unit": 1,
                    "state": "wrap_linear"
                },
                {
                    "texture": "gbuffer_world_pos",
                    "unit": 2,
                    "state": "wrap_linear"
                },
                {
                    "texture": "gbuffer_depth",
                    "unit": 4,
                    "state": "wrap_linear"
                }
            ]
        },
        "gbuffer_view_msaa": {
            "target": [
                "gbuffer_albedo_msaa",
                "gbuffer_normals_msaa",
                "gbuffer_world_pos_msaa",
                "gbuffer_depth_msaa"
            ],
            "resolve": [
                "average_4x",
                "average_4x",
                "average_4x",
                "max_4x"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "clear_depth": 1.0,
            "clear": {
                "gbuffer_albedo": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                },
                "gbuffer_normals": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                },
                "gbuffer_world_pos": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                }
            },
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "blend_state": "disabled",
            "raster_state": "default",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "gbuffer",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ]
        },
        "deferred_lights_view_msaa": {
            "sampler_bindings": [
                {
                    "texture": "gbuffer_albedo_msaa",
                    "unit": 4,
                    "state": "wrap_linear",
                    "bind_flags": [
                        "ps",
                        "msaa"
                    ]
                },
                {
                    "texture": "gbuffer_normals_msaa",
                    "unit": 5,
                    "state": "wrap_linear",
                    "bind_flags": [
                        "ps",
                        "msaa"
                    ]
                },
                {
                    "texture": "gbuffer_world_pos_msaa",
                    "unit": 6,
                    "state": "wrap_linear",
                    "bind_flags": [
                        "ps",
                        "msaa"
                    ]
                },
                {
                    "texture": "gbuffer_depth_msaa",
                    "unit": 7,
                    "state": "wrap_linear",
                    "bind_flags": [
                        "ps",
                        "msaa"
                    ]
                }
            ],
            "permutation": 2,
            "target": [
                "main_colour"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "additive",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "depth_always_no_write",
            "shader": "deferred_render",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_light_volumes"
            ]
        },
        "blit": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "depth_always_no_write",
            "pmfx_shader": "post_process",
            "technique": "blit"
        },
        "blit_depth": {
            "clear_depth": 1.0,
            "colour_write_mask": 0,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "depth_always",
            "pmfx_shader": "post_process",
            "technique": "blit_depth"
        },
        "blit_colour_depth": {
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "depth_always",
            "pmfx_shader": "post_process",
            "technique": "blit_colour_depth"
        },
        "colour_lut": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "colour_lut"
        },
        "high_pass": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "high_pass"
        },
        "filter": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "filter"
        },
        "downsample_2x2": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "downsample_2x2"
        },
        "downsample_average": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "downsample_average"
        },
        "bloom_upsample": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "bloom_upsample"
        },
        "depth_of_field": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "depth_of_field",
            "camera": "model_viewer_camera"
        },
        "menger_sponge": {
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "depth_always",
            "pmfx_shader": "post_process",
            "technique": "menger_sponge",
            "camera": "model_viewer_camera"
        },
        "crt": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "crt",
            "camera": "model_viewer_camera"
        },
        "taa_resolve": {
            "colour_write_mask": 15,
            "clear_colour": [
                0.0,
                1.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "taa_resolve"
        }
    },
    "view_sets": {
        "dynamic_cubemap": [
            "single_shadow_view",
            "sky_chrome1",
            "chrome1_cubemap_render",
            "sky_chrome2",
            "chrome2_cubemap_render",
            "sky",
            "demo_main"
        ],
        "editor": [
            "multiple_shadow_views",
            "multiple_area_light_views",
            "multiple_omni_shadow_views",
            "picking_view",
            "editor_main",
            "editor_view"
        ],
        "editor_basic": [
            "single_shadow_view",
            "editor_main_basic",
            "editor_view"
        ],
        "editor_gi": [
            "multiple_shadow_views",
            "multiple_colour_shadow_views",
            "multiple_area_light_views",
            "multiple_omni_shadow_views",
            "volume_gi_compute",
            "picking_view",
            "editor_main_gi",
            "editor_view"
        ],
        "editor_post_processed": [
            "picking_view",
            "main_view_post_processed",
            "editor_view",
            "volume_rasteriser"
        ],
        "deferred_render": [
            "gbuffer_view",
            "deferred_lights_view"
        ],
        "deferred_render_msaa": [
            "gbuffer_view_msaa",
            "deferred_lights_view_msaa"
        ]
    },
    "view_set": "dynamic_cubemap",
    "blend_states": {
        "disabled": {
            "blend_enable": false
        },
        "additive": {
            "blend_enable": true,
            "src_blend": "one",
            "dest_blend": "one"
        },
        "alpha_blend": {
            "blend_enable": true,
            "src_blend": "src_alpha",
            "dest_blend": "inv_src_alpha"
        }
    },
    "sampler_states": {
        "wrap_linear": {
            "filter": "linear",
            "address": "wrap"
        },
        "wrap_point": {
            "filter": "point",
            "address": "wrap"
        },
        "clamp_linear": {
            "filter": "linear",
            "address": "clamp"
        },
        "clamp_point": {
            "filter": "point",
            "address": "clamp"
        },
        "clamp_linear_lod": {
            "filter": "linear_lod",
            "address": "clamp"
        },
        "shadow_compare": {
            "filter": "linear",
            "address": "clamp",
            "comparison_func": "less"
        }
    },
    "depth_stencil_states": {
        "disabled": {
            "depth_enable": false
        },
        "default": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "less"
        },
        "depth_never": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "never"
        },
        "depth_always": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "always"
        },
        "depth_equal": {
            "depth_enable": true,
            "depth_write": false,
            "depth_func": "equal"
        },
        "depth_always_no_write": {
            "depth_enable": true,
            "depth_write": false,
            "depth_func": "always"
        },
        "stencil_test": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "always",
            "stencil_enable": true,
            "stencil_write_mask": 255,
            "stencil_read_mask": 255,
            "stencil_op": {
                "stencil_fail": "keep",
                "depth_fail": "keep",
                "stencil_pass": "replace",
                "stencil_func": "equal"
            }
        }
    },
    "raster_states": {
        "default": {
            "cull_mode": "back"
        },
        "wireframe": {
            "cull_mode": "none",
            "fill_mode": "wireframe"
        },
        "front_face_cull": {
            "cull_mode": "front",
            "fill_mode": "solid"
        },
        "volume_raster": {
            "cull_mode": "back"
        },
        "post_process": {
            "cull_mode": "none"
        },
        "no_cull": {
            "cull_mode": "none"
        },
        "disabled": {
            "cull_mode": "none"
        }
    },
    "filter_kernels": {
        "gauss_5_1": {
            "weights": [
                0.06136,
                0.24477,
                0.38774,
                0.24477,
                0.06136
            ],
            "offsets": [
                -2.0,
                -1.0,
                0.0,
                1.0,
                2.0
            ]
        },
        "gauss_7_1": {
            "weights": [
                0.00598,
                0.060626,
                0.241843,
                0.383103,
                0.241843,
                0.060626,
                0.00598
            ],
            "offsets": [
                -3.0,
                -2.0,
                -1.0,
                0.0,
                1.0,
                2.0,
                3.0
            ]
        },
        "gauss_9_1": {
            "weights": [
                0.000229,
                0.005977,
                0.060598,
                0.241732,
                0.382928,
                0.241732,
                0.060598,
                0.005977,
                0.000229
            ],
            "offsets": [
                -4.0,
                -3.0,
                -2.0,
                -1.0,
                0.0,
                1.0,
                2.0,
                3.0,
                4.0
            ]
        },
        "poisson_disc_16": {
            "offsets_xy": [
                0.2069841,
                0.2245269,
                0.525808,
                -0.2310817,
                0.1383943,
                0.9056122,
                0.6633009,
                0.5129843,
                -0.4002792,
                0.3727058,
                0.07912822,
                -0.6512921,
                -0.7726067,
                -0.5151217,
                -0.3843193,
                -0.1494132,
                -0.9107782,
                0.2500633,
                0.6940153,
                -0.7098927,
                -0.1964669,
                -0.379389,
                -0.4769286,
                0.1840863,
                -0.247328,
                -0.8798459,
                0.4206541,
                -0.714772,
                0.5829348,
                -0.09794202,
                0.3691838,
                0.4140642
            ]
        },
        "unjitter": {
            "offsets": [],
            "weights": []
        }
    },
    "post_processes": {
        "bloom": [
            {
                "inherit": "high_pass",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal"
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical"
            },
            {
                "inherit": "downsample_average",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_half",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal"
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_half",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical"
            },
            {
                "inherit": "downsample_average",
                "target": [
                    "pp_output_quarter"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_half",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_quarter"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_quarter",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal"
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_quarter"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_quarter",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical"
            },
            {
                "inherit": "downsample_average",
                "target": [
                    "pp_output_eighth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_quarter",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_eighth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_eighth",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal"
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_eighth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_eighth",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical"
            },
            {
                "inherit": "bloom_upsample",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "post_process_colour",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_full",
                        "unit": 1,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_half",
                        "unit": 2,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_quarter",
                        "unit": 3,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_eighth",
                        "unit": 4,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "depth_of_field": [
            {
                "inherit": "downsample_2x2",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_half",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal"
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_half",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical"
            },
            {
                "inherit": "depth_of_field",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "post_process_depth",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_full",
                        "unit": 1,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_half",
                        "unit": 2,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "colour_lut": [
            {
                "inherit": "colour_lut",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "blit_depth": [
            {
                "inherit": "blit_depth",
                "target": [
                    "main_depth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "post_process_depth",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "blit_taa_depth": [
            {
                "inherit": "blit_depth",
                "technique": "blit_depth_unjittered",
                "target": [
                    "main_depth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "taa_depth",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "blit_post_process": [
            {
                "inherit": "blit",
                "target": [
                    "main_colour"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "blit_colour_depth": [
            {
                "inherit": "blit_colour_depth",
                "target": [
                    "main_colour",
                    "main_depth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "post_process_colour",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "post_process_depth",
                        "unit": 1,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "menger_sponge": [
            {
                "inherit": "menger_sponge",
                "target": [
                    "post_process_colour",
                    "post_process_depth"
                ],
                "pp_write_non_aux": true,
                "technique": "menger_sponge",
                "camera": "model_viewer_camera",
                "resolve": [
                    "average_4x",
                    "max_4x"
                ]
            }
        ],
        "crt": [
            {
                "inherit": "crt",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "sss_reflectance": [
            {
                "inherit": "filter",
                "target": [
                    "pp_output_full"
                ],
                "technique": "sss_reflectance",
                "camera": "model_viewer_camera",
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "post_process_depth",
                        "unit": 1,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_full"
                ],
                "technique": "sss_reflectance",
                "camera": "model_viewer_camera",
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "post_process_depth",
                        "unit": 1,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "taa_resolve": [
            {
                "inherit": "taa_resolve",
                "target": [
                    "pp_output_full"
                ],
                "technique": "taa_resolve",
                "camera": "model_viewer_camera",
                "scene_views": [
                    "ecs_taa_resolve"
                ],
                "sampler_bindings": [
                    {
                        "texture": "taa_colour",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "taa_depth",
                        "unit": 1,
                        "state": "clamp_point",
                        "shader": "ps"
                    },
                    {
                        "texture": "taa_history",
                        "unit": 2,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "blit",
                "target": [
                    "taa_history"
                ],
                "pp_write_non_aux": true,
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ]
    },
    "post_process_sets": {
        "blit_only": {
            "chain": [
                "blit_colour_depth"
            ]
        },
        "editor_default": {
            "chain": [
                "blit_depth",
                "blit_post_process"
            ]
        },
        "taa_resolve": {
            "chain": [
                "taa_resolve",
                "blit_taa_depth",
                "blit_post_process"
            ]
        }
    }
}{
    "views": {
        "view_rasterizer_state": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "clear_colour": [
                1.0,
                0.8,
                0.8,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "no_cull",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ces_render_raster_states"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "pmfx_shader": "forward_render",
            "technique": "forward_lit",
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "main_view_no_clear": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "main_view": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "main_view_basic": {
            "raster_state": "default",
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "pmfx_shader": "forward_render",
            "technique": "simple_lighting",
            "sampler_bindings": [
                {
                    "texture": "single_shadow_map",
                    "unit": 7,
                    "state": "shadow_compare",
                    "shader": "ps"
                }
            ],
            "target": [
                "main_colour",
                "main_depth"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "main_view_alpha_blended": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "colour_write_mask": 15,
            "blend_state": "alpha_blend",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit",
                "alpha_blended"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear_lod",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "multiple_shadow_views": {
            "target": [
                "shadow_map"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "front_face_cull",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "zonly",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_shadow_maps"
            ],
            "render_flags": [
                "shadow_map"
            ]
        },
        "single_shadow_view": {
            "target": [
                "single_shadow_map"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "front_face_cull",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "zonly",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_shadow_maps"
            ],
            "render_flags": [
                "shadow_map"
            ]
        },
        "multiple_colour_shadow_views": {
            "target": [
                "colour_shadow_map",
                "colour_shadow_map_depth"
            ],
            "clear_colour": [
                0.0,
                1.0,
                1.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "back_face_cull",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "pmfx_shader": "forward_render",
            "technique": "gi",
            "scene_views": [
                "ecs_render_shadow_maps"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "multiple_omni_shadow_views": {
            "target": [
                "omni_shadow_map"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "front_face_cull",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "omni_shadow",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_omni_shadow_maps"
            ],
            "render_flags": [
                "shadow_map"
            ]
        },
        "multiple_area_light_views": {
            "target": [
                "area_light_textures"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "zonly",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_area_light_textures"
            ],
            "render_flags": [
                "area_light_textures"
            ],
            "generate_mip_maps": true
        },
        "main_view_post_processed": {
            "target": [
                "post_process_colour",
                "post_process_depth"
            ],
            "post_process": "editor_default",
            "resolve": [
                "average_4x",
                "max_4x"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "main_view_temporal_aa": {
            "target": [
                "taa_colour",
                "taa_depth"
            ],
            "post_process": "taa_resolve",
            "jitter": true,
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "velocity_buffer": {
            "target": [
                "velocity_buffer"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "pmfx_shader": "forward_render",
            "technique": "per_pixel_velocity",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "editor_main": {
            "raster_state": "default",
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "target": [
                "main_colour",
                "main_depth"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "editor_main_basic": {
            "raster_state": "default",
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "pmfx_shader": "forward_render",
            "technique": "simple_lighting",
            "sampler_bindings": [
                {
                    "texture": "single_shadow_map",
                    "unit": 7,
                    "state": "shadow_compare",
                    "shader": "ps"
                }
            ],
            "target": [
                "main_colour",
                "main_depth"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "editor_main_gi": {
            "raster_state": "default",
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "volume_gi",
                    "unit": 9,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ],
            "target": [
                "taa_colour",
                "taa_depth"
            ],
            "post_process": "taa_resolve",
            "jitter": true,
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "editor_view": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "wireframe",
            "depth_stencil_state": "default",
            "pmfx_shader": "pmfx_utility",
            "technique": "constant_colour",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_editor"
            ]
        },
        "picking_view": {
            "target": [
                "picking",
                "picking_ds"
            ],
            "clear": {
                "picking": {
                    "clear_colour_u": [
                        -1,
                        -1,
                        -1,
                        -1
                    ]
                }
            },
            "clear_depth": 1.0,
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "blend_state": "disabled",
            "raster_state": "default",
            "depth_stencil_state": "default",
            "pmfx_shader": "pmfx_utility",
            "technique": "picking",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ]
        },
        "volume_rasteriser": {
            "target": [
                "volume_raster",
                "volume_raster_ds"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "volume_raster",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "volume_rasteriser_camera",
            "pmfx_shader": "pmfx_utility",
            "technique": "volume_raster_albedo",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "wrap_linear",
                    "shader": "ps"
                }
            ]
        },
        "volume_gi_compute": {
            "type": "compute",
            "target": [
                "volume_gi"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "pmfx_shader": "compute",
            "technique": "volume_gi",
            "scene": "main_scene",
            "scene_views": [
                "ecs_compute_volume_gi"
            ],
            "generate_mip_maps": true
        },
        "gbuffer_view": {
            "target": [
                "gbuffer_albedo",
                "gbuffer_normals",
                "gbuffer_world_pos",
                "gbuffer_depth"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "clear_depth": 1.0,
            "clear": {
                "gbuffer_albedo": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                },
                "gbuffer_normals": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                },
                "gbuffer_world_pos": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                }
            },
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "blend_state": "disabled",
            "raster_state": "default",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "gbuffer",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ]
        },
        "deferred_lights_view": {
            "target": [
                "main_colour"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "additive",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "depth_always_no_write",
            "shader": "deferred_render",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_light_volumes"
            ],
            "sampler_bindings": [
                {
                    "texture": "gbuffer_albedo",
                    "unit": 0,
                    "state": "wrap_linear"
                },
                {
                    "texture": "gbuffer_normals",
                    "unit": 1,
                    "state": "wrap_linear"
                },
                {
                    "texture": "gbuffer_world_pos",
                    "unit": 2,
                    "state": "wrap_linear"
                },
                {
                    "texture": "gbuffer_depth",
                    "unit": 4,
                    "state": "wrap_linear"
                }
            ]
        },
        "gbuffer_view_msaa": {
            "target": [
                "gbuffer_albedo_msaa",
                "gbuffer_normals_msaa",
                "gbuffer_world_pos_msaa",
                "gbuffer_depth_msaa"
            ],
            "resolve": [
                "average_4x",
                "average_4x",
                "average_4x",
                "max_4x"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "clear_depth": 1.0,
            "clear": {
                "gbuffer_albedo": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                },
                "gbuffer_normals": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                },
                "gbuffer_world_pos": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                }
            },
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "blend_state": "disabled",
            "raster_state": "default",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "gbuffer",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ]
        },
        "deferred_lights_view_msaa": {
            "sampler_bindings": [
                {
                    "texture": "gbuffer_albedo_msaa",
                    "unit": 4,
                    "state": "wrap_linear",
                    "bind_flags": [
                        "ps",
                        "msaa"
                    ]
                },
                {
                    "texture": "gbuffer_normals_msaa",
                    "unit": 5,
                    "state": "wrap_linear",
                    "bind_flags": [
                        "ps",
                        "msaa"
                    ]
                },
                {
                    "texture": "gbuffer_world_pos_msaa",
                    "unit": 6,
                    "state": "wrap_linear",
                    "bind_flags": [
                        "ps",
                        "msaa"
                    ]
                },
                {
                    "texture": "gbuffer_depth_msaa",
                    "unit": 7,
                    "state": "wrap_linear",
                    "bind_flags": [
                        "ps",
                        "msaa"
                    ]
                }
            ],
            "permutation": 2,
            "target": [
                "main_colour"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "additive",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "depth_always_no_write",
            "shader": "deferred_render",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_light_volumes"
            ]
        },
        "blit": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "depth_always_no_write",
            "pmfx_shader": "post_process",
            "technique": "blit"
        },
        "blit_depth": {
            "clear_depth": 1.0,
            "colour_write_mask": 0,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "depth_always",
            "pmfx_shader": "post_process",
            "technique": "blit_depth"
        },
        "blit_colour_depth": {
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "depth_always",
            "pmfx_shader": "post_process",
            "technique": "blit_colour_depth"
        },
        "colour_lut": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "colour_lut"
        },
        "high_pass": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "high_pass"
        },
        "filter": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "filter"
        },
        "downsample_2x2": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "downsample_2x2"
        },
        "downsample_average": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "downsample_average"
        },
        "bloom_upsample": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "bloom_upsample"
        },
        "depth_of_field": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "depth_of_field",
            "camera": "model_viewer_camera"
        },
        "menger_sponge": {
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "depth_always",
            "pmfx_shader": "post_process",
            "technique": "menger_sponge",
            "camera": "model_viewer_camera"
        },
        "crt": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "crt",
            "camera": "model_viewer_camera"
        },
        "taa_resolve": {
            "colour_write_mask": 15,
            "clear_colour": [
                0.0,
                1.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "taa_resolve"
        }
    },
    "view_sets": {
        "rasterizer_state": [
            "view_rasterizer_state"
        ],
        "editor": [
            "multiple_shadow_views",
            "multiple_area_light_views",
            "multiple_omni_shadow_views",
            "picking_view",
            "editor_main",
            "editor_view"
        ],
        "editor_basic": [
            "single_shadow_view",
            "editor_main_basic",
            "editor_view"
        ],
        "editor_gi": [
            "multiple_shadow_views",
            "multiple_colour_shadow_views",
            "multiple_area_light_views",
            "multiple_omni_shadow_views",
            "volume_gi_compute",
            "picking_view",
            "editor_main_gi",
            "editor_view"
        ],
        "editor_post_processed": [
            "picking_view",
            "main_view_post_processed",
            "editor_view",
            "volume_rasteriser"
        ],
        "deferred_render": [
            "gbuffer_view",
            "deferred_lights_view"
        ],
        "deferred_render_msaa": [
            "gbuffer_view_msaa",
            "deferred_lights_view_msaa"
        ]
    },
    "view_set": "rasterizer_state",
    "blend_states": {
        "disabled": {
            "blend_enable": false
        },
        "additive": {
            "blend_enable": true,
            "src_blend": "one",
            "dest_blend": "one"
        },
        "alpha_blend": {
            "blend_enable": true,
            "src_blend": "src_alpha",
            "dest_blend": "inv_src_alpha"
        }
    },
    "sampler_states": {
        "wrap_linear": {
            "filter": "linear",
            "address": "wrap"
        },
        "wrap_point": {
            "filter": "point",
            "address": "wrap"
        },
        "clamp_linear": {
            "filter": "linear",
            "address": "clamp"
        },
        "clamp_point": {
            "filter": "point",
            "address": "clamp"
        },
        "clamp_linear_lod": {
            "filter": "linear_lod",
            "address": "clamp"
        },
        "shadow_compare": {
            "filter": "linear",
            "address": "clamp",
            "comparison_func": "less"
        }
    },
    "depth_stencil_states": {
        "disabled": {
            "depth_enable": false
        },
        "default": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "less"
        },
        "depth_never": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "never"
        },
        "depth_always": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "always"
        },
        "depth_equal": {
            "depth_enable": true,
            "depth_write": false,
            "depth_func": "equal"
        },
        "depth_always_no_write": {
            "depth_enable": true,
            "depth_write": false,
            "depth_func": "always"
        },
        "stencil_test": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "always",
            "stencil_enable": true,
            "stencil_write_mask": 255,
            "stencil_read_mask": 255,
            "stencil_op": {
                "stencil_fail": "keep",
                "depth_fail": "keep",
                "stencil_pass": "replace",
                "stencil_func": "equal"
            }
        }
    },
    "raster_states": {
        "default": {
            "cull_mode": "back"
        },
        "wireframe": {
            "cull_mode": "none",
            "fill_mode": "wireframe"
        },
        "front_face_cull": {
            "cull_mode": "front",
            "fill_mode": "solid"
        },
        "volume_raster": {
            "cull_mode": "back"
        },
        "post_process": {
            "cull_mode": "none"
        },
        "no_cull": {
            "cull_mode": "none"
        },
        "disabled": {
            "cull_mode": "none"
        }
    },
    "render_targets": {
        "single_shadow_map": {
            "size": [
                2048,
                2048
            ],
            "format": "d32f"
        },
        "shadow_map": {
            "size": [
                2048,
                2048
            ],
            "format": "d32f",
            "type": "array"
        },
        "omni_shadow_map": {
            "size": [
                512,
                512
            ],
            "format": "d24s8",
            "type": "cube_array"
        },
        "colour_shadow_map": {
            "size": [
                512,
                512
            ],
            "format": "rgba8",
            "type": "array"
        },
        "colour_shadow_map_depth": {
            "size": [
                512,
                512
            ],
            "format": "d24s8",
            "type": "array"
        },
        "area_light_textures": {
            "size": [
                640,
                480
            ],
            "format": "rgba8",
            "type": "array",
            "mips": true
        },
        "taa_history": {
            "format": "rgba8",
            "size": "equal"
        },
        "taa_colour": {
            "format": "rgba8",
            "size": "equal"
        },
        "taa_depth": {
            "format": "d24s8",
            "size": "equal"
        },
        "velocity_buffer": {
            "format": "r32f",
            "size": "equal"
        },
        "picking": {
            "size": "equal",
            "format": "r32u",
            "cpu_read": true
        },
        "picking_ds": {
            "size": "equal",
            "format": "d24s8"
        },
        "volume_raster": {
            "size": [
                128,
                128
            ],
            "format": "rgba8",
            "cpu_read": true
        },
        "volume_raster_ds": {
            "size": [
                128,
                128
            ],
            "format": "d24s8"
        },
        "volume_gi": {
            "size": [
                256,
                256,
                256
            ],
            "format": "rgba8",
            "gpu_write": true,
            "mips": true
        },
        "gbuffer_depth": {
            "size": "equal",
            "format": "d24s8"
        },
        "gbuffer_albedo": {
            "size": "equal",
            "format": "rgba8"
        },
        "gbuffer_normals": {
            "size": "equal",
            "format": "rgba32f"
        },
        "gbuffer_world_pos": {
            "size": "equal",
            "format": "rgba32f"
        },
        "gbuffer_depth_msaa": {
            "size": "equal",
            "format": "d24s8",
            "samples": 4
        },
        "gbuffer_albedo_msaa": {
            "size": "equal",
            "format": "rgba8",
            "samples": 4
        },
        "gbuffer_normals_msaa": {
            "size": "equal",
            "format": "rgba32f",
            "samples": 4
        },
        "gbuffer_world_pos_msaa": {
            "size": "equal",
            "format": "rgba32f",
            "samples": 4
        },
        "post_process_colour": {
            "size": "equal",
            "samples": 4,
            "format": "rgba8"
        },
        "post_process_depth": {
            "size": "equal",
            "samples": 4,
            "format": "d24s8"
        },
        "pp_output_full": {
            "size": "equal",
            "format": "rgba8",
            "pp": "write",
            "init_read": "post_process_colour"
        },
        "pp_output_half": {
            "size": "half",
            "format": "rgba8",
            "pp": "write"
        },
        "pp_output_quarter": {
            "size": "quarter",
            "format": "rgba8",
            "pp": "write"
        },
        "pp_output_eighth": {
            "size": "eighth",
            "format": "rgba8",
            "pp": "write"
        }
    },
    "filter_kernels": {
        "gauss_5_1": {
            "weights": [
                0.06136,
                0.24477,
                0.38774,
                0.24477,
                0.06136
            ],
            "offsets": [
                -2.0,
                -1.0,
                0.0,
                1.0,
                2.0
            ]
        },
        "gauss_7_1": {
            "weights": [
                0.00598,
                0.060626,
                0.241843,
                0.383103,
                0.241843,
                0.060626,
                0.00598
            ],
            "offsets": [
                -3.0,
                -2.0,
                -1.0,
                0.0,
                1.0,
                2.0,
                3.0
            ]
        },
        "gauss_9_1": {
            "weights": [
                0.000229,
                0.005977,
                0.060598,
                0.241732,
                0.382928,
                0.241732,
                0.060598,
                0.005977,
                0.000229
            ],
            "offsets": [
                -4.0,
                -3.0,
                -2.0,
                -1.0,
                0.0,
                1.0,
                2.0,
                3.0,
                4.0
            ]
        },
        "poisson_disc_16": {
            "offsets_xy": [
                0.2069841,
                0.2245269,
                0.525808,
                -0.2310817,
                0.1383943,
                0.9056122,
                0.6633009,
                0.5129843,
                -0.4002792,
                0.3727058,
                0.07912822,
                -0.6512921,
                -0.7726067,
                -0.5151217,
                -0.3843193,
                -0.1494132,
                -0.9107782,
                0.2500633,
                0.6940153,
                -0.7098927,
                -0.1964669,
                -0.379389,
                -0.4769286,
                0.1840863,
                -0.247328,
                -0.8798459,
                0.4206541,
                -0.714772,
                0.5829348,
                -0.09794202,
                0.3691838,
                0.4140642
            ]
        },
        "unjitter": {
            "offsets": [],
            "weights": []
        }
    },
    "post_processes": {
        "bloom": [
            {
                "inherit": "high_pass",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal"
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical"
            },
            {
                "inherit": "downsample_average",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_half",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal"
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_half",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical"
            },
            {
                "inherit": "downsample_average",
                "target": [
                    "pp_output_quarter"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_half",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_quarter"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_quarter",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal"
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_quarter"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_quarter",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical"
            },
            {
                "inherit": "downsample_average",
                "target": [
                    "pp_output_eighth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_quarter",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_eighth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_eighth",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal"
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_eighth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_eighth",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical"
            },
            {
                "inherit": "bloom_upsample",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "post_process_colour",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_full",
                        "unit": 1,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_half",
                        "unit": 2,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_quarter",
                        "unit": 3,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_eighth",
                        "unit": 4,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "depth_of_field": [
            {
                "inherit": "downsample_2x2",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_half",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal"
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_half",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical"
            },
            {
                "inherit": "depth_of_field",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "post_process_depth",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_full",
                        "unit": 1,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_half",
                        "unit": 2,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "colour_lut": [
            {
                "inherit": "colour_lut",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "blit_depth": [
            {
                "inherit": "blit_depth",
                "target": [
                    "main_depth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "post_process_depth",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "blit_taa_depth": [
            {
                "inherit": "blit_depth",
                "technique": "blit_depth_unjittered",
                "target": [
                    "main_depth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "taa_depth",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "blit_post_process": [
            {
                "inherit": "blit",
                "target": [
                    "main_colour"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "blit_colour_depth": [
            {
                "inherit": "blit_colour_depth",
                "target": [
                    "main_colour",
                    "main_depth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "post_process_colour",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "post_process_depth",
                        "unit": 1,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "menger_sponge": [
            {
                "inherit": "menger_sponge",
                "target": [
                    "post_process_colour",
                    "post_process_depth"
                ],
                "pp_write_non_aux": true,
                "technique": "menger_sponge",
                "camera": "model_viewer_camera",
                "resolve": [
                    "average_4x",
                    "max_4x"
                ]
            }
        ],
        "crt": [
            {
                "inherit": "crt",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "sss_reflectance": [
            {
                "inherit": "filter",
                "target": [
                    "pp_output_full"
                ],
                "technique": "sss_reflectance",
                "camera": "model_viewer_camera",
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "post_process_depth",
                        "unit": 1,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_full"
                ],
                "technique": "sss_reflectance",
                "camera": "model_viewer_camera",
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "post_process_depth",
                        "unit": 1,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "taa_resolve": [
            {
                "inherit": "taa_resolve",
                "target": [
                    "pp_output_full"
                ],
                "technique": "taa_resolve",
                "camera": "model_viewer_camera",
                "scene_views": [
                    "ecs_taa_resolve"
                ],
                "sampler_bindings": [
                    {
                        "texture": "taa_colour",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "taa_depth",
                        "unit": 1,
                        "state": "clamp_point",
                        "shader": "ps"
                    },
                    {
                        "texture": "taa_history",
                        "unit": 2,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "blit",
                "target": [
                    "taa_history"
                ],
                "pp_write_non_aux": true,
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ]
    },
    "post_process_sets": {
        "blit_only": {
            "chain": [
                "blit_colour_depth"
            ]
        },
        "editor_default": {
            "chain": [
                "blit_depth",
                "blit_post_process"
            ]
        },
        "taa_resolve": {
            "chain": [
                "taa_resolve",
                "blit_taa_depth",
                "blit_post_process"
            ]
        }
    }
}{
    "render_targets": {
        "mip_mapped": {
            "size": "equal",
            "format": "rgba8",
            "mips": true
        },
        "single_shadow_map": {
            "size": [
                2048,
                2048
            ],
            "format": "d32f"
        },
        "shadow_map": {
            "size": [
                2048,
                2048
            ],
            "format": "d32f",
            "type": "array"
        },
        "omni_shadow_map": {
            "size": [
                512,
                512
            ],
            "format": "d24s8",
            "type": "cube_array"
        },
        "colour_shadow_map": {
            "size": [
                512,
                512
            ],
            "format": "rgba8",
            "type": "array"
        },
        "colour_shadow_map_depth": {
            "size": [
                512,
                512
            ],
            "format": "d24s8",
            "type": "array"
        },
        "area_light_textures": {
            "size": [
                640,
                480
            ],
            "format": "rgba8",
            "type": "array",
            "mips": true
        },
        "taa_history": {
            "format": "rgba8",
            "size": "equal"
        },
        "taa_colour": {
            "format": "rgba8",
            "size": "equal"
        },
        "taa_depth": {
            "format": "d24s8",
            "size": "equal"
        },
        "velocity_buffer": {
            "format": "r32f",
            "size": "equal"
        }
    },
    "views": {
        "rtmm": {
            "target": [
                "mip_mapped"
            ],
            "clear_colour": [
                0.0,
                1.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "generate_mip_maps": true,
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "main_view_no_clear": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "main_view": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "main_view_basic": {
            "raster_state": "default",
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "pmfx_shader": "forward_render",
            "technique": "simple_lighting",
            "sampler_bindings": [
                {
                    "texture": "single_shadow_map",
                    "unit": 7,
                    "state": "shadow_compare",
                    "shader": "ps"
                }
            ],
            "target": [
                "main_colour",
                "main_depth"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "main_view_alpha_blended": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "colour_write_mask": 15,
            "blend_state": "alpha_blend",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit",
                "alpha_blended"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear_lod",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "multiple_shadow_views": {
            "target": [
                "shadow_map"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "front_face_cull",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "zonly",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_shadow_maps"
            ],
            "render_flags": [
                "shadow_map"
            ]
        },
        "single_shadow_view": {
            "target": [
                "single_shadow_map"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "front_face_cull",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "zonly",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_shadow_maps"
            ],
            "render_flags": [
                "shadow_map"
            ]
        },
        "multiple_colour_shadow_views": {
            "target": [
                "colour_shadow_map",
                "colour_shadow_map_depth"
            ],
            "clear_colour": [
                0.0,
                1.0,
                1.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "back_face_cull",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "pmfx_shader": "forward_render",
            "technique": "gi",
            "scene_views": [
                "ecs_render_shadow_maps"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "multiple_omni_shadow_views": {
            "target": [
                "omni_shadow_map"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "front_face_cull",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "omni_shadow",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_omni_shadow_maps"
            ],
            "render_flags": [
                "shadow_map"
            ]
        },
        "multiple_area_light_views": {
            "target": [
                "area_light_textures"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "zonly",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_area_light_textures"
            ],
            "render_flags": [
                "area_light_textures"
            ],
            "generate_mip_maps": true
        },
        "main_view_post_processed": {
            "target": [
                "post_process_colour",
                "post_process_depth"
            ],
            "post_process": "editor_default",
            "resolve": [
                "average_4x",
                "max_4x"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "main_view_temporal_aa": {
            "target": [
                "taa_colour",
                "taa_depth"
            ],
            "post_process": "taa_resolve",
            "jitter": true,
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "velocity_buffer": {
            "target": [
                "velocity_buffer"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "pmfx_shader": "forward_render",
            "technique": "per_pixel_velocity",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ]
        }
    },
    "view_sets": {
        "rtmm_view_set": [
            "rtmm",
            "main_view"
        ]
    },
    "view_set": "rtmm_view_set",
    "blend_states": {
        "disabled": {
            "blend_enable": false
        },
        "additive": {
            "blend_enable": true,
            "src_blend": "one",
            "dest_blend": "one"
        },
        "alpha_blend": {
            "blend_enable": true,
            "src_blend": "src_alpha",
            "dest_blend": "inv_src_alpha"
        }
    },
    "sampler_states": {
        "wrap_linear": {
            "filter": "linear",
            "address": "wrap"
        },
        "wrap_point": {
            "filter": "point",
            "address": "wrap"
        },
        "clamp_linear": {
            "filter": "linear",
            "address": "clamp"
        },
        "clamp_point": {
            "filter": "point",
            "address": "clamp"
        },
        "clamp_linear_lod": {
            "filter": "linear_lod",
            "address": "clamp"
        },
        "shadow_compare": {
            "filter": "linear",
            "address": "clamp",
            "comparison_func": "less"
        }
    },
    "depth_stencil_states": {
        "disabled": {
            "depth_enable": false
        },
        "default": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "less"
        },
        "depth_never": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "never"
        },
        "depth_always": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "always"
        },
        "depth_equal": {
            "depth_enable": true,
            "depth_write": false,
            "depth_func": "equal"
        },
        "depth_always_no_write": {
            "depth_enable": true,
            "depth_write": false,
            "depth_func": "always"
        },
        "stencil_test": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "always",
            "stencil_enable": true,
            "stencil_write_mask": 255,
            "stencil_read_mask": 255,
            "stencil_op": {
                "stencil_fail": "keep",
                "depth_fail": "keep",
                "stencil_pass": "replace",
                "stencil_func": "equal"
            }
        }
    },
    "raster_states": {
        "default": {
            "cull_mode": "back"
        },
        "wireframe": {
            "cull_mode": "none",
            "fill_mode": "wireframe"
        },
        "front_face_cull": {
            "cull_mode": "front",
            "fill_mode": "solid"
        },
        "volume_raster": {
            "cull_mode": "back"
        },
        "post_process": {
            "cull_mode": "none"
        },
        "no_cull": {
            "cull_mode": "none"
        },
        "disabled": {
            "cull_mode": "none"
        }
    }
}{
    "cmdline": "../third_party/pmbuild/scripts/jsn/jsn -i assets/configs/sss_demo.jsn -o build/web/data/configs/sss_demo.jsn -I ../assets/configs assets/configs ",
    "files": {
        "build/web/data/configs/sss_demo.jsn": [
            {
                "name": "/Users/alex.dixon/dev/pmtech/examples/assets/configs/sss_demo.jsn",
                "timestamp": 1608572066.9968033,
                "data_file": "data/configs/sss_demo.jsn"
            }
        ]
    }
}{
    "cmdline": "../third_party/pmbuild/scripts/jsn/jsn -i assets/configs/compute_demo.jsn -o build/web/data/configs/compute_demo.jsn -I ../assets/configs assets/configs ",
    "files": {
        "build/web/data/configs/compute_demo.jsn": [
            {
                "name": "/Users/alex.dixon/dev/pmtech/examples/assets/configs/compute_demo.jsn",
                "timestamp": 1608572066.9970367,
                "data_file": "data/configs/compute_demo.jsn"
            }
        ]
    }
}{
    "render_targets": {
        "rt_no_blend": {
            "size": [
                256,
                256
            ],
            "format": "rgba8"
        },
        "rt_alpha_blend": {
            "size": [
                256,
                256
            ],
            "format": "rgba8"
        },
        "rt_additive": {
            "size": [
                256,
                256
            ],
            "format": "rgba8"
        },
        "rt_premultiplied_alpha": {
            "size": [
                256,
                256
            ],
            "format": "rgba8"
        },
        "rt_min": {
            "size": [
                256,
                256
            ],
            "format": "rgba8"
        },
        "rt_max": {
            "size": [
                256,
                256
            ],
            "format": "rgba8"
        },
        "rt_subtract": {
            "size": [
                256,
                256
            ],
            "format": "rgba8"
        },
        "rt_rev_subtract": {
            "size": [
                256,
                256
            ],
            "format": "rgba8"
        },
        "single_shadow_map": {
            "size": [
                2048,
                2048
            ],
            "format": "d32f"
        },
        "shadow_map": {
            "size": [
                2048,
                2048
            ],
            "format": "d32f",
            "type": "array"
        },
        "omni_shadow_map": {
            "size": [
                512,
                512
            ],
            "format": "d24s8",
            "type": "cube_array"
        },
        "colour_shadow_map": {
            "size": [
                512,
                512
            ],
            "format": "rgba8",
            "type": "array"
        },
        "colour_shadow_map_depth": {
            "size": [
                512,
                512
            ],
            "format": "d24s8",
            "type": "array"
        },
        "area_light_textures": {
            "size": [
                640,
                480
            ],
            "format": "rgba8",
            "type": "array",
            "mips": true
        },
        "taa_history": {
            "format": "rgba8",
            "size": "equal"
        },
        "taa_colour": {
            "format": "rgba8",
            "size": "equal"
        },
        "taa_depth": {
            "format": "d24s8",
            "size": "equal"
        },
        "velocity_buffer": {
            "format": "r32f",
            "size": "equal"
        }
    },
    "blend_states": {
        "premultiplied_alpha": {
            "blend_enable": true,
            "src_blend": "one",
            "dest_blend": "inv_src_alpha"
        },
        "min": {
            "blend_enable": true,
            "src_blend": "one",
            "dest_blend": "one",
            "blend_op": "blend_op_min"
        },
        "max": {
            "blend_enable": true,
            "src_blend": "src_colour",
            "dest_blend": "src_colour",
            "blend_op": "blend_op_max"
        },
        "subtract": {
            "blend_enable": true,
            "src_blend": "src_colour",
            "dest_blend": "src_colour",
            "blend_op": "belnd_op_subtract"
        },
        "rev_subtract": {
            "blend_enable": true,
            "src_blend": "one",
            "dest_blend": "one",
            "blend_op": "blend_op_rev_subtract"
        },
        "disabled": {
            "blend_enable": false
        },
        "additive": {
            "blend_enable": true,
            "src_blend": "one",
            "dest_blend": "one"
        },
        "alpha_blend": {
            "blend_enable": true,
            "src_blend": "src_alpha",
            "dest_blend": "inv_src_alpha"
        }
    },
    "views": {
        "clear_backbuffer": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "clear_colour": [
                0.5,
                0.5,
                0.5,
                1.0
            ]
        },
        "base_blend_view": {
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 7,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "pmfx_shader": "post_process",
            "technique": "blit",
            "scene_views": [
                "blend_layers"
            ]
        },
        "view_no_blend": {
            "target": [
                "rt_no_blend"
            ],
            "blend_state": "disabled",
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 7,
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "pmfx_shader": "post_process",
            "technique": "blit",
            "scene_views": [
                "blend_layers"
            ]
        },
        "view_alpha_blend": {
            "clear_colour": [
                1.0,
                0.0,
                0.0,
                1.0
            ],
            "target": [
                "rt_alpha_blend"
            ],
            "blend_state": "alpha_blend",
            "clear_depth": 1.0,
            "colour_write_mask": 7,
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "pmfx_shader": "post_process",
            "technique": "blit",
            "scene_views": [
                "blend_layers"
            ]
        },
        "view_additive": {
            "target": [
                "rt_additive"
            ],
            "blend_state": "additive",
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 7,
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "pmfx_shader": "post_process",
            "technique": "blit",
            "scene_views": [
                "blend_layers"
            ]
        },
        "view_premultiplied_alpha": {
            "target": [
                "rt_premultiplied_alpha"
            ],
            "blend_state": "premultiplied_alpha",
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 7,
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "pmfx_shader": "post_process",
            "technique": "blit",
            "scene_views": [
                "blend_layers"
            ]
        },
        "view_min": {
            "target": [
                "rt_min"
            ],
            "blend_state": "min",
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 7,
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "pmfx_shader": "post_process",
            "technique": "blit",
            "scene_views": [
                "blend_layers"
            ]
        },
        "view_max": {
            "target": [
                "rt_max"
            ],
            "blend_state": "max",
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 7,
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "pmfx_shader": "post_process",
            "technique": "blit",
            "scene_views": [
                "blend_layers"
            ]
        },
        "view_subtract": {
            "target": [
                "rt_subtract"
            ],
            "blend_state": "subtract",
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 7,
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "pmfx_shader": "post_process",
            "technique": "blit",
            "scene_views": [
                "blend_layers"
            ]
        },
        "view_rev_subtract": {
            "target": [
                "rt_rev_subtract"
            ],
            "blend_state": "rev_subtract",
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 7,
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "pmfx_shader": "post_process",
            "technique": "blit",
            "scene_views": [
                "blend_layers"
            ]
        },
        "main_view_no_clear": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "main_view": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "main_view_basic": {
            "raster_state": "default",
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "pmfx_shader": "forward_render",
            "technique": "simple_lighting",
            "sampler_bindings": [
                {
                    "texture": "single_shadow_map",
                    "unit": 7,
                    "state": "shadow_compare",
                    "shader": "ps"
                }
            ],
            "target": [
                "main_colour",
                "main_depth"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "main_view_alpha_blended": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "colour_write_mask": 15,
            "blend_state": "alpha_blend",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit",
                "alpha_blended"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear_lod",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "multiple_shadow_views": {
            "target": [
                "shadow_map"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "front_face_cull",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "zonly",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_shadow_maps"
            ],
            "render_flags": [
                "shadow_map"
            ]
        },
        "single_shadow_view": {
            "target": [
                "single_shadow_map"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "front_face_cull",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "zonly",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_shadow_maps"
            ],
            "render_flags": [
                "shadow_map"
            ]
        },
        "multiple_colour_shadow_views": {
            "target": [
                "colour_shadow_map",
                "colour_shadow_map_depth"
            ],
            "clear_colour": [
                0.0,
                1.0,
                1.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "back_face_cull",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "pmfx_shader": "forward_render",
            "technique": "gi",
            "scene_views": [
                "ecs_render_shadow_maps"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "multiple_omni_shadow_views": {
            "target": [
                "omni_shadow_map"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "front_face_cull",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "omni_shadow",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_omni_shadow_maps"
            ],
            "render_flags": [
                "shadow_map"
            ]
        },
        "multiple_area_light_views": {
            "target": [
                "area_light_textures"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "zonly",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_area_light_textures"
            ],
            "render_flags": [
                "area_light_textures"
            ],
            "generate_mip_maps": true
        },
        "main_view_post_processed": {
            "target": [
                "post_process_colour",
                "post_process_depth"
            ],
            "post_process": "editor_default",
            "resolve": [
                "average_4x",
                "max_4x"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "main_view_temporal_aa": {
            "target": [
                "taa_colour",
                "taa_depth"
            ],
            "post_process": "taa_resolve",
            "jitter": true,
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "velocity_buffer": {
            "target": [
                "velocity_buffer"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "pmfx_shader": "forward_render",
            "technique": "per_pixel_velocity",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ]
        }
    },
    "view_sets": {
        "blend_test": [
            "clear_backbuffer",
            "view_no_blend",
            "view_alpha_blend",
            "view_additive",
            "view_premultiplied_alpha",
            "view_min",
            "view_max",
            "view_subtract",
            "view_rev_subtract"
        ]
    },
    "view_set": "blend_test",
    "sampler_states": {
        "wrap_linear": {
            "filter": "linear",
            "address": "wrap"
        },
        "wrap_point": {
            "filter": "point",
            "address": "wrap"
        },
        "clamp_linear": {
            "filter": "linear",
            "address": "clamp"
        },
        "clamp_point": {
            "filter": "point",
            "address": "clamp"
        },
        "clamp_linear_lod": {
            "filter": "linear_lod",
            "address": "clamp"
        },
        "shadow_compare": {
            "filter": "linear",
            "address": "clamp",
            "comparison_func": "less"
        }
    },
    "depth_stencil_states": {
        "disabled": {
            "depth_enable": false
        },
        "default": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "less"
        },
        "depth_never": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "never"
        },
        "depth_always": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "always"
        },
        "depth_equal": {
            "depth_enable": true,
            "depth_write": false,
            "depth_func": "equal"
        },
        "depth_always_no_write": {
            "depth_enable": true,
            "depth_write": false,
            "depth_func": "always"
        },
        "stencil_test": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "always",
            "stencil_enable": true,
            "stencil_write_mask": 255,
            "stencil_read_mask": 255,
            "stencil_op": {
                "stencil_fail": "keep",
                "depth_fail": "keep",
                "stencil_pass": "replace",
                "stencil_func": "equal"
            }
        }
    },
    "raster_states": {
        "default": {
            "cull_mode": "back"
        },
        "wireframe": {
            "cull_mode": "none",
            "fill_mode": "wireframe"
        },
        "front_face_cull": {
            "cull_mode": "front",
            "fill_mode": "solid"
        },
        "volume_raster": {
            "cull_mode": "back"
        },
        "post_process": {
            "cull_mode": "none"
        },
        "no_cull": {
            "cull_mode": "none"
        },
        "disabled": {
            "cull_mode": "none"
        }
    }
}{
    "view_sets": {
        "example": [
            "main_view",
            "picking_view"
        ],
        "editor": [
            "multiple_shadow_views",
            "multiple_area_light_views",
            "multiple_omni_shadow_views",
            "picking_view",
            "editor_main",
            "editor_view"
        ],
        "editor_basic": [
            "single_shadow_view",
            "editor_main_basic",
            "editor_view"
        ],
        "editor_gi": [
            "multiple_shadow_views",
            "multiple_colour_shadow_views",
            "multiple_area_light_views",
            "multiple_omni_shadow_views",
            "volume_gi_compute",
            "picking_view",
            "editor_main_gi",
            "editor_view"
        ],
        "editor_post_processed": [
            "picking_view",
            "main_view_post_processed",
            "editor_view",
            "volume_rasteriser"
        ],
        "deferred_render": [
            "gbuffer_view",
            "deferred_lights_view"
        ],
        "deferred_render_msaa": [
            "gbuffer_view_msaa",
            "deferred_lights_view_msaa"
        ]
    },
    "view_set": "example",
    "blend_states": {
        "disabled": {
            "blend_enable": false
        },
        "additive": {
            "blend_enable": true,
            "src_blend": "one",
            "dest_blend": "one"
        },
        "alpha_blend": {
            "blend_enable": true,
            "src_blend": "src_alpha",
            "dest_blend": "inv_src_alpha"
        }
    },
    "sampler_states": {
        "wrap_linear": {
            "filter": "linear",
            "address": "wrap"
        },
        "wrap_point": {
            "filter": "point",
            "address": "wrap"
        },
        "clamp_linear": {
            "filter": "linear",
            "address": "clamp"
        },
        "clamp_point": {
            "filter": "point",
            "address": "clamp"
        },
        "clamp_linear_lod": {
            "filter": "linear_lod",
            "address": "clamp"
        },
        "shadow_compare": {
            "filter": "linear",
            "address": "clamp",
            "comparison_func": "less"
        }
    },
    "depth_stencil_states": {
        "disabled": {
            "depth_enable": false
        },
        "default": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "less"
        },
        "depth_never": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "never"
        },
        "depth_always": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "always"
        },
        "depth_equal": {
            "depth_enable": true,
            "depth_write": false,
            "depth_func": "equal"
        },
        "depth_always_no_write": {
            "depth_enable": true,
            "depth_write": false,
            "depth_func": "always"
        },
        "stencil_test": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "always",
            "stencil_enable": true,
            "stencil_write_mask": 255,
            "stencil_read_mask": 255,
            "stencil_op": {
                "stencil_fail": "keep",
                "depth_fail": "keep",
                "stencil_pass": "replace",
                "stencil_func": "equal"
            }
        }
    },
    "raster_states": {
        "default": {
            "cull_mode": "back"
        },
        "wireframe": {
            "cull_mode": "none",
            "fill_mode": "wireframe"
        },
        "front_face_cull": {
            "cull_mode": "front",
            "fill_mode": "solid"
        },
        "volume_raster": {
            "cull_mode": "back"
        },
        "post_process": {
            "cull_mode": "none"
        },
        "no_cull": {
            "cull_mode": "none"
        },
        "disabled": {
            "cull_mode": "none"
        }
    },
    "render_targets": {
        "single_shadow_map": {
            "size": [
                2048,
                2048
            ],
            "format": "d32f"
        },
        "shadow_map": {
            "size": [
                2048,
                2048
            ],
            "format": "d32f",
            "type": "array"
        },
        "omni_shadow_map": {
            "size": [
                512,
                512
            ],
            "format": "d24s8",
            "type": "cube_array"
        },
        "colour_shadow_map": {
            "size": [
                512,
                512
            ],
            "format": "rgba8",
            "type": "array"
        },
        "colour_shadow_map_depth": {
            "size": [
                512,
                512
            ],
            "format": "d24s8",
            "type": "array"
        },
        "area_light_textures": {
            "size": [
                640,
                480
            ],
            "format": "rgba8",
            "type": "array",
            "mips": true
        },
        "taa_history": {
            "format": "rgba8",
            "size": "equal"
        },
        "taa_colour": {
            "format": "rgba8",
            "size": "equal"
        },
        "taa_depth": {
            "format": "d24s8",
            "size": "equal"
        },
        "velocity_buffer": {
            "format": "r32f",
            "size": "equal"
        },
        "picking": {
            "size": "equal",
            "format": "r32u",
            "cpu_read": true
        },
        "picking_ds": {
            "size": "equal",
            "format": "d24s8"
        },
        "volume_raster": {
            "size": [
                128,
                128
            ],
            "format": "rgba8",
            "cpu_read": true
        },
        "volume_raster_ds": {
            "size": [
                128,
                128
            ],
            "format": "d24s8"
        },
        "volume_gi": {
            "size": [
                256,
                256,
                256
            ],
            "format": "rgba8",
            "gpu_write": true,
            "mips": true
        },
        "gbuffer_depth": {
            "size": "equal",
            "format": "d24s8"
        },
        "gbuffer_albedo": {
            "size": "equal",
            "format": "rgba8"
        },
        "gbuffer_normals": {
            "size": "equal",
            "format": "rgba32f"
        },
        "gbuffer_world_pos": {
            "size": "equal",
            "format": "rgba32f"
        },
        "gbuffer_depth_msaa": {
            "size": "equal",
            "format": "d24s8",
            "samples": 4
        },
        "gbuffer_albedo_msaa": {
            "size": "equal",
            "format": "rgba8",
            "samples": 4
        },
        "gbuffer_normals_msaa": {
            "size": "equal",
            "format": "rgba32f",
            "samples": 4
        },
        "gbuffer_world_pos_msaa": {
            "size": "equal",
            "format": "rgba32f",
            "samples": 4
        },
        "post_process_colour": {
            "size": "equal",
            "samples": 4,
            "format": "rgba8"
        },
        "post_process_depth": {
            "size": "equal",
            "samples": 4,
            "format": "d24s8"
        },
        "pp_output_full": {
            "size": "equal",
            "format": "rgba8",
            "pp": "write",
            "init_read": "post_process_colour"
        },
        "pp_output_half": {
            "size": "half",
            "format": "rgba8",
            "pp": "write"
        },
        "pp_output_quarter": {
            "size": "quarter",
            "format": "rgba8",
            "pp": "write"
        },
        "pp_output_eighth": {
            "size": "eighth",
            "format": "rgba8",
            "pp": "write"
        }
    },
    "views": {
        "main_view_no_clear": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "main_view": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "main_view_basic": {
            "raster_state": "default",
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "pmfx_shader": "forward_render",
            "technique": "simple_lighting",
            "sampler_bindings": [
                {
                    "texture": "single_shadow_map",
                    "unit": 7,
                    "state": "shadow_compare",
                    "shader": "ps"
                }
            ],
            "target": [
                "main_colour",
                "main_depth"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "main_view_alpha_blended": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "colour_write_mask": 15,
            "blend_state": "alpha_blend",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit",
                "alpha_blended"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear_lod",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "multiple_shadow_views": {
            "target": [
                "shadow_map"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "front_face_cull",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "zonly",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_shadow_maps"
            ],
            "render_flags": [
                "shadow_map"
            ]
        },
        "single_shadow_view": {
            "target": [
                "single_shadow_map"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "front_face_cull",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "zonly",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_shadow_maps"
            ],
            "render_flags": [
                "shadow_map"
            ]
        },
        "multiple_colour_shadow_views": {
            "target": [
                "colour_shadow_map",
                "colour_shadow_map_depth"
            ],
            "clear_colour": [
                0.0,
                1.0,
                1.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "back_face_cull",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "pmfx_shader": "forward_render",
            "technique": "gi",
            "scene_views": [
                "ecs_render_shadow_maps"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "multiple_omni_shadow_views": {
            "target": [
                "omni_shadow_map"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "front_face_cull",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "omni_shadow",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_omni_shadow_maps"
            ],
            "render_flags": [
                "shadow_map"
            ]
        },
        "multiple_area_light_views": {
            "target": [
                "area_light_textures"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "zonly",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_area_light_textures"
            ],
            "render_flags": [
                "area_light_textures"
            ],
            "generate_mip_maps": true
        },
        "main_view_post_processed": {
            "target": [
                "post_process_colour",
                "post_process_depth"
            ],
            "post_process": "editor_default",
            "resolve": [
                "average_4x",
                "max_4x"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "main_view_temporal_aa": {
            "target": [
                "taa_colour",
                "taa_depth"
            ],
            "post_process": "taa_resolve",
            "jitter": true,
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "velocity_buffer": {
            "target": [
                "velocity_buffer"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "pmfx_shader": "forward_render",
            "technique": "per_pixel_velocity",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "editor_main": {
            "raster_state": "default",
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "target": [
                "main_colour",
                "main_depth"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "editor_main_basic": {
            "raster_state": "default",
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "pmfx_shader": "forward_render",
            "technique": "simple_lighting",
            "sampler_bindings": [
                {
                    "texture": "single_shadow_map",
                    "unit": 7,
                    "state": "shadow_compare",
                    "shader": "ps"
                }
            ],
            "target": [
                "main_colour",
                "main_depth"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "editor_main_gi": {
            "raster_state": "default",
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "volume_gi",
                    "unit": 9,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ],
            "target": [
                "taa_colour",
                "taa_depth"
            ],
            "post_process": "taa_resolve",
            "jitter": true,
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "editor_view": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "wireframe",
            "depth_stencil_state": "default",
            "pmfx_shader": "pmfx_utility",
            "technique": "constant_colour",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_editor"
            ]
        },
        "picking_view": {
            "target": [
                "picking",
                "picking_ds"
            ],
            "clear": {
                "picking": {
                    "clear_colour_u": [
                        -1,
                        -1,
                        -1,
                        -1
                    ]
                }
            },
            "clear_depth": 1.0,
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "blend_state": "disabled",
            "raster_state": "default",
            "depth_stencil_state": "default",
            "pmfx_shader": "pmfx_utility",
            "technique": "picking",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ]
        },
        "volume_rasteriser": {
            "target": [
                "volume_raster",
                "volume_raster_ds"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "volume_raster",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "volume_rasteriser_camera",
            "pmfx_shader": "pmfx_utility",
            "technique": "volume_raster_albedo",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "wrap_linear",
                    "shader": "ps"
                }
            ]
        },
        "volume_gi_compute": {
            "type": "compute",
            "target": [
                "volume_gi"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "pmfx_shader": "compute",
            "technique": "volume_gi",
            "scene": "main_scene",
            "scene_views": [
                "ecs_compute_volume_gi"
            ],
            "generate_mip_maps": true
        },
        "gbuffer_view": {
            "target": [
                "gbuffer_albedo",
                "gbuffer_normals",
                "gbuffer_world_pos",
                "gbuffer_depth"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "clear_depth": 1.0,
            "clear": {
                "gbuffer_albedo": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                },
                "gbuffer_normals": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                },
                "gbuffer_world_pos": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                }
            },
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "blend_state": "disabled",
            "raster_state": "default",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "gbuffer",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ]
        },
        "deferred_lights_view": {
            "target": [
                "main_colour"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "additive",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "depth_always_no_write",
            "shader": "deferred_render",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_light_volumes"
            ],
            "sampler_bindings": [
                {
                    "texture": "gbuffer_albedo",
                    "unit": 0,
                    "state": "wrap_linear"
                },
                {
                    "texture": "gbuffer_normals",
                    "unit": 1,
                    "state": "wrap_linear"
                },
                {
                    "texture": "gbuffer_world_pos",
                    "unit": 2,
                    "state": "wrap_linear"
                },
                {
                    "texture": "gbuffer_depth",
                    "unit": 4,
                    "state": "wrap_linear"
                }
            ]
        },
        "gbuffer_view_msaa": {
            "target": [
                "gbuffer_albedo_msaa",
                "gbuffer_normals_msaa",
                "gbuffer_world_pos_msaa",
                "gbuffer_depth_msaa"
            ],
            "resolve": [
                "average_4x",
                "average_4x",
                "average_4x",
                "max_4x"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "clear_depth": 1.0,
            "clear": {
                "gbuffer_albedo": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                },
                "gbuffer_normals": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                },
                "gbuffer_world_pos": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                }
            },
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "blend_state": "disabled",
            "raster_state": "default",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "gbuffer",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ]
        },
        "deferred_lights_view_msaa": {
            "sampler_bindings": [
                {
                    "texture": "gbuffer_albedo_msaa",
                    "unit": 4,
                    "state": "wrap_linear",
                    "bind_flags": [
                        "ps",
                        "msaa"
                    ]
                },
                {
                    "texture": "gbuffer_normals_msaa",
                    "unit": 5,
                    "state": "wrap_linear",
                    "bind_flags": [
                        "ps",
                        "msaa"
                    ]
                },
                {
                    "texture": "gbuffer_world_pos_msaa",
                    "unit": 6,
                    "state": "wrap_linear",
                    "bind_flags": [
                        "ps",
                        "msaa"
                    ]
                },
                {
                    "texture": "gbuffer_depth_msaa",
                    "unit": 7,
                    "state": "wrap_linear",
                    "bind_flags": [
                        "ps",
                        "msaa"
                    ]
                }
            ],
            "permutation": 2,
            "target": [
                "main_colour"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "additive",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "depth_always_no_write",
            "shader": "deferred_render",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_light_volumes"
            ]
        },
        "blit": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "depth_always_no_write",
            "pmfx_shader": "post_process",
            "technique": "blit"
        },
        "blit_depth": {
            "clear_depth": 1.0,
            "colour_write_mask": 0,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "depth_always",
            "pmfx_shader": "post_process",
            "technique": "blit_depth"
        },
        "blit_colour_depth": {
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "depth_always",
            "pmfx_shader": "post_process",
            "technique": "blit_colour_depth"
        },
        "colour_lut": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "colour_lut"
        },
        "high_pass": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "high_pass"
        },
        "filter": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "filter"
        },
        "downsample_2x2": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "downsample_2x2"
        },
        "downsample_average": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "downsample_average"
        },
        "bloom_upsample": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "bloom_upsample"
        },
        "depth_of_field": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "depth_of_field",
            "camera": "model_viewer_camera"
        },
        "menger_sponge": {
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "depth_always",
            "pmfx_shader": "post_process",
            "technique": "menger_sponge",
            "camera": "model_viewer_camera"
        },
        "crt": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "crt",
            "camera": "model_viewer_camera"
        },
        "taa_resolve": {
            "colour_write_mask": 15,
            "clear_colour": [
                0.0,
                1.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "taa_resolve"
        }
    },
    "filter_kernels": {
        "gauss_5_1": {
            "weights": [
                0.06136,
                0.24477,
                0.38774,
                0.24477,
                0.06136
            ],
            "offsets": [
                -2.0,
                -1.0,
                0.0,
                1.0,
                2.0
            ]
        },
        "gauss_7_1": {
            "weights": [
                0.00598,
                0.060626,
                0.241843,
                0.383103,
                0.241843,
                0.060626,
                0.00598
            ],
            "offsets": [
                -3.0,
                -2.0,
                -1.0,
                0.0,
                1.0,
                2.0,
                3.0
            ]
        },
        "gauss_9_1": {
            "weights": [
                0.000229,
                0.005977,
                0.060598,
                0.241732,
                0.382928,
                0.241732,
                0.060598,
                0.005977,
                0.000229
            ],
            "offsets": [
                -4.0,
                -3.0,
                -2.0,
                -1.0,
                0.0,
                1.0,
                2.0,
                3.0,
                4.0
            ]
        },
        "poisson_disc_16": {
            "offsets_xy": [
                0.2069841,
                0.2245269,
                0.525808,
                -0.2310817,
                0.1383943,
                0.9056122,
                0.6633009,
                0.5129843,
                -0.4002792,
                0.3727058,
                0.07912822,
                -0.6512921,
                -0.7726067,
                -0.5151217,
                -0.3843193,
                -0.1494132,
                -0.9107782,
                0.2500633,
                0.6940153,
                -0.7098927,
                -0.1964669,
                -0.379389,
                -0.4769286,
                0.1840863,
                -0.247328,
                -0.8798459,
                0.4206541,
                -0.714772,
                0.5829348,
                -0.09794202,
                0.3691838,
                0.4140642
            ]
        },
        "unjitter": {
            "offsets": [],
            "weights": []
        }
    },
    "post_processes": {
        "bloom": [
            {
                "inherit": "high_pass",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal"
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical"
            },
            {
                "inherit": "downsample_average",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_half",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal"
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_half",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical"
            },
            {
                "inherit": "downsample_average",
                "target": [
                    "pp_output_quarter"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_half",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_quarter"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_quarter",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal"
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_quarter"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_quarter",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical"
            },
            {
                "inherit": "downsample_average",
                "target": [
                    "pp_output_eighth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_quarter",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_eighth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_eighth",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal"
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_eighth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_eighth",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical"
            },
            {
                "inherit": "bloom_upsample",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "post_process_colour",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_full",
                        "unit": 1,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_half",
                        "unit": 2,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_quarter",
                        "unit": 3,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_eighth",
                        "unit": 4,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "depth_of_field": [
            {
                "inherit": "downsample_2x2",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_half",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal"
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_half",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical"
            },
            {
                "inherit": "depth_of_field",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "post_process_depth",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_full",
                        "unit": 1,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_half",
                        "unit": 2,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "colour_lut": [
            {
                "inherit": "colour_lut",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "blit_depth": [
            {
                "inherit": "blit_depth",
                "target": [
                    "main_depth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "post_process_depth",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "blit_taa_depth": [
            {
                "inherit": "blit_depth",
                "technique": "blit_depth_unjittered",
                "target": [
                    "main_depth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "taa_depth",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "blit_post_process": [
            {
                "inherit": "blit",
                "target": [
                    "main_colour"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "blit_colour_depth": [
            {
                "inherit": "blit_colour_depth",
                "target": [
                    "main_colour",
                    "main_depth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "post_process_colour",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "post_process_depth",
                        "unit": 1,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "menger_sponge": [
            {
                "inherit": "menger_sponge",
                "target": [
                    "post_process_colour",
                    "post_process_depth"
                ],
                "pp_write_non_aux": true,
                "technique": "menger_sponge",
                "camera": "model_viewer_camera",
                "resolve": [
                    "average_4x",
                    "max_4x"
                ]
            }
        ],
        "crt": [
            {
                "inherit": "crt",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "sss_reflectance": [
            {
                "inherit": "filter",
                "target": [
                    "pp_output_full"
                ],
                "technique": "sss_reflectance",
                "camera": "model_viewer_camera",
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "post_process_depth",
                        "unit": 1,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_full"
                ],
                "technique": "sss_reflectance",
                "camera": "model_viewer_camera",
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "post_process_depth",
                        "unit": 1,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "taa_resolve": [
            {
                "inherit": "taa_resolve",
                "target": [
                    "pp_output_full"
                ],
                "technique": "taa_resolve",
                "camera": "model_viewer_camera",
                "scene_views": [
                    "ecs_taa_resolve"
                ],
                "sampler_bindings": [
                    {
                        "texture": "taa_colour",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "taa_depth",
                        "unit": 1,
                        "state": "clamp_point",
                        "shader": "ps"
                    },
                    {
                        "texture": "taa_history",
                        "unit": 2,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "blit",
                "target": [
                    "taa_history"
                ],
                "pp_write_non_aux": true,
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ]
    },
    "post_process_sets": {
        "blit_only": {
            "chain": [
                "blit_colour_depth"
            ]
        },
        "editor_default": {
            "chain": [
                "blit_depth",
                "blit_post_process"
            ]
        },
        "taa_resolve": {
            "chain": [
                "taa_resolve",
                "blit_taa_depth",
                "blit_post_process"
            ]
        }
    }
}{
    "view_set": "deferred_render",
    "blend_states": {
        "disabled": {
            "blend_enable": false
        },
        "additive": {
            "blend_enable": true,
            "src_blend": "one",
            "dest_blend": "one"
        },
        "alpha_blend": {
            "blend_enable": true,
            "src_blend": "src_alpha",
            "dest_blend": "inv_src_alpha"
        }
    },
    "sampler_states": {
        "wrap_linear": {
            "filter": "linear",
            "address": "wrap"
        },
        "wrap_point": {
            "filter": "point",
            "address": "wrap"
        },
        "clamp_linear": {
            "filter": "linear",
            "address": "clamp"
        },
        "clamp_point": {
            "filter": "point",
            "address": "clamp"
        },
        "clamp_linear_lod": {
            "filter": "linear_lod",
            "address": "clamp"
        },
        "shadow_compare": {
            "filter": "linear",
            "address": "clamp",
            "comparison_func": "less"
        }
    },
    "depth_stencil_states": {
        "disabled": {
            "depth_enable": false
        },
        "default": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "less"
        },
        "depth_never": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "never"
        },
        "depth_always": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "always"
        },
        "depth_equal": {
            "depth_enable": true,
            "depth_write": false,
            "depth_func": "equal"
        },
        "depth_always_no_write": {
            "depth_enable": true,
            "depth_write": false,
            "depth_func": "always"
        },
        "stencil_test": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "always",
            "stencil_enable": true,
            "stencil_write_mask": 255,
            "stencil_read_mask": 255,
            "stencil_op": {
                "stencil_fail": "keep",
                "depth_fail": "keep",
                "stencil_pass": "replace",
                "stencil_func": "equal"
            }
        }
    },
    "raster_states": {
        "default": {
            "cull_mode": "back"
        },
        "wireframe": {
            "cull_mode": "none",
            "fill_mode": "wireframe"
        },
        "front_face_cull": {
            "cull_mode": "front",
            "fill_mode": "solid"
        },
        "volume_raster": {
            "cull_mode": "back"
        },
        "post_process": {
            "cull_mode": "none"
        },
        "no_cull": {
            "cull_mode": "none"
        },
        "disabled": {
            "cull_mode": "none"
        }
    },
    "render_targets": {
        "single_shadow_map": {
            "size": [
                2048,
                2048
            ],
            "format": "d32f"
        },
        "shadow_map": {
            "size": [
                2048,
                2048
            ],
            "format": "d32f",
            "type": "array"
        },
        "omni_shadow_map": {
            "size": [
                512,
                512
            ],
            "format": "d24s8",
            "type": "cube_array"
        },
        "colour_shadow_map": {
            "size": [
                512,
                512
            ],
            "format": "rgba8",
            "type": "array"
        },
        "colour_shadow_map_depth": {
            "size": [
                512,
                512
            ],
            "format": "d24s8",
            "type": "array"
        },
        "area_light_textures": {
            "size": [
                640,
                480
            ],
            "format": "rgba8",
            "type": "array",
            "mips": true
        },
        "taa_history": {
            "format": "rgba8",
            "size": "equal"
        },
        "taa_colour": {
            "format": "rgba8",
            "size": "equal"
        },
        "taa_depth": {
            "format": "d24s8",
            "size": "equal"
        },
        "velocity_buffer": {
            "format": "r32f",
            "size": "equal"
        },
        "gbuffer_depth": {
            "size": "equal",
            "format": "d24s8"
        },
        "gbuffer_albedo": {
            "size": "equal",
            "format": "rgba8"
        },
        "gbuffer_normals": {
            "size": "equal",
            "format": "rgba32f"
        },
        "gbuffer_world_pos": {
            "size": "equal",
            "format": "rgba32f"
        },
        "gbuffer_depth_msaa": {
            "size": "equal",
            "format": "d24s8",
            "samples": 4
        },
        "gbuffer_albedo_msaa": {
            "size": "equal",
            "format": "rgba8",
            "samples": 4
        },
        "gbuffer_normals_msaa": {
            "size": "equal",
            "format": "rgba32f",
            "samples": 4
        },
        "gbuffer_world_pos_msaa": {
            "size": "equal",
            "format": "rgba32f",
            "samples": 4
        }
    },
    "views": {
        "main_view_no_clear": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "main_view": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "main_view_basic": {
            "raster_state": "default",
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "pmfx_shader": "forward_render",
            "technique": "simple_lighting",
            "sampler_bindings": [
                {
                    "texture": "single_shadow_map",
                    "unit": 7,
                    "state": "shadow_compare",
                    "shader": "ps"
                }
            ],
            "target": [
                "main_colour",
                "main_depth"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "main_view_alpha_blended": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "colour_write_mask": 15,
            "blend_state": "alpha_blend",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit",
                "alpha_blended"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear_lod",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "multiple_shadow_views": {
            "target": [
                "shadow_map"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "front_face_cull",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "zonly",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_shadow_maps"
            ],
            "render_flags": [
                "shadow_map"
            ]
        },
        "single_shadow_view": {
            "target": [
                "single_shadow_map"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "front_face_cull",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "zonly",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_shadow_maps"
            ],
            "render_flags": [
                "shadow_map"
            ]
        },
        "multiple_colour_shadow_views": {
            "target": [
                "colour_shadow_map",
                "colour_shadow_map_depth"
            ],
            "clear_colour": [
                0.0,
                1.0,
                1.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "back_face_cull",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "pmfx_shader": "forward_render",
            "technique": "gi",
            "scene_views": [
                "ecs_render_shadow_maps"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "multiple_omni_shadow_views": {
            "target": [
                "omni_shadow_map"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "front_face_cull",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "omni_shadow",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_omni_shadow_maps"
            ],
            "render_flags": [
                "shadow_map"
            ]
        },
        "multiple_area_light_views": {
            "target": [
                "area_light_textures"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "zonly",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_area_light_textures"
            ],
            "render_flags": [
                "area_light_textures"
            ],
            "generate_mip_maps": true
        },
        "main_view_post_processed": {
            "target": [
                "post_process_colour",
                "post_process_depth"
            ],
            "post_process": "editor_default",
            "resolve": [
                "average_4x",
                "max_4x"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "main_view_temporal_aa": {
            "target": [
                "taa_colour",
                "taa_depth"
            ],
            "post_process": "taa_resolve",
            "jitter": true,
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "velocity_buffer": {
            "target": [
                "velocity_buffer"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "pmfx_shader": "forward_render",
            "technique": "per_pixel_velocity",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "gbuffer_view": {
            "target": [
                "gbuffer_albedo",
                "gbuffer_normals",
                "gbuffer_world_pos",
                "gbuffer_depth"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "clear_depth": 1.0,
            "clear": {
                "gbuffer_albedo": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                },
                "gbuffer_normals": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                },
                "gbuffer_world_pos": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                }
            },
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "blend_state": "disabled",
            "raster_state": "default",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "gbuffer",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ]
        },
        "deferred_lights_view": {
            "target": [
                "main_colour"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "additive",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "depth_always_no_write",
            "shader": "deferred_render",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_light_volumes"
            ],
            "sampler_bindings": [
                {
                    "texture": "gbuffer_albedo",
                    "unit": 0,
                    "state": "wrap_linear"
                },
                {
                    "texture": "gbuffer_normals",
                    "unit": 1,
                    "state": "wrap_linear"
                },
                {
                    "texture": "gbuffer_world_pos",
                    "unit": 2,
                    "state": "wrap_linear"
                },
                {
                    "texture": "gbuffer_depth",
                    "unit": 4,
                    "state": "wrap_linear"
                }
            ]
        },
        "gbuffer_view_msaa": {
            "target": [
                "gbuffer_albedo_msaa",
                "gbuffer_normals_msaa",
                "gbuffer_world_pos_msaa",
                "gbuffer_depth_msaa"
            ],
            "resolve": [
                "average_4x",
                "average_4x",
                "average_4x",
                "max_4x"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "clear_depth": 1.0,
            "clear": {
                "gbuffer_albedo": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                },
                "gbuffer_normals": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                },
                "gbuffer_world_pos": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                }
            },
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "blend_state": "disabled",
            "raster_state": "default",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "gbuffer",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ]
        },
        "deferred_lights_view_msaa": {
            "sampler_bindings": [
                {
                    "texture": "gbuffer_albedo_msaa",
                    "unit": 4,
                    "state": "wrap_linear",
                    "bind_flags": [
                        "ps",
                        "msaa"
                    ]
                },
                {
                    "texture": "gbuffer_normals_msaa",
                    "unit": 5,
                    "state": "wrap_linear",
                    "bind_flags": [
                        "ps",
                        "msaa"
                    ]
                },
                {
                    "texture": "gbuffer_world_pos_msaa",
                    "unit": 6,
                    "state": "wrap_linear",
                    "bind_flags": [
                        "ps",
                        "msaa"
                    ]
                },
                {
                    "texture": "gbuffer_depth_msaa",
                    "unit": 7,
                    "state": "wrap_linear",
                    "bind_flags": [
                        "ps",
                        "msaa"
                    ]
                }
            ],
            "permutation": 2,
            "target": [
                "main_colour"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "additive",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "depth_always_no_write",
            "shader": "deferred_render",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_light_volumes"
            ]
        }
    },
    "view_sets": {
        "deferred_render": [
            "gbuffer_view",
            "deferred_lights_view"
        ],
        "deferred_render_msaa": [
            "gbuffer_view_msaa",
            "deferred_lights_view_msaa"
        ]
    }
}{
    "render_targets": {
        "post_process_colour": {
            "size": "equal",
            "samples": 4,
            "format": "rgba8"
        },
        "post_process_depth": {
            "size": "equal",
            "samples": 4,
            "format": "d24s8"
        },
        "pp_output_full": {
            "size": "equal",
            "format": "rgba8",
            "pp": "write",
            "init_read": "post_process_colour"
        },
        "pp_output_half": {
            "size": "half",
            "format": "rgba8",
            "pp": "write"
        },
        "pp_output_quarter": {
            "size": "quarter",
            "format": "rgba8",
            "pp": "write"
        },
        "pp_output_eighth": {
            "size": "eighth",
            "format": "rgba8",
            "pp": "write"
        }
    },
    "filter_kernels": {
        "gauss_5_1": {
            "weights": [
                0.06136,
                0.24477,
                0.38774,
                0.24477,
                0.06136
            ],
            "offsets": [
                -2.0,
                -1.0,
                0.0,
                1.0,
                2.0
            ]
        },
        "gauss_7_1": {
            "weights": [
                0.00598,
                0.060626,
                0.241843,
                0.383103,
                0.241843,
                0.060626,
                0.00598
            ],
            "offsets": [
                -3.0,
                -2.0,
                -1.0,
                0.0,
                1.0,
                2.0,
                3.0
            ]
        },
        "gauss_9_1": {
            "weights": [
                0.000229,
                0.005977,
                0.060598,
                0.241732,
                0.382928,
                0.241732,
                0.060598,
                0.005977,
                0.000229
            ],
            "offsets": [
                -4.0,
                -3.0,
                -2.0,
                -1.0,
                0.0,
                1.0,
                2.0,
                3.0,
                4.0
            ]
        },
        "poisson_disc_16": {
            "offsets_xy": [
                0.2069841,
                0.2245269,
                0.525808,
                -0.2310817,
                0.1383943,
                0.9056122,
                0.6633009,
                0.5129843,
                -0.4002792,
                0.3727058,
                0.07912822,
                -0.6512921,
                -0.7726067,
                -0.5151217,
                -0.3843193,
                -0.1494132,
                -0.9107782,
                0.2500633,
                0.6940153,
                -0.7098927,
                -0.1964669,
                -0.379389,
                -0.4769286,
                0.1840863,
                -0.247328,
                -0.8798459,
                0.4206541,
                -0.714772,
                0.5829348,
                -0.09794202,
                0.3691838,
                0.4140642
            ]
        },
        "unjitter": {
            "offsets": [],
            "weights": []
        }
    },
    "views": {
        "blit": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "depth_always_no_write",
            "pmfx_shader": "post_process",
            "technique": "blit"
        },
        "blit_depth": {
            "clear_depth": 1.0,
            "colour_write_mask": 0,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "depth_always",
            "pmfx_shader": "post_process",
            "technique": "blit_depth"
        },
        "blit_colour_depth": {
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "depth_always",
            "pmfx_shader": "post_process",
            "technique": "blit_colour_depth"
        },
        "colour_lut": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "colour_lut"
        },
        "high_pass": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "high_pass"
        },
        "filter": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "filter"
        },
        "downsample_2x2": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "downsample_2x2"
        },
        "downsample_average": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "downsample_average"
        },
        "bloom_upsample": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "bloom_upsample"
        },
        "depth_of_field": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "depth_of_field",
            "camera": "model_viewer_camera"
        },
        "menger_sponge": {
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "depth_always",
            "pmfx_shader": "post_process",
            "technique": "menger_sponge",
            "camera": "model_viewer_camera"
        },
        "crt": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "crt",
            "camera": "model_viewer_camera"
        },
        "taa_resolve": {
            "colour_write_mask": 15,
            "clear_colour": [
                0.0,
                1.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "taa_resolve"
        }
    },
    "post_processes": {
        "bloom": [
            {
                "inherit": "high_pass",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal"
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical"
            },
            {
                "inherit": "downsample_average",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_half",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal"
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_half",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical"
            },
            {
                "inherit": "downsample_average",
                "target": [
                    "pp_output_quarter"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_half",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_quarter"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_quarter",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal"
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_quarter"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_quarter",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical"
            },
            {
                "inherit": "downsample_average",
                "target": [
                    "pp_output_eighth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_quarter",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_eighth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_eighth",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal"
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_eighth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_eighth",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical"
            },
            {
                "inherit": "bloom_upsample",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "post_process_colour",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_full",
                        "unit": 1,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_half",
                        "unit": 2,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_quarter",
                        "unit": 3,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_eighth",
                        "unit": 4,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "depth_of_field": [
            {
                "inherit": "downsample_2x2",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_half",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal"
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_half",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical"
            },
            {
                "inherit": "depth_of_field",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "post_process_depth",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_full",
                        "unit": 1,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_half",
                        "unit": 2,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "colour_lut": [
            {
                "inherit": "colour_lut",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "blit_depth": [
            {
                "inherit": "blit_depth",
                "target": [
                    "main_depth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "post_process_depth",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "blit_taa_depth": [
            {
                "inherit": "blit_depth",
                "technique": "blit_depth_unjittered",
                "target": [
                    "main_depth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "taa_depth",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "blit_post_process": [
            {
                "inherit": "blit",
                "target": [
                    "main_colour"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "blit_colour_depth": [
            {
                "inherit": "blit_colour_depth",
                "target": [
                    "main_colour",
                    "main_depth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "post_process_colour",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "post_process_depth",
                        "unit": 1,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "menger_sponge": [
            {
                "inherit": "menger_sponge",
                "target": [
                    "post_process_colour",
                    "post_process_depth"
                ],
                "pp_write_non_aux": true,
                "technique": "menger_sponge",
                "camera": "model_viewer_camera",
                "resolve": [
                    "average_4x",
                    "max_4x"
                ]
            }
        ],
        "crt": [
            {
                "inherit": "crt",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "sss_reflectance": [
            {
                "inherit": "filter",
                "target": [
                    "pp_output_full"
                ],
                "technique": "sss_reflectance",
                "camera": "model_viewer_camera",
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "post_process_depth",
                        "unit": 1,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_full"
                ],
                "technique": "sss_reflectance",
                "camera": "model_viewer_camera",
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "post_process_depth",
                        "unit": 1,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "taa_resolve": [
            {
                "inherit": "taa_resolve",
                "target": [
                    "pp_output_full"
                ],
                "technique": "taa_resolve",
                "camera": "model_viewer_camera",
                "scene_views": [
                    "ecs_taa_resolve"
                ],
                "sampler_bindings": [
                    {
                        "texture": "taa_colour",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "taa_depth",
                        "unit": 1,
                        "state": "clamp_point",
                        "shader": "ps"
                    },
                    {
                        "texture": "taa_history",
                        "unit": 2,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "blit",
                "target": [
                    "taa_history"
                ],
                "pp_write_non_aux": true,
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ]
    },
    "post_process_sets": {
        "blit_only": {
            "chain": [
                "blit_colour_depth"
            ]
        },
        "editor_default": {
            "chain": [
                "blit_depth",
                "blit_post_process"
            ]
        },
        "taa_resolve": {
            "chain": [
                "taa_resolve",
                "blit_taa_depth",
                "blit_post_process"
            ]
        }
    }
}{
    "cmdline": "../third_party/pmbuild/scripts/jsn/jsn -i ../assets/configs/editor_renderer.jsn -o build/web/data/configs/editor_renderer.jsn -I ../assets/configs assets/configs ",
    "files": {
        "build/web/data/configs/editor_renderer.jsn": [
            {
                "name": "/Users/alex.dixon/dev/pmtech/assets/configs/editor_renderer.jsn",
                "timestamp": 1608572066.9982443,
                "data_file": "data/configs/editor_renderer.jsn"
            }
        ]
    }
}{
    "cmdline": "../third_party/pmbuild/scripts/jsn/jsn -i assets/configs/dynamic_cubemap.jsn -o build/web/data/configs/dynamic_cubemap.jsn -I ../assets/configs assets/configs ",
    "files": {
        "build/web/data/configs/dynamic_cubemap.jsn": [
            {
                "name": "/Users/alex.dixon/dev/pmtech/examples/assets/configs/dynamic_cubemap.jsn",
                "timestamp": 1608572066.9953432,
                "data_file": "data/configs/dynamic_cubemap.jsn"
            }
        ]
    }
}{
    "cmdline": "../third_party/pmbuild/scripts/jsn/jsn -i assets/configs/rasterizer_state.jsn -o build/web/data/configs/rasterizer_state.jsn -I ../assets/configs assets/configs ",
    "files": {
        "build/web/data/configs/rasterizer_state.jsn": [
            {
                "name": "/Users/alex.dixon/dev/pmtech/examples/assets/configs/rasterizer_state.jsn",
                "timestamp": 1608572066.995627,
                "data_file": "data/configs/rasterizer_state.jsn"
            }
        ]
    }
}{
    "cmdline": "../third_party/pmbuild/scripts/jsn/jsn -i assets/configs/render_target_mip_maps.jsn -o build/web/data/configs/render_target_mip_maps.jsn -I ../assets/configs assets/configs ",
    "files": {
        "build/web/data/configs/render_target_mip_maps.jsn": [
            {
                "name": "/Users/alex.dixon/dev/pmtech/examples/assets/configs/render_target_mip_maps.jsn",
                "timestamp": 1608572066.9959788,
                "data_file": "data/configs/render_target_mip_maps.jsn"
            }
        ]
    }
}{
    "views": {
        "single_shadow_view": {
            "target": [
                "single_shadow_map"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "zonly",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_shadow_maps"
            ],
            "render_flags": [
                "shadow_map"
            ]
        },
        "sss_main": {
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "post_process": "pp_sss",
            "sampler_bindings": [
                {
                    "texture": "single_shadow_map",
                    "unit": 8,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "single_shadow_map",
                    "unit": 7,
                    "state": "shadow_compare",
                    "shader": "ps"
                }
            ],
            "target": [
                "post_process_colour",
                "post_process_depth"
            ],
            "resolve": [
                "average_4x",
                "max_4x"
            ],
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "main_view_no_clear": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "main_view": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "main_view_basic": {
            "raster_state": "default",
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "pmfx_shader": "forward_render",
            "technique": "simple_lighting",
            "sampler_bindings": [
                {
                    "texture": "single_shadow_map",
                    "unit": 7,
                    "state": "shadow_compare",
                    "shader": "ps"
                }
            ],
            "target": [
                "main_colour",
                "main_depth"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "main_view_alpha_blended": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "colour_write_mask": 15,
            "blend_state": "alpha_blend",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit",
                "alpha_blended"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear_lod",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "multiple_shadow_views": {
            "target": [
                "shadow_map"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "front_face_cull",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "zonly",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_shadow_maps"
            ],
            "render_flags": [
                "shadow_map"
            ]
        },
        "multiple_colour_shadow_views": {
            "target": [
                "colour_shadow_map",
                "colour_shadow_map_depth"
            ],
            "clear_colour": [
                0.0,
                1.0,
                1.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "back_face_cull",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "pmfx_shader": "forward_render",
            "technique": "gi",
            "scene_views": [
                "ecs_render_shadow_maps"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "multiple_omni_shadow_views": {
            "target": [
                "omni_shadow_map"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "front_face_cull",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "omni_shadow",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_omni_shadow_maps"
            ],
            "render_flags": [
                "shadow_map"
            ]
        },
        "multiple_area_light_views": {
            "target": [
                "area_light_textures"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "zonly",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_area_light_textures"
            ],
            "render_flags": [
                "area_light_textures"
            ],
            "generate_mip_maps": true
        },
        "main_view_post_processed": {
            "target": [
                "post_process_colour",
                "post_process_depth"
            ],
            "post_process": "editor_default",
            "resolve": [
                "average_4x",
                "max_4x"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "main_view_temporal_aa": {
            "target": [
                "taa_colour",
                "taa_depth"
            ],
            "post_process": "taa_resolve",
            "jitter": true,
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "velocity_buffer": {
            "target": [
                "velocity_buffer"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "pmfx_shader": "forward_render",
            "technique": "per_pixel_velocity",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "editor_main": {
            "raster_state": "default",
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "target": [
                "main_colour",
                "main_depth"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "editor_main_basic": {
            "raster_state": "default",
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "pmfx_shader": "forward_render",
            "technique": "simple_lighting",
            "sampler_bindings": [
                {
                    "texture": "single_shadow_map",
                    "unit": 7,
                    "state": "shadow_compare",
                    "shader": "ps"
                }
            ],
            "target": [
                "main_colour",
                "main_depth"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "editor_main_gi": {
            "raster_state": "default",
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "volume_gi",
                    "unit": 9,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ],
            "target": [
                "taa_colour",
                "taa_depth"
            ],
            "post_process": "taa_resolve",
            "jitter": true,
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "editor_view": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "wireframe",
            "depth_stencil_state": "default",
            "pmfx_shader": "pmfx_utility",
            "technique": "constant_colour",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_editor"
            ]
        },
        "picking_view": {
            "target": [
                "picking",
                "picking_ds"
            ],
            "clear": {
                "picking": {
                    "clear_colour_u": [
                        -1,
                        -1,
                        -1,
                        -1
                    ]
                }
            },
            "clear_depth": 1.0,
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "blend_state": "disabled",
            "raster_state": "default",
            "depth_stencil_state": "default",
            "pmfx_shader": "pmfx_utility",
            "technique": "picking",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ]
        },
        "volume_rasteriser": {
            "target": [
                "volume_raster",
                "volume_raster_ds"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "volume_raster",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "volume_rasteriser_camera",
            "pmfx_shader": "pmfx_utility",
            "technique": "volume_raster_albedo",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "wrap_linear",
                    "shader": "ps"
                }
            ]
        },
        "volume_gi_compute": {
            "type": "compute",
            "target": [
                "volume_gi"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "pmfx_shader": "compute",
            "technique": "volume_gi",
            "scene": "main_scene",
            "scene_views": [
                "ecs_compute_volume_gi"
            ],
            "generate_mip_maps": true
        },
        "gbuffer_view": {
            "target": [
                "gbuffer_albedo",
                "gbuffer_normals",
                "gbuffer_world_pos",
                "gbuffer_depth"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "clear_depth": 1.0,
            "clear": {
                "gbuffer_albedo": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                },
                "gbuffer_normals": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                },
                "gbuffer_world_pos": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                }
            },
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "blend_state": "disabled",
            "raster_state": "default",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "gbuffer",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ]
        },
        "deferred_lights_view": {
            "target": [
                "main_colour"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "additive",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "depth_always_no_write",
            "shader": "deferred_render",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_light_volumes"
            ],
            "sampler_bindings": [
                {
                    "texture": "gbuffer_albedo",
                    "unit": 0,
                    "state": "wrap_linear"
                },
                {
                    "texture": "gbuffer_normals",
                    "unit": 1,
                    "state": "wrap_linear"
                },
                {
                    "texture": "gbuffer_world_pos",
                    "unit": 2,
                    "state": "wrap_linear"
                },
                {
                    "texture": "gbuffer_depth",
                    "unit": 4,
                    "state": "wrap_linear"
                }
            ]
        },
        "gbuffer_view_msaa": {
            "target": [
                "gbuffer_albedo_msaa",
                "gbuffer_normals_msaa",
                "gbuffer_world_pos_msaa",
                "gbuffer_depth_msaa"
            ],
            "resolve": [
                "average_4x",
                "average_4x",
                "average_4x",
                "max_4x"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "clear_depth": 1.0,
            "clear": {
                "gbuffer_albedo": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                },
                "gbuffer_normals": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                },
                "gbuffer_world_pos": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                }
            },
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "blend_state": "disabled",
            "raster_state": "default",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "gbuffer",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ]
        },
        "deferred_lights_view_msaa": {
            "sampler_bindings": [
                {
                    "texture": "gbuffer_albedo_msaa",
                    "unit": 4,
                    "state": "wrap_linear",
                    "bind_flags": [
                        "ps",
                        "msaa"
                    ]
                },
                {
                    "texture": "gbuffer_normals_msaa",
                    "unit": 5,
                    "state": "wrap_linear",
                    "bind_flags": [
                        "ps",
                        "msaa"
                    ]
                },
                {
                    "texture": "gbuffer_world_pos_msaa",
                    "unit": 6,
                    "state": "wrap_linear",
                    "bind_flags": [
                        "ps",
                        "msaa"
                    ]
                },
                {
                    "texture": "gbuffer_depth_msaa",
                    "unit": 7,
                    "state": "wrap_linear",
                    "bind_flags": [
                        "ps",
                        "msaa"
                    ]
                }
            ],
            "permutation": 2,
            "target": [
                "main_colour"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "additive",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "depth_always_no_write",
            "shader": "deferred_render",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_light_volumes"
            ]
        },
        "blit": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "depth_always_no_write",
            "pmfx_shader": "post_process",
            "technique": "blit"
        },
        "blit_depth": {
            "clear_depth": 1.0,
            "colour_write_mask": 0,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "depth_always",
            "pmfx_shader": "post_process",
            "technique": "blit_depth"
        },
        "blit_colour_depth": {
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "depth_always",
            "pmfx_shader": "post_process",
            "technique": "blit_colour_depth"
        },
        "colour_lut": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "colour_lut"
        },
        "high_pass": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "high_pass"
        },
        "filter": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "filter"
        },
        "downsample_2x2": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "downsample_2x2"
        },
        "downsample_average": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "downsample_average"
        },
        "bloom_upsample": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "bloom_upsample"
        },
        "depth_of_field": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "depth_of_field",
            "camera": "model_viewer_camera"
        },
        "menger_sponge": {
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "depth_always",
            "pmfx_shader": "post_process",
            "technique": "menger_sponge",
            "camera": "model_viewer_camera"
        },
        "crt": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "crt",
            "camera": "model_viewer_camera"
        },
        "taa_resolve": {
            "colour_write_mask": 15,
            "clear_colour": [
                0.0,
                1.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "taa_resolve"
        }
    },
    "post_process_sets": {
        "pp_sss": {
            "chain": [
                "sss_reflectance",
                "blit_post_process"
            ]
        },
        "blit_only": {
            "chain": [
                "blit_colour_depth"
            ]
        },
        "editor_default": {
            "chain": [
                "blit_depth",
                "blit_post_process"
            ]
        },
        "taa_resolve": {
            "chain": [
                "taa_resolve",
                "blit_taa_depth",
                "blit_post_process"
            ]
        }
    },
    "view_sets": {
        "sss_view": [
            "single_shadow_view",
            "sss_main"
        ],
        "editor": [
            "multiple_shadow_views",
            "multiple_area_light_views",
            "multiple_omni_shadow_views",
            "picking_view",
            "editor_main",
            "editor_view"
        ],
        "editor_basic": [
            "single_shadow_view",
            "editor_main_basic",
            "editor_view"
        ],
        "editor_gi": [
            "multiple_shadow_views",
            "multiple_colour_shadow_views",
            "multiple_area_light_views",
            "multiple_omni_shadow_views",
            "volume_gi_compute",
            "picking_view",
            "editor_main_gi",
            "editor_view"
        ],
        "editor_post_processed": [
            "picking_view",
            "main_view_post_processed",
            "editor_view",
            "volume_rasteriser"
        ],
        "deferred_render": [
            "gbuffer_view",
            "deferred_lights_view"
        ],
        "deferred_render_msaa": [
            "gbuffer_view_msaa",
            "deferred_lights_view_msaa"
        ]
    },
    "view_set": "sss_view",
    "blend_states": {
        "disabled": {
            "blend_enable": false
        },
        "additive": {
            "blend_enable": true,
            "src_blend": "one",
            "dest_blend": "one"
        },
        "alpha_blend": {
            "blend_enable": true,
            "src_blend": "src_alpha",
            "dest_blend": "inv_src_alpha"
        }
    },
    "sampler_states": {
        "wrap_linear": {
            "filter": "linear",
            "address": "wrap"
        },
        "wrap_point": {
            "filter": "point",
            "address": "wrap"
        },
        "clamp_linear": {
            "filter": "linear",
            "address": "clamp"
        },
        "clamp_point": {
            "filter": "point",
            "address": "clamp"
        },
        "clamp_linear_lod": {
            "filter": "linear_lod",
            "address": "clamp"
        },
        "shadow_compare": {
            "filter": "linear",
            "address": "clamp",
            "comparison_func": "less"
        }
    },
    "depth_stencil_states": {
        "disabled": {
            "depth_enable": false
        },
        "default": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "less"
        },
        "depth_never": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "never"
        },
        "depth_always": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "always"
        },
        "depth_equal": {
            "depth_enable": true,
            "depth_write": false,
            "depth_func": "equal"
        },
        "depth_always_no_write": {
            "depth_enable": true,
            "depth_write": false,
            "depth_func": "always"
        },
        "stencil_test": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "always",
            "stencil_enable": true,
            "stencil_write_mask": 255,
            "stencil_read_mask": 255,
            "stencil_op": {
                "stencil_fail": "keep",
                "depth_fail": "keep",
                "stencil_pass": "replace",
                "stencil_func": "equal"
            }
        }
    },
    "raster_states": {
        "default": {
            "cull_mode": "back"
        },
        "wireframe": {
            "cull_mode": "none",
            "fill_mode": "wireframe"
        },
        "front_face_cull": {
            "cull_mode": "front",
            "fill_mode": "solid"
        },
        "volume_raster": {
            "cull_mode": "back"
        },
        "post_process": {
            "cull_mode": "none"
        },
        "no_cull": {
            "cull_mode": "none"
        },
        "disabled": {
            "cull_mode": "none"
        }
    },
    "render_targets": {
        "single_shadow_map": {
            "size": [
                2048,
                2048
            ],
            "format": "d32f"
        },
        "shadow_map": {
            "size": [
                2048,
                2048
            ],
            "format": "d32f",
            "type": "array"
        },
        "omni_shadow_map": {
            "size": [
                512,
                512
            ],
            "format": "d24s8",
            "type": "cube_array"
        },
        "colour_shadow_map": {
            "size": [
                512,
                512
            ],
            "format": "rgba8",
            "type": "array"
        },
        "colour_shadow_map_depth": {
            "size": [
                512,
                512
            ],
            "format": "d24s8",
            "type": "array"
        },
        "area_light_textures": {
            "size": [
                640,
                480
            ],
            "format": "rgba8",
            "type": "array",
            "mips": true
        },
        "taa_history": {
            "format": "rgba8",
            "size": "equal"
        },
        "taa_colour": {
            "format": "rgba8",
            "size": "equal"
        },
        "taa_depth": {
            "format": "d24s8",
            "size": "equal"
        },
        "velocity_buffer": {
            "format": "r32f",
            "size": "equal"
        },
        "picking": {
            "size": "equal",
            "format": "r32u",
            "cpu_read": true
        },
        "picking_ds": {
            "size": "equal",
            "format": "d24s8"
        },
        "volume_raster": {
            "size": [
                128,
                128
            ],
            "format": "rgba8",
            "cpu_read": true
        },
        "volume_raster_ds": {
            "size": [
                128,
                128
            ],
            "format": "d24s8"
        },
        "volume_gi": {
            "size": [
                256,
                256,
                256
            ],
            "format": "rgba8",
            "gpu_write": true,
            "mips": true
        },
        "gbuffer_depth": {
            "size": "equal",
            "format": "d24s8"
        },
        "gbuffer_albedo": {
            "size": "equal",
            "format": "rgba8"
        },
        "gbuffer_normals": {
            "size": "equal",
            "format": "rgba32f"
        },
        "gbuffer_world_pos": {
            "size": "equal",
            "format": "rgba32f"
        },
        "gbuffer_depth_msaa": {
            "size": "equal",
            "format": "d24s8",
            "samples": 4
        },
        "gbuffer_albedo_msaa": {
            "size": "equal",
            "format": "rgba8",
            "samples": 4
        },
        "gbuffer_normals_msaa": {
            "size": "equal",
            "format": "rgba32f",
            "samples": 4
        },
        "gbuffer_world_pos_msaa": {
            "size": "equal",
            "format": "rgba32f",
            "samples": 4
        },
        "post_process_colour": {
            "size": "equal",
            "samples": 4,
            "format": "rgba8"
        },
        "post_process_depth": {
            "size": "equal",
            "samples": 4,
            "format": "d24s8"
        },
        "pp_output_full": {
            "size": "equal",
            "format": "rgba8",
            "pp": "write",
            "init_read": "post_process_colour"
        },
        "pp_output_half": {
            "size": "half",
            "format": "rgba8",
            "pp": "write"
        },
        "pp_output_quarter": {
            "size": "quarter",
            "format": "rgba8",
            "pp": "write"
        },
        "pp_output_eighth": {
            "size": "eighth",
            "format": "rgba8",
            "pp": "write"
        }
    },
    "filter_kernels": {
        "gauss_5_1": {
            "weights": [
                0.06136,
                0.24477,
                0.38774,
                0.24477,
                0.06136
            ],
            "offsets": [
                -2.0,
                -1.0,
                0.0,
                1.0,
                2.0
            ]
        },
        "gauss_7_1": {
            "weights": [
                0.00598,
                0.060626,
                0.241843,
                0.383103,
                0.241843,
                0.060626,
                0.00598
            ],
            "offsets": [
                -3.0,
                -2.0,
                -1.0,
                0.0,
                1.0,
                2.0,
                3.0
            ]
        },
        "gauss_9_1": {
            "weights": [
                0.000229,
                0.005977,
                0.060598,
                0.241732,
                0.382928,
                0.241732,
                0.060598,
                0.005977,
                0.000229
            ],
            "offsets": [
                -4.0,
                -3.0,
                -2.0,
                -1.0,
                0.0,
                1.0,
                2.0,
                3.0,
                4.0
            ]
        },
        "poisson_disc_16": {
            "offsets_xy": [
                0.2069841,
                0.2245269,
                0.525808,
                -0.2310817,
                0.1383943,
                0.9056122,
                0.6633009,
                0.5129843,
                -0.4002792,
                0.3727058,
                0.07912822,
                -0.6512921,
                -0.7726067,
                -0.5151217,
                -0.3843193,
                -0.1494132,
                -0.9107782,
                0.2500633,
                0.6940153,
                -0.7098927,
                -0.1964669,
                -0.379389,
                -0.4769286,
                0.1840863,
                -0.247328,
                -0.8798459,
                0.4206541,
                -0.714772,
                0.5829348,
                -0.09794202,
                0.3691838,
                0.4140642
            ]
        },
        "unjitter": {
            "offsets": [],
            "weights": []
        }
    },
    "post_processes": {
        "bloom": [
            {
                "inherit": "high_pass",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal"
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical"
            },
            {
                "inherit": "downsample_average",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_half",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal"
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_half",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical"
            },
            {
                "inherit": "downsample_average",
                "target": [
                    "pp_output_quarter"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_half",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_quarter"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_quarter",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal"
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_quarter"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_quarter",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical"
            },
            {
                "inherit": "downsample_average",
                "target": [
                    "pp_output_eighth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_quarter",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_eighth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_eighth",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal"
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_eighth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_eighth",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical"
            },
            {
                "inherit": "bloom_upsample",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "post_process_colour",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_full",
                        "unit": 1,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_half",
                        "unit": 2,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_quarter",
                        "unit": 3,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_eighth",
                        "unit": 4,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "depth_of_field": [
            {
                "inherit": "downsample_2x2",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_half",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal"
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_half",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical"
            },
            {
                "inherit": "depth_of_field",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "post_process_depth",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_full",
                        "unit": 1,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_half",
                        "unit": 2,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "colour_lut": [
            {
                "inherit": "colour_lut",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "blit_depth": [
            {
                "inherit": "blit_depth",
                "target": [
                    "main_depth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "post_process_depth",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "blit_taa_depth": [
            {
                "inherit": "blit_depth",
                "technique": "blit_depth_unjittered",
                "target": [
                    "main_depth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "taa_depth",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "blit_post_process": [
            {
                "inherit": "blit",
                "target": [
                    "main_colour"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "blit_colour_depth": [
            {
                "inherit": "blit_colour_depth",
                "target": [
                    "main_colour",
                    "main_depth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "post_process_colour",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "post_process_depth",
                        "unit": 1,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "menger_sponge": [
            {
                "inherit": "menger_sponge",
                "target": [
                    "post_process_colour",
                    "post_process_depth"
                ],
                "pp_write_non_aux": true,
                "technique": "menger_sponge",
                "camera": "model_viewer_camera",
                "resolve": [
                    "average_4x",
                    "max_4x"
                ]
            }
        ],
        "crt": [
            {
                "inherit": "crt",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "sss_reflectance": [
            {
                "inherit": "filter",
                "target": [
                    "pp_output_full"
                ],
                "technique": "sss_reflectance",
                "camera": "model_viewer_camera",
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "post_process_depth",
                        "unit": 1,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_full"
                ],
                "technique": "sss_reflectance",
                "camera": "model_viewer_camera",
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "post_process_depth",
                        "unit": 1,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "taa_resolve": [
            {
                "inherit": "taa_resolve",
                "target": [
                    "pp_output_full"
                ],
                "technique": "taa_resolve",
                "camera": "model_viewer_camera",
                "scene_views": [
                    "ecs_taa_resolve"
                ],
                "sampler_bindings": [
                    {
                        "texture": "taa_colour",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "taa_depth",
                        "unit": 1,
                        "state": "clamp_point",
                        "shader": "ps"
                    },
                    {
                        "texture": "taa_history",
                        "unit": 2,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "blit",
                "target": [
                    "taa_history"
                ],
                "pp_write_non_aux": true,
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ]
    }
}{
    "views": {
        "view_clear": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "clear_colour": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "clear_depth": 1.0,
            "clear_stencil": 0
        },
        "view_boids": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "pmfx_shader": "compute_demo",
            "technique": "boids_render",
            "scene_views": [
                "boids"
            ]
        },
        "update_boids": {
            "type": "compute",
            "pmfx_shader": "compute_demo",
            "technique": "boids_update",
            "scene_views": [
                "boids_update"
            ]
        },
        "main_view_no_clear": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "main_view": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "main_view_basic": {
            "raster_state": "default",
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "pmfx_shader": "forward_render",
            "technique": "simple_lighting",
            "sampler_bindings": [
                {
                    "texture": "single_shadow_map",
                    "unit": 7,
                    "state": "shadow_compare",
                    "shader": "ps"
                }
            ],
            "target": [
                "main_colour",
                "main_depth"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "main_view_alpha_blended": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "colour_write_mask": 15,
            "blend_state": "alpha_blend",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit",
                "alpha_blended"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear_lod",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "multiple_shadow_views": {
            "target": [
                "shadow_map"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "front_face_cull",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "zonly",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_shadow_maps"
            ],
            "render_flags": [
                "shadow_map"
            ]
        },
        "single_shadow_view": {
            "target": [
                "single_shadow_map"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "front_face_cull",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "zonly",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_shadow_maps"
            ],
            "render_flags": [
                "shadow_map"
            ]
        },
        "multiple_colour_shadow_views": {
            "target": [
                "colour_shadow_map",
                "colour_shadow_map_depth"
            ],
            "clear_colour": [
                0.0,
                1.0,
                1.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "back_face_cull",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "pmfx_shader": "forward_render",
            "technique": "gi",
            "scene_views": [
                "ecs_render_shadow_maps"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "multiple_omni_shadow_views": {
            "target": [
                "omni_shadow_map"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "front_face_cull",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "omni_shadow",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_omni_shadow_maps"
            ],
            "render_flags": [
                "shadow_map"
            ]
        },
        "multiple_area_light_views": {
            "target": [
                "area_light_textures"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "zonly",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_area_light_textures"
            ],
            "render_flags": [
                "area_light_textures"
            ],
            "generate_mip_maps": true
        },
        "main_view_post_processed": {
            "target": [
                "post_process_colour",
                "post_process_depth"
            ],
            "post_process": "editor_default",
            "resolve": [
                "average_4x",
                "max_4x"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "main_view_temporal_aa": {
            "target": [
                "taa_colour",
                "taa_depth"
            ],
            "post_process": "taa_resolve",
            "jitter": true,
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "velocity_buffer": {
            "target": [
                "velocity_buffer"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "pmfx_shader": "forward_render",
            "technique": "per_pixel_velocity",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "editor_main": {
            "raster_state": "default",
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "target": [
                "main_colour",
                "main_depth"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "editor_main_basic": {
            "raster_state": "default",
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "pmfx_shader": "forward_render",
            "technique": "simple_lighting",
            "sampler_bindings": [
                {
                    "texture": "single_shadow_map",
                    "unit": 7,
                    "state": "shadow_compare",
                    "shader": "ps"
                }
            ],
            "target": [
                "main_colour",
                "main_depth"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "editor_main_gi": {
            "raster_state": "default",
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "volume_gi",
                    "unit": 9,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ],
            "target": [
                "taa_colour",
                "taa_depth"
            ],
            "post_process": "taa_resolve",
            "jitter": true,
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "editor_view": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "wireframe",
            "depth_stencil_state": "default",
            "pmfx_shader": "pmfx_utility",
            "technique": "constant_colour",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_editor"
            ]
        },
        "picking_view": {
            "target": [
                "picking",
                "picking_ds"
            ],
            "clear": {
                "picking": {
                    "clear_colour_u": [
                        -1,
                        -1,
                        -1,
                        -1
                    ]
                }
            },
            "clear_depth": 1.0,
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "blend_state": "disabled",
            "raster_state": "default",
            "depth_stencil_state": "default",
            "pmfx_shader": "pmfx_utility",
            "technique": "picking",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ]
        },
        "volume_rasteriser": {
            "target": [
                "volume_raster",
                "volume_raster_ds"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "volume_raster",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "volume_rasteriser_camera",
            "pmfx_shader": "pmfx_utility",
            "technique": "volume_raster_albedo",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "wrap_linear",
                    "shader": "ps"
                }
            ]
        },
        "volume_gi_compute": {
            "type": "compute",
            "target": [
                "volume_gi"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "pmfx_shader": "compute",
            "technique": "volume_gi",
            "scene": "main_scene",
            "scene_views": [
                "ecs_compute_volume_gi"
            ],
            "generate_mip_maps": true
        },
        "gbuffer_view": {
            "target": [
                "gbuffer_albedo",
                "gbuffer_normals",
                "gbuffer_world_pos",
                "gbuffer_depth"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "clear_depth": 1.0,
            "clear": {
                "gbuffer_albedo": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                },
                "gbuffer_normals": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                },
                "gbuffer_world_pos": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                }
            },
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "blend_state": "disabled",
            "raster_state": "default",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "gbuffer",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ]
        },
        "deferred_lights_view": {
            "target": [
                "main_colour"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "additive",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "depth_always_no_write",
            "shader": "deferred_render",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_light_volumes"
            ],
            "sampler_bindings": [
                {
                    "texture": "gbuffer_albedo",
                    "unit": 0,
                    "state": "wrap_linear"
                },
                {
                    "texture": "gbuffer_normals",
                    "unit": 1,
                    "state": "wrap_linear"
                },
                {
                    "texture": "gbuffer_world_pos",
                    "unit": 2,
                    "state": "wrap_linear"
                },
                {
                    "texture": "gbuffer_depth",
                    "unit": 4,
                    "state": "wrap_linear"
                }
            ]
        },
        "gbuffer_view_msaa": {
            "target": [
                "gbuffer_albedo_msaa",
                "gbuffer_normals_msaa",
                "gbuffer_world_pos_msaa",
                "gbuffer_depth_msaa"
            ],
            "resolve": [
                "average_4x",
                "average_4x",
                "average_4x",
                "max_4x"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "clear_depth": 1.0,
            "clear": {
                "gbuffer_albedo": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                },
                "gbuffer_normals": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                },
                "gbuffer_world_pos": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                }
            },
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "blend_state": "disabled",
            "raster_state": "default",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "gbuffer",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ]
        },
        "deferred_lights_view_msaa": {
            "sampler_bindings": [
                {
                    "texture": "gbuffer_albedo_msaa",
                    "unit": 4,
                    "state": "wrap_linear",
                    "bind_flags": [
                        "ps",
                        "msaa"
                    ]
                },
                {
                    "texture": "gbuffer_normals_msaa",
                    "unit": 5,
                    "state": "wrap_linear",
                    "bind_flags": [
                        "ps",
                        "msaa"
                    ]
                },
                {
                    "texture": "gbuffer_world_pos_msaa",
                    "unit": 6,
                    "state": "wrap_linear",
                    "bind_flags": [
                        "ps",
                        "msaa"
                    ]
                },
                {
                    "texture": "gbuffer_depth_msaa",
                    "unit": 7,
                    "state": "wrap_linear",
                    "bind_flags": [
                        "ps",
                        "msaa"
                    ]
                }
            ],
            "permutation": 2,
            "target": [
                "main_colour"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "additive",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "depth_always_no_write",
            "shader": "deferred_render",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_light_volumes"
            ]
        },
        "blit": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "depth_always_no_write",
            "pmfx_shader": "post_process",
            "technique": "blit"
        },
        "blit_depth": {
            "clear_depth": 1.0,
            "colour_write_mask": 0,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "depth_always",
            "pmfx_shader": "post_process",
            "technique": "blit_depth"
        },
        "blit_colour_depth": {
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "depth_always",
            "pmfx_shader": "post_process",
            "technique": "blit_colour_depth"
        },
        "colour_lut": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "colour_lut"
        },
        "high_pass": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "high_pass"
        },
        "filter": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "filter"
        },
        "downsample_2x2": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "downsample_2x2"
        },
        "downsample_average": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "downsample_average"
        },
        "bloom_upsample": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "bloom_upsample"
        },
        "depth_of_field": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "depth_of_field",
            "camera": "model_viewer_camera"
        },
        "menger_sponge": {
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "depth_always",
            "pmfx_shader": "post_process",
            "technique": "menger_sponge",
            "camera": "model_viewer_camera"
        },
        "crt": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "crt",
            "camera": "model_viewer_camera"
        },
        "taa_resolve": {
            "colour_write_mask": 15,
            "clear_colour": [
                0.0,
                1.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "taa_resolve"
        }
    },
    "view_sets": {
        "boids": [
            "update_boids",
            "view_boids",
            "editor_view"
        ],
        "editor": [
            "multiple_shadow_views",
            "multiple_area_light_views",
            "multiple_omni_shadow_views",
            "picking_view",
            "editor_main",
            "editor_view"
        ],
        "editor_basic": [
            "single_shadow_view",
            "editor_main_basic",
            "editor_view"
        ],
        "editor_gi": [
            "multiple_shadow_views",
            "multiple_colour_shadow_views",
            "multiple_area_light_views",
            "multiple_omni_shadow_views",
            "volume_gi_compute",
            "picking_view",
            "editor_main_gi",
            "editor_view"
        ],
        "editor_post_processed": [
            "picking_view",
            "main_view_post_processed",
            "editor_view",
            "volume_rasteriser"
        ],
        "deferred_render": [
            "gbuffer_view",
            "deferred_lights_view"
        ],
        "deferred_render_msaa": [
            "gbuffer_view_msaa",
            "deferred_lights_view_msaa"
        ]
    },
    "view_set": "boids",
    "blend_states": {
        "disabled": {
            "blend_enable": false
        },
        "additive": {
            "blend_enable": true,
            "src_blend": "one",
            "dest_blend": "one"
        },
        "alpha_blend": {
            "blend_enable": true,
            "src_blend": "src_alpha",
            "dest_blend": "inv_src_alpha"
        }
    },
    "sampler_states": {
        "wrap_linear": {
            "filter": "linear",
            "address": "wrap"
        },
        "wrap_point": {
            "filter": "point",
            "address": "wrap"
        },
        "clamp_linear": {
            "filter": "linear",
            "address": "clamp"
        },
        "clamp_point": {
            "filter": "point",
            "address": "clamp"
        },
        "clamp_linear_lod": {
            "filter": "linear_lod",
            "address": "clamp"
        },
        "shadow_compare": {
            "filter": "linear",
            "address": "clamp",
            "comparison_func": "less"
        }
    },
    "depth_stencil_states": {
        "disabled": {
            "depth_enable": false
        },
        "default": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "less"
        },
        "depth_never": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "never"
        },
        "depth_always": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "always"
        },
        "depth_equal": {
            "depth_enable": true,
            "depth_write": false,
            "depth_func": "equal"
        },
        "depth_always_no_write": {
            "depth_enable": true,
            "depth_write": false,
            "depth_func": "always"
        },
        "stencil_test": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "always",
            "stencil_enable": true,
            "stencil_write_mask": 255,
            "stencil_read_mask": 255,
            "stencil_op": {
                "stencil_fail": "keep",
                "depth_fail": "keep",
                "stencil_pass": "replace",
                "stencil_func": "equal"
            }
        }
    },
    "raster_states": {
        "default": {
            "cull_mode": "back"
        },
        "wireframe": {
            "cull_mode": "none",
            "fill_mode": "wireframe"
        },
        "front_face_cull": {
            "cull_mode": "front",
            "fill_mode": "solid"
        },
        "volume_raster": {
            "cull_mode": "back"
        },
        "post_process": {
            "cull_mode": "none"
        },
        "no_cull": {
            "cull_mode": "none"
        },
        "disabled": {
            "cull_mode": "none"
        }
    },
    "render_targets": {
        "single_shadow_map": {
            "size": [
                2048,
                2048
            ],
            "format": "d32f"
        },
        "shadow_map": {
            "size": [
                2048,
                2048
            ],
            "format": "d32f",
            "type": "array"
        },
        "omni_shadow_map": {
            "size": [
                512,
                512
            ],
            "format": "d24s8",
            "type": "cube_array"
        },
        "colour_shadow_map": {
            "size": [
                512,
                512
            ],
            "format": "rgba8",
            "type": "array"
        },
        "colour_shadow_map_depth": {
            "size": [
                512,
                512
            ],
            "format": "d24s8",
            "type": "array"
        },
        "area_light_textures": {
            "size": [
                640,
                480
            ],
            "format": "rgba8",
            "type": "array",
            "mips": true
        },
        "taa_history": {
            "format": "rgba8",
            "size": "equal"
        },
        "taa_colour": {
            "format": "rgba8",
            "size": "equal"
        },
        "taa_depth": {
            "format": "d24s8",
            "size": "equal"
        },
        "velocity_buffer": {
            "format": "r32f",
            "size": "equal"
        },
        "picking": {
            "size": "equal",
            "format": "r32u",
            "cpu_read": true
        },
        "picking_ds": {
            "size": "equal",
            "format": "d24s8"
        },
        "volume_raster": {
            "size": [
                128,
                128
            ],
            "format": "rgba8",
            "cpu_read": true
        },
        "volume_raster_ds": {
            "size": [
                128,
                128
            ],
            "format": "d24s8"
        },
        "volume_gi": {
            "size": [
                256,
                256,
                256
            ],
            "format": "rgba8",
            "gpu_write": true,
            "mips": true
        },
        "gbuffer_depth": {
            "size": "equal",
            "format": "d24s8"
        },
        "gbuffer_albedo": {
            "size": "equal",
            "format": "rgba8"
        },
        "gbuffer_normals": {
            "size": "equal",
            "format": "rgba32f"
        },
        "gbuffer_world_pos": {
            "size": "equal",
            "format": "rgba32f"
        },
        "gbuffer_depth_msaa": {
            "size": "equal",
            "format": "d24s8",
            "samples": 4
        },
        "gbuffer_albedo_msaa": {
            "size": "equal",
            "format": "rgba8",
            "samples": 4
        },
        "gbuffer_normals_msaa": {
            "size": "equal",
            "format": "rgba32f",
            "samples": 4
        },
        "gbuffer_world_pos_msaa": {
            "size": "equal",
            "format": "rgba32f",
            "samples": 4
        },
        "post_process_colour": {
            "size": "equal",
            "samples": 4,
            "format": "rgba8"
        },
        "post_process_depth": {
            "size": "equal",
            "samples": 4,
            "format": "d24s8"
        },
        "pp_output_full": {
            "size": "equal",
            "format": "rgba8",
            "pp": "write",
            "init_read": "post_process_colour"
        },
        "pp_output_half": {
            "size": "half",
            "format": "rgba8",
            "pp": "write"
        },
        "pp_output_quarter": {
            "size": "quarter",
            "format": "rgba8",
            "pp": "write"
        },
        "pp_output_eighth": {
            "size": "eighth",
            "format": "rgba8",
            "pp": "write"
        }
    },
    "filter_kernels": {
        "gauss_5_1": {
            "weights": [
                0.06136,
                0.24477,
                0.38774,
                0.24477,
                0.06136
            ],
            "offsets": [
                -2.0,
                -1.0,
                0.0,
                1.0,
                2.0
            ]
        },
        "gauss_7_1": {
            "weights": [
                0.00598,
                0.060626,
                0.241843,
                0.383103,
                0.241843,
                0.060626,
                0.00598
            ],
            "offsets": [
                -3.0,
                -2.0,
                -1.0,
                0.0,
                1.0,
                2.0,
                3.0
            ]
        },
        "gauss_9_1": {
            "weights": [
                0.000229,
                0.005977,
                0.060598,
                0.241732,
                0.382928,
                0.241732,
                0.060598,
                0.005977,
                0.000229
            ],
            "offsets": [
                -4.0,
                -3.0,
                -2.0,
                -1.0,
                0.0,
                1.0,
                2.0,
                3.0,
                4.0
            ]
        },
        "poisson_disc_16": {
            "offsets_xy": [
                0.2069841,
                0.2245269,
                0.525808,
                -0.2310817,
                0.1383943,
                0.9056122,
                0.6633009,
                0.5129843,
                -0.4002792,
                0.3727058,
                0.07912822,
                -0.6512921,
                -0.7726067,
                -0.5151217,
                -0.3843193,
                -0.1494132,
                -0.9107782,
                0.2500633,
                0.6940153,
                -0.7098927,
                -0.1964669,
                -0.379389,
                -0.4769286,
                0.1840863,
                -0.247328,
                -0.8798459,
                0.4206541,
                -0.714772,
                0.5829348,
                -0.09794202,
                0.3691838,
                0.4140642
            ]
        },
        "unjitter": {
            "offsets": [],
            "weights": []
        }
    },
    "post_processes": {
        "bloom": [
            {
                "inherit": "high_pass",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal"
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical"
            },
            {
                "inherit": "downsample_average",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_half",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal"
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_half",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical"
            },
            {
                "inherit": "downsample_average",
                "target": [
                    "pp_output_quarter"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_half",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_quarter"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_quarter",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal"
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_quarter"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_quarter",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical"
            },
            {
                "inherit": "downsample_average",
                "target": [
                    "pp_output_eighth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_quarter",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_eighth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_eighth",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal"
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_eighth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_eighth",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical"
            },
            {
                "inherit": "bloom_upsample",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "post_process_colour",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_full",
                        "unit": 1,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_half",
                        "unit": 2,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_quarter",
                        "unit": 3,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_eighth",
                        "unit": 4,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "depth_of_field": [
            {
                "inherit": "downsample_2x2",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_half",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal"
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_half",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical"
            },
            {
                "inherit": "depth_of_field",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "post_process_depth",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_full",
                        "unit": 1,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_half",
                        "unit": 2,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "colour_lut": [
            {
                "inherit": "colour_lut",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "blit_depth": [
            {
                "inherit": "blit_depth",
                "target": [
                    "main_depth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "post_process_depth",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "blit_taa_depth": [
            {
                "inherit": "blit_depth",
                "technique": "blit_depth_unjittered",
                "target": [
                    "main_depth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "taa_depth",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "blit_post_process": [
            {
                "inherit": "blit",
                "target": [
                    "main_colour"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "blit_colour_depth": [
            {
                "inherit": "blit_colour_depth",
                "target": [
                    "main_colour",
                    "main_depth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "post_process_colour",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "post_process_depth",
                        "unit": 1,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "menger_sponge": [
            {
                "inherit": "menger_sponge",
                "target": [
                    "post_process_colour",
                    "post_process_depth"
                ],
                "pp_write_non_aux": true,
                "technique": "menger_sponge",
                "camera": "model_viewer_camera",
                "resolve": [
                    "average_4x",
                    "max_4x"
                ]
            }
        ],
        "crt": [
            {
                "inherit": "crt",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "sss_reflectance": [
            {
                "inherit": "filter",
                "target": [
                    "pp_output_full"
                ],
                "technique": "sss_reflectance",
                "camera": "model_viewer_camera",
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "post_process_depth",
                        "unit": 1,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_full"
                ],
                "technique": "sss_reflectance",
                "camera": "model_viewer_camera",
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "post_process_depth",
                        "unit": 1,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "taa_resolve": [
            {
                "inherit": "taa_resolve",
                "target": [
                    "pp_output_full"
                ],
                "technique": "taa_resolve",
                "camera": "model_viewer_camera",
                "scene_views": [
                    "ecs_taa_resolve"
                ],
                "sampler_bindings": [
                    {
                        "texture": "taa_colour",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "taa_depth",
                        "unit": 1,
                        "state": "clamp_point",
                        "shader": "ps"
                    },
                    {
                        "texture": "taa_history",
                        "unit": 2,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "blit",
                "target": [
                    "taa_history"
                ],
                "pp_write_non_aux": true,
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ]
    },
    "post_process_sets": {
        "blit_only": {
            "chain": [
                "blit_colour_depth"
            ]
        },
        "editor_default": {
            "chain": [
                "blit_depth",
                "blit_post_process"
            ]
        },
        "taa_resolve": {
            "chain": [
                "taa_resolve",
                "blit_taa_depth",
                "blit_post_process"
            ]
        }
    }
}{
    "cmdline": "../third_party/pmbuild/scripts/jsn/jsn -i assets/configs/blend_modes.jsn -o build/web/data/configs/blend_modes.jsn -I ../assets/configs assets/configs ",
    "files": {
        "build/web/data/configs/blend_modes.jsn": [
            {
                "name": "/Users/alex.dixon/dev/pmtech/examples/assets/configs/blend_modes.jsn",
                "timestamp": 1608572066.996229,
                "data_file": "data/configs/blend_modes.jsn"
            }
        ]
    }
}{
    "cmdline": "../third_party/pmbuild/scripts/jsn/jsn -i ../assets/configs/basic_renderer.jsn -o build/web/data/configs/basic_renderer.jsn -I ../assets/configs assets/configs ",
    "files": {
        "build/web/data/configs/basic_renderer.jsn": [
            {
                "name": "/Users/alex.dixon/dev/pmtech/assets/configs/basic_renderer.jsn",
                "timestamp": 1608572066.9984138,
                "data_file": "data/configs/basic_renderer.jsn"
            }
        ]
    }
}{
    "views": {
        "single_shadow_view": {
            "target": [
                "shadow_map"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "front_face_cull",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "zonly",
            "scene": "main_scene",
            "camera": "shadow_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "debug_view": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "wireframe",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "constant_colour",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "shadows_debug"
            ]
        },
        "shadow_demo_main": {
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "wrap_linear",
                    "shader": "ps"
                }
            ],
            "target": [
                "main_colour",
                "main_depth"
            ],
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "main_view_no_clear": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "main_view": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "main_view_basic": {
            "raster_state": "default",
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "pmfx_shader": "forward_render",
            "technique": "simple_lighting",
            "sampler_bindings": [
                {
                    "texture": "single_shadow_map",
                    "unit": 7,
                    "state": "shadow_compare",
                    "shader": "ps"
                }
            ],
            "target": [
                "main_colour",
                "main_depth"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "main_view_alpha_blended": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "colour_write_mask": 15,
            "blend_state": "alpha_blend",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit",
                "alpha_blended"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear_lod",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "multiple_shadow_views": {
            "target": [
                "shadow_map"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "front_face_cull",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "zonly",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_shadow_maps"
            ],
            "render_flags": [
                "shadow_map"
            ]
        },
        "multiple_colour_shadow_views": {
            "target": [
                "colour_shadow_map",
                "colour_shadow_map_depth"
            ],
            "clear_colour": [
                0.0,
                1.0,
                1.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "back_face_cull",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "pmfx_shader": "forward_render",
            "technique": "gi",
            "scene_views": [
                "ecs_render_shadow_maps"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "multiple_omni_shadow_views": {
            "target": [
                "omni_shadow_map"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "front_face_cull",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "omni_shadow",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_omni_shadow_maps"
            ],
            "render_flags": [
                "shadow_map"
            ]
        },
        "multiple_area_light_views": {
            "target": [
                "area_light_textures"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "zonly",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_area_light_textures"
            ],
            "render_flags": [
                "area_light_textures"
            ],
            "generate_mip_maps": true
        },
        "main_view_post_processed": {
            "target": [
                "post_process_colour",
                "post_process_depth"
            ],
            "post_process": "editor_default",
            "resolve": [
                "average_4x",
                "max_4x"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "main_view_temporal_aa": {
            "target": [
                "taa_colour",
                "taa_depth"
            ],
            "post_process": "taa_resolve",
            "jitter": true,
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "velocity_buffer": {
            "target": [
                "velocity_buffer"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "pmfx_shader": "forward_render",
            "technique": "per_pixel_velocity",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ]
        }
    },
    "view_sets": {
        "shadow_map": [
            "single_shadow_view",
            "shadow_demo_main",
            "debug_view"
        ]
    },
    "view_set": "shadow_map",
    "blend_states": {
        "disabled": {
            "blend_enable": false
        },
        "additive": {
            "blend_enable": true,
            "src_blend": "one",
            "dest_blend": "one"
        },
        "alpha_blend": {
            "blend_enable": true,
            "src_blend": "src_alpha",
            "dest_blend": "inv_src_alpha"
        }
    },
    "sampler_states": {
        "wrap_linear": {
            "filter": "linear",
            "address": "wrap"
        },
        "wrap_point": {
            "filter": "point",
            "address": "wrap"
        },
        "clamp_linear": {
            "filter": "linear",
            "address": "clamp"
        },
        "clamp_point": {
            "filter": "point",
            "address": "clamp"
        },
        "clamp_linear_lod": {
            "filter": "linear_lod",
            "address": "clamp"
        },
        "shadow_compare": {
            "filter": "linear",
            "address": "clamp",
            "comparison_func": "less"
        }
    },
    "depth_stencil_states": {
        "disabled": {
            "depth_enable": false
        },
        "default": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "less"
        },
        "depth_never": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "never"
        },
        "depth_always": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "always"
        },
        "depth_equal": {
            "depth_enable": true,
            "depth_write": false,
            "depth_func": "equal"
        },
        "depth_always_no_write": {
            "depth_enable": true,
            "depth_write": false,
            "depth_func": "always"
        },
        "stencil_test": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "always",
            "stencil_enable": true,
            "stencil_write_mask": 255,
            "stencil_read_mask": 255,
            "stencil_op": {
                "stencil_fail": "keep",
                "depth_fail": "keep",
                "stencil_pass": "replace",
                "stencil_func": "equal"
            }
        }
    },
    "raster_states": {
        "default": {
            "cull_mode": "back"
        },
        "wireframe": {
            "cull_mode": "none",
            "fill_mode": "wireframe"
        },
        "front_face_cull": {
            "cull_mode": "front",
            "fill_mode": "solid"
        },
        "volume_raster": {
            "cull_mode": "back"
        },
        "post_process": {
            "cull_mode": "none"
        },
        "no_cull": {
            "cull_mode": "none"
        },
        "disabled": {
            "cull_mode": "none"
        }
    },
    "render_targets": {
        "single_shadow_map": {
            "size": [
                2048,
                2048
            ],
            "format": "d32f"
        },
        "shadow_map": {
            "size": [
                2048,
                2048
            ],
            "format": "d32f",
            "type": "array"
        },
        "omni_shadow_map": {
            "size": [
                512,
                512
            ],
            "format": "d24s8",
            "type": "cube_array"
        },
        "colour_shadow_map": {
            "size": [
                512,
                512
            ],
            "format": "rgba8",
            "type": "array"
        },
        "colour_shadow_map_depth": {
            "size": [
                512,
                512
            ],
            "format": "d24s8",
            "type": "array"
        },
        "area_light_textures": {
            "size": [
                640,
                480
            ],
            "format": "rgba8",
            "type": "array",
            "mips": true
        },
        "taa_history": {
            "format": "rgba8",
            "size": "equal"
        },
        "taa_colour": {
            "format": "rgba8",
            "size": "equal"
        },
        "taa_depth": {
            "format": "d24s8",
            "size": "equal"
        },
        "velocity_buffer": {
            "format": "r32f",
            "size": "equal"
        }
    }
}{
    "cmdline": "../third_party/pmbuild/scripts/jsn/jsn -i assets/configs/geometry_primitives.jsn -o build/web/data/configs/geometry_primitives.jsn -I ../assets/configs assets/configs ",
    "files": {
        "build/web/data/configs/geometry_primitives.jsn": [
            {
                "name": "/Users/alex.dixon/dev/pmtech/examples/assets/configs/geometry_primitives.jsn",
                "timestamp": 1608804817.810136,
                "data_file": "data/configs/geometry_primitives.jsn"
            }
        ]
    }
}{
    "blend_states": {
        "disabled": {
            "blend_enable": false
        },
        "additive": {
            "blend_enable": true,
            "src_blend": "one",
            "dest_blend": "one"
        },
        "alpha_blend": {
            "blend_enable": true,
            "src_blend": "src_alpha",
            "dest_blend": "inv_src_alpha"
        }
    },
    "sampler_states": {
        "wrap_linear": {
            "filter": "linear",
            "address": "wrap"
        },
        "wrap_point": {
            "filter": "point",
            "address": "wrap"
        },
        "clamp_linear": {
            "filter": "linear",
            "address": "clamp"
        },
        "clamp_point": {
            "filter": "point",
            "address": "clamp"
        },
        "clamp_linear_lod": {
            "filter": "linear_lod",
            "address": "clamp"
        },
        "shadow_compare": {
            "filter": "linear",
            "address": "clamp",
            "comparison_func": "less"
        }
    },
    "depth_stencil_states": {
        "disabled": {
            "depth_enable": false
        },
        "default": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "less"
        },
        "depth_never": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "never"
        },
        "depth_always": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "always"
        },
        "depth_equal": {
            "depth_enable": true,
            "depth_write": false,
            "depth_func": "equal"
        },
        "depth_always_no_write": {
            "depth_enable": true,
            "depth_write": false,
            "depth_func": "always"
        },
        "stencil_test": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "always",
            "stencil_enable": true,
            "stencil_write_mask": 255,
            "stencil_read_mask": 255,
            "stencil_op": {
                "stencil_fail": "keep",
                "depth_fail": "keep",
                "stencil_pass": "replace",
                "stencil_func": "equal"
            }
        }
    },
    "raster_states": {
        "default": {
            "cull_mode": "back"
        },
        "wireframe": {
            "cull_mode": "none",
            "fill_mode": "wireframe"
        },
        "front_face_cull": {
            "cull_mode": "front",
            "fill_mode": "solid"
        },
        "volume_raster": {
            "cull_mode": "back"
        },
        "post_process": {
            "cull_mode": "none"
        },
        "no_cull": {
            "cull_mode": "none"
        },
        "disabled": {
            "cull_mode": "none"
        }
    },
    "render_targets": {
        "single_shadow_map": {
            "size": [
                2048,
                2048
            ],
            "format": "d32f"
        },
        "shadow_map": {
            "size": [
                2048,
                2048
            ],
            "format": "d32f",
            "type": "array"
        },
        "omni_shadow_map": {
            "size": [
                512,
                512
            ],
            "format": "d24s8",
            "type": "cube_array"
        },
        "colour_shadow_map": {
            "size": [
                512,
                512
            ],
            "format": "rgba8",
            "type": "array"
        },
        "colour_shadow_map_depth": {
            "size": [
                512,
                512
            ],
            "format": "d24s8",
            "type": "array"
        },
        "area_light_textures": {
            "size": [
                640,
                480
            ],
            "format": "rgba8",
            "type": "array",
            "mips": true
        },
        "taa_history": {
            "format": "rgba8",
            "size": "equal"
        },
        "taa_colour": {
            "format": "rgba8",
            "size": "equal"
        },
        "taa_depth": {
            "format": "d24s8",
            "size": "equal"
        },
        "velocity_buffer": {
            "format": "r32f",
            "size": "equal"
        }
    },
    "views": {
        "main_view_no_clear": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "main_view": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "main_view_basic": {
            "raster_state": "default",
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "pmfx_shader": "forward_render",
            "technique": "simple_lighting",
            "sampler_bindings": [
                {
                    "texture": "single_shadow_map",
                    "unit": 7,
                    "state": "shadow_compare",
                    "shader": "ps"
                }
            ],
            "target": [
                "main_colour",
                "main_depth"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "main_view_alpha_blended": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "colour_write_mask": 15,
            "blend_state": "alpha_blend",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit",
                "alpha_blended"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear_lod",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "multiple_shadow_views": {
            "target": [
                "shadow_map"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "front_face_cull",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "zonly",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_shadow_maps"
            ],
            "render_flags": [
                "shadow_map"
            ]
        },
        "single_shadow_view": {
            "target": [
                "single_shadow_map"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "front_face_cull",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "zonly",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_shadow_maps"
            ],
            "render_flags": [
                "shadow_map"
            ]
        },
        "multiple_colour_shadow_views": {
            "target": [
                "colour_shadow_map",
                "colour_shadow_map_depth"
            ],
            "clear_colour": [
                0.0,
                1.0,
                1.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "back_face_cull",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "pmfx_shader": "forward_render",
            "technique": "gi",
            "scene_views": [
                "ecs_render_shadow_maps"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "multiple_omni_shadow_views": {
            "target": [
                "omni_shadow_map"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "front_face_cull",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "omni_shadow",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_omni_shadow_maps"
            ],
            "render_flags": [
                "shadow_map"
            ]
        },
        "multiple_area_light_views": {
            "target": [
                "area_light_textures"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "zonly",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_area_light_textures"
            ],
            "render_flags": [
                "area_light_textures"
            ],
            "generate_mip_maps": true
        },
        "main_view_post_processed": {
            "target": [
                "post_process_colour",
                "post_process_depth"
            ],
            "post_process": "editor_default",
            "resolve": [
                "average_4x",
                "max_4x"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "main_view_temporal_aa": {
            "target": [
                "taa_colour",
                "taa_depth"
            ],
            "post_process": "taa_resolve",
            "jitter": true,
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "velocity_buffer": {
            "target": [
                "velocity_buffer"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "pmfx_shader": "forward_render",
            "technique": "per_pixel_velocity",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ]
        }
    }
}{
    "cmdline": "../third_party/pmbuild/scripts/jsn/jsn -i assets/configs/pmfx_demo.jsn -o build/web/data/configs/pmfx_demo.jsn -I ../assets/configs assets/configs ",
    "files": {
        "build/web/data/configs/pmfx_demo.jsn": [
            {
                "name": "/Users/alex.dixon/dev/pmtech/examples/assets/configs/pmfx_demo.jsn",
                "timestamp": 1608572066.9940987,
                "data_file": "data/configs/pmfx_demo.jsn"
            }
        ]
    }
}{
    "depth_stencil_states": {
        "stencil_ref_equal": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "less",
            "stencil_enable": true,
            "stencil_write_mask": 255,
            "stencil_read_mask": 255,
            "stencil_op": {
                "stencil_fail": "keep",
                "depth_fail": "keep",
                "stencil_pass": "replace",
                "stencil_func": "equal"
            }
        },
        "disabled": {
            "depth_enable": false
        },
        "default": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "less"
        },
        "depth_never": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "never"
        },
        "depth_always": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "always"
        },
        "depth_equal": {
            "depth_enable": true,
            "depth_write": false,
            "depth_func": "equal"
        },
        "depth_always_no_write": {
            "depth_enable": true,
            "depth_write": false,
            "depth_func": "always"
        },
        "stencil_test": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "always",
            "stencil_enable": true,
            "stencil_write_mask": 255,
            "stencil_read_mask": 255,
            "stencil_op": {
                "stencil_fail": "keep",
                "depth_fail": "keep",
                "stencil_pass": "replace",
                "stencil_func": "equal"
            }
        }
    },
    "views": {
        "view_stencil_clear": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "clear_colour": [
                0.9,
                0.6,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "clear_stencil": 34,
            "colour_write_mask": 255
        },
        "view_stencil_test": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "no_cull",
            "depth_stencil_state": "stencil_ref_equal",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "pmfx_shader": "forward_render",
            "technique": "lambert",
            "stencil_ref": 34
        },
        "main_view_no_clear": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "main_view": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "main_view_basic": {
            "raster_state": "default",
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "pmfx_shader": "forward_render",
            "technique": "simple_lighting",
            "sampler_bindings": [
                {
                    "texture": "single_shadow_map",
                    "unit": 7,
                    "state": "shadow_compare",
                    "shader": "ps"
                }
            ],
            "target": [
                "main_colour",
                "main_depth"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "main_view_alpha_blended": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "colour_write_mask": 15,
            "blend_state": "alpha_blend",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit",
                "alpha_blended"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear_lod",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "multiple_shadow_views": {
            "target": [
                "shadow_map"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "front_face_cull",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "zonly",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_shadow_maps"
            ],
            "render_flags": [
                "shadow_map"
            ]
        },
        "single_shadow_view": {
            "target": [
                "single_shadow_map"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "front_face_cull",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "zonly",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_shadow_maps"
            ],
            "render_flags": [
                "shadow_map"
            ]
        },
        "multiple_colour_shadow_views": {
            "target": [
                "colour_shadow_map",
                "colour_shadow_map_depth"
            ],
            "clear_colour": [
                0.0,
                1.0,
                1.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "back_face_cull",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "pmfx_shader": "forward_render",
            "technique": "gi",
            "scene_views": [
                "ecs_render_shadow_maps"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "multiple_omni_shadow_views": {
            "target": [
                "omni_shadow_map"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "front_face_cull",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "omni_shadow",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_omni_shadow_maps"
            ],
            "render_flags": [
                "shadow_map"
            ]
        },
        "multiple_area_light_views": {
            "target": [
                "area_light_textures"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "zonly",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_area_light_textures"
            ],
            "render_flags": [
                "area_light_textures"
            ],
            "generate_mip_maps": true
        },
        "main_view_post_processed": {
            "target": [
                "post_process_colour",
                "post_process_depth"
            ],
            "post_process": "editor_default",
            "resolve": [
                "average_4x",
                "max_4x"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "main_view_temporal_aa": {
            "target": [
                "taa_colour",
                "taa_depth"
            ],
            "post_process": "taa_resolve",
            "jitter": true,
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "velocity_buffer": {
            "target": [
                "velocity_buffer"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "pmfx_shader": "forward_render",
            "technique": "per_pixel_velocity",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "editor_main": {
            "raster_state": "default",
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "target": [
                "main_colour",
                "main_depth"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "editor_main_basic": {
            "raster_state": "default",
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "pmfx_shader": "forward_render",
            "technique": "simple_lighting",
            "sampler_bindings": [
                {
                    "texture": "single_shadow_map",
                    "unit": 7,
                    "state": "shadow_compare",
                    "shader": "ps"
                }
            ],
            "target": [
                "main_colour",
                "main_depth"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "editor_main_gi": {
            "raster_state": "default",
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "volume_gi",
                    "unit": 9,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ],
            "target": [
                "taa_colour",
                "taa_depth"
            ],
            "post_process": "taa_resolve",
            "jitter": true,
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "editor_view": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "wireframe",
            "depth_stencil_state": "default",
            "pmfx_shader": "pmfx_utility",
            "technique": "constant_colour",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_editor"
            ]
        },
        "picking_view": {
            "target": [
                "picking",
                "picking_ds"
            ],
            "clear": {
                "picking": {
                    "clear_colour_u": [
                        -1,
                        -1,
                        -1,
                        -1
                    ]
                }
            },
            "clear_depth": 1.0,
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "blend_state": "disabled",
            "raster_state": "default",
            "depth_stencil_state": "default",
            "pmfx_shader": "pmfx_utility",
            "technique": "picking",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ]
        },
        "volume_rasteriser": {
            "target": [
                "volume_raster",
                "volume_raster_ds"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "volume_raster",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "volume_rasteriser_camera",
            "pmfx_shader": "pmfx_utility",
            "technique": "volume_raster_albedo",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "wrap_linear",
                    "shader": "ps"
                }
            ]
        },
        "volume_gi_compute": {
            "type": "compute",
            "target": [
                "volume_gi"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "pmfx_shader": "compute",
            "technique": "volume_gi",
            "scene": "main_scene",
            "scene_views": [
                "ecs_compute_volume_gi"
            ],
            "generate_mip_maps": true
        },
        "gbuffer_view": {
            "target": [
                "gbuffer_albedo",
                "gbuffer_normals",
                "gbuffer_world_pos",
                "gbuffer_depth"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "clear_depth": 1.0,
            "clear": {
                "gbuffer_albedo": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                },
                "gbuffer_normals": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                },
                "gbuffer_world_pos": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                }
            },
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "blend_state": "disabled",
            "raster_state": "default",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "gbuffer",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ]
        },
        "deferred_lights_view": {
            "target": [
                "main_colour"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "additive",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "depth_always_no_write",
            "shader": "deferred_render",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_light_volumes"
            ],
            "sampler_bindings": [
                {
                    "texture": "gbuffer_albedo",
                    "unit": 0,
                    "state": "wrap_linear"
                },
                {
                    "texture": "gbuffer_normals",
                    "unit": 1,
                    "state": "wrap_linear"
                },
                {
                    "texture": "gbuffer_world_pos",
                    "unit": 2,
                    "state": "wrap_linear"
                },
                {
                    "texture": "gbuffer_depth",
                    "unit": 4,
                    "state": "wrap_linear"
                }
            ]
        },
        "gbuffer_view_msaa": {
            "target": [
                "gbuffer_albedo_msaa",
                "gbuffer_normals_msaa",
                "gbuffer_world_pos_msaa",
                "gbuffer_depth_msaa"
            ],
            "resolve": [
                "average_4x",
                "average_4x",
                "average_4x",
                "max_4x"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "clear_depth": 1.0,
            "clear": {
                "gbuffer_albedo": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                },
                "gbuffer_normals": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                },
                "gbuffer_world_pos": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                }
            },
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "blend_state": "disabled",
            "raster_state": "default",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "gbuffer",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ]
        },
        "deferred_lights_view_msaa": {
            "sampler_bindings": [
                {
                    "texture": "gbuffer_albedo_msaa",
                    "unit": 4,
                    "state": "wrap_linear",
                    "bind_flags": [
                        "ps",
                        "msaa"
                    ]
                },
                {
                    "texture": "gbuffer_normals_msaa",
                    "unit": 5,
                    "state": "wrap_linear",
                    "bind_flags": [
                        "ps",
                        "msaa"
                    ]
                },
                {
                    "texture": "gbuffer_world_pos_msaa",
                    "unit": 6,
                    "state": "wrap_linear",
                    "bind_flags": [
                        "ps",
                        "msaa"
                    ]
                },
                {
                    "texture": "gbuffer_depth_msaa",
                    "unit": 7,
                    "state": "wrap_linear",
                    "bind_flags": [
                        "ps",
                        "msaa"
                    ]
                }
            ],
            "permutation": 2,
            "target": [
                "main_colour"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "additive",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "depth_always_no_write",
            "shader": "deferred_render",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_light_volumes"
            ]
        },
        "blit": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "depth_always_no_write",
            "pmfx_shader": "post_process",
            "technique": "blit"
        },
        "blit_depth": {
            "clear_depth": 1.0,
            "colour_write_mask": 0,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "depth_always",
            "pmfx_shader": "post_process",
            "technique": "blit_depth"
        },
        "blit_colour_depth": {
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "depth_always",
            "pmfx_shader": "post_process",
            "technique": "blit_colour_depth"
        },
        "colour_lut": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "colour_lut"
        },
        "high_pass": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "high_pass"
        },
        "filter": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "filter"
        },
        "downsample_2x2": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "downsample_2x2"
        },
        "downsample_average": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "downsample_average"
        },
        "bloom_upsample": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "bloom_upsample"
        },
        "depth_of_field": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "depth_of_field",
            "camera": "model_viewer_camera"
        },
        "menger_sponge": {
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "depth_always",
            "pmfx_shader": "post_process",
            "technique": "menger_sponge",
            "camera": "model_viewer_camera"
        },
        "crt": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "crt",
            "camera": "model_viewer_camera"
        },
        "taa_resolve": {
            "colour_write_mask": 15,
            "clear_colour": [
                0.0,
                1.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "taa_resolve"
        }
    },
    "view_sets": {
        "stencil_buffer_test": [
            "view_stencil_clear",
            "view_stencil_test"
        ],
        "editor": [
            "multiple_shadow_views",
            "multiple_area_light_views",
            "multiple_omni_shadow_views",
            "picking_view",
            "editor_main",
            "editor_view"
        ],
        "editor_basic": [
            "single_shadow_view",
            "editor_main_basic",
            "editor_view"
        ],
        "editor_gi": [
            "multiple_shadow_views",
            "multiple_colour_shadow_views",
            "multiple_area_light_views",
            "multiple_omni_shadow_views",
            "volume_gi_compute",
            "picking_view",
            "editor_main_gi",
            "editor_view"
        ],
        "editor_post_processed": [
            "picking_view",
            "main_view_post_processed",
            "editor_view",
            "volume_rasteriser"
        ],
        "deferred_render": [
            "gbuffer_view",
            "deferred_lights_view"
        ],
        "deferred_render_msaa": [
            "gbuffer_view_msaa",
            "deferred_lights_view_msaa"
        ]
    },
    "view_set": "stencil_buffer_test",
    "blend_states": {
        "disabled": {
            "blend_enable": false
        },
        "additive": {
            "blend_enable": true,
            "src_blend": "one",
            "dest_blend": "one"
        },
        "alpha_blend": {
            "blend_enable": true,
            "src_blend": "src_alpha",
            "dest_blend": "inv_src_alpha"
        }
    },
    "sampler_states": {
        "wrap_linear": {
            "filter": "linear",
            "address": "wrap"
        },
        "wrap_point": {
            "filter": "point",
            "address": "wrap"
        },
        "clamp_linear": {
            "filter": "linear",
            "address": "clamp"
        },
        "clamp_point": {
            "filter": "point",
            "address": "clamp"
        },
        "clamp_linear_lod": {
            "filter": "linear_lod",
            "address": "clamp"
        },
        "shadow_compare": {
            "filter": "linear",
            "address": "clamp",
            "comparison_func": "less"
        }
    },
    "raster_states": {
        "default": {
            "cull_mode": "back"
        },
        "wireframe": {
            "cull_mode": "none",
            "fill_mode": "wireframe"
        },
        "front_face_cull": {
            "cull_mode": "front",
            "fill_mode": "solid"
        },
        "volume_raster": {
            "cull_mode": "back"
        },
        "post_process": {
            "cull_mode": "none"
        },
        "no_cull": {
            "cull_mode": "none"
        },
        "disabled": {
            "cull_mode": "none"
        }
    },
    "render_targets": {
        "single_shadow_map": {
            "size": [
                2048,
                2048
            ],
            "format": "d32f"
        },
        "shadow_map": {
            "size": [
                2048,
                2048
            ],
            "format": "d32f",
            "type": "array"
        },
        "omni_shadow_map": {
            "size": [
                512,
                512
            ],
            "format": "d24s8",
            "type": "cube_array"
        },
        "colour_shadow_map": {
            "size": [
                512,
                512
            ],
            "format": "rgba8",
            "type": "array"
        },
        "colour_shadow_map_depth": {
            "size": [
                512,
                512
            ],
            "format": "d24s8",
            "type": "array"
        },
        "area_light_textures": {
            "size": [
                640,
                480
            ],
            "format": "rgba8",
            "type": "array",
            "mips": true
        },
        "taa_history": {
            "format": "rgba8",
            "size": "equal"
        },
        "taa_colour": {
            "format": "rgba8",
            "size": "equal"
        },
        "taa_depth": {
            "format": "d24s8",
            "size": "equal"
        },
        "velocity_buffer": {
            "format": "r32f",
            "size": "equal"
        },
        "picking": {
            "size": "equal",
            "format": "r32u",
            "cpu_read": true
        },
        "picking_ds": {
            "size": "equal",
            "format": "d24s8"
        },
        "volume_raster": {
            "size": [
                128,
                128
            ],
            "format": "rgba8",
            "cpu_read": true
        },
        "volume_raster_ds": {
            "size": [
                128,
                128
            ],
            "format": "d24s8"
        },
        "volume_gi": {
            "size": [
                256,
                256,
                256
            ],
            "format": "rgba8",
            "gpu_write": true,
            "mips": true
        },
        "gbuffer_depth": {
            "size": "equal",
            "format": "d24s8"
        },
        "gbuffer_albedo": {
            "size": "equal",
            "format": "rgba8"
        },
        "gbuffer_normals": {
            "size": "equal",
            "format": "rgba32f"
        },
        "gbuffer_world_pos": {
            "size": "equal",
            "format": "rgba32f"
        },
        "gbuffer_depth_msaa": {
            "size": "equal",
            "format": "d24s8",
            "samples": 4
        },
        "gbuffer_albedo_msaa": {
            "size": "equal",
            "format": "rgba8",
            "samples": 4
        },
        "gbuffer_normals_msaa": {
            "size": "equal",
            "format": "rgba32f",
            "samples": 4
        },
        "gbuffer_world_pos_msaa": {
            "size": "equal",
            "format": "rgba32f",
            "samples": 4
        },
        "post_process_colour": {
            "size": "equal",
            "samples": 4,
            "format": "rgba8"
        },
        "post_process_depth": {
            "size": "equal",
            "samples": 4,
            "format": "d24s8"
        },
        "pp_output_full": {
            "size": "equal",
            "format": "rgba8",
            "pp": "write",
            "init_read": "post_process_colour"
        },
        "pp_output_half": {
            "size": "half",
            "format": "rgba8",
            "pp": "write"
        },
        "pp_output_quarter": {
            "size": "quarter",
            "format": "rgba8",
            "pp": "write"
        },
        "pp_output_eighth": {
            "size": "eighth",
            "format": "rgba8",
            "pp": "write"
        }
    },
    "filter_kernels": {
        "gauss_5_1": {
            "weights": [
                0.06136,
                0.24477,
                0.38774,
                0.24477,
                0.06136
            ],
            "offsets": [
                -2.0,
                -1.0,
                0.0,
                1.0,
                2.0
            ]
        },
        "gauss_7_1": {
            "weights": [
                0.00598,
                0.060626,
                0.241843,
                0.383103,
                0.241843,
                0.060626,
                0.00598
            ],
            "offsets": [
                -3.0,
                -2.0,
                -1.0,
                0.0,
                1.0,
                2.0,
                3.0
            ]
        },
        "gauss_9_1": {
            "weights": [
                0.000229,
                0.005977,
                0.060598,
                0.241732,
                0.382928,
                0.241732,
                0.060598,
                0.005977,
                0.000229
            ],
            "offsets": [
                -4.0,
                -3.0,
                -2.0,
                -1.0,
                0.0,
                1.0,
                2.0,
                3.0,
                4.0
            ]
        },
        "poisson_disc_16": {
            "offsets_xy": [
                0.2069841,
                0.2245269,
                0.525808,
                -0.2310817,
                0.1383943,
                0.9056122,
                0.6633009,
                0.5129843,
                -0.4002792,
                0.3727058,
                0.07912822,
                -0.6512921,
                -0.7726067,
                -0.5151217,
                -0.3843193,
                -0.1494132,
                -0.9107782,
                0.2500633,
                0.6940153,
                -0.7098927,
                -0.1964669,
                -0.379389,
                -0.4769286,
                0.1840863,
                -0.247328,
                -0.8798459,
                0.4206541,
                -0.714772,
                0.5829348,
                -0.09794202,
                0.3691838,
                0.4140642
            ]
        },
        "unjitter": {
            "offsets": [],
            "weights": []
        }
    },
    "post_processes": {
        "bloom": [
            {
                "inherit": "high_pass",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal"
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical"
            },
            {
                "inherit": "downsample_average",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_half",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal"
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_half",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical"
            },
            {
                "inherit": "downsample_average",
                "target": [
                    "pp_output_quarter"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_half",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_quarter"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_quarter",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal"
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_quarter"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_quarter",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical"
            },
            {
                "inherit": "downsample_average",
                "target": [
                    "pp_output_eighth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_quarter",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_eighth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_eighth",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal"
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_eighth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_eighth",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical"
            },
            {
                "inherit": "bloom_upsample",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "post_process_colour",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_full",
                        "unit": 1,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_half",
                        "unit": 2,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_quarter",
                        "unit": 3,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_eighth",
                        "unit": 4,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "depth_of_field": [
            {
                "inherit": "downsample_2x2",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_half",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal"
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_half",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical"
            },
            {
                "inherit": "depth_of_field",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "post_process_depth",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_full",
                        "unit": 1,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_half",
                        "unit": 2,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "colour_lut": [
            {
                "inherit": "colour_lut",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "blit_depth": [
            {
                "inherit": "blit_depth",
                "target": [
                    "main_depth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "post_process_depth",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "blit_taa_depth": [
            {
                "inherit": "blit_depth",
                "technique": "blit_depth_unjittered",
                "target": [
                    "main_depth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "taa_depth",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "blit_post_process": [
            {
                "inherit": "blit",
                "target": [
                    "main_colour"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "blit_colour_depth": [
            {
                "inherit": "blit_colour_depth",
                "target": [
                    "main_colour",
                    "main_depth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "post_process_colour",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "post_process_depth",
                        "unit": 1,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "menger_sponge": [
            {
                "inherit": "menger_sponge",
                "target": [
                    "post_process_colour",
                    "post_process_depth"
                ],
                "pp_write_non_aux": true,
                "technique": "menger_sponge",
                "camera": "model_viewer_camera",
                "resolve": [
                    "average_4x",
                    "max_4x"
                ]
            }
        ],
        "crt": [
            {
                "inherit": "crt",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "sss_reflectance": [
            {
                "inherit": "filter",
                "target": [
                    "pp_output_full"
                ],
                "technique": "sss_reflectance",
                "camera": "model_viewer_camera",
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "post_process_depth",
                        "unit": 1,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_full"
                ],
                "technique": "sss_reflectance",
                "camera": "model_viewer_camera",
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "post_process_depth",
                        "unit": 1,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "taa_resolve": [
            {
                "inherit": "taa_resolve",
                "target": [
                    "pp_output_full"
                ],
                "technique": "taa_resolve",
                "camera": "model_viewer_camera",
                "scene_views": [
                    "ecs_taa_resolve"
                ],
                "sampler_bindings": [
                    {
                        "texture": "taa_colour",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "taa_depth",
                        "unit": 1,
                        "state": "clamp_point",
                        "shader": "ps"
                    },
                    {
                        "texture": "taa_history",
                        "unit": 2,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "blit",
                "target": [
                    "taa_history"
                ],
                "pp_write_non_aux": true,
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ]
    },
    "post_process_sets": {
        "blit_only": {
            "chain": [
                "blit_colour_depth"
            ]
        },
        "editor_default": {
            "chain": [
                "blit_depth",
                "blit_post_process"
            ]
        },
        "taa_resolve": {
            "chain": [
                "taa_resolve",
                "blit_taa_depth",
                "blit_post_process"
            ]
        }
    }
}{
    "cmdline": "../third_party/pmbuild/scripts/jsn/jsn -i assets/configs/msaa_resolve.jsn -o build/web/data/configs/msaa_resolve.jsn -I ../assets/configs assets/configs ",
    "files": {
        "build/web/data/configs/msaa_resolve.jsn": [
            {
                "name": "/Users/alex.dixon/dev/pmtech/examples/assets/configs/msaa_resolve.jsn",
                "timestamp": 1608572066.99455,
                "data_file": "data/configs/msaa_resolve.jsn"
            }
        ]
    }
}{
    "render_targets": {
        "gbuffer_depth": {
            "size": "equal",
            "format": "d24s8"
        },
        "gbuffer_albedo": {
            "size": "equal",
            "format": "rgba8"
        },
        "gbuffer_normals": {
            "size": "equal",
            "format": "rgba32f"
        },
        "gbuffer_world_pos": {
            "size": "equal",
            "format": "rgba32f"
        },
        "gbuffer_depth_msaa": {
            "size": "equal",
            "format": "d24s8",
            "samples": 4
        },
        "gbuffer_albedo_msaa": {
            "size": "equal",
            "format": "rgba8",
            "samples": 4
        },
        "gbuffer_normals_msaa": {
            "size": "equal",
            "format": "rgba32f",
            "samples": 4
        },
        "gbuffer_world_pos_msaa": {
            "size": "equal",
            "format": "rgba32f",
            "samples": 4
        }
    },
    "views": {
        "gbuffer_view": {
            "target": [
                "gbuffer_albedo",
                "gbuffer_normals",
                "gbuffer_world_pos",
                "gbuffer_depth"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "clear_depth": 1.0,
            "clear": {
                "gbuffer_albedo": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                },
                "gbuffer_normals": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                },
                "gbuffer_world_pos": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                }
            },
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "blend_state": "disabled",
            "raster_state": "default",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "gbuffer",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ]
        },
        "deferred_lights_view": {
            "target": [
                "main_colour"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "additive",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "depth_always_no_write",
            "shader": "deferred_render",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_light_volumes"
            ],
            "sampler_bindings": [
                {
                    "texture": "gbuffer_albedo",
                    "unit": 0,
                    "state": "wrap_linear"
                },
                {
                    "texture": "gbuffer_normals",
                    "unit": 1,
                    "state": "wrap_linear"
                },
                {
                    "texture": "gbuffer_world_pos",
                    "unit": 2,
                    "state": "wrap_linear"
                },
                {
                    "texture": "gbuffer_depth",
                    "unit": 4,
                    "state": "wrap_linear"
                }
            ]
        },
        "gbuffer_view_msaa": {
            "target": [
                "gbuffer_albedo_msaa",
                "gbuffer_normals_msaa",
                "gbuffer_world_pos_msaa",
                "gbuffer_depth_msaa"
            ],
            "resolve": [
                "average_4x",
                "average_4x",
                "average_4x",
                "max_4x"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "clear_depth": 1.0,
            "clear": {
                "gbuffer_albedo": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                },
                "gbuffer_normals": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                },
                "gbuffer_world_pos": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                }
            },
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "blend_state": "disabled",
            "raster_state": "default",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "gbuffer",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ]
        },
        "deferred_lights_view_msaa": {
            "sampler_bindings": [
                {
                    "texture": "gbuffer_albedo_msaa",
                    "unit": 4,
                    "state": "wrap_linear",
                    "bind_flags": [
                        "ps",
                        "msaa"
                    ]
                },
                {
                    "texture": "gbuffer_normals_msaa",
                    "unit": 5,
                    "state": "wrap_linear",
                    "bind_flags": [
                        "ps",
                        "msaa"
                    ]
                },
                {
                    "texture": "gbuffer_world_pos_msaa",
                    "unit": 6,
                    "state": "wrap_linear",
                    "bind_flags": [
                        "ps",
                        "msaa"
                    ]
                },
                {
                    "texture": "gbuffer_depth_msaa",
                    "unit": 7,
                    "state": "wrap_linear",
                    "bind_flags": [
                        "ps",
                        "msaa"
                    ]
                }
            ],
            "permutation": 2,
            "target": [
                "main_colour"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "additive",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "depth_always_no_write",
            "shader": "deferred_render",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_light_volumes"
            ]
        }
    },
    "view_sets": {
        "deferred_render": [
            "gbuffer_view",
            "deferred_lights_view"
        ],
        "deferred_render_msaa": [
            "gbuffer_view_msaa",
            "deferred_lights_view_msaa"
        ]
    }
}{
    "cmdline": "../third_party/pmbuild/scripts/jsn/jsn -i assets/configs/pp_demo.jsn -o build/web/data/configs/pp_demo.jsn -I ../assets/configs assets/configs ",
    "files": {
        "build/web/data/configs/pp_demo.jsn": [
            {
                "name": "/Users/alex.dixon/dev/pmtech/examples/assets/configs/pp_demo.jsn",
                "timestamp": 1608572066.9948738,
                "data_file": "data/configs/pp_demo.jsn"
            }
        ]
    }
}{
    "depth_stencil_states": {
        "stencil_write": {
            "depth_enable": false,
            "depth_write": false,
            "depth_func": "default",
            "stencil_enable": false,
            "stencil_write_mask": 255,
            "stencil_read_mask": 255,
            "stencil_op": {
                "stencil_fail": "replace",
                "depth_fail": "replace",
                "stencil_pass": "replace",
                "stencil_func": "always"
            }
        },
        "stencil_shadow_volume": {
            "depth_enable": true,
            "depth_write": false,
            "depth_func": "less",
            "stencil_enable": true,
            "stencil_write_mask": 255,
            "stencil_read_mask": 255,
            "stencil_op_front": {
                "stencil_fail": "keep",
                "depth_fail": "keep",
                "stencil_pass": "decr",
                "stencil_func": "always"
            },
            "stencil_op_back": {
                "stencil_fail": "keep",
                "depth_fail": "keep",
                "stencil_pass": "incr",
                "stencil_func": "always"
            }
        },
        "stencil_shadow_test": {
            "depth_enable": true,
            "depth_write": false,
            "depth_func": "equal",
            "stencil_enable": true,
            "stencil_write_mask": 255,
            "stencil_read_mask": 255,
            "stencil_op": {
                "stencil_fail": "keep",
                "depth_fail": "keep",
                "stencil_pass": "replace",
                "stencil_func": "equal"
            }
        },
        "disabled": {
            "depth_enable": false
        },
        "default": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "less"
        },
        "depth_never": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "never"
        },
        "depth_always": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "always"
        },
        "depth_equal": {
            "depth_enable": true,
            "depth_write": false,
            "depth_func": "equal"
        },
        "depth_always_no_write": {
            "depth_enable": true,
            "depth_write": false,
            "depth_func": "always"
        },
        "stencil_test": {
            "depth_enable": true,
            "depth_write": true,
            "depth_func": "always",
            "stencil_enable": true,
            "stencil_write_mask": 255,
            "stencil_read_mask": 255,
            "stencil_op": {
                "stencil_fail": "keep",
                "depth_fail": "keep",
                "stencil_pass": "replace",
                "stencil_func": "equal"
            }
        }
    },
    "views": {
        "view_clear": {
            "target": [
                "post_process_colour",
                "post_process_depth"
            ],
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "clear_stencil": 0,
            "colour_write_mask": 15
        },
        "view_fill_depth": {
            "target": [
                "post_process_colour",
                "post_process_depth"
            ],
            "colour_write_mask": 0,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "pmfx_shader": "forward_render",
            "technique": "zonly"
        },
        "view_clear_stencil": {
            "target": [
                "post_process_colour",
                "post_process_depth"
            ],
            "clear_stencil": 0,
            "type": "template"
        },
        "view_shadow_volume": {
            "target": [
                "post_process_colour",
                "post_process_depth"
            ],
            "colour_write_mask": 0,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "no_cull",
            "depth_stencil_state": "stencil_shadow_volume",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "stencil_shadow_volumes"
            ],
            "pmfx_shader": "forward_render",
            "technique": "shadow_extrude",
            "type": "template"
        },
        "view_single_light": {
            "target": [
                "post_process_colour",
                "post_process_depth"
            ],
            "blend_state": "additive",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "stencil_shadow_test",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "scene_stencil_tested"
            ],
            "render_flags": [
                "forward_render"
            ],
            "pmfx_shader": "forward_render",
            "technique": "single_light_directional",
            "stencil_ref": 0,
            "type": "template"
        },
        "view_multi_pass_lights": {
            "scene": "main_scene",
            "scene_views": [
                "render_multi_pass_lights"
            ],
            "type": "abstract"
        },
        "view_resolve": {
            "target": [
                "post_process_colour",
                "post_process_depth"
            ],
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "colour_write_mask": 15,
            "resolve": [
                "average_4x",
                "max_4x"
            ]
        },
        "view_blit": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "post_process": "blit_only"
        },
        "main_view_no_clear": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "main_view": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "main_view_basic": {
            "raster_state": "default",
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "pmfx_shader": "forward_render",
            "technique": "simple_lighting",
            "sampler_bindings": [
                {
                    "texture": "single_shadow_map",
                    "unit": 7,
                    "state": "shadow_compare",
                    "shader": "ps"
                }
            ],
            "target": [
                "main_colour",
                "main_depth"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "main_view_alpha_blended": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "colour_write_mask": 15,
            "blend_state": "alpha_blend",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit",
                "alpha_blended"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear_lod",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "multiple_shadow_views": {
            "target": [
                "shadow_map"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "front_face_cull",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "zonly",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_shadow_maps"
            ],
            "render_flags": [
                "shadow_map"
            ]
        },
        "single_shadow_view": {
            "target": [
                "single_shadow_map"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "front_face_cull",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "zonly",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_shadow_maps"
            ],
            "render_flags": [
                "shadow_map"
            ]
        },
        "multiple_colour_shadow_views": {
            "target": [
                "colour_shadow_map",
                "colour_shadow_map_depth"
            ],
            "clear_colour": [
                0.0,
                1.0,
                1.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "back_face_cull",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "pmfx_shader": "forward_render",
            "technique": "gi",
            "scene_views": [
                "ecs_render_shadow_maps"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "multiple_omni_shadow_views": {
            "target": [
                "omni_shadow_map"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "front_face_cull",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "omni_shadow",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_omni_shadow_maps"
            ],
            "render_flags": [
                "shadow_map"
            ]
        },
        "multiple_area_light_views": {
            "target": [
                "area_light_textures"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "zonly",
            "scene": "main_scene",
            "scene_views": [
                "ecs_render_area_light_textures"
            ],
            "render_flags": [
                "area_light_textures"
            ],
            "generate_mip_maps": true
        },
        "main_view_post_processed": {
            "target": [
                "post_process_colour",
                "post_process_depth"
            ],
            "post_process": "editor_default",
            "resolve": [
                "average_4x",
                "max_4x"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "main_view_temporal_aa": {
            "target": [
                "taa_colour",
                "taa_depth"
            ],
            "post_process": "taa_resolve",
            "jitter": true,
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "velocity_buffer": {
            "target": [
                "velocity_buffer"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "pmfx_shader": "forward_render",
            "technique": "per_pixel_velocity",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "editor_main": {
            "raster_state": "default",
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "target": [
                "main_colour",
                "main_depth"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ]
        },
        "editor_main_basic": {
            "raster_state": "default",
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "pmfx_shader": "forward_render",
            "technique": "simple_lighting",
            "sampler_bindings": [
                {
                    "texture": "single_shadow_map",
                    "unit": 7,
                    "state": "shadow_compare",
                    "shader": "ps"
                }
            ],
            "target": [
                "main_colour",
                "main_depth"
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "editor_main_gi": {
            "raster_state": "default",
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                1.0
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "shadow_compare",
                    "shader": "ps"
                },
                {
                    "texture": "area_light_textures",
                    "unit": 11,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "omni_shadow_map",
                    "unit": 10,
                    "state": "clamp_linear",
                    "shader": "ps"
                },
                {
                    "texture": "volume_gi",
                    "unit": 9,
                    "state": "clamp_linear",
                    "shader": "ps"
                }
            ],
            "target": [
                "taa_colour",
                "taa_depth"
            ],
            "post_process": "taa_resolve",
            "jitter": true,
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ]
        },
        "editor_view": {
            "target": [
                "main_colour",
                "main_depth"
            ],
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "wireframe",
            "depth_stencil_state": "default",
            "pmfx_shader": "pmfx_utility",
            "technique": "constant_colour",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_editor"
            ]
        },
        "picking_view": {
            "target": [
                "picking",
                "picking_ds"
            ],
            "clear": {
                "picking": {
                    "clear_colour_u": [
                        -1,
                        -1,
                        -1,
                        -1
                    ]
                }
            },
            "clear_depth": 1.0,
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "blend_state": "disabled",
            "raster_state": "default",
            "depth_stencil_state": "default",
            "pmfx_shader": "pmfx_utility",
            "technique": "picking",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ]
        },
        "volume_rasteriser": {
            "target": [
                "volume_raster",
                "volume_raster_ds"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "volume_raster",
            "depth_stencil_state": "default",
            "scene": "main_scene",
            "camera": "volume_rasteriser_camera",
            "pmfx_shader": "pmfx_utility",
            "technique": "volume_raster_albedo",
            "scene_views": [
                "ecs_render_scene"
            ],
            "render_flags": [
                "forward_lit"
            ],
            "sampler_bindings": [
                {
                    "texture": "shadow_map",
                    "unit": 15,
                    "state": "wrap_linear",
                    "shader": "ps"
                }
            ]
        },
        "volume_gi_compute": {
            "type": "compute",
            "target": [
                "volume_gi"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "pmfx_shader": "compute",
            "technique": "volume_gi",
            "scene": "main_scene",
            "scene_views": [
                "ecs_compute_volume_gi"
            ],
            "generate_mip_maps": true
        },
        "gbuffer_view": {
            "target": [
                "gbuffer_albedo",
                "gbuffer_normals",
                "gbuffer_world_pos",
                "gbuffer_depth"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "clear_depth": 1.0,
            "clear": {
                "gbuffer_albedo": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                },
                "gbuffer_normals": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                },
                "gbuffer_world_pos": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                }
            },
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "blend_state": "disabled",
            "raster_state": "default",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "gbuffer",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ]
        },
        "deferred_lights_view": {
            "target": [
                "main_colour"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "additive",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "depth_always_no_write",
            "shader": "deferred_render",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_light_volumes"
            ],
            "sampler_bindings": [
                {
                    "texture": "gbuffer_albedo",
                    "unit": 0,
                    "state": "wrap_linear"
                },
                {
                    "texture": "gbuffer_normals",
                    "unit": 1,
                    "state": "wrap_linear"
                },
                {
                    "texture": "gbuffer_world_pos",
                    "unit": 2,
                    "state": "wrap_linear"
                },
                {
                    "texture": "gbuffer_depth",
                    "unit": 4,
                    "state": "wrap_linear"
                }
            ]
        },
        "gbuffer_view_msaa": {
            "target": [
                "gbuffer_albedo_msaa",
                "gbuffer_normals_msaa",
                "gbuffer_world_pos_msaa",
                "gbuffer_depth_msaa"
            ],
            "resolve": [
                "average_4x",
                "average_4x",
                "average_4x",
                "max_4x"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "clear_depth": 1.0,
            "clear": {
                "gbuffer_albedo": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                },
                "gbuffer_normals": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                },
                "gbuffer_world_pos": {
                    "clear_colour_f": [
                        0.0,
                        0.0,
                        0.0,
                        0.0
                    ]
                }
            },
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "blend_state": "disabled",
            "raster_state": "default",
            "depth_stencil_state": "default",
            "pmfx_shader": "forward_render",
            "technique": "gbuffer",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_scene"
            ]
        },
        "deferred_lights_view_msaa": {
            "sampler_bindings": [
                {
                    "texture": "gbuffer_albedo_msaa",
                    "unit": 4,
                    "state": "wrap_linear",
                    "bind_flags": [
                        "ps",
                        "msaa"
                    ]
                },
                {
                    "texture": "gbuffer_normals_msaa",
                    "unit": 5,
                    "state": "wrap_linear",
                    "bind_flags": [
                        "ps",
                        "msaa"
                    ]
                },
                {
                    "texture": "gbuffer_world_pos_msaa",
                    "unit": 6,
                    "state": "wrap_linear",
                    "bind_flags": [
                        "ps",
                        "msaa"
                    ]
                },
                {
                    "texture": "gbuffer_depth_msaa",
                    "unit": 7,
                    "state": "wrap_linear",
                    "bind_flags": [
                        "ps",
                        "msaa"
                    ]
                }
            ],
            "permutation": 2,
            "target": [
                "main_colour"
            ],
            "clear_colour": [
                0.0,
                0.0,
                0.0,
                0.0
            ],
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "additive",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "default",
            "depth_stencil_state": "depth_always_no_write",
            "shader": "deferred_render",
            "scene": "main_scene",
            "camera": "model_viewer_camera",
            "scene_views": [
                "ecs_render_light_volumes"
            ]
        },
        "blit": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "depth_always_no_write",
            "pmfx_shader": "post_process",
            "technique": "blit"
        },
        "blit_depth": {
            "clear_depth": 1.0,
            "colour_write_mask": 0,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "depth_always",
            "pmfx_shader": "post_process",
            "technique": "blit_depth"
        },
        "blit_colour_depth": {
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "depth_always",
            "pmfx_shader": "post_process",
            "technique": "blit_colour_depth"
        },
        "colour_lut": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "colour_lut"
        },
        "high_pass": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "high_pass"
        },
        "filter": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "filter"
        },
        "downsample_2x2": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "downsample_2x2"
        },
        "downsample_average": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "downsample_average"
        },
        "bloom_upsample": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "bloom_upsample"
        },
        "depth_of_field": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "depth_of_field",
            "camera": "model_viewer_camera"
        },
        "menger_sponge": {
            "clear_depth": 1.0,
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "depth_always",
            "pmfx_shader": "post_process",
            "technique": "menger_sponge",
            "camera": "model_viewer_camera"
        },
        "crt": {
            "colour_write_mask": 15,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "crt",
            "camera": "model_viewer_camera"
        },
        "taa_resolve": {
            "colour_write_mask": 15,
            "clear_colour": [
                0.0,
                1.0,
                0.0,
                1.0
            ],
            "clear_depth": 1.0,
            "blend_state": "disabled",
            "viewport": [
                0.0,
                0.0,
                1.0,
                1.0
            ],
            "raster_state": "post_process",
            "depth_stencil_state": "disabled",
            "pmfx_shader": "post_process",
            "technique": "taa_resolve"
        }
    },
    "view_sets": {
        "stencil_shadow": [
            "view_clear",
            "view_fill_depth",
            "view_clear_stencil",
            "view_shadow_volume",
            "view_single_light",
            "view_multi_pass_lights",
            "view_resolve",
            "view_blit",
            "editor_view"
        ],
        "editor": [
            "multiple_shadow_views",
            "multiple_area_light_views",
            "multiple_omni_shadow_views",
            "picking_view",
            "editor_main",
            "editor_view"
        ],
        "editor_basic": [
            "single_shadow_view",
            "editor_main_basic",
            "editor_view"
        ],
        "editor_gi": [
            "multiple_shadow_views",
            "multiple_colour_shadow_views",
            "multiple_area_light_views",
            "multiple_omni_shadow_views",
            "volume_gi_compute",
            "picking_view",
            "editor_main_gi",
            "editor_view"
        ],
        "editor_post_processed": [
            "picking_view",
            "main_view_post_processed",
            "editor_view",
            "volume_rasteriser"
        ],
        "deferred_render": [
            "gbuffer_view",
            "deferred_lights_view"
        ],
        "deferred_render_msaa": [
            "gbuffer_view_msaa",
            "deferred_lights_view_msaa"
        ]
    },
    "view_set": "stencil_shadow",
    "blend_states": {
        "disabled": {
            "blend_enable": false
        },
        "additive": {
            "blend_enable": true,
            "src_blend": "one",
            "dest_blend": "one"
        },
        "alpha_blend": {
            "blend_enable": true,
            "src_blend": "src_alpha",
            "dest_blend": "inv_src_alpha"
        }
    },
    "sampler_states": {
        "wrap_linear": {
            "filter": "linear",
            "address": "wrap"
        },
        "wrap_point": {
            "filter": "point",
            "address": "wrap"
        },
        "clamp_linear": {
            "filter": "linear",
            "address": "clamp"
        },
        "clamp_point": {
            "filter": "point",
            "address": "clamp"
        },
        "clamp_linear_lod": {
            "filter": "linear_lod",
            "address": "clamp"
        },
        "shadow_compare": {
            "filter": "linear",
            "address": "clamp",
            "comparison_func": "less"
        }
    },
    "raster_states": {
        "default": {
            "cull_mode": "back"
        },
        "wireframe": {
            "cull_mode": "none",
            "fill_mode": "wireframe"
        },
        "front_face_cull": {
            "cull_mode": "front",
            "fill_mode": "solid"
        },
        "volume_raster": {
            "cull_mode": "back"
        },
        "post_process": {
            "cull_mode": "none"
        },
        "no_cull": {
            "cull_mode": "none"
        },
        "disabled": {
            "cull_mode": "none"
        }
    },
    "render_targets": {
        "single_shadow_map": {
            "size": [
                2048,
                2048
            ],
            "format": "d32f"
        },
        "shadow_map": {
            "size": [
                2048,
                2048
            ],
            "format": "d32f",
            "type": "array"
        },
        "omni_shadow_map": {
            "size": [
                512,
                512
            ],
            "format": "d24s8",
            "type": "cube_array"
        },
        "colour_shadow_map": {
            "size": [
                512,
                512
            ],
            "format": "rgba8",
            "type": "array"
        },
        "colour_shadow_map_depth": {
            "size": [
                512,
                512
            ],
            "format": "d24s8",
            "type": "array"
        },
        "area_light_textures": {
            "size": [
                640,
                480
            ],
            "format": "rgba8",
            "type": "array",
            "mips": true
        },
        "taa_history": {
            "format": "rgba8",
            "size": "equal"
        },
        "taa_colour": {
            "format": "rgba8",
            "size": "equal"
        },
        "taa_depth": {
            "format": "d24s8",
            "size": "equal"
        },
        "velocity_buffer": {
            "format": "r32f",
            "size": "equal"
        },
        "picking": {
            "size": "equal",
            "format": "r32u",
            "cpu_read": true
        },
        "picking_ds": {
            "size": "equal",
            "format": "d24s8"
        },
        "volume_raster": {
            "size": [
                128,
                128
            ],
            "format": "rgba8",
            "cpu_read": true
        },
        "volume_raster_ds": {
            "size": [
                128,
                128
            ],
            "format": "d24s8"
        },
        "volume_gi": {
            "size": [
                256,
                256,
                256
            ],
            "format": "rgba8",
            "gpu_write": true,
            "mips": true
        },
        "gbuffer_depth": {
            "size": "equal",
            "format": "d24s8"
        },
        "gbuffer_albedo": {
            "size": "equal",
            "format": "rgba8"
        },
        "gbuffer_normals": {
            "size": "equal",
            "format": "rgba32f"
        },
        "gbuffer_world_pos": {
            "size": "equal",
            "format": "rgba32f"
        },
        "gbuffer_depth_msaa": {
            "size": "equal",
            "format": "d24s8",
            "samples": 4
        },
        "gbuffer_albedo_msaa": {
            "size": "equal",
            "format": "rgba8",
            "samples": 4
        },
        "gbuffer_normals_msaa": {
            "size": "equal",
            "format": "rgba32f",
            "samples": 4
        },
        "gbuffer_world_pos_msaa": {
            "size": "equal",
            "format": "rgba32f",
            "samples": 4
        },
        "post_process_colour": {
            "size": "equal",
            "samples": 4,
            "format": "rgba8"
        },
        "post_process_depth": {
            "size": "equal",
            "samples": 4,
            "format": "d24s8"
        },
        "pp_output_full": {
            "size": "equal",
            "format": "rgba8",
            "pp": "write",
            "init_read": "post_process_colour"
        },
        "pp_output_half": {
            "size": "half",
            "format": "rgba8",
            "pp": "write"
        },
        "pp_output_quarter": {
            "size": "quarter",
            "format": "rgba8",
            "pp": "write"
        },
        "pp_output_eighth": {
            "size": "eighth",
            "format": "rgba8",
            "pp": "write"
        }
    },
    "filter_kernels": {
        "gauss_5_1": {
            "weights": [
                0.06136,
                0.24477,
                0.38774,
                0.24477,
                0.06136
            ],
            "offsets": [
                -2.0,
                -1.0,
                0.0,
                1.0,
                2.0
            ]
        },
        "gauss_7_1": {
            "weights": [
                0.00598,
                0.060626,
                0.241843,
                0.383103,
                0.241843,
                0.060626,
                0.00598
            ],
            "offsets": [
                -3.0,
                -2.0,
                -1.0,
                0.0,
                1.0,
                2.0,
                3.0
            ]
        },
        "gauss_9_1": {
            "weights": [
                0.000229,
                0.005977,
                0.060598,
                0.241732,
                0.382928,
                0.241732,
                0.060598,
                0.005977,
                0.000229
            ],
            "offsets": [
                -4.0,
                -3.0,
                -2.0,
                -1.0,
                0.0,
                1.0,
                2.0,
                3.0,
                4.0
            ]
        },
        "poisson_disc_16": {
            "offsets_xy": [
                0.2069841,
                0.2245269,
                0.525808,
                -0.2310817,
                0.1383943,
                0.9056122,
                0.6633009,
                0.5129843,
                -0.4002792,
                0.3727058,
                0.07912822,
                -0.6512921,
                -0.7726067,
                -0.5151217,
                -0.3843193,
                -0.1494132,
                -0.9107782,
                0.2500633,
                0.6940153,
                -0.7098927,
                -0.1964669,
                -0.379389,
                -0.4769286,
                0.1840863,
                -0.247328,
                -0.8798459,
                0.4206541,
                -0.714772,
                0.5829348,
                -0.09794202,
                0.3691838,
                0.4140642
            ]
        },
        "unjitter": {
            "offsets": [],
            "weights": []
        }
    },
    "post_processes": {
        "bloom": [
            {
                "inherit": "high_pass",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal"
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical"
            },
            {
                "inherit": "downsample_average",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_half",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal"
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_half",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical"
            },
            {
                "inherit": "downsample_average",
                "target": [
                    "pp_output_quarter"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_half",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_quarter"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_quarter",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal"
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_quarter"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_quarter",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical"
            },
            {
                "inherit": "downsample_average",
                "target": [
                    "pp_output_eighth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_quarter",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_eighth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_eighth",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal"
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_eighth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_eighth",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical"
            },
            {
                "inherit": "bloom_upsample",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "post_process_colour",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_full",
                        "unit": 1,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_half",
                        "unit": 2,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_quarter",
                        "unit": 3,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_eighth",
                        "unit": 4,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "depth_of_field": [
            {
                "inherit": "downsample_2x2",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_half",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal"
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_half"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_half",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ],
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical"
            },
            {
                "inherit": "depth_of_field",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "post_process_depth",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_full",
                        "unit": 1,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "pp_output_half",
                        "unit": 2,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "colour_lut": [
            {
                "inherit": "colour_lut",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "blit_depth": [
            {
                "inherit": "blit_depth",
                "target": [
                    "main_depth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "post_process_depth",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "blit_taa_depth": [
            {
                "inherit": "blit_depth",
                "technique": "blit_depth_unjittered",
                "target": [
                    "main_depth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "taa_depth",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "blit_post_process": [
            {
                "inherit": "blit",
                "target": [
                    "main_colour"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "blit_colour_depth": [
            {
                "inherit": "blit_colour_depth",
                "target": [
                    "main_colour",
                    "main_depth"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "post_process_colour",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "post_process_depth",
                        "unit": 1,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "menger_sponge": [
            {
                "inherit": "menger_sponge",
                "target": [
                    "post_process_colour",
                    "post_process_depth"
                ],
                "pp_write_non_aux": true,
                "technique": "menger_sponge",
                "camera": "model_viewer_camera",
                "resolve": [
                    "average_4x",
                    "max_4x"
                ]
            }
        ],
        "crt": [
            {
                "inherit": "crt",
                "target": [
                    "pp_output_full"
                ],
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "sss_reflectance": [
            {
                "inherit": "filter",
                "target": [
                    "pp_output_full"
                ],
                "technique": "sss_reflectance",
                "camera": "model_viewer_camera",
                "filter_kernel": "gauss_9_1",
                "filter_direction": "horizontal",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "post_process_depth",
                        "unit": 1,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "filter",
                "target": [
                    "pp_output_full"
                ],
                "technique": "sss_reflectance",
                "camera": "model_viewer_camera",
                "filter_kernel": "gauss_9_1",
                "filter_direction": "vertical",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "post_process_depth",
                        "unit": 1,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ],
        "taa_resolve": [
            {
                "inherit": "taa_resolve",
                "target": [
                    "pp_output_full"
                ],
                "technique": "taa_resolve",
                "camera": "model_viewer_camera",
                "scene_views": [
                    "ecs_taa_resolve"
                ],
                "sampler_bindings": [
                    {
                        "texture": "taa_colour",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    },
                    {
                        "texture": "taa_depth",
                        "unit": 1,
                        "state": "clamp_point",
                        "shader": "ps"
                    },
                    {
                        "texture": "taa_history",
                        "unit": 2,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            },
            {
                "inherit": "blit",
                "target": [
                    "taa_history"
                ],
                "pp_write_non_aux": true,
                "camera": "model_viewer_camera",
                "sampler_bindings": [
                    {
                        "texture": "pp_output_full",
                        "unit": 0,
                        "state": "clamp_linear",
                        "shader": "ps"
                    }
                ]
            }
        ]
    },
    "post_process_sets": {
        "blit_only": {
            "chain": [
                "blit_colour_depth"
            ]
        },
        "editor_default": {
            "chain": [
                "blit_depth",
                "blit_post_process"
            ]
        },
        "taa_resolve": {
            "chain": [
                "taa_resolve",
                "blit_taa_depth",
                "blit_post_process"
            ]
        }
    }
}       PFFTMkG    GDEF  p    OS/22z@  X   `cmap
:    gasp  h   glyfM   Lhead-      6hhea
     $hmtxEy    
loca\    maxp,  8    name gh  post k  u    xY_<      32    32 	                 	 	                   '            @       i   3   3  s                              pyrs @                          p    U                                 ]                              y n                       2                           @                    
                                                                           z                     Z                                @    5 5             z                                  Z  Z          @                                                                    ,  _                 @                                              s                               @         	            @                        (                                     @            @      @        -   M M -  M M                  @                                 @  @  -              `   b                 $                                       6                                         4           8       " "  "  "  "  "                  @                  D         @                   ,              ,     @                                                 	     m                        )                 @    @   	                                	                                   '                      D     9                   >                              d  Y     *     	  '	   	   	   	   	   	                                             	                                                           	                                                                                   T	      	   	   	   	   	            	         	   	      	                                                 @   	     f     	                                              %                 R           E	            	      	     $                    !  k  (                   D    '	         	         %                 	                %	                                         	                                                       0  %    /       &                                                      p @  0       !"""`>N^n~.>N^n~>N^n~          !"""` !@P`p  0@P`p !@P`p \XSB1
	                                                                                                                                                                                                                                                                                       
	                                                                                        ,   ,   ,   ,   ,   ,   ,   ,   ,   ,   ,   ,   ,         t    L    T  $    l  	x  	  
T  (      d             l  ,          4    d    p  H    $  d  ,    t  (        !  "0  #   $,  $  &D  '  (  )T  *  *  ,  ,  -  .@  .  /`  /  0  0  1  2  3d  44  4  5   5  5  6   6\  6  7H  7  8  8`  8  9L  9  :h  :  ;  <p  =p  ><  >  ?h  ?  @H  @  A0  A  BX  B  Cd  C  DL  D  E  F  G0  G  H  I  J8  K  L  Md  N,  N  N  O  P`  P  Q4  Q  R  Rl  S,  S  T`  U0  W  X  Z  [@  [  \<  \  ]  ^(  ^  _  `p  b,  b  d  d  eP  e  f  g`  g  iL  i  jD  k  k  l  m@  n,  oL  p  q  r  sx  t  t  uD  {`  |   |  }  }  ~          H          l  @            l  H       T    H        `      @      $  \  X    D        T  X      D  P  ,    8    d  \                    H    x       t    X    p     d          x  t              @            \             0    d              x        ,              8  ,    `    l  H    `    T        @    l            l  p                                       4        X    $  l    (      `               	d 
 
    ,    ,   8   (  X    x | T  @    |   ! "x # #l $ $ 'h ( *L ,T .L 1t 1 2 30 3 4 5t 6T 7$ 8 9H : : ; < < ?X @ A B C D EH FH Gp HH Ix J  J K L M N@ P@ Q R SD T  UL V` V WX X4 X Z Z [d [ \| ] ^ ` aH a b cX d et fh g h i\ jx n p@ s v w x y z {h | } } \   l t  4     t  8 8  L  T         |     |     4 x   L      X (           @   l  t   $   x L L    H      T (         l d  P   x p    T T    L     < H  $  l    4          P l   ,  x  p , x t  d   4   4  , h  P 	4 
    4  < , , 4 0 8 $  8  T   | !h " $L %0 &H ' ( ) *0 * + , .$ . 0 1 2@ 2 3 4t 5$ 6 9  : : ; ; <( < =4 ? @ A C D F H` H I L L L L L L L L L L L L L L L L  p       7!!!@pp p       ]    !2#!"&463!&54>3!2+@&&&&@+$(($F#+ &4&&4& x+#       +  ".4>32".4>32467632 DhgZghDDhg-iW DhgZghDDhg-iW&@(8 2N++NdN+';2N++NdN+'3
 8      !        #"'#"$&6$ rL46$ooo|W%r4L&V|ooo%        = M  %+".'&%&'3!26<.#!";2>767>7#!"&5463!2 %3@m00m@3% @:"7..7":6]^B@B^^BB^  $+0110+$ (	
t1%%1+`B^^B@B^^        "'.54632>324
#L</>oP$$Po>Z$_dC+I@$$@I+     "  #"'%#"&547&547%62V??V8<8yb%	I))9I	       	 +  	%%#"'%#"&547&547%62q2ZZ2IzyV)??V8<8)>~>[
2b%	I))9I	         %#!"&54>3 72  &6  }XX}.GuLlLuG. >mmUmEEm>         / ? O _ o      54&+";2654&+";2654&+";264&#!"3!2654&+";2654&+";264&#!"3!2654&+";2654&+";2654&+";267#!"&5463!2&&&&&&&&&&&& & && & &&&&&&&&& && &&&&&&&&&&&&&^BB^^B@B^@&&&&&&&&&&&& && &&&&&&&&&& && &&&&&&&&&&&&&&B^^B@B^^        / ?  #!"&5463!2#!"&5463!2#!"&5463!2#!"&5463!2 L4 4LL4 4LL4 4LL4 4LL4 4LL4 4LL4 4LL4 4L 4LL44LL4LL44LL4LL44LL4LL44LL 	        / ? O _ o    #!"&=463!2#!"&=463!2#!"&=463!2#!"&=463!2#!"&=463!2#!"&=463!2#!"&=463!2#!"&=463!2#!"&=463!2 8((88(@(88((88(@(88((88(@(88((88(@(88((88(@(88((88(@(88((88(@(88((88(@(88((88(@(8 (88((88(88((88(88((88(88((88(88((88(88((88(88((88(88((88(88((88          / ? O _  #!"&=463!2#!"&=463!2#!"&=463!2#!"&=463!2#!"&=463!2#!"&=463!2 8((88(@(88((88(@(8 8(@(88((8 8((88(@(8 8(@(88((88(@(88((8 (88((88(88((88(88((88(88((88(88((88(88((88    y     "/&4?62	62,PP&PP,jP  n #  $"'	"/&47	&4?62	62	PP&P&&P&P&P&&P&P      # + D  ++"&=#"&=46;546;232      #"'#"$&6$  @@rK56$ooo|W@@rjK&V|ooo        0  #!"&=463!2      #"'#"$&6$  @rK56$ooo|W@@rjK&V|ooo         ) 5   $&54762>54&'.7>"&5462 zz+i *bkQQkb* j*LhLLhLzzBm +*i JyhQQhyJ i*+ mJ4LL44LL          / ? O  %+"&=46;2%+"&546;2%+"&546;2+"&546;2+"&546;2 `r@@r@@        n   4&"2#"/+"&/&'#"'&'&547>7&/.=46?67&'&547>3267676;27632 #H
	,/1)
~'H(C
	,/1)	$Hm6%2X
%	l2k	r6
[21..9Q
$
k2k	
w3[20       / ; C g  +"&546;2+"&546;2+"&546;2!3!2>!'&'!+#!"&5#"&=463!7>3!2!2 @@ @@ @@@`0

o`^BB^`5FN(@(NF5 @@@L%%Ju		@LSyuS@%44%       f  5  #!!!"&5465	7#"'	'&/&6762546;2& &??>LL>
 X 
  &&&AJ	A	J
Wh          #  #!"&5463!2!&'&!"&5!(8((88((`x
c`(8 `((88(@(8(D9 8(           ,  #!"&=46;46;2 .  6  $$ @(r^aa@@`(_^aa    2  N   C  5.+";26#!26'.#!"3!"547>3!";26/.#!2W.@@.$SS$@9I  I6>>         % =  $4&"2$4&"2#!"&5463!2?!2"'&763!463!2!2 &4&&4&&4&&48(@(88(::(8@6@* & & *4&&4&&4&&4& (88(@(8888)@)'&&@      $ 0  "'&76;46;232  >& $$ `
(r^aa`		@`2(^aa         $ 0  ++"&5#"&54762  >& $$ ^
?@(r^aa`?		(^aa         #  !.'!!!%#!"&547>3!2<<<_@`&&
5@5
@&&>=(""=       '   #"'&5476.  6  $$    ! (r^aaJ	%%(_^aa     3  #!"'&?&#"3267672#"$&6$3276 &@*hQQhwI
	mzzk)' @&('QQh_
	
z8zoe      $ G   !"$'"&5463!23267676;2#!"&4?&#"+"&= !2762@hk4&&&GaF*&@&F*Ak4&nf&&&4BHrd@&&4rdMoe&            / ? O _ o   +"&=46;25+"&=46;25+"&=46;2#!"&=463!25#!"&=463!25#!"&=463!24&#!"3!26#!"&5463!2@@@@@@@@@@^B@B^^BB^`@@@@@@@@@@@@3@MB^^B@B^^         !54&"#!"&546;54   32@ @8(@(88( p (8 jj(88(@(88   @   7  +"&5&5462#".#"#"&5476763232>32@@@@KjK=}\I&:k~&26]S& H&&H5KKut,4,	& x:;*4*&        K  #+"&546;227654$ >3546;2+"&="&/&546$ <X@@Gv"DD"vG@@X<4L41!Sk @ G<_bb_<G  kS!1zz          "'!"&5463!62 &4&&M4&&M&&M&          -  "'!"&5463!62 #"&54>4.54632 &4&&M4&UF
&""""&
F&M&&M&%/B/%      G  - I k  "'!"&5463!62 #"&54>4.54632#"&54767>4&'&'&54632#"&547>7676'&'.'&54632 &4&&M4&UF
&""""&
FU&'8JSSJ8'&&'.${{$.'&&M&&M&%/B/%7;&'66'&;4[&$[2[$&[              # / 3 7  #5#5!#5!!!!!!!#5!#5!5##!35!!!                        # ' + / 3 7 ; ?  3#3#3#3#3#3#3#3#3#3#3#3#3#3#3#3#3????  ^>>~??????~??~??^??^^?  ^??          4&"2#"'.5463!2KjKKjv%'45%5&5L45&%jKKjK@5%%%%54L5&6'      k   5   4&"2#"'.5463!2#"&'654'.#32KjKKjv%'45%5&5L45&%%'4$.%%5&55&%jKKjK@5%%%%54L5&6'45%%%54'&55&6'  
y T d t  #!"&'&74676&7>7>76&7>7>76&7>7>76&7>7>63!2#!"3!2676'3!26?6&#!"3!26?6&#!"g(sAeM,*$/!'&JP$G]
x6,&`h`"9Hv@WkNC<.
&k&
("$p"	.#u&#	%!'	pJvwEF#@@        2#"'	#"'.546763!''!0#GG$/!''!	8""8 X!	8"	"8	          <  )!!#"&=! 4&"27+#!"&=#"&546;463!232(8&4&&48(@(8qO@8((`(@Oq 8(&4&&4&@`(88(Oq (8(`( q      ! )   2"&42#!"&546;7>3!2      Ijjjj3e5 5e3gr`Ijjjj1GG1r        P  2327&7>7;"&#"4?2>54.'%3"&#"#!9&WB03&K5!)V?@L'	>R>e;&L::%P>vO
'h N_":-&+#
:	'	      + a  %3 4'.#"32>54.#"7>7><5'./6$3232#"&#"+JBx)EB_I:I*CRzb3:dtB2P$$5.3bZF|\8!-T>5Fu\,,jn OrB,<!
54wJ]?tTFi;23j.p^%/2+	S:T}K4W9: #dfE     :  7>7676'5.'732>7"#"&#&#"OAzj=N!}:0e%	y+tD3~U#B4#g		'2
%/!:T	bRU,7        }  %2"/&6;#"&?62+326323!2>?23&'.'.#"&"$#"#&=>764=464.'&#"&'!~:~!PP!~:~!P6,,$$%*'c2N 	
($"LA23Yl!x!*%% %% pP,T	NE	Q7^oH!+(
3	 *Ueeuwg      a   32632$?23&'.5&'&#"&"5$#"#&=>7>4&54&54>.'&#"&'2#".465!#".'&47>32!4&4>Q6,,Fa w!*'
=~Pl*	
($"LA23Yl	)!*<7@@7< <7@@7<  pP,T	MFQ747HoH!+(
3	 tJHQ6wh',686,'$##$',686,'$##$          / ?  %#!"&=463!2#!"&=463!2#!"&=463!2#!"&=463!2 &&&&& && & & && &&&&&&&&&f&&&&f&&&&f&&&&          / ?  %#!"&=463!2#!"&=463!2#!"&=463!2#!"&=463!2 &&&&&&&& &&&&&&&&&&&&f&&&&f&&&&f&&&&          / ?  %#!"&=463!2#!"&=463!2#!"&=463!2#!"&=463!2 &&&&& && && && &&&&&&&&&f&&&&f&&&&f&&&&            / ?  %#!"&=463!2#!"&=463!2#!"&=463!2#!"&=463!2 &&&&&&&&&&&&&&&&&&&&f&&&&f&&&&f&&&&            / ? O _ o   %+"&=46;2+"&=46;2+"&=46;2#!"&=463!2+"&=46;2#!"&=463!2#!"&=463!2#!"&=463!2  @  @@@sssss          / ? O  #"'&47632#!"&=463!2#!"&=463!2#!"&=463!2#!"&=463!2			 	@@@@	 		 	sss         / ? O   #"&54632	#!"&=463!2#!"&=463!2#!"&=463!2#!"&=463!2`			 @@@@		@		sss           #"'#!"&5463!2632 'mw@www'*wwww          .   "&462!5	!"3!2654&#!"&5463!2pppp@  @^BB^^B@B^ppp@@  @ @B^^BB^^   k    %  !7'34#"3276'	!7632k[[v

6`%`$65&%[[k
`5%&&'          4&"2"&'&54    !?H?!,, mF!&&!Fm,        %"  $$  ^aa`@^aa           -  4'.'&"26%   547>7>2 "KjK XQqYn	243nYqQ$!+!77!+!$5KK,	]""]	        9 > H  7'3 &7#!"&5463!2'&#!"3!26=4?6	!762xtt`   ^Qwww@?61B^^B@B^	@(` `\\\P`tt8`  ^ww@w1^BB^^B~	@` \ \P          + Z  #!"&5463!12+"3!26=47676#"'&=# #"'.54>;547632www M8
pB^^B@B^'sw-

9*##;Noj'#ww@w"^BB^^B
	*"g`81T`PSA:'*4       / D  #!"&5463!2#"'&#!"3!26=4?632"'&4?62	62www@?61
B^^B@B^	@
BRnBBn^ww@w1
^BB^^B	@
BnnB          C   "&=!32"'&46;!"'&4762!#"&4762+!5462  4&& 4 &&4  4&& 4 &&4 4 &&4  4&& 4 &&4  4&&        6'&'+"&546;267:	&&&&	s@	
Z&&&&Z
	     +  6'&''&'+"&546;267667:	:	&&&&		s@	
:	
Z&&&&Z
	:
	  z   6'&''&47667S:	:	s@	
:4:
	    |   	&546h!!0a$           #!"&5463!2#!"&5463!2 & && && && &@&&&&&&&&          #!"&5463!2 &&&&@&&&&         &54646&5-	:	s:	
:4:
	        +  &5464646;2+"&5&5-		&&&&	:	s:	
:	
&&&&
	:
	         &54646;2+"&5-	&&&&	s:	
&&&&
	          62#!"&!"&5463!24@&&&&-:& && &        	"'&476244444     Zf   	"/&47	&4?62S44444       # /  54&#!4&+"!"3!;265!26  $$ & && && && &@^aa@& && && && &+^aa        54&#!"3!26  $$ & && &@^aa@&&&&+^aa       + 7  4/7654/&#"'&#"32?32?6  $$ }ZZZZ^aaZZZZ^aa      #  4/&"'&"327> $$ [4h4[j^aa"ZiZJ^aa      : F  %54&+";264.#"32767632;265467>$ $$  oW	5!"40K(0?i+! ":^aaXRdD4!&.uC$=1/J=^aa       . :  %54&+4&#!";#"3!2654&+";26 $$  ```^aa ^aa      / _  #"&=46;.'+"&=32+546;2>++"&=.'#"&=46;>7546;232m&&m l&&l m&&m l&&ls&%&&%&&%&&%& &&l m&&m l&&l m&&m ,&%&&%&&%&&%&        # / ;  "/"/&4?'&4?627626.  6  $$ I














(r^aa














(_^aa           ,  	"'&4?6262.  6  $$ Z4f44fz(r^aaZ&4ff4(_^aa        	  "  4'32>&#"  $&6$  WoV zzz8YW[?zz:zz   @5 K    #!#"'&547632!2 A4@%&&K%54'u%%&54&K&&4A5K$l$L%%%54'&&J&j&K    5K    #"/&47!"&=463!&4?632%u'43'K&&%@4AA4&&K&45&%@6%u%%K&j&%K55K&$l$K&&u#   5K@ !  #"'+"&5"/&547632K%K&56$K55K$l$K&&#76%%53'K&&%@4AA4&&K&45&%%u'     5K "  #"'&54?63246;2632K%u'45%u&&J'45%&L44L&%54'K%5%t%%$65&K%%4LL4@&%%K'      ,   "&5#"#"'.'547!3462  4&bqb>#5&4 4 & 6Uue7D#		" &        /   #!"&546262"/"/&47'&463!2
&@&&4L

r&4

r

L&&
4&&&L

rI@&

r

L4&&     s  /  "/"/&47'&463!2 #!"&546262 &4

r

L&&
&@&&4L

r@@&

r

L4&&
4&&&L

r         #  #!+"&5!"&=463!46;2!28(`8((8`(88(8((8(8 (8`(88(8((8(88(`8          #!"&=463!28(@(88((8 (88((88   z 5  '%+"&5&/&67-.?>46;2%6.@g.L44L.g@.
.@g.
L44L
.g@.g.n.4LL43.n.gg.n.34LL4.n.g        -     $54&+";264'&+";26/a^



^aafm
        @    J  %55!;263'&#"$4&#"32+#!"&5#"&5463!"&46327632#!2$$8~+(888(+}(`8((8`]]k==k]]8,8e8P88P8`(88(@MM        N   4&#"327>76$32 #"'.#"#"&'.54>54&'&54>7>7>32 &z&^&./+>+)>J>	Wm7'
'"''? &4&c&^|h_bml/J@L@#*#M6:D
35sw$	'%
'	\t          3  #!"&=463!2'.54>54''@ 1O``O1CZZ71O``O1BZZ7@@N]SHH[3`)TtbN]SHH[3^)Tt           ! 1  &'   547 $ 4&#"2654632    '&476   ==}(zVl''@uhyyhu9(}VzD##D#     	  = C U  %7.547 4&#"2654632% #"'&547.'&476 !27632#76$7&'7+NWb=}(zVj\i1
z,XY[6
$!%'FuJiys?_9?kyhun(}VzYF
KALa
02-F"@Qsp@_        ! 3  %54&+";264'&+";26#!"&'&7>2 

 #%;" ";%# <F<7
??""??$$     ll 2  #"'&'	+&/&'&?632	&'&?67>`,@L5`		
`	L`4LH``	a	5L@              # 3 7 ; ? O s  !!!!%!!!!%!!!!!!!!%!!4&+";26!!%!!!!74&+";26%#!"&546;546;2!546;232 `@ `@ @@  @@@ @  @@L44LL4^B@B^^B@B^4L  @@@@      @@  @@   M 4LL4 4L`B^^B``B^^B`L        7 q  .+"&=46;2 #"&=".'673!54632#"&=!"+"&=46;2>767>3!54632<M33K,		 j8Z4L2B4:;M33K, ?			 0N<* .)C=W]xD0N<* .)C=W]xD ?\-7H)		".=']-7H)
w		<?.>mBZxPV3!<?.>mBZxPV3!
         &   #"'&'5&6&>7>7&54>$32 dFK1A
0)L.C58.H(Ye      # 3 C   $=463!22>=463!2#!"&5463!2#!"&5463!2 H&&/<R.*.R</&& &&&& &&&&B&&4L&&L4&&f&&&&&&&&     Z     %"'	"/&476244455     Z   	"'&4?62	6244455        % K  %#!".<=#"&54762+!2"'&546;!"/&5463!232 @&@<@&@	:&	& 
&&
&	
`&          :  $"&462"&462!2#!"&54>7#"&463!2!2LhLLhLhLLh!&& &&& &4hLLhLLhLLhL %z<
0&4&&)17&4&&&           #!"&5463!2!2\@\\@\\@\\\\         W  *  #!"&547>3!2!"4&5463!2!2W+B"5P+B@"5^=\@\ \H#t3G#3G:_Ht\\     @      +32"'&46;#"&4762&& 4 && 4 4& &4  4& &4       @     "&=!"'&4762!5462  4& &4  4& &4 4 && 4 &&              !!!3!!                    0 @  67&#".'&'#"'#"'32>54'6#!"&5463!2 8ADAE=\W{O[/5dIkDtpe1?*w@www	(M&B{Wta28r=Ku?RZ^GwT	-@www       $  2+37#546375&#"#3!"&5463ww/Dz?swww@wS88	ww           # ' . >   4&#"26546326"&462!5! &  !5!!=!!%#!"&5463!2B^8(  > @|K5 5KK5 5K^B(8>v 5KK5 5KK   H  G   4&"&#"2654'32#".'#"'#"&54$327.54632@pp)*Pppp)*Pb	'"+`N*(a2c`." b
PTY9ppP*)pppP*) b ".`(*N2`+"'	b
MRZB               4&"24&"264&"26#"/+"&/&'#"'&547>7&/.=46?67&'&547>3267676;27632#"&'"'#"'&547&'&=4767&547>32626?2#"&'"'#"'&547&'&=4767&547>32626?2LhLKjKLhLKjK	"8w
s%(")v

>
	"8x
s"+")v
<
3zLLz33>8L3)x33zLLz33>8L3)x3 4LL45KK54LL45KK
#)0C	wZl/

Y	
N,&
#)0C	vZl.

YL0"qG^^Gqq$ ]G)FqqG^^Gqq$ ]G)Fq         % O   #"'#"&'&4>7>7.546$ '&'&'# '32$7>54'VZ|$2$
|E~E<|
$2$|ZV:(t}X(	&%(HwxH(%&	(XZT\MKG        < m  $4&"24&#!4654&#+32;254'>4'654&'>7+"&'&#!"&5463!6767>763232 &4&&4N2`@`%)7&,$)'  %/0y#5 +1	&<$]`{t5KK5$e:1&+'3TF0h4&&4&3M:;b^v+D2 5#$IIJ 2E=\$YJ!$MCeM-+(K55KK5y*%Au]c         > q   4&"24&'>54'654&'654&+"+322654&5!267+#"'.'&'&'!"&5463!27>;2 &4&&4+ 5#bW0/%  ')$,&7)%`@``2Nh0##T3'"(0;e$5KK5 tip<&	1&4&&4& #\=E2&%IURI$#5 2D+v^b;:M2gc]vDEA%!bSV2MK55K(,,MeCM$!I     @   #"&547&547%6@?V8b%	I)         9  4.""'."	67"'.54632>32+C`\hxeH>Hexh\`C+ED4
#L</>oP$$Po>Q|I.3MCCM3.I|Q/Z$_dC+I@$$@I+           ( @  %#!"&5463!2#!"3!: "&5!"&5463!462ww@B^^B 
4&@&&&4 ` ww ^B@B^24& && &        % 5  73#7.";2634&#"35#347>32#!"&5463!2FtIG9;HIxI<,tw@wwwz4DD43EEueB&#1s@www      .  4&"26#!+"'!"&5463"&463!2#2&S3Ll&c4LL44LL4c@&&{ LhLLhL           ' ?  #!"&5463!2#!"3!26546;2"/"/&47'&463!2www@B^^B@B^@&4t

r

& &`ww@w@^BB^^B@R &t

r

4&&         @   "&5!"&5463!462	#!"&54&>3!2654&#!*.54&>3!24&@&&&4 sw@B^^B
@w4& && &3@w ^BB^       I  &5!%5!>732#!"&=4632654&'&'.=463!5463!2!2J  JSq*5&=CKuuKC=&5*qS8( ^B@B^ (8`N`GtO6)"M36J[E@@E[J63M")6OtG(8`B^^B`8   	        ' , 2    6'&'&76'6'&6&'&6'&4#"7&64   654'.'&'.63226767.547&7662>76#!"&5463!2		/[		.
=X4,+"*+, 1JH'5G::#L5+@=&# w@wwwP.1GE,44+	;/5cFO:>JJ>:O9W5$@(b4@www      ' ?  $4&"2$4&"2#!"&5463!3!267!2#!#!"&5!"'&762 &4&&4&&4&&48(@(88(c= =c(8* & & *6&4&&4&&4&&4& (88(@(88HH88`(@&&('@       1 c  4&'.54654'&#"#"&#"32632327>7#"&#"#"&54654&54>76763232632


	N<;+gC8A`1a99gw|98aIe$IVNz<:LQJ
,-[%	061I()W,$-7,oIX()oA;=N0
eTZ	 (       O  #".'&'& '&'.54767>3232>32e^\4?P	bMO0#382W#& 9C9
L"	82<*9FF(W283#0OMb	P?4\^eFF9*<28	"L
9C9 &#           !"3!2654&#!"&5463!2`B^^B@B^^www@w ^BB^^B@B^ww@w      #  !72#"'	#"'.546763 YY!''!0#GG$/!''! &UUjZ	8""8 X!	8"	"8	        G W  4.'.#"#".'.'.54>54.'.#" 32676#!"&5463!2  1.-
+$)c8)1)

05.D<90)$9 w@wwwW

)1)7c)$+
-.1 9$)0<D.59@www  ,  T  1  # '327.'327.=.547&54632676TC_L#+i!+*pDNBN,y[`m`%i]hbEm}au&,SXK
&$f9s?
    _    #"!#!#!54632V<%' HH	(       T \ d k s z       &54654'>54'6'&&"."&'./"?'& 546'&6'&6'&6'&6'&74"727&6/a49[aA)O%-j'&]]5r-%O)@a[9'
0BA;+

>HCU


	#	
	
$				2	AC: oM=a-6OUwW[q	( -	q[WwUP6$C

+) (	
8&/&eMa	
&$	        %  +"&54&"32#!"&5463!54   &@&`(88(@(88(r && jj8((88(@(8        # ' +  2#!"&5463"!54&#265!375!35!B^^BB^^B` ^B@B^^BB^ `       ! =   "&462+"&'& '.=476;+"&'& $'.=476;pppp$!$qr%}#ppp!E$rq#%!           ) ?   "&462"&4624&#!"3!26!.#!"#!"&547>3!2/B//B//B//B@2^B@B^\77\aB//B//B//B/@~B^^B@2^5BB52     . 4  2## %&'.67#"&=463! 2 5KK5L4_u:B&1/&.-
zB^^B4LvyKjK4L[!^k'!A3;):2*<vTq6^BB^L4$)*    @     A  4#"&54"3! 4."#!"&5!"&5>547&5462;U gIv0ZZ0L4@@4L2RX='8P8'=XR U;Ig0,3lb??bl34LjjL4*\(88(\    } I  /#"/'&/'&?'&'&?'&76?'&7676767676`
(5)0
)*)
0)5(

(5)0
))))
0)5(
*)
0)5(
)5)0
)**)
0)5)

)5)0
)*      5 h  $4&"24&#!4>54&#"+323254'>4'654&'!267+#"'&#!"&5463!2>767>32!2 &4&&4N2$YGB(HGEG  HQ#5K4Li!<;5KK5 
A#("/?&}vh4&&4&3M95S+C=,@QQ9@@IJ 2E=L5i>9eME;K55K	J7R>@#zD<      5 = q  %3#".'&'&'&'.#"!"3!32>$4&"2#!"#"&?&547&'#"&5463!&546323!2`  #A<(H(GY$2NL4K5#aWTh&4&&4K5;=!ihv}&?/"(#A
 5K2*!	Q@.'!&=C+S59M34L=E2 JI UR@@&4&&4&5K;ELf9>ig<Dz#@>R7J	K          5 h  4&"24#"."&#"4&#"".#"!54>7#!"&54.'&'.5463246326326 &4&&4IJ 2E=L43M95S+C=,@QQ9@@E;K55K	J7R>@#zD<gi>9eMZ4&&4&<#5K4LN2$YGB(HGEG  HV;5KK5 
A#("/?&}vhi!<         4 < p  4.=!32>332653272673264&"2/#"'#"&5#"&54>767>5463!2@@2*!	Q@.'!&=C+S59M34L.9E2 JI UR&4&&4&Lf6Aig6Jy#@>R7J	K55K;E@TH  #A<(H(GY$2NL4K#5#a=4&&4&D=ihv}&?/"(#A
 5KK5;         +  54&#!764/&"2?64/!26  $$  &
[6[[j6[& ^aa@&4[[6[[6&+^aa        +   4/&"!"3!277$ $$ [6[
&&[6j[^aae6[j[6&&4[j[^aa      +   4''&"2?;2652?$ $$ [6[[6&&4[^aaf6j[[6[
&&[^aa      +   4/&"4&+"'&"2?  $$ [6&&4[j[6[j^aad6[&&
[6[[j ^aa             $2>767676&67>?&'4&'.'.'."#&6'&6&'3.'.&'&'&&'&6'&>567>#7>7636''&'&&'.'"6&'6'..'/"&'&76.'7>767&.'"76.7"7"#76'&'.'2#22676767765'4.6326&'.'&'"'>7>&&'.54>'>7>67&'&#674&7767>&/45'.67>76'27".#6'>776'>7647>?6#76'6&'676'&67.'&'6.'.#&'.&6'&.5/a^D&"	


	4	$!	#	
		
	


 
.0"Y
	+!	
	
$		"+


		
		
		^aa
	

					

		
			P '-(	#	*	$
"!				*
!	
(				
	
$
		
2   ~   /  $4&"2	#"/&547#"  32>32&4&&4V%54'j&&'/:,{	&4&&4&V%%l$65&b'Cr!"k[G             + ;  %!5!!5!!5!#!"&5463!2#!"&5463!2#!"&5463!2    &&&&&&&&&&&&@ && && && && && &&   {    #"'&5&763!2{' * *)* )'             /  !5!#!"&5!3!26=#!5!463!5463!2!2  ^B@B^&@&`   ^B`8(@(8`B^   B^^B&&B^(88(^      G  	76#!"'&?	#!"&5476	#"'&5463!2	'&763!2#"'c)'&@**@&('c(&*cc*&'*@&('c'(&*cc*&('c'(&@*        1 9 A S [  #"&532327#!"&54>322>32 "&462  &6 +&'654'32>32"&462QgRp|Kx;CByy 6Fe=
BPPB
=eF6  V>!pRgQBC;xK|{QNa*+%xx5eud_C(+5++5+(C_due2>NQ{u%+*j     p ! C i  4/&#"#".'32?64/&#"327.546326 #"/&547'#"/&4?632632(* 8(!)(A(')* 8(!USxySSXXVzxTTUSxySSXXVzxT@( (8 *(('((8 SSUSx{VXXTTSSUSx{VXXT        #!" 5467&54 32632t,;F`j)6,>jK?  s  !  %#!"&7#"&463!2+!'5#8EjjE8@&& &&@XYY&4&&4&qDS%q%         N \ j x     2"&4#"'#"'&7>76326?'&'#"'.'&676326326&'&#"32>'&#"3254?''74&&4&lNnbSVZbRSD	zz	DSRb)+USbn\.2Q\dJ'.2Q\dJ.Q2.'Jd\Q2.'Jd`!O` 	`&4&&4r$#@B10M5TNT{L5T	II	T5L;l'OT4M01B@#$*3;$*3;;3*$;3*$:$/ @@Qq`@         " % 3 <  2#!"&5!"&5467>3!263!	!!#!!46!#!(88(@(8(8(`((8D<++<8(` (8(`8(@(88( 8((`(8((<`(8 (``(8    || ?  %#"'&54632#"'&#"32654'&#"#"'&54632|udqs]
=
OfjL?R@T?"&
>
f?rRX=Edudsq
=
_MjiL?T@R?E& f
>
=XRr?b      ! 1 E  )!34&'.##!"&5#3463!24&+";26#!"&5463!2  

08((88(@(88((88((`(1

`(88( (88( @`(88(@(8(`         #!"&5463!2 w@www`@www             /  %#!"&=463!2#!"&=463!2#!"&=463!2 &&&&&&&&&&&&&&&&&&&&&&&&    @    ' 7 G  $"&462"&462#!"&=463!2 "&462#!"&=463!2#!"&=463!2ppppppp@ppp@@ppppppppp         < L \ l |  #"'732654'>75"##5!!&54>54&#"'>3235#!"&=463!2!5346=#'73#!"&=463!2#!"&=463!2}mQjB919+i1$AjM_3</BB/.#U_:IdDRE@k*Gj@@TP\BX-@8
C)5XsJ@$3T4+,:;39SG2S.7<vcc))%Ll}         5 e  2#!"&=463%&'&5476!2/&'&#"!#"/&'&=4'&?5732767654'&@02uBo
T25XzrDCBBEh:%)0%HPIP{rQ9f#-+>;I@KM-/Q"@@@#-bZ$&P{<8[;:XICC>. '5oe80#.0(l0&%,"J&9%$<=DTI     c s  &/6323276727#"327676767654./&'&'737#"'&'&'&54'&54&#!"3!260%<4"VRt8<@<-#=XYhW8+0$"+dTLx-'I&JKkmuw<=V@!X@		v'|N;!/!$8:IObV;C#V
&(mL.A:9 !./KLwPM$@@  
       / ? O _ o     %54&#!"3!2654&#!"3!2654&#!"3!2654&#!"3!2654&#!"3!2654&#!"3!2654&#!"3!2654&#!"3!2654&#!"3!26#!"&5463!2 @@ @ @ @ @ @ @@^BB^^B@B^NB^^B@B^^         # + 3  	'$"/&4762%/?/?/?/?%k*66bbbb|<<<bbbbbbbb%k66bbb<<<<^bbbbbb    @      M  $4&"2!#" 4&"2&#"&5!"&5#".54634&>?>;5463!2LhLLh		 LhLLhL!'@'!&	?& &LhLLhL 		hLLhL 	jjjj	&@6/"&&       J   #"'676732>54.#"7>76'&54632#"&7>54&#"&54$  ok;	-j=yhwi[+PM3k=J%62>VcaaQ^ ]G"'9r~:`}Ch  0=ZW=#uY2BrUI1^Fk[|a      L  2#!67673254.#"67676'&54632#"&7>54&#"#"&5463ww+U	,i<F{jh}Z+OM
2j<J%51=Ubwww@wzX"'8'TyI9`{Bf 
,>XW<"uW1AqSH1bdww        ' 7  4'!3#"&46327&#"326%35#5##33#!"&5463!20U6cc\=hlYmmnnnnw@wwww&46#;edwnnnnn@www    	 ] # /  #"$&6$3 &#"32>7!5!%##5#5353ttu{zz{SZC`cot*tq||.EXN#??           , <  !5##673#$".4>2"&5!#2!46#!"&5463!2 rM* *M~~M**M~~M*jjj& && &`P%|NN||NN|* jj jj@&&&&    @     "'&463!2 @4@&Z4@4&        @    #!"&4762 &&4Z4&&4@     @    "'&4762&4@4&@&4&      @    "&5462@@4&&44@&&@           3!!%!!26#!"&5463!2`m`^BB^^B@B^ `@B^^BB^^    @     "'&463!2#!"&4762 @4@&&&&44@4&Z4&&4@            "'&463!2 @4@&4@4&        @    #!"&4762 &&4Z4&&4@          :  #!"&5;2>76%6 +".'&$'.5463!2 ^B@B^,9j9Gv33vG9H9+bI\
A+=66=+A
[">nSMA_:B^^B1&c*/11/*{'VO3@/$$/@*?Nh^    l   +  !+"&5462!4&#"!/!#>32]_gTRdgdQV?UI*Gg?!2IbbIJaaiwE3300 08        4   #"$'&6?6332>4.#"#!"&54766$32 zm
IwhQQhbF*@&('kz
	
_hQQGB'(&*eoz  ( q  !#"'&547"'#"'&54>7632&4762.547>32#".'632%k'45%&+ ~((h		&

\((		&

~ +54'k%5%l%%l$65+ ~

&		((\

&		h((~ +%'         ! ) 1 9 K   4&"2 4&"26.676&$4&"2 4&"24&"2#!"'&46$ KjKKjKjKKje2.e<^P,bKjKKjKjKKjKjKKj##LlLKjKKjKjKKjK~-M<M(PM<rjKKjKjKKjKujKKjKL           <    6?32$6&#"'#"&'5&6&>7>7&54$ LhW.{+9E=cQdFK1A
0)pJ2`[Q?l&C58.H(Y'        : d    6?32$64&$ #"'#"&'&4>7>7.546'&'&'# '32$7>54'Yj`a#",5NK
~EVZ|$2$
|:
$2$|ZV:(t}hfR88T
hX(	&%(Hw(%&	(XZT\MKG{x   | !  #"'.7#"'&7>3!2%632u
jH{(e9
1b      U  #!"&546;5!32#!"&546;5!32#!"&546;5463!5#"&5463!2+!232 8((88(` `(88((88(` `(88((88(`L4 `(88(@(88(` 4L`(8 (88(@(88((88(@(88((88(@(84L8(@(88((8L48      O Y  "&546226562#"'.#"#"'.'."#"'.'.#"#"&5476 $32&"5462&4&NdN!>!1X:Dx++ww++xD:X1- U! *,*&4&hh&&2NN2D&
..J<
$$
<JJ<
$$
<J..
Pbb&&          7  !!"&5!54&#!"3!26!	#!"&=!"&5463!2 `(8 @ + 8(@(8(88(@(8(8( @@m+U`(88(8(@(88(h`         ( \  "&54&#"&46324."367>767#"&'"&547&547&547.'&54>2l42cKEooED
)

)
Dg-;</-?.P^P.?-/<;-gYY.2 L4H|O--O|HeO,,Oeq1Ls26%%4.2,44,2.4%%62sL1qcqAAq      4  #!#"'&547632!2#"&=!"&=463!54632 		@	`		`?`
@		@	!		
          5  4&+4&+"#"276#!" 5467&54 32632 	`		_
v,;G_j)``			_7,>jL>       5  4'&";;265326#!" 5467&54 32632 			
v,;G_j)	`		`7,>jL>        X `  $"&462#!"&54>72654&'547 7"2654'54622654'54&'46.'  &6 &4&&4&yy%:hD:FppG9Fj 8P8 LhL 8P8 E;
Dh:%>4&&4&}yyD~s[4Dd=PppP=d>hh>@jY*(88(*Y4LL4Y*(88(*YDw"
A4*[s~>       M   4&"27 $=.54632>32#"' 65#"&4632632 65.5462 &4&&4G9&
<#5KK5!!5KK5#<
&9Gpp&4&&4&@>bu &$KjKnjjKjK$& jjb>Ppp        %  !5!#"&5463!!35463!2+32  @\\ 8(@(8 \@@\ \@\  (88(\   @    3  4#"&54"3#!"&5!"&5>547&5462;U gI@L4@@4L2RX='8P8'=XR U;Ig04LjjL4*\(88(\    @    "   4&+32!#!"& +#!"&5463!2pP@@P j j@@\@\&0pj	 \\&       - B  +"&5.5462265462265462+"&5#"&5463!2G9L44L9G&4&&4&&4&&4&&4& L44L &=d4LL4d=&&`&&&&`&&&&4LL4  &         # 3 C S  #!"&5463!2!&'&!"&5!463!2#!"&52#!"&=4632#!"&=463(8((88((`x
c`(8  @@@`((88(@(8(D9 8( `@@@ @@        / ? O _ o         -=  %+"&=46;25+"&=46;2+"&=46;2%+"&=46;2+"&=46;2%+"&=46;2%+"&=46;2%+"&=46;2+"&=46;2%+"&=46;2%+"&=46;2%+"&=46;2+"&=46;2%+"&=46;2%+"&=46;2+"&=46;2%+"&=46;2+"&=46;2!!!5463!2#!"&5463!2@@@@ @@ @@ @@ @@ @@ @@ @@ @@ @@ @@ @@ @@ @@ @@ @@ @@ @ & && &@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@  `&&&&        / ? O _ o        %+"&=46;25+"&=46;2+"&=46;2%+"&=46;2+"&=46;2%+"&=46;2%+"&=46;2+"&=46;2%+"&=46;2+"&=46;2!!#!"&=!!5463!24&+"#54&+";26=3;26%#!"&5463!463!2!2@@@@ @@ @@ @@ @@ @@ @@ @@ @@  8(@(8 @@@@@ & &&@8((8@&@@@@@@@@@@@@@@@@@@@@ (88( @````- && & (88(&  @    < c  $4&"2!# 4&"254&+54&+"#";;26=326+"&5!"&5#"&46346?>;463!2KjKKj KjKKj &&&@&&KjKKjK 
jKKjK .&jjjj&4&@@&&      # ' 1 ? I  54&+54&+"#";;26=326!5!#"&5463!!35463!2+32    \\8(@(8 \  \ \@\  (88(\          :  #32+53##'53535'575#5#5733#5;2+3@E&&`@@`    `@@`&&E%@`@ @ @		      		@ 0
    @      !3!57#"&5'7!7! K5@   @ 5K@@@      # 3  %4&+"!4&+";265!;26#!"&5463!2 && &&&& && w@www&&@&&&&@&&@www        # 3  54&#!4&+"!"3!;265!26#!"&5463!2 &&&&&@&&@& w@www@&@&&&&&&@&:@www    - M3  )  $"'&4762	"'&4762	s
2

.



2

w
2

.



2

w
2





2

ww

2





2

ww     M3  )   "/&47	&4?62"/&47	&4?62S
.

2

w

2


.

2

w

2

M
.

2



2

.

.

2



2

.   M 3S  )  $"'	"/&4762"'	"/&47623
2

ww

2





2

ww

2




2

w

2



.v
2

w

2



.    M 3s  )   "'&4?62	62"'&4?62	623
.

.

2



2

.

.

2



2
.



2

w

2v
.



2

w

2   - Ms3    	"'&4762s
w

2

.



2
ww

2





2     MS3    "/&47	&4?62S
.

2

w

2

M
.

2



2

.    M3S    "'	"/&47623
2

ww

2



m
2

w

2



.    M-3s    "'&4?62	623
.

.

2



2-
.



2

w

2        /  4&#!"3!26#!#!"&54>5!"&5463!2 @^B  & &  B^^B@B^ @MB^%Q=&&<P&^B@B^^            + 3  "&5463!2#3!2654&#!"3#!"&=324+"3B^^B@B^^B@`^BB^p ^BB^^B@B^`@S`(88(``             '  $4&"2%4&#!"3!26#!"&5463!2&4&&4@^BB^^B@B^f4&&4&@B^^B@B^^            /  $4&"2%4&#!"3!264+";%#!"&5463!2/B//B   0L4 4LL4 4L_B//B/@M    4LL4 4LL            >& $$ (r^aa(^aa        ! C  #!"&54>;2+";2#!"&54>;2+";2 pPPpQh@&&@j8(PppPPpQh@&&@j8(Pp@PppPhQ&&j (8pPPppPhQ&&j (8p         ! C  +"&=46;26=4&+"&5463!2+"&=46;26=4&+"&5463!2 Qh@&&@j8(PppPPpQh@&&@j8(PppPPp@hQ&&j (8pPPppP@hQ&&j (8pPPpp     @@  	   # + 3 ; G  $#"&5462 "&462 "&462#"&462 "&462 "&462 "&462#"&54632K54LKj=KjKKjKjKKjL45KKjK<^^^KjKKjppp\]]\jKL45KjKKjKujKKjK4LKjKK^^^jKKjKpppr]]\            $$  ^aaQ^aa      ,  #"&5465654.+"'&47623  #>bqb&4  4&5"		#D7euU6 & 4 & m       1 X   ".4>2".4>24&#""'&#";2>#".'&547&5472632>3=T==T==T==T=v)GG+v@bRRb@=&\Nj!>3lkik3hPTDDTPTDDTPTDDTPTDD|xxXK--K|Mp<#	)>dA{RXtfOT# RNftWQ          ,  %4&#!"&=4&#!"3!26#!"&5463!2!2 8(@(88((88((8\@\\@\\(88(@(88(@(88@\\\\       u  ' E  4#!"3!2676%!54&#!"&=4&#!">#!"&5463!2!2325([5@(\& 8((88((8 ,9.+C\\@\ \6Z]#+#,k(88(@(88(;5E>:5E\\\ \1.           $ 4 @  "&'&676267> "&462"&462 .  > $$ n%%/02
KjKKjKKjKKjKfff^aayy/PccP/jKKjKKjKKjKffff@^aa        $ 4 @  &'."'.7>2 "&462"&462 .  > $$ n20/%7KjKKjKKjKKjKfff^aa3/PccP/y	jKKjKKjKKjKffff@^aa         + 7   #!"&463!2 "&462"&462 .  > $$ &&&&KjKKjKKjKKjKfff^aa4&&4&jKKjKKjKKjKffff@^aa       # + 3 C  54&+54&+"#";;26=3264&"2 4&"2$ #"'##"  3!2@@KjKKjKKjKKjK,gjKKjKKjKKjKX,,          # / ; G S _ k w       +"=4;27+"=4;2'+"=4;2#!"=43!2%+"=4;2'+"=4;2+"=4;2'+"=4;2+"=4;2+"=4;2+"=4;2+"=4;2+"=4;54;2!#!"&5463!2```` ````````````` `` `` p` K55KK55Kp````````````````````````` 5KK55KK     @   * V  #"'.#"63232+"&5.5462#"/.#"#"'&547>32327676R?d^7ac77,9xm#@#KjK#
XF@Fp:f_ #WIpp&3z	h[ 17q%q#::#5KKu't#!X:	%#+=&>7p   @    * 2 F r  56565'5&'.	#"32325#"'+"&5.5462#"/.#"#"'&547>32327676@82.,#,fk*1x-!#@#KjK#
XF@Fp:f_ #WIpp&3z	e`vo8t-	:5	[*#::#5KKu't#!X:	%#+=&>7p    3  $  	"/&47	&4?62#!"&=463!2I.

2

w

2


-@).

2



2

.
-@@     -S  $ 9  %"'&4762		/.7>	"/&47	&4?62i2

.



2

w
E>u>.

2

w

2


2





2

ww
!h.

2



2

.
       ;  #"'&476#"'&7'.'#"'&476'  )'s"+5+@'  )'F* 4 *Er4M:}}8GO* 4 *     ~ 
 (  -/'	#"'%#"&7&67%632B;><V??V --C4
<B=cB5!%%!b 7I))9I7        	#"'.5!".67632y(
#
  ##@,(
)        8  !	!++"&=!"&5#"&=46;546;2!76232-SSS

		 SS``		

          K  $4&"24&"24&"27"&5467.546267>5.5462 8P88P88P88P8P88P4,CS,4pp4,,4pp4,6d7AL*',4ppP88P8P88P8HP88P8`4Y&+(>EY4PppP4Y4Y4PppP4Y%*<O4Y4Ppp        % @ \ h t   	"'&4762"&5462&#!"&463!2#"'&'7?654'7&#"&'&54?632#!"&463!2"&5462"'&4762 		 

	@USxySR#PT('#TUSxySN@ 		 

		 		

 		
3@xSSUO#'(V^'(PVvxSSUi @ 		

 		
   `     <  +"&=46;2+"&=467>54&#"#"/.7!2<'G,')7N;2]=A+#H0PRH6^;<T%-S#:/*@Z}

>h         .  %#!"&=46;#"&=463!232#!"&=463!2& &&@@&&&@&& && &&&&&&&&f&&&&   b      #!"&=463!2#!"&'&63!2 & && &' '%@% &&&& && &&    k % J  %#/&'#!53#5!36?!#!'&54>54&#"'6763235
}4NZN4;)3.i%Sin1KXL7*		#&		*@jC?.>!&1'\%Awc8^;:+<!P        % I  %#/&'#!53#5!36?!#!'&54>54&#"'6763235
}4NZN4;)3.i%PlnEcdJ*		#&		*-@jC?.>!&1'\%AwcBiC:D'P           %!	#!"&'&6763!2P &: &?&: &?5"K ,)""K ,)      h  #".#""#"&54>54&#"#"'./"'"5327654.54632326732>32YO)I-D%n "h.=T#)#lQTv%.%P_	%	%_P%.%vUPl#)#T=@/#,-91P+R[Ql#)#|''
59%D-I)OY[R+P19-,# #,-91P+R[YO)I-D%95%_P%.%v      ' 3   !2#!"&463!5& =462   =462 &546  &&&& &4&r&4& @&4&&4&G&&&&f    s   C K  &=462	#"'32 =462 !2#!"&463!5&'"/&4762%4632e*&4&i76`al&4& &&&& }n

R



R
zfOego&&5`3&&&4&&4&D

R



R
z v        "  !676"'.5463!2@@w^Cct~55~tcC&&@?J V|RIIR|V &&           # G  !!%4&+";26%4&+";26%#!"&546;546;2!546;232@@ @@L44LL4^B@B^^B@B^4L   N 4LL4 4L`B^^B``B^^B`L      L   4&"2%#"'%.5!#!"&54675#"#"'.7>7&5462!467%632 &4&&4@ o& &}c ;pG=(8Ai8^^.&4&&4&`	`fs&& jo/;J!#2
 KAE*,B^^B!`	   $   -   4&"2#"/&7#"/&767%676$!28P88PQr	@U	@
{`PTP88P8P`
	@U	@rQ           !6'&+!!!!28e;<*@8 !GGGQII            %764'	64/&"2  $$ f3f4:4^aaf4334f:4:^aa         %64'&"	2  $$ :4f3f4F^aa4f44f^aa         764'&"27	2  $$ f:4:f4334^aaf4:4f3^aa            %64/&"	&"2  $$ -f44f4^aa4f3f4:w^aa   @    7!!/#35%!'!%j/djg2|855dc b    @   !	!%!!7!FG)DH:&HdS)         U   4&"2#"/ $'#"'&5463!2#"&=46;5.546232+>7'&763!2&4&&4f]wq4qw]	`dC&&:FF:&&Cd`4&&4&	]]	`d[}&&"uFjjFu"&&y}[d       #  2#!"&546;4   +"&54&" (88(@(88( r&@& 8((88(@(8@&&jj           ' 3   "&462 &         .  > $$  >aX,fff^aaa>TX,,~ffff@^aa          /  +"&=46;2+"&=46;2+"&=46;28((88((8 8((88((8 8((88((8 (88((88((88((88((88((88           /  +"&=46;2+"&=46;2+"&=46;28((88((88((88((88((88((8 (88((88(88((88(88((88        5 E  $4&"2%& '&;26%&.$'&;276#!"&5463!2 KjKKjf	
\
w@wwwjKKjK"Gf


	@www             $64'&327/a^  !  ^aaJ@%%	  65   /  	64'&"2	"/64&"'&476227 <ij6j6u%k%~8p8}%%%k%}8p8~%<<ij4j4t%%~8p8~%k%%%}8p8}%k          54&#!"3!26#!"&5463!2 &&&& w@www@&&&&:@www        /  #!"&=463!24&#!"3!26#!"&5463!2@^BB^^B@B^www@w@@2@B^^BB^^ww@w        +#!"'&?63!#"'&762(@	@(@>@%%%         !232"'&76;!"/&76 ($>(		 J &%       $  %64/&"'&"2#!"&5463!2ff4-4ff4fw@wwwf4f-f4@www         /  #5#5'&76	764/&"%#!"&5463!248`# \P\w@www4`8#@  `\P\`@www        )  4&#!"273276#!"&5463!2 & *f4' w@www`&')4f*@www     % 5  	64'&"3276'7>332#!"&5463!2`'(wa8!
,j.(&w@www`4`*'?_`ze<	bw4/*@www           - .  6  $$     (r^aaO (_^aa       -  "'&763!24&#!"3!26#!"&5463!2yB((@ w@www]#@## @@www       -  #!"'&7624&#!"3!26#!"&5463!2y((@B@u@ w@www###@@@www       -   '&54764&#!"3!26#!"&5463!2@@####@ w@wwwB((@@www      `  %#" '#"&=46;&7#"&=46;6 32/.#"!2#!!2#!32>?6#!"'?_BCbCaf\	+~2	

	}0$q90r pr%Dpu       ?  #!"&=46;#"&=46;54632'.#"!2#!!546;2Da__	g	
*`-Uh1}
	$^L    4   b  +"&=.'&?676032654.'.5467546;2'.#"B{PDg	q%%Q{%P46'-N/B).9kC<Q7>W*_x*%K./58`7E%_	,-3
cVO2")#,)9;J)"!*
#VD,'#/&>AX      >  ++"' '&=46;267!"&=463!&+"&=463!2+32$
		pU9@/*fo	VRfqf=S     E  !#"&5!"&=463!5!"&=46;&76;2>76;232#!!2#![ 

%
)
	"JgUhBW&WXhUg        8   4&#!!2 #!!2#!+"&=#"&=46;5#"&=46;463!2j@jog|@~vvu            n  #467!!3'##467!++"'#+"&'#"&=46;'#"&=46;&76;2!6;2!6;232+32QKt# #FNQo!"!mY

Zga~bm]

[o"U+, @h
h@@Xhh@   8  3 H \  #5"'#"&+73273&#&+5275363534."#22>4.#2>ut3NtRP*Ho2
Lo@!R(Ozh=,G<X2O:&D1A.1G$<2I+A;"B,;&$LGlF/ 3D;a$8$".!3!
.          3!#!"&5463! 8( 8((88(  h (8(88(@(8         ( 8 H  !!#!"&5463!54&#!"3!2654&#!"3!2654&#!"3!26(D 8((88( 8@@@$(88(@(8(8 @@@@@@   " }  
 $ B R  3/&5##"'&76;46;232!56?5"#+#5!76;5!53'#3!533H

Dq		x7	K//KFh/"		@`Z		sYwjjjjj     " }  
 $ 4 R  %3/&5##"'&76;46;232!53'#3!533!56?5"#+#5!76;5H

K//KFq		x7	h/"		@`jjjjjZ		sY
w  "     ) 9 I Y  %#"'&76;46;232#!"&=463!2#!"&=463!2#!"&=463!2#!"&=463!2

 @@  `		@`     "     ) 9 I Y  #!"&=463!2%#"'&76;46;232#!"&=463!2#!"&=463!2#!"&=463!2   

@@ r		@`r    "   
 $ C V  %4&#"326#"'&76;46;232%#"'&'73267##"&54632!5346=#'73BX;4>ID2F

8PuE>.'%&TeQ,jm{+>R{?jJrL6V		@`7>wmR1quWei/rr:Vr     "   
 $ 7 V  4&#"326#"'&76;46;232!5346=#'73#"'&'73267##"&54632BX;4>ID2F

+>R{8PuE>.'%&TeQ,jm{?jJrL6		@`rr:Vr3>wmR1quWei    @   \  %4&#"326#!"&5463!2+".'&'.5467>767>7>7632!2 &%%&&&& &7.'	:@$LBWM{#&$h1D!		.I/!	Nr&&%%&&&&V?, L=8=9%pEL+%%r@W!<%*',<2(<&L,"r       @    \  #"&546324&#!"3!26%#!#"'.'.'&'.'.546767>; &%%&&&& &i7qN	!/I.		!D1h$&#{MWBL$@:	'.&&%%&&&&=XNr%(M&<(2<,'*%<!W@r%%+LEp%9=8=L       	   + = \ d       %54#"327354"%###5#5#"'&53327#"'#3632#"'&=4762#3274645"=424'.'&!  7>76#'#3%54'&#"32763##"'&5#327#!"&5463!2BBPJNC'%!	B?)#!CC $)54f"@@
B+,A

A+&+A
ZK35N #J!1331CCC $)w@www2"33FYF~(-%"o4*)$(*	(&;;&&9LA38334S,;;,WT+<<+T;(\g7x:&&::&&<r%-@www       	   + = [ c }     #"'632#542%35!33!3##"'&5#327%54'&#"5#353276%5##"=354'&#"32767654"2 '.'&547>76 3#&'&'3#"'&=47632%#5#"'&53327''RZZ:kid YYY.06	62+YY-06	R[!.'CD''EH$VVX::YX;:Yfyd/%jG&DC&&CD&O[52.[$C-D..D^^* ly1%=^I86i077S3
$EWgO%33%OO%35	EEFWt;PP;pt;PP;pqJgTFQ%33&PP%33%R7>%3!+}   {  '  +"&72'&76;2+"'66;2U
&
	(P

*'eJ."-dZ-n -         ' 7  4'&+";27&+";276'56#!"&5463!2~}		7e 	w@www"$Q#'!#@www       
   I  -22#!&$/.'.'.'=&7>?>369II ! '	$ !01$$%A'	$ ! g	
\7@)(7Y
	
 \7@)(7Y
   @       	'5557	,VWQV.RW=?l%l`~0            !#!#%777	5!	R!!XCCfff# `,{{{`          O g   4&"2  &6 $"&462$"&62>7>7>&46.'.'.  '.'&7>76   HR6L66LGHyU2LL2UyHHyU2LL2UyHn
X6X

XX
H6L66L6L2UyHHyU2LL2UyHHyU2Ln6X

XX

           2#!"&5463 4&"2$4&"2ww@ww||||||w@www|||||||       	   !3	37!  $$  n6^55^h
^aaM1^aa    P 
  * C g  '.676.7>.'$7>&'.'&'? 7%&'.'.'>767$/u5'&$I7ob?K\[zH,1+.@\7<?5\V,$Vg.GR@ 7U,+!	#	"8$}{)<?L RR;kr,yE[z#	/1
"#	#eCI0/"5#`	"84~&p)4	2{H-.%W.L>       ' : Y i  4&67&'&676'.'>7646&' '7>6'&'&7>7#!"&5463!2PR$++'TJXj7-FC',,&C."!$28h/"	+p^&+3$i0(w@www+.i6=Bn\C1XR:#"'jj8Q.cAj57!?"0D$4"P[&2@www     D   "  %.5#5>7>;!!76PYhpN!HrD0M C0N#>8\xx: W]oW-X45       /  %'#.5!5!#"37>#!"&5463!2p>,;$4
 5eD+WcEw@wwwK()F
,VhV^9tjA0/@www  @     #"'&76;46;23

	 &

         ++"&5#"&7632	^

c &

     @    #!'&5476!2  &

^

b	        '&=!"&=463!546
 &

	
     q  & 8  #"'&#"#"5476323276326767q'T1[VA=QQ3qqHih"-bfGw^44O#A?66%CKJA}}  !"""A$@C3^q|z=KK?6lk)           %!%!VVuuu^-m5w}n      ~    7 M [   264&"264&"2"&546+"&=##"&5'#"&5!467'&766276#"&54632    *<;V<<O@-K<V<<+*<J.@kclGH__H<+*<<*+<    <*R+<<+*<f.@+<<++<<+@.7uu7**R+<<++;; 	      "%3I  #5472&6&67><&4'>&4.'.'.'.'.'&6&'.'.6767645.'#.'6&'&7676"&'&627>76'&7>'&'&'&'&766'.7>7676>76&6763>6&'&232.'.6'4."7674.'&#>7626'.'&#"'.'.'&676.67>7>5'&7>.'&'&'&7>7>767&'&67636'.'&67>7>.'.67	\

	U7	
J#!W!'	"';%
k	)"	
	'

/7* 		I	,6
*&"!O6*O $.(	*.'
.x,	$CN	
		*	
6		
7%&&_f&
",VL,G$3@@$+
"


V5 3"	""#dA++
y0D-%&n4P'A5j$9E#"c7Y
6"	&
8Z(;=I50' !!eR

"+0n?t(-z.'<>R$A"24B@(	~	9B9,	*$				<>	?0D9f?Ae 	.(;1.D	4H&.Ct iY% *	
7J	 <W0%$	
""I!*D	 ,4A'4J"	.0f6D4pZ{+*D_wqi;W1G("%%T7F}AG!1#% JG3        ' . 2 > V b  %&#'32&'!>?>'&' &>"6&#">&'>26 $$  *b6~#= XP2{&%gx| .W)oOLOsEzG<	CK}E	$MFD<5+
z^aa$MWM1>]|YY^DA<KmE6<"@9I5*^aa       > ^  4./.543232654.#"#".#"32>#"'#"$&547&54632632':XM1h*+D($,/9p`DoC&JV<Z PA3Q1*223IoBkhMIoPhMIoP2S6,M!"@-7Y.?oI=[<%$('3 -- <-\%FuPoIMhPoIMh    ,  # ? D  76&#!"7>;267676&#!"&=463!267
#!"'&5463!26%8#!&&Z"M>2!	^I7LRx_@>MN""`=&&*%I},
		L7_jj9          /  %4&#!"3!264&#!"3!26#!"&5463!2  &&&&  &&&&         1 9  #"'#++"&5#"&5475##"&54763!2 "&462 8(3-	&B..B&	-3(8 IggI `(8+Ue&.BB.&+8(kk`      % -  "&5#"&5#"&5#"&5463!2 "&462 8P8@B\B@B\B@8P8pPPp@`(88(`p.BB.0.BB.(88(Ppp      !  %>&'&#"'.$ $$ ^/(V=$<;$=V).X^aaJ`"(("`J^aa    ,   I   4."2>%'%"/'&5%&'&?'&767%476762%6[[[o
 
		$$	"	$$		[[[[5`

^^

2``2

^^

`     1  %#"$54732$%#"$&546$76327668hf&^zs,!V[vn)	6<f{z}))Ns3(  @   +   4&#!"3!2#!"&5463!2#!"&5463!2@& && f&&&&@& && &4&&4& @&&&& && &&    ` B H   +"/##"./#"'.?&5#"&46;'&462!76232!46 `&C6@Bb03eI;:&&&4L4&F
Z4&w4) ''5r&4&&4&&4    }G   #&/.#./.'&4?63%27>'./&'&7676>767>?>%6})(."2*& @P9A
#sGq]
#lh<*46+(	
<5R5"*>%</
 '2@ 53*9*,Z&VE/#E+)AC
(	2k<X1$:hI(B"	!:4Y&>"/	+[>hy
	   K 
  ! / U i   %6&'&676&'&6'.7>%.$76$% $.5476$6?62'.76&&'&676%.76&'..676#"NDQt	-okQ//jo_		%&JYJA-.--
9\DtT+X?*<UW3'	26$>>W0{"F!"E ^f`$"_]\<`F`FDh>CwlsJ@;=?s:i_^{8+?`)O`s2RDE58/K       r 	    #"'>7&4$&5m"#$5$"^^W=acE*c      z  k  ./ "&4636$7.'>67.'>65.67>&/>z X^hc^O<q+f$H^XbVS!rr?5GD_RV@-FbV=3!G84&3Im<$/6X_D'=NUTL;2KPwtPt= 

&,J~S/#NL,8JsF);??1zIEJpqDIPZXSF6\?5:NR=;.&1          +!"&=!!%!5463!2sQ9Qs***sQNQsBUwwUBF H CCTww      % 1   #"&=!"&=463!54632.  6  $$ 		`?(r^aa		
(_^aa         % 1  #!#"'&47632!2.  6  $$ 		@	`(r^aa
?		@	(_^aa        /  #"'&476324&#!"3!26#!"&5463!2 &@& @ w@www&@B@&@@www          "&462  >& $$  *(r^aa (^aa       ]  6  #"$547 32>%#"'!"&'&7>32'!!!2f:z~u: ((%`V6B^hD%i(]	*>6r#!3?^BEa#9       # 3  6'&632#"'&'&63232#!"&5463!2
Q,&U#+' ;il4L92<D`w@www`96]`C477&@www       D  +"&5#"'&=4?5#"'&=4?546;2%6%66 546;2
	
	wwwwcB
G]B
Gty]ty      # 3 C  #!+"&5!"&=463!46;2!24&#!"3!26#!"&5463!2@`@`^BB^^B@B^www@w@`@`2@B^^BB^^ww@w        ' / ? P  +5#"&547.467&546;532!764'!"+32#323!&ln@:MM:@nY*Yz--zY*55QDDU9pY-`]]`.X /2I$	t@@/!!/@@3,$,3$p$00&*0&&!P@     R V  2#"&/#"&/#"&546?#"&546?'&54632%'&54632763276%>S]8T;/M77T</L7=Q7,i<R7,5T</L666U;/M5<U<,i6iQ=a!;;V6-j;V6-5	P=/L596Q</L5<U6-i;V7,7O;-I68i;k         ) I  2#!"&5463#9"'.'.'3!264&#!"2>7%>ww@ww!"5bBBb//*
8(@(87)(8=%/'#?w@www#~$EE y &L(88e):8(%O r		

		O           ? G Q a q  47&67>&&'&67>&"&#6$32#"#"'654   $&6  $6&$ CoL.*KPx.* 
iSi
7J?~pi{_;lLUZ=_t'<Z :!
	@!
j`Q7$ky, Rfk*4LlL=Z=           &$&546$7%7&'5>]5%w  &P?zrSF!|         & 0  	##!"&5#5!3!3!3!32!546;2!5463)
)     ;));;)) &&        &@@&&&    	   6   $&727 "'%+"'&7&54767%&4762>4Pt+8?::
		
::AW``EvEEvE<."e$IE&O&EI&{h.`  m  "  &#"& '327>73271[>+)@(]:2,C?*%Zx/658:@#N
C=E(oE=W'c:     #  !#"$&6$3 &#"32>7! yy,{W^F!LC=y:yw0H\R%          " N ^   '&76232762$"&5462"&46274&"&'264&#"'&&#"32$54'>$ $&6$ G>>0yx14J55J5J44J5Fd$?4J55%6E#42F%$fLlLq>>11J44%&4Z%44J54R1F$Z-%45J521Z%F1#: 9LlL          # Q a  "'&7622762%"&5462"&546274&#"&'73264&#"'&&#"32654'>#!"&5463!255**.>.-@-R.>.-@-<+*q6- -- 0<o,+< 3w@www55**.. -- .. --G*<N' ,-@-+*M <*2zz1@www      0 <  754&""&=#326546325##"&='26  $$ bZtt&sRQsZ<tsQ^aa>OpoOxzRrqP6z~{{Prr^aa    ]  0  54&"#"&5!2654632!#"&57265&<T<H<T<H<T<8v*<<*
+;;+l:=:*;;*         %!!"!!26#!"&5463!2@ ]]@w@www] @@www         	     % )  3!!#335!!5!5!%#!!5!5!%#HH{RHH{GG{)qGRRqRRq     	  # 0 @   #"'632 #"'632 &#"7532&#"#7532#!"&5463!2L5+*5L5+*5~}7W|3B}}JC7=}w@wwwDZQ[1N:_)i$)@www   
 )	             6.#&#"'&547>'&#".'&'#"&5467%&4>7>3263232654.547'654'63277.'.*#">7?67>?>32#"'7'>3'>3235?KcgA+![<E0y$,<'.cI
	,# '!;7$=ep	//7/
D+R>,7*
2(-#=
	/~[(D?G  |,)"#+)O8,+'6	y{=@0mI#938OAE`
-
)y_/FwaH8j7=7?%a	%%!?)L
J9=5]~pj
 %(1$",I $@((
+!.S		-L__$'-9L	5V+	
	6T+6.8-$0+t|S1       6 ]   &#"'&#"67>76'&'&#"67>32764.#"#.32>67>7 $&54>7>7>7rJ@"kb2)W+,5/1		#

Z
-!$IOXp7sLCF9vz NAG#/ 5|';RKR/J#=$,9,+$UCS7'2"1
 !/
,
/--ST(::(ep4AM@=I>".)xlsY|qK@
%(YQ&NEHv~        < Z x  '#"&5467&6?2?'&"/.7.546326#"&'&/7264/7'764&"'?>>32.AUpIUxYE.A%%%h%%hJ%D,FZxULsTgxUJrVD%hJ%@/LefL.C%Jh%CVsNUx@.FZyUHpVA%h&%%%Ji%CWpIUybJ/Uy^G,D%Jh%@UsMtUC%hJ%C-Kfy        E X [ _ g j    &/&'.''67>7>7&'&'&'>76763>7>#&'&'767672'%'7'+"&'&546323267>7%#"'4'6767672,32,+DCCQLDf'
%:/d
B	4@}&!0$?Jfdf-.=6(:!TO?
!IG_U%
.k*.=;	5gN_X	"
##
292Q41*6nA;|BSN.	%1$6	$nk^        ' 7 G W g w       2+"&5463#!"&5463!254&+";2654&+";2654&+";2654&+";2654&+";2654&+";2654&+";2654&+";2654&+";26#"&=! B^^BB^^B:FjB^8((`(   `(8^BB^^B@B^"vE j^B (8(`( 8(         / ? O _ o         /?  2#!"&5463;26=4&+";26=4&+";26=4&+";26=4&+"54&+";2654&+";2654&+";2654&+";2654&+";2654&#!"3!2654&+";2654&+";2654&+";2654&+";2654&+";2654&+";2654&+";2654&+";2654&+";26@&& &&@@@@@@@@@@@@@@@@@@ @@@@@@@@@ @@@@@@@@@@ &&&&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    @`  '  	"&5#"&5&4762!762$"&462B\B@B\BOpP.BB..BB.8$PO      3 C Q  #".54>32#".546322#"&#"#"54>%".54>32%2#"&54>&X=L|<&X=M{<TMLFTMLFv"?B+D?BJpH=X&<{M=X&<|dMTFLMTF(<kNsI<kNsPvoJPwo/s.=ZYVvNk<JsNk<IshwPJovPJo  @     +"&7.54>2r_-$$-_rUU%&&5%            '-"'.546762@FF$@B@$.&,&.]]|q #<<# (B  B               B  %'-%'-'%'-"'%&'"'%.5467%467%62@ll@ll,@GG&!@@@@@@!&+#+#6#+$*`:p:px
p=`$>>$&@&@

@&p@       	  & . A  !!"!&2673!"54 32!%!254#!5!2654#!%!2#!8Zp?vdens6(N[RWu?rt1SrF|iZ@7oy2IMC~[R yK{T:         % , A G K  2#!"&5463!!2654'654.#532#532"&5!654&#"327#2#>!!ww@ww~uk'JTMwa|
DH>I1qFj?w@wwwsq*4p9O*Z^qh LE
"(nz8B
M         ' ?   "&462 4&#"'.'324&#"3267 ##"&/6326 32 .hhMALR vGh~~KyO^*LM@!<I~~t\0          C M   4&"2 #"&'676&/632#!"&=3267%2654&#"&#"%463!2"&4632rqqtR8^4.<x3=RRw@w_h
Y	K>wwde)qrOPqs:03=<x!m@wwE\xg%wwd  V   - < K \  %.'.>7'.?67'67%'>&%'7%7./6D\$>	"N,?a0#O1G9'/P(1#00($=!F"9|]"RE<6'o9%8J$\:\HiTe<?}V#oj?d,6%N#"
HlSVY]C=    @     C   4&"2!.#!" 4&"2+"&=!"&=#"&546;>3!232^^^Y	 	^^^`pp pp`]ib bi]~^^^e^^^ PppPPppP]^^]       3 ; E M  2+"&=!"&=#"&546;>;5463!232 264&"!.#!" 264&" ]`pp pp`]ibbi^^^dY	 	!^^^]@PppP@@PppP@]^^] ^^^e^^^      3  $#!#!"&5467!"&47#"&47#"&4762++&2
$$
2&&&4&&Z4&&##&&4&4&44&m4&m      + D P  4'&#"32763232674'&!"32763 3264'&$#"32763232> $$ g* o`#0#z#l(~)-g+^aaF s"	+g(*3#!|#/IK/%*%D=)[^aa        	!!!'!!77! ,/,-a/G      	 t  % / ; < H T b c q         %7.#"32%74'&"32765"/7627#"5'7432#"/7632#"5'7432#"&5'74632	#"/6327#"/6327#"/46329"&/462"&/>21"&/567632#!.547632 632
		*
			X		

^`		

^b	c
	fuU`59u


4J
	l~		~	F	
	2		m|O, 	
ru|	u
"           ) 9    $7 $&=  $7 $&=  $7 $&=   $&=46w`ww`ww`wb` VTEvEEvETVTEvEEvET*VTEvEEvET*EvEEvEEvEEv         # ^ c t    #!"&5463!2!&'&!"&5!632#"&'#"/&'&7>766767.76;267674767&5&5&'67.'&'&#3274(8((88((`x
c`(8 !3;:A0?Y
	^U	47D$	74U3I|L38wtL0`((88(@(8(D9 8( Q1&(!;
(g-	Up~R2(/{E(Xz*Z%(i6CmVo8            # T  #!"&5463!2!&'&!"&5!3367653335!3#4.5.'##'&'35(8((88((`x
c`(8 iFFZcrcZ`((88(@(8(D9 8( kk"	kkJ	 	!	k          # S  #!"&5463!2!&'&!"&5!%!5#7>;#!5#35!3#&'&/35!3(8((88((`x
c`(8 -Kg
kL#DCJgjLD`((88(@(8(D9 8( jj	jjkkkk            # 8 C  #!"&5463!2!&'&!"&5!%!5#5327>54&'&#!3#32(8((88((`x
c`(8  G]L*COJ?0R\wx48>`((88(@(8(D9 8( jjRQxk!RY            # * 2  #!"&5463!2!&'&!"&5!!57"&462(8((88((`x
c`(8  Pppp`((88(@(8(D9 8( ppp  	          # * 7 J R  5#5#5#5##!"&5463!2!&'&!"&5##5!"&54765332264&"  <(8((88((`x
c`(8 kcO"jKKjK`((88(@(8(D9 8( SmmS?M&4&&4            # 9 L ^  #!"&5463!2!&'&!"&5!#"/#"&=46;76276'.'2764'.(8((88((`x
c`(8 6ddWW6&44`((88(@(8(D9 8( .	G5{{5]]$5995           # 3 C  #!"&5463!2!&'&!"&5!2#!"&5463#"'5632(8((88((`x
c`(8 4LL44LL4l			`((88(@(8(D9 8( L44LL44L	
Z
	           # 7 K [  #!"&5463!2!&'&!"&5!>&'&7!/.?'&6?6.7>'(8((88((`x
c`(8 `3333v?`((88(@(8(D9 8( &&-&&?
  '  6  #'.
'!67&54632".'654&#"32eaA/PRAids`WXyzOv:C;A:25@>-05rn`H(' gQWZc[          
     -  %7'	%'-'%	%"'&54762[3[MN3",""3,3"ong$]gn$+)")")"         x # W  #"&#!+.5467&546326$32327.'#"&5463232654&#"632#".#"oGn\u_MK'|g?CM7MM5,QAAIQqAy{b]BL4PJ9+OABIRo?z.z
n6'+s:zcIAC65D*DRRD*wyal@B39E*DRRD*             ' / 7     $&6$ 6277&47'  7'"' 6& 6'lLRRZB|RR>dZZ LlLZRRZ&>|R     !   $&54$7  >54 '5PffP@s-ff`-      c  6721>?>././76&/7>?>?>./&31#"$&(@8!IH2hM>'
)-*h'N'!'Og,R"/!YQG<I *1)
(-O1D+0nz3fwG2'3rd1!sF0o .q"!%GsH8@-!5|w|pgS="B2PJfhGdR 	        ( P ] l y    &$'77&7567'676'"'7&'&'7&47'6767'627''6$ '67'654'7&'7'&'&'7&'5 &$  $6 $&6$ jj:,AAS9bb9R#:j8AA,zC9Z04\40Z9C!B;X0,l,0X;B*A8A&#9j`b9S$#R99#&A8A`<Z<LlLfB"129,V<4!!88dpm"BV,92[P*V*P\MC

CM\P*V*P]LD

DL&BV*8*8!f!4<gmpd88!&!8*8*VB Z<LlL        9 E i s   %#"5432#"543275#&#"3254&'.547>54'63&547#5#"=3235#47##6323#324&"26%#!"&5463!2F]kbf$JMM$&N92<Vv;,&)q(DL+`N11MZ
%G&54	#	i<$8&@0H12F1dw@wwwB?@UTZ3%}rV2hD5%f-C#C@,nO	a7.0x2	yRuR/u%6;&$76%$56S@www     D     < H l w  %4#"324&#"32!".5475&5475.546322#654'3%#".535"&#"5354'33"&+32 #"&54632S;<;||w$+|('-GVVG-EznAC?H_`Rb]Gg>Z2&`9UW=N9:PO;:dhe\=R
+)&')-S99kJ<)UmQ/-Ya^"![Y'(<`X;_L6#)|tWW:;X          	#'#3#!"&5463!2)
p*xew@www0,\8@www  9    I   #"'#"&'&>767&5462#"'.7>32>4."&'&54>32JrO<3>5-&FD(=Gq@C$39aLLL4
&)
@]vq#CO!~<ZK#*Pq.%LLLarh({w\     i  &5467&6747632#".'&##".'&'.'#".5467>72765'./"#"&'&5}1R<2"7MW'$	;IS7@5sQ@@)R#DvTA;
0xI)!:>+<B76:NFcP:SC4rl+r E%.*a-(6%('>)C	6.      >  
  ! - I [   4&#"324&#"3264&#"324&#"326&#"#".'7$4$32'#"$&6$32D2)+BB+)3(--(31)+BB+)4'--'4'#!0>R	HM9ou7D
R23('3_,--,R23('3_,--,NJ
?uWm%        #"'%#"'.5	%&'&7632! ;	`u%"( !]#c)(	            #"'%#"'.5%&'&76	! 	(%##fP_"( !)'+       4 I   #"$'&6?6332>4.#"#!"&54766$32#!"&=46;46;2 zm
IwhQQhbF*@&('k@z
	
_hQQGB'(&*eoz@@`             >.  $$ ffff^aa fff^aa  >   "&#"#"&54>7654'&#!"#"&#"#"&54>765'46.'."&54632326323!27654'.5463232632,-,,",:!%]&%@2(/.+*)6!	<.$..**"+8##Q3,,++#-:#"</$)

w


,*

x9-.2"'
,,
@&,,
Qw
,     ,  #"+"&5#+"&5&'&'&547676)2%2$l$#l#b~B@XXyo2$CI@5$$>$$/:yuxv)%$ 	          / ? C G  %!5%2#!"&5463!5#5!52#!"&54632#!"&5463#5!5`&& &&  && &&&& &&@& && &  & && & & && &      %  2 &547%#"&632%&546 #"'6\~~\h
~\h\ V
VVV       % 5  $4&#"'64'73264&"&#"3272#!"&5463!2 }XT==TX}}~>SX}}XS>~}w@www~:xx:~}}Xx9}}9xX}@www        / > L X d s   .327>76 $&6$32762#"/&4762"/&47626+"&46;2'"&=462#"'&4?62E0l,
*"T.D@Yooo@5D

[		

Z
Z

		[	 ``[



Z

	2
,l0
(T".D5@oooY@D,

Z

		[			[		

Z
``EZ

		[		
         5  %!  $&66='&'%77'727'%amlLmf?55>fFtuutFLlLHYCL||LY(E''E*(           / ? I Y i y      %+"&=46;2+"&=46;2+"&=46;2+"&=46;2%"&=!#+"&=46;2+"&=46;2+"&=46;2+"&=46;2!54!54>$ +"&=46;2#!"&=@&&@3P>P3&&rrr&&rrr
he
4LKM:%%:MKL4WT&&            % / 9  ##!"&563!!#!"&5"&5!2!5463!2!5463!2&& &  & &&   &&& i@ &&@& 7         '#5&?6262%%o;j|/&jJ%p&j;&i&p/|j%Jk%o%      	  : g  "&5462#"&546324&#!"263662>7'&75.''&'&&'&6463!276i~ZYYZ~@OS;+[G[3YUD#o?D&G3I=JyTkBuhNV!WOhuAiSy*'^CC^'*SwwSTvvTSwwSTvvWID\_"[gq# /3qFr2/ $rg%4
HffHJ4   d       #!#7!!7!#5!VFNrmNNNN!     Y  + ? N e  %&'&'&7>727>'#&'&'&>2'&'&676'&76$7&'&767>76'6#<;11x#*#G,T93%/#0vNZ;:8)M:(	&C.J}2	%0 	^*
JF	
&7'X"2LDM"	+6
M2+'BQfXV#+]
#'
L/(eB9   
             # , 8  !!!5!!5!5!5!5#26%!!26#!"&5!5          &4& &pPPp        @@&&@!&@PppP@  *  	  9 Q  $"&54627"."#"&547>2"'.#"#"&5476$ "'&$ #"&5476$ (}R}hLK
NN
 Ud:
xx
8

 ,, |2222
MXXM
ic,>>,

		

           ' / 7 ? K S c k {  4&"2$4&"2 4&"2 4&"2 4&"2 4&"2 4&"2 4&"24&"26 4&"24&#!"3!264&"2#!"&5463!2KjKKjKjKKjKjKKjKKjKKjKjKKjKjKKjKKjKKjKjKKjKLhLLhLKjKKj& && &KjKKjL44LL44L5jKKjKKjKKjKjKKjKjKKjKjKKjKjKKjKjKKjKjKKjK4LL44LLjKKjK && &&jKKjK  4LL4 4LL  	   ' E  !#"+"&7>76;7676767>'#'"#!"&7>3!2W",&7'	#$	&gpf5O.PqZZdS-V"0kqzTxD!!8p8%'i_F?;kR(`
!&)   '    
   (  2 !&6367 !	&63!2!
`B1LO(+#=) heCQg#s`f4#6q'X|0-g   	      > I Y  #6?>7&#!%'.'33#&#"#"/3674'.54636%#"3733#!"&5463!24:@7vH%hEP{0&<'VFJo1,1.F6A#L4 4LL4 4L"%	
 
7x'6O\JYFw~v^fH$ !"xdjD"!6`J 4LL4 4LL   	    + 3 @ G X c g q z     -<JX{  &#"327&76'32>54.#"35#3;5#'#3537+5;3'23764/"+353$4632#"$2#462#"6462""'"&5&5474761256321##%354&'"&#"5#35432354323=#&#"32?4/&54327&#"#"'326'#"=35#5##3327"327'#"'354&3"5#354327&327''"&46327&#"3=#&#"32?"5#354327&3=#&"32?"#3274?67654'&'4/"&#!"&5463!2_gQQh^_~\[[\]_^hQQge<F$$$ !!&&/!/!!00/e&'!"e$
		'!!''
	8''NgL4 4LL4 4LUQghQUk=<Sccc,-{kjUQhgQ9
,&W &$UK$$KK$$KDC(>("
!
=))=2( '! 'L#(>(&DC(>(zL#DzG)<) 4LL4 4LL    	  
    B W b j q }    +532%+5324&+32763#4&'.546327&#"#"'3265#"&546325&#"32!26 4&"2%#'#735#535#535#3'654&+353#!"&5463!29$<=$@?SdO__J-<AA@)7")9,<$.%0*,G3@%)1??.+&((JgfJ*A!&jjjGZYGwsswPiL>8aA	!M77MM77M3!4erJ]&3YM(,
,%7(#),(@=)M%A20C&Mee(X0&jjjV	8Z8J9N/4$8NN88NN      	       # & : O [   	$?b  3'7'#3#%54+32%4+324+323'%#5#'#'##337"&##'!!732%#3#3##!"&53733537!572!56373353#'#'#"5#&#!'#'#463!2#"5#"5!&+&+'!!7353273532!2732%#54&+#32#46.+#2#3#3##+53254&".546;#"67+53254&.546;#"#'#'##"54;"&;7335wY-AJF=c(TS)!*RQ+*RQ+Y,B^9^Ft`njUM')	~PS PRmM77Mo7q

@)U	8"E(1++NM77Mx378D62W74;9<-A"EA0:AF@1:Bf~~""12"4(w$#11#@}}!%+%5(v$:O\zK?*$\amcrVlOO176Nn<!E(=<&l/<<[ZZYY891767OO7==..//cV==::z,,,,aa,,7OO7Z::;;YfcW(		"6-!c(		!5	#
bt88176tV:
&$'*9	%e#:%'*9B<<;
&(        	    # : S n       #"&54632%#76;2#"&54632%4&+";2?>23266&+"&#"3267;2 4&+"'&+";27%4&+";2?>23266&+"&#"3267;254+";27#76;2#!"&5463!23%#2%%,, _3$$2%%M>ALVb5)LDHeE:<EMj,K'-RM ~M>ARVb5)LEHeE:<EJABI*'!($rL4 4LL4 4Lv%1 %3!x*k$2 %3!;5h
n
a
!(lI;F	
	
	rp
p8;5h
t
a
!(lI;F`	#k 4LL4 4LL   
  	  
  2 H W [ l t    #"'5632#6324&'.54327&#"#"&'32767#533275#"=5&#"'#36323#4'&#"'#753276 4&"24'&#"327'#"'&'36#!"&5463!2=!9n23BD$ &:BCRM.0AC'0RH`Q03'`.>,&I / * /

8/n-(G@5$ S3=,.B..B02^`o?7je;9G+L4 4LL4 4LyE%#	Vb;A!p &'F:Aq)%)#orgT$v2 8)2z948/{8AB..B/q?@r<7(g/ 4LL4 4LL        ?  #!"&'24#"&54"&/&6?&5>547&54626=L4@ ;U g3

T
2RX='8P8|5
4Ljj U;Ig@
	
`
 "*\(88(]k
          & N  4#"&54"3	.#"#!"&'7!&7&/&6?&5>547&54626;U gIm*]Z0L4@=o=CT

T
2RX='8P8|5
 U;IgXu?bl3@4Ljja`
	
`
 "*\(88(]k         / 7 [  %4&+";26%4&+";26%4&+";26!'&'!+#!"&5#"&=463!7>3!2!2 @@ @@ @@0

o`^BB^`5FN(@(NF5@@@u		@LSyuS@%44%     , < H  #" 54 32+"=4&#"326=46;2  >.  $$ ~Isy9"SgR8vHD	w
ffff^aam2N+	)H-mF+10*F		+fff^aa        b  4&#"32>"#"'&'#"&54632?>;23>5 !"3276#"$&6$3  k^?zb=ka`U4J{K_/4^W&	vx :XB0ff)
fzzXlz=lapzob35!2BX
G@8'	'=vN$\ff	1	SZz8zX          # (   "/+'547'&4?6276	'D^h



i%5 @%[i



h]@ ]h



i%@ 5%[i



h^@@       )  2 #"&5476 #".5327>OFi-ay~\~;'S{s:D8>)AJfh ]F?X{[TC6LlG]v2'"%B];$         - o     %!2>7>3232>7>322>7>32".'.#"#"&'.#"#"&'.#"#546;!!!!!32#"&54>52#"&54>52#"&54>52  -P&+#($P.-P$'#+&PZP&+#"+&P-($P-.P$(#+$P.-P$'#+&P-.P$+#pP@     @Pp H85K"&Z H85K"&Z H85K"&Z@Pp@@@pMSK5, :&LMSK5, :&LMSK5, :&        !!3	!	    @  @@           	#"$$3!!2 "jaxl alxaa j         !!3/"/'62'&63!2   'y

`I

y My

`I

y'       W `  #".'.#"32767!"&54>3232654.'&546#&'5&#"

4$%E;iNL291 ;XxR`fQ8TWiWgW:;*:`Qs&?RWXJ8oNU0J1F@#)
[%6_POQiX(o`_?5"$i\&>bds6aP*< -;iFn*-c1B       W g  4'.'4.54632#7&'.#"#"'.#"32767'#"&54632326#!"&5463!2#$(	1$6]'
!E3P|ad(2S;aF9'EOSej]m]<*rYshpt.#)$78L*khw@wwwB
%$/$G6
sP`X):F/fwH1pdlqnmPHuikw_:[9D'@www            3   4."2>$4.#!!2>#!".>3!2QQQQQh~wwhf ff QQQQQZZQffff           #  >3!2#!".2>4."f ff QQQQffffQQQ      	      , \  !"&?&#"326'3&'!&#"#"'     5467'+#"  327#"&463!!'#"&463!2632(#AHs9q  ci<=
#]<OFA!re&&U&& ![eF U?g4_a?b+r7&4&&4&p,           + K   4&"2$4&"2.#!"3!264&#!"3!2#"&=!"&=#47>$ KjKKjKKjKKjH#j#H&&&KjK KjKg	V	ijKKjKKjKKjK..n(([5KK55KK5[poNv<<vN:f      . R   #!"&463!24'!"&5463!&$#"!2#!32>+#" '#"&546;&546$32 322$B$22$$*$22$X$22$tX'hs2$kc$22$1c$2F33F3VVT2#$2VT2#$2g#2UU
2$#2UU12         , u   54#"67.632&#"32654'.#"32764.'&$#"7232&'##"&54732654&#"467&5463254632>32#"'&ru&9%"*# <yK0Og" &9B3;8s%+DWXRD= @Y%	!Q6R!4M8+6rU^z=)RN.)C>O%GR=O&^opC8pP*bY
_#$N Pb@6)?+0L15"4$.Es
5IQ"!@h"Y7e|J>ziPeneHbIlF>^]@n*9         6 [ _  3#"&54632#.#"32%3#"&54632#.#"326%4&'.'&! ! 7>7>!=39?
6'_>29?
5'17m-VU--,bW. @Fyu0HC$@Fyu0HC$L=??<=! A	<          `  ;  +"&54&#!+"&5463!2#!"&546;2!26546;2p0pp@I pp        > S c  +"&=46;254&+"&+";2=46;2;2=46;2;2%54&#!";2=;26#!"&5463!2A5DD5A7^6a7MB55B7?5B~```0`rr5A44A5v5AA5f*A``0`       	   !!!!	#!"&5463!27H7jv@vvv'  :@vvv          M U a h m r x                  #"'!"'!#"&547.547.54674&547&54632!62!632!#!627'!%!"67'#77!63!!7357/7'%#	%'3/&=&'	5#?&5476 !p4q"""6" 'h*[|*,@?wAUMpV@)w7({*U%K6=0(M		"!O		dX$k
!!!b	
[TDOi
@6bxBA5:J+3,px1Fi
(R         463!#!"&5%'4&#!"3`@..@A-XfB$.BB..C     } 
   )   &54$32 &'  % &&'6 7"w`Rd]G{o]>p6sc(@wgmJPAjyYWaAZq{HZ:<dv\gx>2ATKn       + ;  "'&#"&#"+6!263 2&#"&#">3267&#">326e~|||iyZ7r|ux9[[9jj9ANN+,#ll"BS32fk     [   / ? \  %4&+";26%4&+";26%4&+";26%4&+";26%#!"&5467&546326$32]]eeeeee$~i
qfN-*#Sjt2"'qCB8!   '  >    	      ! % ) - 1 5 9 = A E I M Q U Y ] a g k o s w {           !	%!	5!#5#5#5#5#57777????#5!#5!#5!#5!#5!#5!#5!#5#537#5!#5!#5!#5!#5!#55#535353535353%"&546326#"'#32>54.&54>3237.#" Q%%%%%%%%%?iiihOiixiiyiixiiArssrrssr%sssrrssNs%%%%%%%%%%'<D<'paC_78#7PO7)("I$	75! RAb(ssssssssss"/!".""."!."".!/^.".^.".]/".$$$$$$$$$$$$$$$$Os$$$$$$$$$$$$$$sO$sssssssssss#}$)	13?*
,./:
-      s    *   4&"2$4&"2#!"&5463!2!5463!2_?--??-,@@,-?pq8,??,D,??,,??      (    Z  2#".#"3267>32#".54 3232654&#"#"&54654&#"#"&547>326UzrhgrxSdU <exZf_g:k=2;^97\xx\7K=5XltWW{e_%N%,%CI%      # + W   4&+54&"#";26=32 "&462"&462!2#!"&54>7#"&463!2!2&&4&&&&4&KjKKjKjKKj && &%&& &&4&&&&4&&&5jKKjKKjKKjK %z
0&4&&3D7&4&%&          ' S   4&"4&"'&"27 "&462"&462!2#!"&54>7#"&463!2!2 &4&4&4& 4 KjKKjKjKKj && &%&& &&4&%&&&4  "jKKjKKjKKjK %z
0&4&&3D7&4&%&           	    &  	!'!	!%!!!!%"'.763!2o]FooZY@:@!! gf /  /      I    62'"/"/"/"/"/"/"/7762762762762762762%"/77627&6?35!5!!3762762'"/"/"/"/"/"/%5#5!4ZSS6SS4SS4SS4SS4SS4SS4ZSS4SS4SS4SS4SS4SS4S-4ZSS4S@   4SS4ZSS6SS4SS4SS4SS4SS4S@ ZSSSSSSSSSSSSSSZSSSSSSSSSSSSSyZRRR@%:=
:+:
=RRZSSSSSSSSSSSSS         C v  !/&'&#""'&#"	32>;232>7>76#!"&54>7'3&547&547>763226323@``` 
VFaaFV
$.

.$yy	.Q5ZE$ ,l<l, $ER?Y*@@2	!#""#!	yy=rna@@(89*>*%>>%*>*98(QO!       L \ p  '.'&67'#!##"  327&+"&46;2!3'#"&7>;276;2+6267!"'&7&#"(6&#"#"'DgOOG`n% ELL{@&&Nc, sU&&!Fre&&ss#/,<=
#]gLoGkP'r-n&4&2-ir&&?o 4_      5 O W  ! .54>762>7.'.7>+#!"&5#"&5463!2"&462{{BtxG,:`9(0bb0(9`:,GxtB&@& &@&K55K`?e==e?1O6#,
#$
,#6OO&&&&5KK      ?  !"'&'!2673267!'.."!&54632>32 1
4q#F""8'go#-#,"tYg>oP$$Po> 	Zep#)R0+I@$$@I+     + 3   32++"&=#"&=46;.7>76$     @* r@@r      ' /  2+"&5".4>32!"&=463      &@~[[[u~gr&`u[[[~~@r         = E   32++"&=#"&=46;5& 547&'&6;22676;2      >``@``?E,,=?rH@``@GH`jjr     B J  463!2+"&= 32++"&=#"&=46;5.76 76%#"&5        &@~``@`` vX r&@``@+BF`r       k s  463!2+"&= 32++"&=#"&=46;5& 547'/.?'+"&5463!2+7>6 %#"&5        &@~``@``~4e	
0
	io@& jV	
0
	Z9 r&@``@G5o
,
sp &@k^
,
c8~~`r       8 > K R _  32++"&=!+"&=#"&=46;.76 766 6'27&547&#"  &'2  #"@ @''sggsww@sgg@@-ssl99OOr99     F P ^ l  463!2+"&= $'.7>76%#"&=463!2+"&=%#"&54'>%&54 7.#" 2 54&'   &@L?CuP	vY  &@;"  55`&_gwBF@&J_	s&&?%x%x      J P \ h  463!2+"&= '32++"&=#"&=46;5.76 76632%#"&56'  327&7&#"2  #" &@L? u``@``}  ueeu9uee&_"|N@``@""|a~lo99r9@9       ; C  2+"&5"/".4>327'&4?627!"&=463      &@		.	
N~[[[uN		.	
gr&`
	.		Ou[[[~N
	.		@r       9 A   '.'&675#"&=46;5"/&4?62"/32+     '\
	.		4		.	
\r|@\		.	

	.		\@r     ~ 9 A  "/&4?!+"&=# #"$7>763546;2!'&4?62      m		-

@@&

-		@rm4

-		*		-

r           +"&5& 54>2      @[[rdGu[[r                 ".4>2 r[[[r5[[[[      $  2#!37#546375&#"#3!"&5463#22#y/Dz?s!#22#2##2S88	2#V#2        L  4>32#"&''&5467&5463232>54&#" #"'.Kg&RvgD
$*2%	+Z hP=DXZ@7^?13O+lh4`M@8'+c+RI2
\ZAhSQ>B>?S2Vhui/,R0+	ZRkm      z  + > Q   2#"'.'&756763232322>4."7 #"'&546n/9bLHG2E"D8_
pdddxO"2xx_lx2X	
!+'5>-pkW[CI
I@50OdddMhfxx^  	           # ' + /  7!5!!5! 4&"2!5! 4&"24&"2!!!     8P88P   8P88P88P88P     P88P8 P88P88P88P8          + N    &6 !2#!+"&5!"&=463!46;23!#!"&54>32267632#"_>@`` L4 Dgy 6Fe=OOU4L>``4L2y5eud_C(====`L4       3 V    &6 #"/#"/&54?'&54?6327632#!"&54>32 7632_>																%%Sy 6Fe=J%>																%65%Sy5eud_C(zz.!6%          $  !2!!!46;2 4&"2!54&#!" &   &&@V@& &@  &&@&             3!!!	!5!'!53!!	# 7IeeI7 CzC l @@  @            #  2#!"&?.54$3264&"!@ppp  ((ppp              # + /  2#!"&?.54$3264&"! 264&"!@^^^@^^^@ ((^^^  ^^^         v    (  #"'%.54632	"'% 	632U/@k0G,zD#[k#
/t g
FGz        	#'#3!)
p*xe 0,\8     T   # / D M %2<GQ^lw  &'&676676&'&7654&'&&546763"#"'3264&7.>&'%'.767&7667&766747665"'.'&767>3>7&'&'47.'.7676767&76767.'$73>?>67673>#6766666&'&6767.'"'276&67&54&&671&'6757>7& "2654&57>&>&'5#%67>76$7&74>=.''&'&'#'#''&'&'&'65.'&6767.'#%&''&'#2%676765&'&'&7&5&'6.7>&5R4&5S9W"-J0(/rV"-J0(.)#"6&4pOPppc|o}vQ[60XQW1V	#5X		N"&.
)
D>q J:102(z/=f*4!>S5b<U$:I o<G*	,&"O	X5
#!
	R N#C83J*R	!(D#%37	;$-.(,6ij
	")9
E%!B83
	j96/,	:QD')yX#63Vba	,
UeLPA@*	`Xx*&E
V36%	B3%	B3XA	#!.mU"A	#!.mUB-#2+Jiiim-C<I(m8qF/*)0S
		
I
E5&+>!%
(!$p8~5..:5I~T
4~9p# !
)& ?()5F	1		
 d%{v*: @e
s|D1d {:*dAA|oYk'&<tuut&vHCXXTR;w71Z*&'1	9?	.$Gv5k65P<?8q=4a	SC"1#</6B&!ML	^;6k5wF1<P    C	   ;  $"&462"&46232>.$.`aasa``Z9k'9a-*Gl|Me_]`F&OsDD!/+``aa``a1<YK3(
 /8HQelAZ3t_fQP<343J;T7Q           + ? K g w     $6&$  $&62+"5432+"&=.54  $;26=462;26=4& 4&#!"3!26)4R4mlLr {jK#@#Qa^@@`&&&&4R4LlLN @K5#:rr:#5K^aa``]]`` && &&       	     /  !3#4&#!"3!265##!"&5463!22 @ K5^BB^^B@B^5K    @5KB^^BB^^BK        	     /  !2##!"&5463!2#4&#!"3!265  5KK5^BB^^B@B^@   K55KB^^BB^^B` @      	     /  !2##!"&5463!2#4&#!"3!265  5KK5^BB^^B@B^@   K55KB^^BB^^B` @      	     /  !2##!"&5463!2#4&#!"3!265  5KK5^BB^^B@B^@   K55KB^^BB^^B` @      	    +  2##!"&5463!2#4&#!"3!2655KK5^BB^^B@B^@K55KB^^BB^^B` @    {    #!&'#"'&547632m*
0(('($0K
**      %   3#!3# '!#53 5#534!#53 6!3@@@@pp@@@@@pp@`     	          + / 7 ; A  #3!5!!3#!!5!35!355#%53#5!#35#!!!!!!!!                           
   	    # ' + / 3 ? C G W  #3!5!!35!!3#!!5!#!5!3535!355#%#3%!53#5!#35#!5##5!3!5!3!5	               !"&5463!2!"! `(88(@(8`(8}22R `8(@(88(`8HR22         #  #6?6%!!!46#!"&5463!2x  8(`( (88(@(8 
  (8 (`(8(@(88      	    ' A T d   +5326+5323##"' %5&465./&76%4&'5>54&'"&#!!26#!"&5463!2

iLCly5)*Hcelzzlec0hb,,beIVB9@RB9J_L4 4LL4 4L44%2"4:I;p!q4bb3p(P`t`P(6EC.7BI6 4LL4 4LL    	     . >  $4&'6 #".54$ 4.#!"3!2>#!"&5463!2Zjbjj[w]>o*-oXL4 4LL4 4L'))J)]wL`e 4LL4 4LL           ;  4&#!"3!26#!"&5463!2#54&#!";#"&5463!2@^BB^^B@B^B^^B@B^`@MB^^B@B^^>^B@B^^         5 = U m  	!	!!2#!"&=463!.'!"&=463!>2!2#264&"".54>762".54>762  ?(``(?b|b?B//B/]]FrdhLhdrF ]]FrdhLhdrF@@@(?@@?(@9GG9@/B//BaItB!!BtI!!ItB!!BtI!!        - M  32#!"&=46;7&#"&=463!2#>5!!4.'.46`@``MsF FsMMsF FsMojjo@@jj@@<!(!!(!        - 3 ?  32#!"&=46;7&#"&=463!2+!!64.'#`@`` 		DqLLqDojjo@@jj@@B>=C          - 3 ;  32#!"&=46;7&#"&=463!2+!!6.'#`@`` UVU96gg6ojjo@@jj@@**        - G  32#!"&=46;7&#"&=463!2#>5!!&'.46`@``MsF FsMkkojjo@@jj@@<!(!33!(!          9 I  2#!"&=4637>7.'!2#!"&=463@b":1P4Y,++,Y4P1:"":1P4Y,++,Y4P1:"b@@@7hVX@K-AA-K@XVh77hVX@K-AA-K@XVh7         A j  "#54&#"'54&#"3!26=476=4&#"#54&'&#"#54&'&'2632632#!"&5&=4632>326 5K @0.B @0.B#6'&&
l
@0.B 2'	.B A2TA9B;h" dmpPTlLc_4.HK5]0CB.S0CB./#'?&&)$$)0CB. }(AB.z3M2"61d39L/PpuT(Ifc_E       `  1 X   "#4&"'&#"3!267654&"#4&"#4&26326#!"&'&5463246326\B B\B&@5K&@"6LB\B B\B sciL}QP<m$3jN2cB.p.BB. 3K5+" 3," .BB..BB..G=ci(+lOh7/ DVj"c=        & 5 J b   #"'&=.547!"&46;'.54632!2327%.54&#"327%>%&#"!"3!754?27%>54&#!26=31?>Ijjq,J[j.-tjlV\$B.R1?@B.+?2`$v5K-%5KK5.olRIS+6K5$B\B 94E.&15uE&
PjjdXUGJ7!.B

P2 .B
%2@	7K5(B@KjKj?+f UE,5K~!1.>F.F,Q5*H          $ b  2#!"&=%!"&=463!7!"&'&=4634'&#!">3!!"3!32#!"3!23!26=n$<vpPPpPpw*RdApP]'@A&
3@&H-[(8@
2EB^&1=&& 81PppPpP wcOg Ppc4& #.& &,,:8(%^B &.&&       2 t  "&'&54'&5467>32>32>32#"#.#"#.#"3!27654&#"547654&#"#654&Myet|]WSSgSY\x{
70"1i92DU1&=		=&0@c	>&/Btd4!*"8K4+"@H@/'=	t? _K93-]
UlgQQgsW
]# +i>p&30&VZ&0B/%3B."to ){+C4I(/D0&p0D      3 [ _ c g  "'&#"3!2676=4&"#54&#"#54&#"#4&'2632632632#!"&'&5463246#!#!#5K)B4J&@#\8P8 @0.B J65K J6k
cJ/4qG^\hB2<m$3iG;     K5 6L4+" 3p`b)<8(=0CB.@Z7OK5`:7OkEW^tm@Q7/ DVi##j       % 4 I a   2#!"&5&546325462632"32654&"3267654&76;74&"#.#"2676=#"&'+53264&#!"3</UXdjjPEu!7JG72P

B%
B.!7	@Af+?jKjK@B(5K,EUH*5Q,F.F>.1!~K5y?^\Vljt-.j[J,qjjI7$?1R.B+.B$`2?gvEo.5KK5%-K6+SIR[&.E49 B\B$5K           G  #!+"&5!"&=463!2+"&'+"'+"'&5>;2>76;2YM	
.x	-
	N	

	u,u
?
LW

#	          	 * : J  4'&+326+"'#+"&5463!2  $6&  $&6$ <!T{BH4	&>UbUI-uu,uuLlLAX!Jmf\$
6uuu,KLlL        - [ k {  276/&'&#"&5463276?6'.#"!276/&'&#"&5463276?6'.#"  $6&   $&6]h-%Lb`J%E5,5R-h
-%Lb`J%E5,5R-'uu,uulL/hRdMLcNhRdMLcN1uuu,LlL   @     	'	7	'7	``H ``H !``H  ```H`            '  %		7'	7'7	'  $&6$ X`(W:,:X`(WLLlLX`(W:BX`(XLlL 
  	 $    % / 9 E S [   #"&54632$"&4624&"26$4&#"2%#"&462$#"&4632  #"32&! 24>      !#"&'.'#"$547.'!6$327&'77'&77N77N'qqqqqPOrqEsttsst}||}u[WQ~,>	nP/RU Pn	>,m'77'&77N77N6^Orqqqqqqt(~||on[us^~33pc8{y%cq33dqp  f   	  L     54    "2654"'&'"/&477&'.67>326?><
x
,(-'sIVCVHr'-(
$0@!BHp9[%&!@0$u

]\\]-$)!IHVDVHI!)$-#3      6 > N   "&462."&/.2?2?64/67>&  #!"&5463!2]]]3
$;
&|v;$
(CS31	=rM=	4TC(Gzw@www]]]($-;,540=	sL	=45,;@www       (  2#"$&546327654&#"	&#"AZ\@/#%E1/##.1E$![A@@\!#21E!6!E13"|!     	 g L   &5& '.#4&5! 67&'&'5676&'6452>3.'5 A5RV[t,G'Q4}-&<C!l n?D_@>r!G;>!g12sV&2:#;d=*'5E2/..FD71$1>2F!&12,@K       
  r    #"&5462>%.#"'&#"#"'>54#".'7654&&5473254&/>7326/632327?&$  $6 $&6$ !&"2&^	u_x^h;JHJqE
Dm!MG?'%o8
9U(F(LlL&!&!SEm|[n{[<
"p C
Di%(KHCpC
Bm8	@KHF(LlL         " *  6%&6$	7&$5%%6'$2"&4}x3nQH:dXe8 z'	li=!7So?v      M    '&7>>7'7>''>76.'6' El:Fgr*t6K3UZ83P)3^I%=9	)<}Jk+C-Wd	&U -TE+]Qr-<Q#0
C+M8	3':$_Q=+If5[&&SGZoMk c         # 7  &#"327#"'&$&546$;#"'654'632fKYYKfyL1hvvwwkn]*]nlxDLw~?T8bb9SA}       + 5 ? F  !3267!#"'#"4767% !2$324&#"6327.'!.#" c28-\? @hU0KeFjTlyE3aVsz.bW80]TSts<hO_u7bBtSbF/o|V]SHJ        3  4&#!"3!26#!!2#!"&=463!5!"&5463!2 @^B `` B^^B@B^ @@B^@@^BB^^       >  3!"&546)2+6'.'.67>76%&F8$.39_0DD40DD0+*M7{L *="#
U<-M93#D@U8vk_Y	[hD00DD00Dce-JF1BDN&)@/1 d      y  % F    #"'&'&'&'&763276?6#"/#"/&54?'&763276"&'&'&5#&763567632#"'&7632654'&#"32>54'&#"'.5463!2#!3>7632#"'&'&#"'&767632yqoq>*432fba
$B?
	>B
BBAA.-QPPR+	42
%<ci:6&hHGhkG@n`I5
!m(|.mzyPQ-.		je	q>@@?ppgVZE|fb6887a
%RB?
=B
ABBAJvniQP\\PRh!cDS`g23geFGPHXcCI_5"	
n*T.\PQip[*81
/9@:       > t   %6#".'.>%6%&7>'.#*.'&676./&'.54>754'&#"%4>327676=>vwd"
l"3	/!,+	j2.|%&(N&wh>8X}xc2"W<4<,Z~fdaA`FBIT;hmA<7QC1>[u])		u1V(k1S)
-	0B2*%M;W(0S[T]I)	A 5%R7<vlR12I]O"V/,b-8/_        # 3 C G k  2#!"&546;546;2!546;2%;2654&+";2654&+"!32++"&=#"&=46;546;2 4LL44LL4^B@B^^B@B^ @@ @@ @@ L4 4LL4 4L`B^^B``B^^B``    @@@          # 3 W  #!"&=463!2!!%4&+";26%4&+";26%#!"&546;546;2!546;232@ @@ @@L44LL4^B@B^^B@B^4L@@   N 4LL4 4L`B^^B``B^^B`L       # ' 7 G k  %"/"/&4?'&4?62762!!%4&+";26%4&+";26%#!"&546;546;2!546;232W.	

	.				.	

	.			 @@ @@L44LL4^B@B^^B@B^4L.				.	

	.				.	

   N 4LL4 4L`B^^B``B^^B`L         ( 8 \  	"'&4?6262!!%4&+";26%4&+";26%#!"&546;546;2!546;232 

		.	

	.	`@@ @@L44LL4^B@B^^B@B^4L< 		 
	.				.	:   N 4LL4 4L`B^^B``B^^B`L         2632632#!"&5463&&&&&& &&&&&&         #   27+"&5     %264&#"26546>&&T,X q&&1X,Lw     %    % ;  #!"&5463!546;2!2!+"&52#!"/&4?63!5!

(&&@&& ( &&@&&(

(  

& &@&&@ &&& &

        # '  '%#"'&54676%6%%
hh @` !  !  


         # 5  2#"&5476!2#"&5476!2#"'&546      @  @   
@ 
             8   4&"2$4&"2$4&"2 #"'&'&7>7.54$ KjKKjKjKKjKjKKjdne4"%!KjKKjKKjKKjKKjKKjK.8
!%00C'Z'             . W   "&462"&462"&462 6?32$6&#"'#"&'5&6&>7>7&54>$ KjKKjKjKKjKjKKjhW.{+9E=cQdFK1A
0)LlLjKKjKKjKKjKKjKKjKpJ2`[Q?l&C58.H(Yee   	    
   			        Y'w(O'    R@ $   #"&#"'>7676327676#"
b,XHUmM.U_t,7A3gez9@xSaQBLb(	VU         
  !!!  == w)          A U  !!77'7'#'#274.#"#32!5'.>537#"76=4>5'.465!  KkkK_5 5 #BH1`L
I&v6SF !Sr99rS!`` /7K%s}HXV
PV	e		V    d   / 9 Q [   $547.546326%>>32"&5%632264&#"64'&""&'&"2>&2654&#" ;2P3>tSU<)tqH+>XX|Wh,:UStW|XX>=X*
))
+^X^|WX=>X:_.2//a:Ru?
	Q%-W|XW>J(	=u>XX|WX`

*((*


+2		2X>=XW|    E  0  3>$32!>7'&'&7!6./EUnohiI\0<{ >ORD~VoR C37J6I`Tb<^M~M8O     	  	     5!#!"&!5!!52!5463	 ^B@B^  `B^ ^B `B^^"^BB^         0 ;  %'#".54>327&$#"32$	 !"$&6$3  ##320JUnLn~~&q@tKL}'` -
-oxnUyl}~~FLlLt`(88(           	7!'	!\W\d;tZ`_O;        }  54+";2%54+";2!4&"!4;234;2354;2354>3&546263232632#"&#"26354;2354;2354;2`` `` pp``` !,! -&M<FI(2```@PppPpppppp#  #
ppppp     	  j  #"'&=!;5463!2#!"&=#".'.#!#"&463232>7>;>32#"&'#"!546	%. `@` :,.',-XjjXh-,'.,: kb>PppP>bk .%Z &
:k%$> $``6&L')59I"TllT"I95)'L&69GppG9$ >$%k:            !   +32 &#!332  $&6$ ~O88OLlL>pNiLlL   	 ' ' : M a  4&'#"'.7654.#""'&#"3!267#!"&54676$32 #"'.76'&>$#"'.7654'&676mD5)
z{6lP,@KijjOo>>[ta)GG4?a )ll>;_-/
9GH{zyN@,KoNy!?hh>$D">?  $   	 n  "&5462'#".54>22654.'&'.54>32#"#*.5./"~~s!m{b6#	-SjR,l'(s-6^]Itg))[zxZ&+6,4$.X%%Dc*
&D~WL}]I0"
YYZvJ@N*CVTR3/A3$#/;'"/fR-,&2-"7Zr^Na94Rji3.I+

&6W6>N%&60;96@7F6I3        +  4&#!"3!26%4&#!"3!26  $$     ^aa`@@^aa       ' 7     $  >. %"&546;2#!"&546;2#/a^(^aa(N@@          4&#!"3!26  $$ @@^aa`@^aa       '     $  >. 7"&5463!2#/a^(n@^aa(N@           % =  %#!"'&7!>3!26=!26=!2%"&54&""&546 ##]VTV$ KjKKjK $&4&&4&>9G!5KK55KK5! && jj &&         # / ; I m  2+#!"&'#"&463>'.3%4&"26%4&"26%6.326#>;463!232#.+#!"&5#"5KK5sH. .Hs5KK5e# )4# %&4&&4&&4&&4&` #4) #%~]eZ&&Ze]E-&&-E KjKj.<<.KjK)#)`"@&&`&&&&`&&)#`)"dXo&&oXG,8&&8  !  O  ##!!2#!+"'&7#+"'&7!"'&?63!!"'&?63!6;236;2!2@@8@7

8Q
	NQ
	N
	8G@

8GQ
	NQ
	N7
	    88 HH     k      %  		 ".>2I20]@] @oo@@ooa22 ]] p^|11|99|11|     (       %7'7'	'	7T dltl)qnluul        ) 1  $4&"2 4&"2  &6 +"&5476;2 &6  LhLLhLLhLLhL> &  &`>hLLhLLhLLhL>&&>    G  
     	.7)1!62	1!62he220e22>	v+4	[d+d           1  35#5&'72!5!#"&'"'#"$547&54$ Eh`X(cYz:L:zYc\$_K`Pa}fiXXifa    	         ( + . >  #5#5!5!5!54&+'#"3!267!7!#!"&5463!2U``'  jjV>(>VV>>Vq     (^(>VV>>VV          =  &'&'&'&76'&'&.' #.h8"$Y
''>eX5,	,PtsK25MRLqS;:.K'5RChhRt(+e^TTu B"$:2~<2HpwTT V        / 7 G W g   . %&32?673327>/.'676$4&"2 $&6$    $6&  $&6$ d--m	
	,6*6,	
	mKjKKjoooKzz8zzLlLU4>>4-.YG0
)xx)
0GY.jKKjKqoooolzzz80LlL    D   / 7 H   #"'.7'654&#"'67'.6?>%"&46227#".547|D,=),9#7[fx!X: D$+s)hhijZt<F/*8C,qe\r,WBX/C2hhh=tXm        > N Z  +"&=46;2+"&=4>7>54&#"#"/.7632  >.  $$ p =+& 35,W48'3	l
zffff^aaP2P: D#;$#$*;?R
Cfff^aa   'Y  	 > O `   "&5462&'.'.76.5632.'#&'.'&6?65\\[<CzC25U#
.ZK m+[$/#>(	|	r[A@[[@A#2#7*<Y$+}"(q87] F 	_1)
	     	    # 1 K e   34&+326+"&=!#!"&763!2#!"&5463!2#>?4.'3#>?4.'3#>?4.'3Xe`64[l7
,	L;=+3&98&+)>>+3&98&+)>=+3&88&+)>	Wj|r>Q$~d$kaw+-wi[[\;/xgY$kaw+-wi[[\;/xgY$kaw+-wi[[\;/xgY     J \ m   4.'.'&#"#"'.'&47>7632327>7>54&'&#"327>"&47654'&462"'&476'&462"'&47>&'&462i$		$^"
%%
"^$		$W "@9O?1&&18?t@" W&%%&4KK6pp&46ZaaZ&4mttm^x	--	x^=/U7Ckkz'[$=&5%54'4&KK4r<r4&X4[ [4&mm             ' / 7 ? G O W _ g o w        "264$"264"264 "264$"264 "264$"264"264 "&462"&462 "&462"&462 "&462 "&462 "&462 "&462 "&462"&462 "&462"&462^^^^^^^^^^^^^^^^^^^^^^^^^^ ppppppppppppppppppppppppppppppppppppppppppppppp`^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^pppppppppppppppppppppppppppppppppppppppp  	         L T i {   "&4626"&462$"&462#"&4632654>7>54   "&54>2"&462%"&54&#""&546 %#"&'&'.7>#"'&'.7>&4&&4&4&&4S Z &4&&44$#&&&j3$"('$&4&[[&4&&4F&4&]\&4&$
	!D4%	,\44&&4&4&&4&- Z 4&&4& ;cX/)#&>B)&4&j9aU0'.4a7&&u[[4&&4&@&&]]&&0
u40
)4         # g   &'.#"32676%4/&#"326'&#"2632#2+&'%#"'&6?676676632%#"'&6767#"&'&6767#"'.7>327"#"&'&6763"'.7>;7632;>%5K$
"0%>s$
"0%>;;>%5KVL#>H30\($$(\(yO2F/{(?0(TK.5sg$y#-F/{$70(TK.5sg$L#>H30\($$(\#(@5"'K58!'"58!'"55"'K#dS$K		K$Sdx#@1wd>N;ET0((?
-
2K|1wd#N;ET0$(?
-
2K$#dS$K		K$Sdx          D N \  2654& 265462"2654   #"32654>7>54."/&47&'?62 &4&&4&h[&4&r$'("$3j&&&#$4["@GB["&&&&][u&&7a4.'0Ua9j&4&)B>&#)/Xc;u""Gi[       X h  #"&54676324&'&#"'>54#"32#"54>54'.#"32>7>767632326#!"&5463!2b)
:4FDN[1,^JK-*E#9gWRYvm0O	w@wwwC22c@X&!9{MA_"S4b// DR"XljPY<	@www     %   e  4.#"32>7676#'.#"#"&54>3232>754&*#"&54>763 >32''il$E/
@P@
^`'W6&!.. ! -P5+


E{n46vLeVz:,SN/
M5M[	]$[^5iC'2H&!(?]v`*	l	b$9>    = R   2#"&5467%!"&7>3-.7>;%.7>322326/.76/.'&6766/&/&#"&676	&676&6766/&672? =1(H/ 	'96&@)9<')29%
&06##$ J 07j)5@"*3%"!M
%#K"%Ne8)'8_(9.<c +8 8(%6 <)'4@@)#-<^
?%$-`%.}Q!&}%&N-lIJ;6>/=*%8!Q #P"\Q#N&a)<9     b R ] m p  %"'.'&54>76%&54763263  #"/7#"' #"&/%$% 322654&#"%'OV9
nt
|\d
[nt
|@D:)	;98'+|j," 41CH^nVz(~R	9\'	r
@L@	@w46HI(+C
,55,
f[op@\j;(zV~      i  / 5 O  #"'&54>32&#" 654'67'"'>54''&'"'6767&546767>7`V BMR B9)!SH-77IXmSMH*k#".o;^J q>@YM$bKd [E";Kx%^6;%T,U:im=Mk        ) . D T  4'"&5463267&#" 6;64'.'4'>732676%#!"&5463!2),s5-<A4
2W9
&P:\3)SEPJD4:3NIw@wwwNE	2@uus+,/?xsatmP')fHVEA(%dA4w&4J5*@www        O [  4'.'&54>54&#"#"'654'.#"#"&#"3263232>3232>76  $$ Cf'/'%($UL
(
#'/'@3#@,G)+H+@#3^aaX@_O#NW#O_.*	##(^aa   q [  632632#"&#"#".'&#"#".'&54767>7654.54632327&547>P9	B6?K?%O4T% >6>Z64Y=6>%S4N$?L?4B	@{:y/$ ,'R!F!8%#)(()#%:!F Q'+%0z:z       O _  4'.'&54>54&#"#"'654'.#"#"&#"3263232>3232>76#!"&5463!2 Cf'.'%($VM
)
#'.'@3#A,G)+H+A#4 w@wwwXA?4N$NW&M&L/*
##	+@www      	   O  $>?>762'&#"./454327 327>7>	 EpB5
3FAP/h\/NGSL	  RP*m95F84f&3Ga4B|wB .\FI*/.?&,5~K %&Y."7n<	"-I.M`{ARwJ!       F X ^ d j  ''''"'7&'7&'7&'7&547'67'67'67'63277774$#"32$			*',?g=OO&L&NJBg;1''.=gCIM$'&&NJBg=.%w\\wIoo<<   -NIDg=/%(+AhEHO*"#*OICh=/'(/=h>ON.]xw]7e[@        ) 6  !!"3#"&546%3567654'3!67!4&'7Sgny]K-#75LSl>9V%cPe}&Hn_H=UoLQ1!45647UC"    
        ! - 9 [ n x     "&46254&"326754&"326754&"26754&"26#".547632632626326'4#"#"54732764&"264.#"327632>#"'"'#"'#"&5#"'67&'327&'&54>3267>7>7>32632632T"8""8)<())(<))))<))<))<))<)T{Rhx=8 78 n 81pH_6SocF@b@?d?uKbM70[f5Y$35KUC<:[;+8 n 87 8/8Zlv]64qE 'YK0-AlB;
W#;WS9&(#-7Z://:/Tr++r,,r++r,,r++r,,r++r,,gxXVe9222222^KVvF02OO23OO`lF;mhj84DroB@r+@222222C0DP`.r8h9~T4.&o@91P       % 1  4'!3#"&46327&#"326%35#5##33  $$ }Pcc]<hlYmmnnnn^aaw!LY;edwnnnnnv^aa     %    '  #"$#"#.5462632327>32 1IU?LL?cc4MX& 04;0XpD[[DpD,)&&    Q	    9 V \   26&".'&'&6?.#"#26327677>'32>&3#'&+"?626&"#!'.'!"&5463!>;26;2!2P  P 	
92#.}SP9::%L\B )spN/9oJ5 
!+D`]BgY9+,9%
Pk4 P  P &NnF!_7*}B<{o0&&B;*<@$ucRRc#@16#37c&@@@J"@*4^`EDBo/8927
*@O LC!T!323X$BJ@@@ &AS
0C59"'D/&&D488$5A&         % O  #!"&547>7>2$7>/.".'&'&2> ^B@B^>FFzn_0P:P2\nzFF>R&p^1P:P1^&R
P2NMJMQ0Rr.B^^B	7:5]yPH!%%"FPy]5:7	=4QH!%%!Ht4=<"-/ ?          1 P p  +".'.'.?>;2>7$76&'&%.+"3!26#!"&5476 7>;2'
+~'*OJ%%JN,&x'%^M,EE,M7ZE[P*FF*P:5^B@B^){$.MK%%KM.$+X)o3"a  22!]4	I>"">,&S8JB##B12``B^^B8&ra#11#$R&              " & . 2 v  %/%''%/%7%7'%7'/#&5'&&?&'&?&'&7%27674?6J"0<=_gNU? DfuYGb7=^H^`	=v~yT3GDPO	4Fqi_w\!1uS%V_-d
1=U{J8n~r        ' U  4.#".'"3!264&"26+#!"&5463!232+32+320P373/./373P0T=@=T|`^B@B^^BB^`````*9deG-!

!-Ged9IaallkOB^^BB^^B       	 + Y i  "&54622#!"&54>;2>+32+32+#!"&5463!2324&#!"3!260.I/ OBBO	-Q52-)&)-2`````^B@B^^BB^` @|kkl"=IYL)CggC0[jM4				B^^BB^^B@@       ! 1 A Q u   4.#".'"3!24&"254&#!"3!2654&#!"3!2654&#!"3!26#!54&+"!54&+"!"&5463!2 )P90,***,09P)J6 6S"@8@ ^B@ @B^^BB^Ukc9		9ckU?@@88@@N@B^````^BB^^       ! 1 A Q u    #!"&4>32>72"&462#!"&=463!25#!"&=463!25#!"&=463!24&#!"3!546;2!546;2!26#!"&5463!2 J6 6J)P90,***,09P)"@8@@`@ @`^B@B^^BB^UUkc9		9c`@@88@@2@````@B^^BB^^            (  %.'"&' $&   #"$&6$ wCCwjJ~J>LlLJSSJ>6LlL         $ ,     $&6654&$ 3 72&&  lLmzzBl> KlLGzzG>           ' 7  #!"&54>7&54>2   62654' '3/U]B,,B]U/OQQ>+X}}X0bb0}hQQh>ff            # =   #!"&4>3272"&462!3!26#!"&5463!;26=!2 J6 6J)Q8PP8Q) ^B@B^^B``B^VVVld9KK9d`@B^^BB^``^        + ; K [ e u  4.#"'"3!264&"254&#!"3!2654&#!"3!26%54&+";2654&#!"3!26!54&#!"!#!"&5463!2"D/@@/D"?,,?pppp@@@ @^B@B^^BB^D6]W2@@2W]67MMppp@@@@@@@@n`@B^^BB^^       + ; K [ e u  #!"&54>3272"&462#!"&=463!2%#!"&=463!2+"&=46;25#!"&=463!2!3!26#!"&5463!2?,V,?"D/@@/D"pppp@@@ ^B@B^^BB^D7MM76]W2@@2W]ppp@@@@@@@@`@B^^BB^^      A  #"327.#"'63263#".'#"$&546$32326J9"65I).!1iCCu
+I\Gw\B!alyV/]:=B>9+<F+a[lePn[A&JR7t)+tHkFIK      e	    .    #"'&'>32%#!"&5463!2#"&54>54'&#"#"54654'.#"#"'.54>54'&'&543232654&432#"&54>764&'&'.54632 ?c'p& ?b1w{2V	?#&#9&CY'&.&#+B
: &65&*2w1GF1)2<)<'

(
BH=:NT :O	)4:i F~b`e!}U3i?fRUX|'&'&Ic&Q
	*2U.L6*/L:90%>..>%b>++z7ymlw45)0	33J@0!!TFL P]=GS-kwm	!*         (  %6&692?  $&6$ 	' al@lLlL,&EC
h$LlL          / 3 7 ;  %"&546734&'4&" 67   54746 #5#5#5ppF::FD<pp<D

PppP<dud<M- PppP -M9            / 3 7 ;  %"&546734&'4&" 67   54746 #5#5#5ppF::FD<pp<D

PppP<dud<M- PppP -M9            / 3 7 ;  %"&546734&'4&" 67   54746 #5#5#5ppF::FD<pp<D

PppP<dud<M- PppP -M9            / 3 7 ;  %"&5467534&'4&" 67   54746 #5#5#5ppF::FD<pp<D

PppP<dd<M- PppP -M9            	  + / 3 7  %"&54624&'4&" 67   54746 #5#5#5ppppD<pp<D

PppPOqqOM- PppP -M9         & . 6 > F N V ^ f n v ~      "/&4?.7&#"!4>3267622"&4"&46262"&42"&4462"$2"&42"&4"&46262"&4"&46262"&42"&4$2"&42"&42"&4



R

,H8Jfj QhjG^R,

!4&&4&Z4&&4&4&&4&4&&4& &4&&4 4&&4&4&&4&Z4&&4&4&&4&4&&4&4&&4&4&&4&&4&&4&Z4&&4&Z4&&4&



R

,[cGj  hQRJ'A,

&4&&4Z&4&&4Z&4&&4Z&4&&444&&4&&4&&4Z&4&&4Z&4&&4Z&4&&4&4&&4Z&4&&4Z&4&&4&&4&&4Z&4&&4Z&4&&4        % - 5 = E M }           +"&=#!"'+"&=&= "&4626"&462&"&462"&462&"&462&"&462#!"&=46;4632676/&?.7&#"!2 "&462&"&462&"&462"&462&"&462&"&462"&462&"&462"&462@?A A?@@R...R@`jlL.h)**$	%35K.....uvnu....@@jN **.t2#K5..R..R.        @ H q   '&'&54  &7676767654$'.766$76"&462&'&'&7>54.'.7>76|_yv/k]
:Buq
CA
_kXVobZZbnW |V	0 	Q2-
l}O		/	:1z	
q% zG
4(

6Roa\<

)4	J}        %!!#!"&5463!2    ^B@B^^BB^ `@B^^BB^^       %#!"&=463!2 ^B@B^^BB^B^^BB^^           &  ))!32#!#!"&5463!463!2      `B^ ^B^B@B^^B`^BB^   ^B @B^B^^BB^`B^^       # 3  %764/764/&"'&"2?2#!"&5463!2














s^B@B^^BB^














@B^^BB^^     # ' 7  "/"/&4?'&4?62762!!%#!"&5463!2














   ^B@B^^BB^














 `@B^^BB^^          	!  $&6$ .2r`LlLf4LlL         # . C    &>"'&4762"/&4?62'"'&4762%'.>6.'.>6'>/>76&'&.'&7&'">?4'.677>7.>37654'&'67>776 $&6$ (4Z##&##&y"6&.JM@& "(XE*$+8
jT<l$3-V<2'.
-1%#e"!Z
+*)H	 8(j	#*-Vv/kh?'MlM$($R#&"#'#vZ@+&MbV$

G7--)

R2T
313dJ6@8lr2_5m/."G:=	)%5f0gt*2)?;CB66&, 	`48]USyLlL         G  6?>?3#'.'&!3!2>?3.'#!57>7'./5!27#'.#!"g%%D-!gg<6WWZe#1=/2*]Y3-,C1/Dx] VFIq-HD2NK'>*%R=f07=.fD]\|yu       , 0 > S e u  #2#"'&5<>323#3#&'#334'."#"+236'&54.#"5#37326#!"&5463!2		<	zzjk-L+ )[$8=".un/2 ^B@B^^BB^5cy	

(I(8?C(3> #"($=@B^^BB^^     0K    S   &'.'&' ./674&$#">&>?>'76'#  "&#./.'7676767>76$w.~kuBR] T%z+",|j<)(!(	~zF8"{%%#5)}''xJF0"H[$%EJ#%.Gk29(B13"?@S)5" #9dmW";L65RA0@T.$}i`:f3A%%
BM<$q:)BD	aa%`]A&c|	Ms!
Z2}i[F&**
< sc"J<&NsF  %  0 @ W m  6&'.6$.7>7$76".4>2.,&>6 '"'&7>=GV:e#:$?+%
q4g
&3hT`ZtQQQpAP1LK!:<}`dlb,9'

%%($!a3)W)xQQQQcQ-e)Us2XD\Yd           / ? O _ o      #"=#"=4;543#"=#"=4;543#"=#"=4;543#"=#"=4;543#"=#"=4;543%#!"&5463!2++532325++532325++532325++532325++53232p00pp00pp00pp00pp008((88(@(8 0pp00pp00pp00pp00pp0          @(88((88          / Q    /&'%&/"&=.6?&?&'&6?'.>-#".6?'.>'&6'.>54627>%>76#"'%%6272Gf!)p&4&p)!fG272	*6	"472Gf!)p&4&p)!fG272"	6*	!k3j&3
%,*&&*9%
3&j3k!./!>>$,*!k3.j&3
%9*&&*,%
3&j3k!*,$>>!/.           &  6.'&$	&76$76$PutiPuGxy
[xy
-_veNuve	 =u[t78X       
    & 6  ##'7-'%'&$  $6 $&6$ 31NE0gR=|||">"LlL^v!1f2iwgfZQQ^>"||||wLlL  &Z X b l w          .'&>'&'&".'.'&&'&'&7>767>67>7626&'&>&'&> '.7>.676'&'&'&'.67.>7>6&'&676&'&676.676&'&>&'&676'.>6/4-LJg-$	6)j2%+QF)b3FSP21DK2AW")")$??8A&AE5lZm=gG2Sw*&>$5jD GHyX/4F r	1	1""!l=6>	6
,5./'e
.*|Ed!u&&%&	&5d	))66@C&8B@qL?P^7	G-hI[q:<rS	U~97A_IR`gp1	1	;"("j?>"T6
,6 
   &        / `                                      L       w       Q'             	 
              A  	   ^    	     	     	  "   	    	  $&  	  _  	    	  y  	 	   	  *  	  < C o p y r i g h t   D a v e   G a n d y   2 0 1 6 .   A l l   r i g h t s   r e s e r v e d .  Copyright Dave Gandy 2016. All rights reserved.  F o n t A w e s o m e  FontAwesome  R e g u l a r  Regular  F O N T L A B : O T F E X P O R T  FONTLAB:OTFEXPORT  F o n t A w e s o m e  FontAwesome  V e r s i o n   4 . 7 . 0   2 0 1 6  Version 4.7.0 2016  F o n t A w e s o m e  FontAwesome  P l e a s e   r e f e r   t o   t h e   C o p y r i g h t   s e c t i o n   f o r   t h e   f o n t   t r a d e m a r k   a t t r i b u t i o n   n o t i c e s .  Please refer to the Copyright section for the font trademark attribution notices.  F o r t   A w e s o m e  Fort Awesome  D a v e   G a n d y  Dave Gandy  h t t p : / / f o n t a w e s o m e . i o  http://fontawesome.io  h t t p : / / f o n t a w e s o m e . i o / l i c e n s e /  http://fontawesome.io/license/                                                	
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`ab   cdefghijklmnopqrstuvwxyz{|}~  "	
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRS TUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~ 	
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~ glassmusicsearchenvelopeheartstar
star_emptyuserfilmth_largethth_listokremovezoom_inzoom_outoffsignalcogtrashhomefile_alttimeroaddownload_altdownloaduploadinboxplay_circlerepeatrefreshlist_altlockflag
headphones
volume_offvolume_down	volume_upqrcodebarcodetagtagsbookbookmarkprintcamerafontbolditalictext_height
text_width
align_leftalign_centeralign_rightalign_justifylistindent_leftindent_rightfacetime_videopicturepencil
map_markeradjusttinteditsharecheckmovestep_backwardfast_backwardbackwardplaypausestopforwardfast_forwardstep_forwardejectchevron_leftchevron_right	plus_sign
minus_signremove_signok_signquestion_sign	info_sign
screenshotremove_circle	ok_circle
ban_circle
arrow_leftarrow_rightarrow_up
arrow_down	share_altresize_fullresize_smallexclamation_signgiftleaffireeye_open	eye_closewarning_signplanecalendarrandomcommentmagnet
chevron_upchevron_downretweetshopping_cartfolder_closefolder_openresize_verticalresize_horizontal	bar_charttwitter_signfacebook_signcamera_retrokeycogscommentsthumbs_up_altthumbs_down_alt	star_halfheart_emptysignoutlinkedin_signpushpinexternal_linksignintrophygithub_sign
upload_altlemonphonecheck_emptybookmark_empty
phone_signtwitterfacebookgithubunlockcredit_cardrsshddbullhornbellcertificate
hand_right	hand_lefthand_up	hand_downcircle_arrow_leftcircle_arrow_rightcircle_arrow_upcircle_arrow_downglobewrenchtasksfilter	briefcase
fullscreengrouplinkcloudbeakercutcopy
paper_clipsave
sign_blankreorderulolstrikethrough	underlinetablemagictruck	pinterestpinterest_signgoogle_plus_signgoogle_plusmoney
caret_downcaret_up
caret_leftcaret_rightcolumnssort	sort_downsort_upenvelope_altlinkedinundolegal	dashboardcomment_altcomments_altboltsitemapumbrellapaste
light_bulbexchangecloud_downloadcloud_uploaduser_mdstethoscopesuitcasebell_altcoffeefoodfile_text_altbuildinghospital	ambulancemedkitfighter_jetbeerh_signf0fedouble_angle_leftdouble_angle_rightdouble_angle_updouble_angle_down
angle_leftangle_rightangle_up
angle_downdesktoplaptoptabletmobile_phonecircle_blank
quote_leftquote_rightspinnercirclereply
github_altfolder_close_altfolder_open_alt
expand_altcollapse_altsmilefrownmehgamepadkeyboardflag_altflag_checkeredterminalcode	reply_allstar_half_emptylocation_arrowcrop	code_forkunlink_279exclamationsuperscript	subscript_283puzzle_piece
microphonemicrophone_offshieldcalendar_emptyfire_extinguisherrocketmaxcdnchevron_sign_leftchevron_sign_rightchevron_sign_upchevron_sign_downhtml5css3anchor
unlock_altbullseyeellipsis_horizontalellipsis_vertical_303	play_signticketminus_sign_altcheck_minuslevel_up
level_down
check_sign	edit_sign_312
share_signcompasscollapsecollapse_top_317eurgbpusdinrjpyrubkrwbtcfile	file_textsort_by_alphabet_329sort_by_attributessort_by_attributes_altsort_by_ordersort_by_order_alt_334_335youtube_signyoutubexing	xing_signyoutube_playdropboxstackexchange	instagramflickradnf171bitbucket_signtumblrtumblr_signlong_arrow_downlong_arrow_uplong_arrow_leftlong_arrow_rightwindowsandroidlinuxdribbleskype
foursquaretrellofemalemalegittipsun_366archivebugvkweiborenren_372stack_exchange_374arrow_circle_alt_left_376dot_circle_alt_378vimeo_square_380plus_square_o_382_383_384_385_386_387_388_389uniF1A0f1a1_392_393f1a4_395_396_397_398_399_400f1ab_402_403_404uniF1B1_406_407_408_409_410_411_412_413_414_415_416_417_418_419uniF1C0uniF1C1_422_423_424_425_426_427_428_429_430_431_432_433_434uniF1D0uniF1D1uniF1D2_438_439uniF1D5uniF1D6uniF1D7_443_444_445_446_447_448_449uniF1E0_451_452_453_454_455_456_457_458_459_460_461_462_463_464uniF1F0_466_467f1f3_469_470_471_472_473_474_475_476f1fc_478_479_480_481_482_483_484_485_486_487_488_489_490_491_492_493_494f210_496f212_498_499_500_501_502_503_504_505_506_507_508_509venus_511_512_513_514_515_516_517_518_519_520_521_522_523_524_525_526_527_528_529_530_531_532_533_534_535_536_537_538_539_540_541_542_543_544_545_546_547_548_549_550_551_552_553_554_555_556_557_558_559_560_561_562_563_564_565_566_567_568_569f260f261_572f263_574_575_576_577_578_579_580_581_582_583_584_585_586_587_588_589_590_591_592_593_594_595_596_597_598f27euniF280uniF281_602_603_604uniF285uniF286_607_608_609_610_611_612_613_614_615_616_617_618_619_620_621_622_623_624_625_626_627_628_629uniF2A0uniF2A1uniF2A2uniF2A3uniF2A4uniF2A5uniF2A6uniF2A7uniF2A8uniF2A9uniF2AAuniF2ABuniF2ACuniF2ADuniF2AEuniF2B0uniF2B1uniF2B2uniF2B3uniF2B4uniF2B5uniF2B6uniF2B7uniF2B8uniF2B9uniF2BAuniF2BBuniF2BCuniF2BDuniF2BEuniF2C0uniF2C1uniF2C2uniF2C3uniF2C4uniF2C5uniF2C6uniF2C7uniF2C8uniF2C9uniF2CAuniF2CBuniF2CCuniF2CDuniF2CEuniF2D0uniF2D1uniF2D2uniF2D3uniF2D4uniF2D5uniF2D6uniF2D7uniF2D8uniF2D9uniF2DAuniF2DBuniF2DCuniF2DDuniF2DEuniF2E0uniF2E1uniF2E2uniF2E3uniF2E4uniF2E5uniF2E6uniF2E7_698uniF2E9uniF2EAuniF2EBuniF2ECuniF2EDuniF2EE                                   =    O<0    1h       DSIG     D   FFTMNg  l   GDEF   L    OS/2&O     `cmap]    zcvt M^    <fpgms#  ,  gasp  	  4   glyf9T]    Dhead     6hheaxb  T   $hmtxO
F    localM    maxp|g  x    name8    
2post|    *prep  4  j      3_<      o-    o-9                                    y  j    / Z  -R     3  3  a f	 @ x        1ASC @  "~&g`    :E      D         6 B   +VP  tN r |    g     ` t t t ^ ,    q    q        f  f  O L  
   $ $ I s           u   c         E  ^ B    l  8  4 O    t G t82   w  k                  q           f f f f f  8     $                   }       t n     B  B   t  ]   PZn  [%                 t      X   "     ~ 1S    " : D ""     1R    " 9 D ""  o&                                     b c d e f g h i j k l m  n o p q r s t u v w x y z { | } ~                                                                                                	
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`a  pcdhvnj ti  q  fu     kz bm    l{      w  o  x     @EYXUTSRQPONMLKJIHGFEDCBA@?>=<;:9876510/.-,('&%$#"!
	 ,E#F` &`&#HH-,E#F#a &a&#HH-,E#F` a F`&#HH-,E#F#a ` &a a&#HH-,E#F`@a f`&#HH-,E#F#a@` &a@a&#HH-, < <-, E# D# ZQX# D#Y QX# MD#Y &QX# D#Y!!-,  EhD ` EFvhE`D-,
C#Ce
-, 
C#C-, (#p(>(#p(E: -, E%EadPQXED!!Y-,I#D-, E C`D-,CCe
-, i@a  , b`+d#da\XaY-,E+)#D)z-,Ee,#DE+#D-,KRXED!!Y-,KQXED!!Y-,%#  `#-,%#  a#-,% -,F#F`F# F`ab# #pE`  PXaFY`h:-, E%FRKQ[X%F ha%%?#!8!Y-, E%FPX%F ha%%?#!8!Y-, CC-,!!d#d@ b-,!QXd#d  b @/+Y`-,!QXd#dUb /+Y`-,d#d@ b`#!-,KSX%Id#Ei@ab aj#D#!# 9/Y-,KSX %Idi &%Id#ab aj#D&#D#D& 9# 9//Y-,E#E`#E`#E`#vhb -,H+-, E TX@D E@aD!!Y-,E0/E#Ea``iD-,KQX/#p#B!!Y-,KQX %EiSXD!!Y!!Y-,EC `c`iD-,/ED-,E# E`D-,E#E`D-,K#QX 34 3 4 YDD-,CX&EXdf`d `f X!@YaY#XeY)#D#)!!!!!Y-,CTXKS#KQZX8!!Y!!!!Y-,CX%Ed `f X!@Ya#XeY)#D%% XY%% F%#B<%%%% F%`#B< X Y%%)) EeD%%)%% XY%%CH%%%%`CH!Y!!!!!!!-,%  F%#B%%EH!!!!-,% %%CH!!!-,E# E  P X#e#Y#h @PX!@Y#XeY`D-,KS#KQZX E`D!!Y-,KTX E`D!!Y-,KS#KQZX8!!Y-, !KTX8!!Y-,CTXF+!!!!Y-,CTXG+!!!Y-,CTXH+!!!!Y-,CTXI+!!!Y-, #KSKQZX#8!!Y-, %I SX @8!Y-,F#F`#Fa#  Fab@@pE`h:-, #Id#SX<!Y-,KRX}zY-, KKTB-, B#Q@SZX   TXC`BY$QX   @TXC`B$TX C`B KKRXC`BY@  TXC`BY@  c TXC`BY@  c TXC`BY@  c TX@C`BYYYYY-,Eh#KQX# E d@PX|Yh`YD-, %%#> #>
#eB#B#? #?#eB#B-,zE#-   @d	P(F(F*F5k[kD
F&=F@FF@36FF > U@=U=U=UA	  T d F    =@c @P P3_o_oP&p 0p/?o& 0Pp@)F P?@+H/?/?A 2 U      p  @P`p&F&0@F@*F@1F@F@F/? o@ &S0/o  @ F 0O_o0/@F   0  F@PF&J<=<J 00@	FsP&oF5nF5U3U3U`P&_P&&F@F^ZH\F1[ZHZF12UU2U<5@(F
@%P&RPQQ@Q58F@Q%(FPLLFKFHP@ZJF&IF5HF5GF5FFFF2UU2U U ?_/Oo?o O TS++KRK	P[%S@QZ UZ[XY BK2SX`YKdSX@YKSX BYststu+++++stu++++s ++tt++s++++s+++++++ +++++++++++ ++stts+++++++s +sttt+usttt++ss+++s+++s++ sts+sst sttst+ss st+s+ststu +st t+sss++s_s+tt++++++t++^s+ ++++^s sssts+++ +s_^   }E  `E               :  w            W                                                                                                  ~                                                  |      _                           o x      ^ ` t    PL  	 {+                           k   k      > nE   `L     N [ ^  i o   ^ h             &J  {   u h          3      i q [ R                          p   M M d d  h EE   zEM  n L b F  D   , , , , T ~00$\Jv\"2	d	
j4L&>T,:x^~tZ0xX\hvZ N !\!"B""#^$N$%V%&&2&''>'(^)())*+,
,,---.N..//00T0\001L1112 2z2222233|333334
4"4:4T445 5505H5b56z666667R8
8"888R8p88999999::&:D:h;;0;H;^;t;;;<<<<=="===>h? ?H?@ @4@H@n@@A
AVAABB<B^C C"CdCDJD    D  dU   . /<2<2  /<2<23!%!!D $hUD     D   )@ 	 ?/9/9/]3210#353 M   '@	/     ?33/2/]]9/10#3#3()M     6  E    @H&&
	 /?0@P 
!	 

 OO_@"HO_
 /3?399//]q+]q33223322/]3/3/9///]qq33/]/999910]]+!!#!##53#5!3!33!!CXnVTnTCYnXkXnX@EjCAlhhl=lhhl=    Bs~ 9 D O@D=T=eNnGe<j/u**v))v""ey

y		yz,o--EK3'?$u   o EE E`EpEE E0EpEEEEEEQo@ H:o @ 2@s$Js3??$--'$%@ 'H%@H%%$Ks @P`@P ?33/]3/]q2?3/++33/9/322/]q3/]+3/]q]9/3332223/]10 ]]]]]]]]]]]]#5.'7&'&'&#.54>753.'4.'>~8rw"-MpM1bXL8@r]ff@
'?X;:rgXA$(E]6Gb<0Pj:AkM+|K_9%6[D)'7Ia?RwO(,PuL!0O9!V+:Ql66G/!5E^?Q4!)8R    Q   + ? S  >@	H8(	H4(	H.	H@	H(	H(	H@	HyV v    @:
H/?1J;1p@@@@U	"E,O6'  ????/9/]99//]+883]3]10 ++++++++3#3%2#".54>4.#"32>2#".54>4.#"32>:gM--Nh<<iN,-Nj#3!#6$$5" 3$:gM--Nh<<iN,-Nj#3!#6$$5" 3$IMc`P##O`cMBX55WB@W66WMc`P##O`cMBX55WB@W66W   +M = O _ @sNNyQQeXuXXiS9% 	H	H.@=	H%HI#I>0>0;;;1I0kPl(KS>-P4p>>>>>0@?H?000aVH@H`-p--eP)PP4-
0EKUKeKK0(S[CQ7[Q 
 ?32?9]/9]]]/+99//]+9/]99]]2/]]10 ]]+++]] ]] ]".'#".54>7.54>32>732674.#">.'32>0)LC:GVg;mf1-Nk>+WYEvV0DrN>DJ**?W1+a(08-@',I5&@qU1JYBU^ @aA'G<1#/2&:fPM~gQ DIL%>mQ.#Dd@GlVF!6d`].Wy+^63	I"8'.C*At+2:Gdt.e4\D'&    M  @     ?3/9/]10#3)M  VW{  (@    ??/]9/]3210#.54>73)X`\Y++Y\`X)vqqv  PWu  $@    ??/]329/10#>54.'3u*X\`X**X`\X*qvvq     @[k P`	_	o	@LH
@H
p


 

 u		p	H  ?3/+]39/]33]33339/]9]+M9/+39/+310_^]] ]%'7%73-ww-gIH HIk)    t W  I@%	@ 
0 	 ?32]+ M9/_^]32+M10#!5!3!X`TT    +  9@'	   H	H/ o     /]10+]+]!	j N~p  @     / /]/]9/105!N0    +  @      /9/]10!3+   rY  =@9iy6fv      ??/]82]]9/83]]103r5     |OZ  ' + y@R6 FVFVIYIY* *@*P* )*)*) n@P -o 


O(O(_(())#s#s ??9/]q/]9/]q99//]]q10 ]]]]]#".54>324.#"32>%53OMfgKKjeL(NqHLtO()OrIGrO+XGG
@@~45~88"       jE  Y@9 o?O_ps		s  ?2?33/9/]q33/]q3/2/]1035!#52>73!`}BJ|`a(G4"=T2L      <Z & @\u9 tvwwi
kY&&n?o (n `$p$$$$     s$s  ?2?3//]]3/]3/9/]q2/10 ]]]]]]]]]]35>54.#"'>32!,T'Ga;6]F,	@ojiu>V uaJ<W9<Y;Le:0]Y^F   KZ ; @cu99c9@9P9x44l4K4[4t//.v..w))l%Z%cdUyyy{61n? _    n@ @<H
=&n''n


 


6s,&&#s,s@@ ?3/]q?3/9/9/]]3/99//+]q3/q910 ]]]]]]]]]]]]]]]]]]#".'732654.+532>54&#"'>32K?ytt:	+JmIEgy3fb3n[;wP{Ywl3%IoJR}T+r[d6AkI8\B$~yDZ57Y?jwzo][-8`I7gV@	<Wj     g  eE 
  U@5iy			oo s/o ??39/]332/]9/]3322/]10]#!533	!r{??zCK    KE , @^iyiyJZEU"@H"" n%$!o  
@ .n


 


%s  so((($s!s ?3/?9/]3//]]]9/]q9/3222/+10 ]]]]#".'732>54.#"#!!>32K@~{orC(EeHFrQ,*NqH-LA5/!0civ@d{F4[zF(K;#+PuI<gL+%W%5@q    HZ $ 8 @}zzhxg#w##g"w""E7U7C1S1J-Z-K'[',<n n%@% %%%%%:/n

 




*so      4s4s ??3/]9/]]/]q29/]qq2/10 ]]]]]]]]]]#".54>32.#">324.#"32>H;so{z=EvH~gN{QJxT-1s`o<$HjF1dQ3(KjBAgH&d}F]_CnP[QE[_>rkCpP-!AbAHb9-Rt       -E  5@n o @H s ??2/+]9/9/10
#47!5!-`LPa;2$    FZ ) = Q @~u((vxxwy""xjFj@ePeJe<e6$4nn***
 n@> >>>>>SHn



 


$Cs99Mv/syMs ?]?]9/93/]]]9/]q99//9910 ]]]]]]]]]]]]]#".54>75.54>324.#"32>4.#"32>F9u}|w9/Oe6;]?!9pmso6!?]==hM+>dIFc?:fPVf7#DsVOoE  FrQSoDzTl==kSGsT4	>Td5D}`9:`~D4dT=
5Tq3/R<##<R/%RE-.ER-YG,,HZ/;eJ*)Kg     ?Z $ 8 @wzzg w  hxE7U7E1U1J-Z-K'['#3 n?%%%%%%%%:n

/n 4s@H*s"sp ?3/]?9/+3/]]]3/9/]q310 ]]]]]]]]]#".'732>7#".54>324.#"32>?FwQfHw[JxU1I]k8`l;?xo%IkFAhH'#FhE2gS5]!FpO[UD/J3DzehxBIc;-SsFBsW2"Ce   :   $@    	  /?9/]3210!33++  `:    3!	+j    t W  w R@  R@(     ?o@H /]3/+]39=/33/]3++++105	tZ;    tXW   L@7	 @H 0P`pPp /]]q/+q/]32105!5!tX    t W  wR@   R@(    ? o   @H  /+]2/]39=/33/]2++++1075	5tZon^     ^  1Z ' + m@IiyiyJZ%%f v  	+
((  -
@H

#)(f#v### ?3/]/9/+/9/]9/32]10 ]]]]#>54.#"'>32531%>ORO?''>NPM<%)MmDDoR2J~pl~DEhRB;;DS7CfQA;;DS57T9&Ge>Zl=0]    , _ x;@DD5?U?u?>>l4|44Hl|lf|fJfZf&]jSeIuII???@H~9o***O*_*Hj7z77iQKLLLLV 7)/
`(
j7@H7/?7

7zAHAV@& HV2oc!((&&!/!!!@	HK!!KF<H<[ FQ ??+9///+]]3]3/332/++9///]]+3329/]3 ]]10 +]_]_]+]]]]]]]+]]]]#".5<>5##".54>3237332>54.#"32>7#".546324&#"32>7>)NrH4'.;I*?V5,AQb8*>+	 tc(A/5e`xB;of;fYQ&G+ao~IMT?bF;%@4(, 'G:.`%<,
'G6AkJLuU0/?$*QI=4$Py`b*:!W%D5q&cvvjm,Kdqw9<gK+7dW461       E   r@BR^ R  ^_ZK  ?2?33]]9/32//]3/]9++ ++10!!#3	.'!
~E&NF56FN%Y    E  ! . w@Oe-j$f {toK[)Z@H Z """0)Z (_)_)_ ??9/9/]29/]9/+9]]10 ]]]]]]#!!24&+32>4.+!2>Th(uC!CdDUX.QrH!Q3]P
I}[3|g[*E&O|V8eQ;	8Wq(k[`9P?X9"8^     qvZ ) @-9'FVff6 0`p @$H  


@E	H

+v   [0@P FV%_  
 
0
`
p
0





IY_ ?]3/]q?3/]/]q]9/+]3/3/+3/]qr10 ]]]]32>7#".54>32.#":(T\?eO:RtfA@eoM4Ia<YR&H0Nf6AFi@e[7]yBA.XD*D       eE   a@Euzp$d+k44
; Z Z __ ??/]9/]10 ]]]]]]]]]#!!24.+32eP7U8ruyYEMy9
     bE  Z@;@
H 
 


	Z    _?o	_	_  ??9/qr/]29/]3/9/+103!!!!!(dEZ3    =E 	 G@-Z _??o@)H _ ??9/+]r/]29/9/10!!#!\{E    qOZ ) @J%uU''
% Z%%%% %%%+6v[0
@
P
 


'_(( @H_ _ ??3/+9//]q]9/]]]2/3/]9/10 ]]]%#".54>32.#"32>7!5!M$_tN@>doK&oZ~O#0SC16-iZ4YyE8nyE	P     *E  W@<Z / ? o  o      Zp _P	  ?2?39/]q/]q29/]q310!!#3!3k
oE6      E  Y@8  	p  Z	?			O	_								__  ?2?29/]]q]+3/M2/10!!!!5!!7<<E     E  Keu@"H Z			 __		 ?3/?/]3/]9/9/10 +]#"&'73265!5!3eb#
*:I)hids>@]<	     E  @4t

F
V
f
dt k { I Y 9

 H
r			@-H			  Z 
v  ?2?399]33/]23/]833/83+]99 +10]]]]] ]]]!#33	<E~+E_      LE  &@Z/ ?     _  ??/]]9/1033!EW     KE ,  @H&6*H)*9*@HH$$,\* @H  .@
 L\ (-H@	H$@H$*  ?2?39/3+33/++]2+9/+3933++10]+]+!46767#.'&'#367>73!		d3j,3175-d&J)/17<04-i3EM&,1/+%N      *E  x@$\ 	H ?o
@-H
\p zi	uf  ?33]]]?33]]]/]q2+9/]]qq3+10!#3&'.53Dj+-&Y'E(.'b3`     ffZ   y@Vv4v4y;y;VEFVIYIY [_@H [P


__ ??/]q9/]+q10 ]]]]]]]]]]]]]#".54>32 #"32fFx@D|Y^V    _E   [@>fv  IYi Z@H Z _@	H_	 ??9/+/]29/]+]]]10 ]#!#!24&+32>_;y{}|>RyO&TxHE:j^}+Jf   f}qZ   , @b5,u,,5(u((:&z&&:"z""iyJZFVFVZ [!_!!@H !!!.'[P$_*_`_ /]?3?/]q99//]+q2/10 ]]]]]]]]3267#".'.54>32 #"32f3bZ)e@&[1UaFpq8D|m~r	3_WgV      E     M@# L   H vZ@6H Z _?o _  ?2?9/]q2/]29/]]+]9/]32/83+]]10+ +!##!24)!2>xw;'T[SqE?E3aW>{gL*(CZ    OhZ ? @y4=m-K[k`t>>t=@=P=<D<T<v77t''!t!!Tzy*Z)) Z A	Z4Z 4/`$**$_@	P			 ?3/]?3/99/]]9/]2/10 ]]]]]]]]]]]]]]]]]]#"$'732>54.'.54>32.#"h>$0TzUHwU0AjD2f^Q="H~dtqD+GdDPlB5[yE7pgYB&rUh:%7ZA$:Z?FX8#'5KeC`W()RyP!3P6!9N-<K1 *9Rn   L  E  J@1Z?O_	 _ ??29/]]q+M10#!5!E4W   =E  ^@Deueu Z?Z



 


_ ??3/]]q9/]]qq10 ]]#".5332>53=:wzts:=iPSoD{85umaX((YgF    
  E  @U H)9+vTd6F$ R	^  R	^	U	D		  ?33]]?3/]3/]9 ++++10]]]]]]+!#367>73@>Ez-a*0/-0)b/       E 2L@! M M L L@ L1 M1 L L#@ L" L"
 M  L   L  L 	
 L@ L( L(	
 L@ L"	2		R#+#@		#R""@H			 R1+1^2 22 R^+	2224	/"O"_"""1+ $ ?3]33?39/]3/3/]9 ++++++ ++ ]_]+++++++++++++++10++++!#.'&'#367>732>73hjmmm
h4;?FLMF?;3}EA|193EC=<7q8;=CFDfz6C   $  E  @\			Y) 	

	 R^
R^



 


 	@
H@H 	
 ?3?39/+3/+999//q + ++ +10]] ]]]	3	#	#	3fMMMD|?=    $  E  @h4DT\;K	)S4D  /Z?O_
	@ P ` ?    ??39/]]339/]]q9]2+M210_^]_]]]]] ]#3	3vtHHc  I  E 	 u@&iWw)9IR^H @	H  /?O__ ?2?2/]9///++ ++10]]]]])5!5!!2a   W  /@	  ? o       ??/]]]9/310!!!#oWu     sZ  ?@ z 9 i  6fv    ??/]83]]9/83]]]1035     W1  )@`	  0     ??/]39/]105!!5!o#W_   FE  c@/y ) i y   pfv@     ?33/2]/]83]9/]893]]33]]10	#3z|#u    $     ///105!``   :  @t  ?/]10]%53    N 2 A @?$zi=y==%656 	H	-	=	-- 0FO8_888C&G'@-'''?G 9Q3,&&/&&&&&!P,3P Q ?33/?3/]q9//]3/]89/]332/]10 ]]]+]]]]%267#".'##"&54>?54.#"'>32%2>=M"C&3I.DXrJOT7T82Q:%
7dk*SzQ(7oY8Yop7Q64T; kN;C^:'C3@kN+.PQ?`t5Y0[LRd  B   4 a@BzD3T3d3K#[#k#:5u G`!!!6+F &P 0P ?3???3/]229/]10 ]]]]]]#"&'##>533>324.#"32>Bt00u?_BBjI((IiA?`@!"Vb7.!	+<H'Y9i_pg1-g|w_'.f  8N % @RddydDTK[uG

G?O`'G   p `p@HP!P@H ?3/+]?3/+]q/]9/]]q2/10 ]]]]]]]4>32.#"3267#".V_boFvVuGGuUl	Drdw652WvD[i7iddn:jmC|^9V    3 k@KD"T"d"K2[2k2:j5
u
zF* P5 G  /P%P  ?3?3??/]9/]q3310 ]]]]]]%#"!234&4&53#.532>54.#"^1yy1=`CEkI%%HjE@`? i_6Vb*2-	'H<+	$2:lph10ixt`*.f    FN   + @ed$dI)Y)i)I$Y$uwxzDTd'GI


 

`


-& G  P&&!PP




 ?3/]]?9//]29/]]2/10 ]]]]]]]]]32>7#".54>32"!.B&LqJ7]J2@jhs~CO`r3%.eV;H4MbUg9,=$--[I/H8TJb^~L       K  ^ 
@6	HF?/?o@%H  !P  P ??32?99//]+]3/33/]210 +#!5!54>32.#"!D-drPPGHOHBb@Te[*6^K
     XK 1 E @>z00f?EUeK:[:k:5!u
z/F2"PGF @(H<G (7P"AP	P  0  ?2/]?3?3?/]q3/+89/]q3310 ]]]]]]]".'732>=##".54>3234>734.#"32>gZc=q\9[A#;SnHf\++_nq-!0Oe5Cb@?aB5fP1X&Gb<KQ"KxV(L:#BJia>7(	+<I'qc,-cqu^'+`      ?@'ptF!F P   ??3?3/]229/10 ]]33>32#4.#"#@Ri@SZ/!;P0;gM,z2e./L5,\e/Pg=-U}Q       e 	  H@(J F0
`


P P ?2?/]q/9/q2/2/3/9/10%!!5!!5!'53|*     uWD   K@,u

J F 
0PP ??//]q/9/]2/9/10 ]]#".'532>5!5!'53DGvV)RLA<HO(8aH)iKm_*	
=_C      e  @,fvd	t		{IYiIYk {  I Y 
@(H
	D	T			  F %HH@H
   ?2??9933/+++]23/8]]33/]839910+]]] ]]] ]!#33	Iboa/      \ 	 3@ F
P  P ?2?9/q2/3/9/10%!!5!!5!|*     c  dN 9  *	H @Y	H"9H  .H///`/p////?/O/_//// /0///;H ?5P"(/  ?22??32/]]qqr29/]]qqq9/910 ++!4.#"#4.'33>323>32#4.#"+ !4&$3F.XW+8H/=T4+ BMOjA3]QS"KC0)58'G6`d/I2,\e/OjA     N % =@&p""!!t!!%F  'F P  ?2??3/]29/10 ]]!4.#"#4.'33>32d!;P0;gM,AUjBSW-Pg=-U}QS"KC0,9;/L5,\e/     IN  # Y@=d"F"V"dFVkIYkIY G `%G 

PP ??/]9/]q10 ]]]]]]]]#".5324.#"32>IC~rm}D+Mj@AnO-/Oi9AoP-ED~b')c{~b('b   WBP ( < e@Dd;F;V;k+I+Y+&&v&&4!;y G`)))>3F .P$8P
 ?3???3/]229/]10 ]]]]]]]]#".'##4.'33>324.#"32>B(\n7dVC?Pd>n\(;aI;hM-%HjDIb;"{U,F2.:Y(J;*	%4<4L1P}dk8%asa*9n     WJ $ 8 f@GK-[-k-D1T1d1:5$$u$$
  z  F%P:/G ""4P*P  ?2??3/]9/]q3310 ]]]]]]234>73#46767##"4.#"32>BfO=?QeA(JiADa=<`E;hN-J.E/91#	(DbC6:3N5w^(3injj6'c    N  F@+x!	F

o



R	 ???3/]3|/29/10 ]]].#"#4.'33>32/g>T\1
>UtR8l*DuX8tgR>CD>dF&
   $K 8 @Xlylj6s11G1W1$7*
  (I'' H:I

/H `p/-P" (((("P ?3/?3/]99/]3/9/2/10 ]]]]]]]]]]#".'732>54.'.54632.#"$;pi^rM5Kb9:cH)3XyG@~c=OlI.CT.+NlAAqI5LzU.>gL7A")A02=*(AdM?cE-8!.9&*Fm   T  X@6jz(	H	F@%H@H P P ?33/2?/]++33/]29/3/10 +]533!!32>7#"&5:xPUa(UOEFWf6tOL

    : % E@,""{!!
!!*!9F'F $$$P  ?2??3/]9/310 ]]]]32>53#.5##".5m5U?@gI'>RjFZT':ROjA-U}Qs"KC0,9;/L5,\d   E  :  @BVIY[	%U(h R	K  R	K	p@
H@HU	D	*	:		  ?33]]]?3/+3/+]9 ++++10]]]]]]]!#3>73O:@?D??B?    : *R@tFV$4@JHeu$4 Hk{-={ H H*:@H%5u H*:z @pH % 5  RKRLR#L R)#)K* * #*t****,*f2)*#u  ?3333]3?39/3_]]//3/]9++ ++++++10]_]+]]+]]+]]++]]]]]+]]]]+]]]!#.'&'#367>734>73				
]		
eE %%%$G-:U`\-)#IWG#).Z_V_    ^  m:  @pGv9yvY
		 
		RK			 RK  
		p
  ?2?39/3/3/]3/9 +++ +10]] ]]]!	#	3	3	s,*sD,[  BW:  @RHeuIY H-=+; HIu  & f jzIY iy	H
H!@
@H@HP ??39/3+]/+833/+839/9+]33]]]]10 +]]+]]+!#"&'5326?3>73%PbxN": 0O0* bo;v1/~OM>	=KO       ,: 	 X@7&VRK` PP  ?2?2/]]9///] ++10]35!5!!LV&   W% 1 u@viy	H@7	H1113 ,%? %Oo0 0  ??9/]q9/]]33/]929/]310 ++]]".54.'5>54>3!#";AlN+/Nc33cN/+NlA	-A*)BS)+SA(P[W,PoD_?W67V>`FpO*.J69\E,

-D]:jY W  @
     ??9/103Wu    W 1 s@v""i)y))@=	H/	H0%%% ,3O      &%/%O%o%%%%%   ??9/]q9/]]39/322/]910 ++]]532654>75.54.+5!2#[Q(AR+)RB)*A-	AlN+/Nc33cN/+NlAWYj[:]D-

,E\9Z6J.*OpF>V76W?DoP,     l)`'   ]@&6f0	 L0	 L@%	 L0	 L" @H @	H 
 /]3++2/]10+ +++]23267#"&'&#"5>s)OMK%233E{4<=D(EIX&A<82'2*,- &.    :   ,@ 	   ??9/9/]32103##5ID   Fc ) @`hD(T(J&Z&I G!!F +'F $P!!!!!  `p P //]99//3/]q333/]/]9/]3/9/3210 ]]]2>7#5.54>753.#"{8]H/		:cZnm6:phVa=z6Q6>t\>SnvS	7Vo?[l  8  Z 6 @bHo")-oO"_"**""* o 66682n@$H ,s)?o2%s""2s66 ?3/2?3/9/]q32|/]+3/9}/]9///]]]3210 ]+%#!5>=#5354>322.#"!!!267	 6Q:+H33hlJ~eH'2uNzxh$<,X;9+VD+0FfK\f7:V9
?@s};`M<55   /s # 7 @I"Y"-"="IY-=IY-=FV"2FV"2FV"2FV"2IY-=!! o.... 9  $     !!	)@`?3	 /3/3/]]3/393333/]3/39/]]2/39333310]] ]]]]]]]] ]]]]]]467'7>327'#"&''7.732>54.#")%dhc6IG~6ah`%+,&dfe6~GH4iff%)-Lf:9fM,,Mf9:fL-G6dge'+*&ai`6GG5die%)*&iif6I:fL,,Lf::fM,,Mf     4  E  @o]K)9R@$4  @ P O_		/ \O	_						``  ??399//332329/]]33229]2+M29/39/310_^]]]]_]]]]!!!!#!5!7!5!3	3A}@eim  i   9   %@ 	    ??99//9/321033
    T, M a@ssiVu``C_S_C[S[CZSZsZZC>S>jz*JZ*QJQZQjQ*PPH*Hl9|99*9
$$MM]"XIAFSNIKI7I"K@@HAK""KA,I NNNNc-I ,,SF]<vFFjFF 2Q' ----'Q    ?2//3/]99]]3333/]9/]9////+999910 ]]]]]]+]]]]]]]]]]]2.#"#".'732>54.'.54>7.5464.'>xOlI.CU.}2Sm;DpF7R61O7:pk]uO7Nc9:fM,9_{AAhA ;T5*K9!5Xq=:Y<1Rl<6]D'?bE-=%YG-@. .IjL-WI73@Q3IuS,@hM7G)-D/6I3#.IjI-SG5.@P00E3#!4E'.B0"/F  O|{   1@   ? _    @H  /+]22/]3/1053!53      & ) = Q@w{PPtJJvOOvKKtFF{@@yEEyAAPPJJ,#f v   
 p/?@H4>H>***SH@WHH40
@



0




%  P pMiCyCCC9 fMvMMM/ ?]?]99//]q]3/3/]q/+3/]+99//+]]]32]10 ]]]]]]]] ]]]]32>7#".54>32.#"#".54>324.#"32>8T8)?/!s4JcCZW++VWCcH1r
 .<':S5[yx\\yy[\MfeMMefMHxV0-8#+Q?&@r^bo;$;K'!2&.SvJUUVVGGFF   * ; z 	H@7	H"(	H)H)(	H$ 555 =+    0(6$!(
 ?3/?339/2/]3/9/]332/10 +++++4>?54&#"'>323267#"&'##"&732>=:cG^VT\0TyO+	8RK+fy&9';\A"2ZD(fE\8+]YDM
/R>#:<^UKMYr}2&-DQ%35     `   P@+ 
	 


	   ?9=/33233/]9/10%53	!53	RToPQm?sm?s   t W  !@  ?   ?]/]10%!5!      &  ' 5 > @){&&t  v%%v!!t{yy/@H3(	H&&  4))@&)1;+,(55516p66,6,6
H   @@2H
(,4*;:- --,;--;,#iy f#v### ?]?]9///]23/+3/]+99//]2/83298310 ]]++]]]] ]]]]#".54>324.#"32>##!24&+326[yx\\yy[\MfeMMefM3hU_QPTUUVVGGFFP?~of{PEHU R B     G Z  ' J 	H@&	H	H	H   



#  ?3/]/]3/10 ++++#".54>324.#"32>-Ni;;hN..Nh;;iN-m0A&%A00A%&A0=;hM--Mh;<hM,,Mh<&A11A&%A11A    t  W   j@7	 
@/? 	H /+32]q+ M/9/_^]32+M3210#!5!3!5!XuvX 83   SZj@(	Ho "       ?2?3//]3/3/9/]2/10 +]'>54&#"'>32!:XdgR4GJDX.LlC6UgcS3g=_PGIR2>KID3W@%p=bRIIN/k    2' 5 { *@ 	H(	H0-"##-O_ @"	H7	 0(""(		 ?3/?3/9/9/]9/+99//]3/910 ++#".'732654.+532>54&#"'>32WtI$	XUMS%8C=9=2 JGDT2Og:EhF#VZ4K0t'@Q+CEHL-6	m5(<EFA:V9!;O.Kn%6D :  @{  ?/]10]573    w<: ' h@H9"F `@*$SH)F@'SH@#H@H  P	  ??33??3/]+++229/+]q310 ]+!.5##"&'##332>535rR ?eICpR.1>?mn@: ?|EtU/4[~Ki"LC1   8E  A@   /3?9/2/]9/2/9/]10###".54>3!P`52_WG-XXT]2z      wD    R @/HDTH@	H   @H ?/9/+/]3/9/+33310 +]+#"&'532>54&#*73AhK-2$)9"=HAk'^^*E1b (*dS 3  ?@"? 		  ?2?33/9/]33/3/2/]105!#52>733#	7JV+0WI8y3kb*m#2!k      ! R@0zzu!!u #o
 

P

 ??/]q9/]10 ]]]]#".54>324&#"3261bb]a30abg],xrt}"=U3uWh99hWTh;:hULmE    k L   P@* 

	
	   ?9=/33233/9/10%#5	53#5	53RRROot?ot?    E'   &     (@P@`    ]5]5]]55 ?55     E'   &    @`    ]5]5 ?5     Q' !  &     @5P:@:: @  ]5]]55 ?55    l9 ' + w@6fvfvEUi y  
	(++  p-    	@H		#*+i#y### ?3/]/9/+/]9/]9/32]10 ]]]74>7332>7#".#5%>ORO?''>NPM<%)MmDDoR2J~ql~DqOEhRB;;DS7CfQA;;DS57T9&Ge>Zl=0]D      & $   C  &%+5 +5     & $   t ]  @&]%+5 +5       & $       @& %+5 +5       & $       @&  0%+5 +5       ]& $   i    @& %+55 +55       `& $   U @8%+55 ?55      E   @Q+R^		\__?o__ ?3?299//qr/9/9/3299// ++10]!#!!!!!!#!GzIdER/BHDo  qDvZ& &   xb   2*%+5      b& (   C  & 
%+5 +5    b& (   t [  @&? 
%+5 +5      b& (       & 
%+5 +5    b]& (   i   & 
%+55 +55    & ,   C  & %+5 +5    & ,   t g  @&g %+5 +5      & ,       @&  %+5 +5      ]& ,   i    @&  %+55 +55       eE   @br0`$y+;k Z !Z
 _	O	?	o						@(H		__ ??9/+]q32/]3/329/]9/10 ]]]]]_]#!#53!2!324.+!eP7U8ruy!YU[MG

y9A    *& 1       @& /%+5 +5    ff& 2   C  &"
 %+5 +5  ff& 2   t b  @&b!
 %+5 +5    ff& 2       @& $
 %+5 +5    ff& 2       @& )9
 %+5 +5    ff]& 2   i   @&" 
 %+55 +55      .s  @   @HH
HHH@&H	H	H
O
 


 ?3/]]]310 ]+]+]+]+++++]]]]	7			bh^^i`fJb`g_iia     8p  " + @eujzwg%%FVFVIYIY4"t""v{6t&9&;+{++&%# [_@H -#[
P%& )_ _	 ?3?399/]q39/]+q29910 ]]]]]]]]]]]]]]] ]#"&''7.54>3274'32.#"fFxo?u^0/D|t^00 O 'tKYFDAXVAUrR
tBA   =& 8   C  &
 %+5 +5  =& 8   t V  @&V
 %+5 +5    =& 8       @&  
 %+5 +5    =]& 8   i    @& 
 %+55 +55    $  & <   t e  @	&e	%+5 +5       _E   c@Bveujz Z@H Z ``	 ??99///]229/]+]10 ]]]#!#3!24&+32>_;y{}|>RyO&XxGE<oc,Ok     C @)|::u88eBfAD?T?t??e/e.u..(	H3@%	H96H&=6==H@P		* HH@)	HE*F+@H ++=$P1 +`	p				P ?3/]??9/]+9/++9///]]]10 ++]]]]]] ]#"&/32654.54>54.#"#4>32)W_P7BJN%\b6Q_Q6!1:1!!?Z9DkI'?xnfi5!3:3!7R_R7'BvX4
_O;R?9G^F3I:04?+%>-#MzXwp6.Pm>;WC412 (=:@To & D   C  B&pCF%+5 +5    & D   tM  @B&/BE%+5 +5  & D     C& HHB%+]5 +5    & D     "@B&0M MMM]%+]]]5 +5   {& D   i  @
B& FFD%+]55 +55   & D     @G&LB'/%+55 +55   N A P Y @|XX|TTjzl|==77!!(	H8V IK$K	I

@HWKKWKWKW[/H00BHO_Q*P5 PVKQ$V$V$;85/////5EP			 ?3/]332?3/]3399//2/]3/99//]]2/329910 +]]]]]]]3267#".'#".54>?54.#"'>32>3232>="!.,F1KY+ImM9\H56I\:Da?9]v>!4$ 3&(JqP[y#-}L`N 998Q4z%J:%>3#i	XRb7^H--[I/7Y@1U>$,TwKkN;C^:'C3@kN+FEJAXzRd?`t5Y0[RJb D8N& F   xQ   !.& %+5    F& H   C  ,&-0%+5 +5    F& H   to  @,&o,/%+5 +5  F& H     @-&2,%+5 +5  F{& H   i  @,&0.%+55 +55    e&    C  @
&`P%+]]5 +5     e&    th  @
&T
%+5 +5    e&    
  "@&`P0
%+]]]5 +5     e{&    i)  /@
&p`P@ 	%+]]]]]]55 +55   }N % 7 @E6U6e6E1U1e1J.Z.j.J(Z(j(+;k$$	!Gp&& &&`&&&90G!! !!eujz	+P       3P  ?3/3?99//]39]]/]]q9/]qr399//3/910 ]]]]]]2.''7.'3%#".54>4.#"32>dGu+'iL78xB-S*79x}v84t!GqPQsI!QvK$ YEsn^-N#3rl\}yKIokK^Z,-\\,Z   & Q   
  @&&	1A$%+5 +5  I& R   C  $&%(
 %+5 +5    I& R   te  @$&e$'
 %+5 +5  I& R      @%& *$
 %+5 +5  I& R      @$& /?
 %+5 +5  I{& R   i   @$& (&
 %+55 +55   t Wu    c@<p ?O 
	@ /?OO ?]q+ M9/_^]]32]+M10535!53   n]N  % 1 @$E$U$e$k0J0Z0 Hy@Ht@	Ht@gH*)& G 0@p P `p3&G

@(.H@H*)!--P!P		 ?3/?3/99/++3/9/]qr2/9910 +]+] +]+ ]]]#"&''7.54>3274&'32>%.#"]Fwe@MLT03CyzHNPa+r@EvV0*qEEuU0E56WD_EzFdRDZLx.5*'b~Ku.@2')c    & X   C  &&'*$%+5 +5    & X   tZ  @&&T&)$%+5 +5  & X      '&,&$%+5 +5    {& X   i   &&*($%+55 +55    BW& \   tk  @ &k #%+5 +5   WB  8 e@Dy!!dFVkIY5:&vG`   :2
/F 0001 /(P#P ?3?3??/]229/]10 ]]]]]]]]4.#"32>>32#".'##3;aI;hM-%HjDIb;?Pd>n\((\n7dVC"dk8%asa*9n4L1P}{U,F2.:YuY9  BW{& \   i  @ &$"%+55 +55     e: 	 3@ F
P P ?2?9/q2/3/9/10%!!5!!5!|*     K  ( t@Iv&&F	V	IY\*$\_?o__ ?3/2?3/29/qr/9/9/299//10 ]]]!#"4>32!!!!!%267.#"a1={|:3.ro;;;NuN'(OtR\ LH9!:?   N & : C @s{BBz>>v88y**fvd3t33k/{//""
@ H''%I		%HAAAE1HO_ P@@6;,P 6P ?3/]332?3329//]9/]2/9/29910 ]]]]]]]]]]3267#"'#".532>32%4.#"32>"!.)@,AN(DfHQ*[KxU-O-Q[{Jk,?''A/.>#(A.L7/ DPUg9^H--[I/]ZD^SXz'~b')c{~b('b)Jb    	 %@ P` H	 ?3+/]10#'##573ih    t|X  '  	H@a	H	H	H     0 p     `     

@	H#/Oo/?Oo@H /+]q+]/]]]qr10 ++++#".54>324.#"32>X<[==[<<[==[<y.!!..!!.D'H8!!8H''H7!!7H'     Q@
	H@$	H/?
 0
  ?23/]3/]10 +]+]".#"#>3232>73*TPM#
o-J;,TPJ!
p+J%-%,-XG,%-%,,XG-  "L     ?//105!x L     ?//105!
 ^?  *@H     ?/]10+]!?7n    ^A  3@" H	  	H     ?/]10+]]+!	^n   ]  ;@( H	  	H/       /]]10+]]+!]	n    ^   W@	H@&H/     ?32/]/]]10+]+]!!!c727nn   ^   h@KH		H H	  	H /       ?32/]]/]10+]]++]]+!!!i		^nn     j@LH		H H	  	H /       22/]]/]10+]]++]]+!!!i		nn   P{  7@%%5%5*:*:  

 /3//]3/10 ]]]]#".54>32{,Mf:9cK++Kc9:fM,:fL--Lf:9dJ++Jd Z ]  .@ O   ?9=/33/]]10%53	PQm?s n q  0@  `  ?9=/33/]10%#5	53 RQot?     E  ' @
   ??/]839/8310!#3BvsE     [cZ < @Ui17GW+**5  9>39n  "@Hs;6 s!3!o?!!!.s%++%s0 ?3/]?3/99//]]3232/+3/33/]22/39/39/33310 ]]!32>7#".'#53.5467#53>32.#"!!!i5*MtP4WKBL*X`l>x{Gww8d]W+R:VIrS3%OzT+%. D}m"#,*:Gz_+*      (@      ?  @H  /+]9/]103+  %ME  D@  			  ?2?33/]9/]33/3/2/1053#52>733I/3/03/ytMk$
w,!sk    MQ   O @ 	H "     _  ?2?3/]/]3/3/9/2/10 +5>54&#"'>32!JTTD*3<=;'A\=xy.GVRD|Ma7UH?@G,9@>=/P:!pg7YKA?A&k    ;Q 3  *@@	H(	H  {0"##
-
 
5O
 


0(_"""(@	P ?3/]?3/]9/9/]]9/99//3/ ]]10 ++#".'732654.+532654&#"'>32'D^8@\>"	A06B)6)%D@6)-B,DU0:W:CERK6S9%<L'<=<A%/
m9B52?96P67J*BUd   K5E 
  ]@		`p@ @H  /  ??39/]332/]+9/]3322/10#5!533!<6iz	ce	" 
       n        5 l                                      =       Z       P             	       
c       '       .       5=         	   j    	     	     	  $   	    	  #  	  J  	  b  	  (U  	 	   	 
  	  8  	  \D  	  j  	  4s D i g i t i z e d   d a t a   c o p y r i g h t   ( c )   2 0 1 0   G o o g l e   C o r p o r a t i o n .  Digitized data copyright (c) 2010 Google Corporation.  C o u s i n e  Cousine  R e g u l a r  Regular  A s c e n d e r   -   C o u s i n e  Ascender - Cousine  C o u s i n e  Cousine  V e r s i o n   1 . 0 0  Version 1.00  C o u s i n e  Cousine  C o u s i n e   i s   a   t r a d e m a r k   o f   G o o g l e   a n d   m a y   b e   r e g i s t e r e d   i n   c e r t a i n   j u r i s d i c t i o n s .  Cousine is a trademark of Google and may be registered in certain jurisdictions.  A s c e n d e r   C o r p o r a t i o n  Ascender Corporation  S t e v e   M a t t e s o n  Steve Matteson  C o u s i n e   w a s   d e s i g n e d   b y   S t e v e   M a t t e s o n   a s   a n   i n n o v a t i v e ,   r e f r e s h i n g   s a n s   s e r i f   d e s i g n   t h a t   i s   m e t r i c a l l y   c o m p a t i b l e   w i t h   C o u r i e r   N e w!" .   C o u s i n e   o f f e r s   i m p r o v e d   o n - s c r e e n   r e a d a b i l i t y   c h a r a c t e r i s t i c s   a n d   t h e   p a n - E u r o p e a n   W G L   c h a r a c t e r   s e t   a n d   s o l v e s   t h e   n e e d s   o f   d e v e l o p e r s   l o o k i n g   f o r   w i d t h - c o m p a t i b l e   f o n t s   t o   a d d r e s s   d o c u m e n t   p o r t a b i l i t y   a c r o s s   p l a t f o r m s .  Cousine was designed by Steve Matteson as an innovative, refreshing sans serif design that is metrically compatible with Courier New. Cousine offers improved on-screen readability characteristics and the pan-European WGL character set and solves the needs of developers looking for width-compatible fonts to address document portability across platforms.  h t t p : / / w w w . a s c e n d e r c o r p . c o m /  http://www.ascendercorp.com/  h t t p : / / w w w . a s c e n d e r c o r p . c o m / t y p e d e s i g n e r s . h t m l  http://www.ascendercorp.com/typedesigners.html  L i c e n s e d   u n d e r   t h e   S I L   O p e n   F o n t   L i c e n s e ,   V e r s i o n   1 . 1  Licensed under the SIL Open Font License, Version 1.1  h t t p : / / s c r i p t s . s i l . o r g / O F L  http://scripts.sil.org/OFL          # T                               	 
                        ! " # $ % & ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 : ; < = > ? @ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \ ] ^ _ ` a                                b c  d  e        f     g      h    j i k m l n  o q p r s u t v w  x z y { } |    ~                       	
uni00B2uni00B3uni00B9Eurouni2219onefractiontwofractionthreefracitonfourfraction                                                  v$    o-#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//post_process taa_resolve ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 texcoord_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 texcoord;
};
struct ps_output
{
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform src_info
{
    float4 inv_texel_size[8];
};
layout (std140) uniform taa_cbuffer
{
    float4x4 frame_inv_view_projection;
    float4x4 prev_view_projection;
    float4 jitter;
};
texture_2d( src_texture_0, 0 );
texture_2d( src_texture_1, 1 );
texture_2d( src_texture_2, 2 );
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.texcoord = texcoord_vs_output;
    ps_output _output;
    float2 ctc = _input.texcoord.xy - (jitter.xy * 0.5);
    float2 tc = _input.texcoord.xy;
    float frame_depth = 1.0;
    float2 samples[9];
    float2 inv_sm_size = inv_texel_size[0].xy;
    samples[0] = float2(-1.0, -1.0) * inv_sm_size;
    samples[1] = float2(1.0, -1.0) * inv_sm_size;
    samples[2] = float2(-1.0, 1.0) * inv_sm_size;
    samples[3] = float2(1.0, 1.0) * inv_sm_size;
    samples[4] = float2(-1.0, 0.0) * inv_sm_size;
    samples[5] = float2(0.0, -1.0) * inv_sm_size;
    samples[6] = float2(0.0, 0.0) * inv_sm_size;
    samples[7] = float2(0.0, 1.0) * inv_sm_size;
    samples[8] = float2(1.0, 0.0) * inv_sm_size;
    float2 tc2 = float2(0.0, 0.0);
    float4 nh_min9 = float4(1.0, 1.0, 1.0, 1.0);
    float4 nh_max9 = float4(0.0, 0.0, 0.0, 0.0);
    float4 nh_min5 = float4(1.0, 1.0, 1.0, 1.0);
    float4 nh_max5 = float4(0.0, 0.0, 0.0, 0.0);
    for(int i = 0; i < 9; ++i)
    {
        float2 tcc = ctc + samples[i];
        float d = sample_texture(src_texture_1, tcc).r;
        float4 c = sample_texture(src_texture_0, tcc);
        if(i < 5)
        {
            nh_min5 = min(nh_min5, c);
            nh_max5 = max(nh_max5, c);
        }
        nh_min9 = min(nh_min9, c);
        nh_max9 = max(nh_max9, c);
        if(d < frame_depth)
        {
            tc2 = ctc + samples[i];
            frame_depth = d;
        }
    }
    float4 nh_min = lerp(nh_min9, nh_min5, 0.5);
    float4 nh_max = lerp(nh_max9, nh_max5, 0.5);
    float2 ndc = tc2 * float2(2.0, 2.0) - float2(1.0, 1.0);
    float4 up = float4(ndc.x, ndc.y, frame_depth, 1.0);
    float4 wp = mul(up, frame_inv_view_projection);
    wp /= wp.w;
    float4 pp = mul(wp, prev_view_projection);
    pp /= pp.w;
    float2 ptc = pp.xy * 0.5 + 0.5;
    float2 vel = ptc.xy - tc2.xy;
    float2 ftc = tc + vel;
    float4 frame_colour = sample_texture(src_texture_0, ctc);
    float4 history_colour = sample_texture(src_texture_2, ftc);
    float alpha = 1.0/16.0;
    for(int i = 0; i < 2; ++i)
    if(ftc[i] < 0.0 || ftc[i] > 1.0)
    {
        alpha = 1.0;
        break;
    }
    float vv = saturate(length(vel)*100.0);
    if(jitter.z == 1.0)
    vv = 1.0;
    float4 blended = lerp(history_colour, frame_colour, alpha);
    _output.colour = lerp(clamp(blended, nh_min, nh_max), frame_colour, vv);
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//post_process blit_depth_unjittered ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 texcoord_vs_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 texcoord;
};
struct ps_output_depth
{
    float depth;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform src_info
{
    float4 inv_texel_size[8];
};
layout (std140) uniform pp_info
{
    float4 frame_jitter;
};
texture_2d( src_texture_0, 0 );
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.texcoord = texcoord_vs_output;
    ps_output_depth _output;
    float2 uj = inv_texel_size[0].xy * frame_jitter.xy * 0.5;
    _output.depth = sample_texture( src_texture_0, _input.texcoord.xy - uj ).r;
    //assign glsl global outputs from structs
    depth_ps_output = _output.depth;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//post_process high_pass ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 texcoord_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 texcoord;
};
struct ps_output
{
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform material_data
{
    float m_threshold;
    float m_smoothness;
    float2 m_padding;
};
texture_2d( src_texture_0, 0 );
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.texcoord = texcoord_vs_output;
    ps_output _output;
    _output.colour = sample_texture( src_texture_0, _input.texcoord.xy );
    float lum = dot( float3(0.2126, 0.7152, 0.0722), _output.colour.rgb);
    _output.colour *= smoothstep(m_threshold, m_threshold + m_smoothness, lum);
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//post_process debug ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 texcoord_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 texcoord;
};
struct ps_output
{
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.texcoord = texcoord_vs_output;
    ps_output _output;
    _output.colour = float4(1.0, 0.0, 1.0, 1.0);
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//post_process blit vs 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
layout(location = 0) in float4 position_vs_input;
layout(location = 1) in float4 texcoord_vs_input;
out float4 texcoord_vs_output;
uniform float v_flip;
struct vs_input
{
    float4 position;
    float4 texcoord;
};
struct vs_output
{
    float4 position;
    float4 texcoord;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
void main()
{
    //assign vs_input struct from glsl inputs
    vs_input _input;
    _input.position = position_vs_input;
    _input.texcoord = texcoord_vs_input;
    vs_output _output;
    _output.position = _input.position;
    _output.texcoord = _input.texcoord;
    //assign glsl global outputs from structs
    gl_Position = _output.position;
    gl_Position.y *= v_flip;
    texcoord_vs_output = _output.texcoord;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//post_process blit_rgb ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 texcoord_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 texcoord;
};
struct ps_output
{
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
texture_2d( src_texture_0, 0 );
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.texcoord = texcoord_vs_output;
    ps_output _output;
    _output.colour = sample_texture( src_texture_0, _input.texcoord.xy );
    _output.colour.a = 1.0;
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//post_process menger_sponge ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 texcoord_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 texcoord;
};
struct ps_output_colour_depth
{
    float4 colour;
    float depth;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
float point_light_attenuation(
float4 light_pos_radius,
float3 world_pos)
{
    float d = length( world_pos.xyz - light_pos_radius.xyz );
    float r = light_pos_radius.w;
    float denom = d/r + 1.0;
    float attenuation = 1.0 / (denom*denom);
    return attenuation;
}
float op_union( float d1, float d2 )
{
    return min(d1,d2);
}
float op_subtract( float d1, float d2 )
{
    return max(-d1,d2);
}
float sd_box(float3 p, float3 b)
{
    float3 d = abs(p) - b;
    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
}
float sd_cross(float3 p, float2 s)
{
    float da = sd_box(p.xyz, float3(s.y, s.x, s.x));
    float db = sd_box(p.yzx, float3(s.x, s.y, s.x));
    float dc = sd_box(p.zxy, float3(s.x, s.x, s.y));
    return op_union(da, op_union(db, dc));
}
float map( float3 p )
{
    float scale = 10.0;
    float rep = 30.0;
    float3 q = mod(p, rep) - 0.5 * rep;
    q = q / scale;
    float d = sd_box(q, float3(1.0, 1.0, 1.0));
    float s = 1.0;
    for( int m=0; m<4; m++ )
    {
        float3 a = mod(q * s, float3(2.0, 2.0, 2.0)) - 1.0;
        s *= 3.0;
        float3 r = 1.0 - 3.0 * abs(a);
        float c = sd_cross(r, float2(1.0, 10000.0) ) / s;
        d = op_subtract(-c, d);
    }
    return d * scale;
}
float3 calc_normal(float3 pos)
{
    float3 eps = float3(0.001, 0.0, 0.0);
    float3 nor;
    nor.x = map(pos+eps.xyy) - map(pos-eps.xyy);
    nor.y = map(pos+eps.yxy) - map(pos-eps.yxy);
    nor.z = map(pos+eps.yyx) - map(pos-eps.yyx);
    return normalize(nor);
}
float intersect(float3 ro, float3 rd, out float3 pos)
{
    for(float t = 0.0; t < 150.0;)
    {
        float3 p = ro + rd * t;
        float d = map(p);
        if(d < 0.001)
        {
            pos = p;
            return t;
        }
        t += d;
    }
    return -1.0;
}
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.texcoord = texcoord_vs_output;
    ps_output_colour_depth _output;
    float2 ndc = _input.texcoord.xy * float2(2.0, 2.0) - float2(1.0, 1.0);
    ndc = remap_ndc_ray(ndc);
    float4 near = float4(ndc.x, ndc.y, 0.0, 1.0);
    float4 far = float4(ndc.x, ndc.y, 1.0, 1.0);
    float4 wnear = mul(near, vp_matrix_inverse);
    wnear /= wnear.w;
    float4 wfar = mul(far, vp_matrix_inverse);
    wfar /= wfar.w;
    float4 col = float4(0.0, 0.0, 0.0, 1.0);
    float3 ray_origin = wnear.xyz;
    float3 ray_dir = normalize(wfar.xyz - wnear.xyz);
    float3 world_pos;
    float d = intersect(ray_origin, ray_dir, world_pos);
    float3 grad_a = float3(0.9, 0.5, 0.0);
    float3 grad_b = float3(0.5, 0.0, 1.0);
    float grad_t = ray_dir.y * 0.5 + 0.5;
    float4 sky = float4(lerp(grad_a, grad_b, grad_t), 1.0);
    _output.depth = 1.0;
    float4 sd_col = sky;
    float sky_t = 0.0;
    if(d > 0.0)
    {
        float3 n = calc_normal(ray_origin + ray_dir * d);
        float4 lpr = float4(camera_view_pos.xyz, 100.0);
        float3 l = normalize(lpr.xyz - world_pos);
        float ndotl = dot(n, l);
        float a = point_light_attenuation(lpr, world_pos.xyz);
        float3 lc = a * ndotl * float3(0.0, 0.7, 0.9);
        sd_col = float4(lc, 1.0);
        float4 proj = mul(float4(world_pos, 1.0), vp_matrix);
        proj /= proj.w;
        _output.depth = proj.z;
        sky_t = smoothstep(150.0, 80.0, length(world_pos - ray_origin));
    }
    _output.colour = lerp(sky, sd_col, sky_t);
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
    depth_ps_output = _output.depth;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//post_process sss_reflectance ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 texcoord_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 texcoord;
};
struct ps_output
{
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
layout (std140) uniform src_info
{
    float4 inv_texel_size[8];
};
layout (std140) uniform filter_kernel
{
    float4 filter_info;
    float4 filter_offset_weight[16];
};
texture_2d( src_texture_0, 0 );
texture_2d( src_texture_1, 1 );
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.texcoord = texcoord_vs_output;
    float4 sss_kernel[25];
    sss_kernel[0] = float4(0.530605, 0.613514, 0.739601, 0);
    sss_kernel[1] = float4(0.000973794, 1.11862e-005, 9.43437e-007, -3);
    sss_kernel[2] = float4(0.00333804, 7.85443e-005, 1.2945e-005, -2.52083);
    sss_kernel[3] = float4(0.00500364, 0.00020094, 5.28848e-005, -2.08333);
    sss_kernel[4] = float4(0.00700976, 0.00049366, 0.000151938, -1.6875);
    sss_kernel[5] = float4(0.0094389, 0.00139119, 0.000416598, -1.33333);
    sss_kernel[6] = float4(0.0128496, 0.00356329, 0.00132016, -1.02083);
    sss_kernel[7] = float4(0.017924, 0.00711691, 0.00347194, -0.75);
    sss_kernel[8] = float4(0.0263642, 0.0119715, 0.00684598, -0.520833);
    sss_kernel[9] = float4(0.0410172, 0.0199899, 0.0118481, -0.333333);
    sss_kernel[10] = float4(0.0493588, 0.0367726, 0.0219485, -0.1875);
    sss_kernel[11] = float4(0.0402784, 0.0657244, 0.04631, -0.0833333);
    sss_kernel[12] = float4(0.0211412, 0.0459286, 0.0378196, -0.0208333);
    sss_kernel[13] = float4(0.0211412, 0.0459286, 0.0378196, 0.0208333);
    sss_kernel[14] = float4(0.0402784, 0.0657244, 0.04631, 0.0833333);
    sss_kernel[15] = float4(0.0493588, 0.0367726, 0.0219485, 0.1875);
    sss_kernel[16] = float4(0.0410172, 0.0199899, 0.0118481, 0.333333);
    sss_kernel[17] = float4(0.0263642, 0.0119715, 0.00684598, 0.520833);
    sss_kernel[18] = float4(0.017924, 0.00711691, 0.00347194, 0.75);
    sss_kernel[19] = float4(0.0128496, 0.00356329, 0.00132016, 1.02083);
    sss_kernel[20] = float4(0.0094389, 0.00139119, 0.000416598, 1.33333);
    sss_kernel[21] = float4(0.00700976, 0.00049366, 0.000151938, 1.6875);
    sss_kernel[22] = float4(0.00500364, 0.00020094, 5.28848e-005, 2.08333);
    sss_kernel[23] = float4(0.00333804, 7.85443e-005, 1.2945e-005, 2.52083);
    sss_kernel[24] = float4(0.000973794, 1.11862e-005, 9.43437e-007, 3);
    ps_output _output;
    float2 tc = _input.texcoord.xy;
    float z = sample_texture(src_texture_1, tc).r;
    float n = camera_view_pos.w;
    float f = camera_view_dir.w;
    float ez = (2.0 * n * f) / (f + n - z * (f - n));
    float lz = (ez - n) / (f - n);
    float dist = 1.0 / tan(0.5 * 60.0 * 3.14 / 180.0 );
    float scale = dist / lz;
    float w = 1.0;
    float2 final_step = w * scale * filter_info.xy;
    final_step *= 1.0 / 3.0;
    float3 col = sample_texture(src_texture_0, tc).rgb * sss_kernel[0].rgb;
    float2 it = inv_texel_size[0].xy;
    for(int i = 1; i < 25; ++i)
    {
        float2 offset = sss_kernel[i].a * it.xy * final_step;
        col += sample_texture(src_texture_0, (tc + offset)).rgb * sss_kernel[i].rgb;
    }
    _output.colour.rgb = col;
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//post_process downsample_average ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 texcoord_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 texcoord;
};
struct ps_output
{
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform src_info
{
    float4 inv_texel_size[8];
};
texture_2d( src_texture_0, 0 );
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.texcoord = texcoord_vs_output;
    ps_output _output;
    float2 inv_texel = inv_texel_size[0].xy;
    float2 offset[9];
    offset[0] = float2(0.0, 0.0) * inv_texel;
    offset[1] = float2(1.0, 0.0) * inv_texel;
    offset[2] = float2(1.0, 1.0) * inv_texel;
    offset[3] = float2(0.0, 1.0) * inv_texel;
    offset[4] = float2(-1.0, 0.0) * inv_texel;
    offset[5] = float2(-1.0, -1.0) * inv_texel;
    offset[6] = float2(-1.0, 1.0) * inv_texel;
    offset[7] = float2(0.0, -1.0) * inv_texel;
    offset[8] = float2(1.0, -1.0) * inv_texel;
    float2 tc = _input.texcoord.xy;
    _output.colour = float4(0.0, 0.0, 0.0, 1.0);
    for(int i = 0; i < 9; ++i)
    {
        _output.colour += sample_texture( src_texture_0, tc + offset[i]);
    }
    _output.colour /= 9.0;
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//post_process depth_of_field ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 texcoord_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 texcoord;
};
struct ps_output
{
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
layout (std140) uniform material_data
{
    float m_focus_centre;
    float m_centre_range;
    float m_focus_width;
    float m_width_range;
};
texture_2d( src_texture_0, 0 );
texture_2d( src_texture_1, 1 );
texture_2d( src_texture_2, 2 );
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.texcoord = texcoord_vs_output;
    ps_output _output;
    float2 tc = _input.texcoord.xy;
    float z = sample_texture( src_texture_0, tc).r;
    float4 focus_colour = sample_texture( src_texture_1, tc);
    float4 blur_colour = sample_texture( src_texture_2, tc);
    float n = camera_view_pos.w;
    float f = camera_view_dir.w;
    float ez = (2.0 * n * f) / (f + n - z * (f - n));
    float lz = (ez - n) / (f - n);
    float centre_scale = m_centre_range / (f-n);
    float width_scale = m_width_range / (f-n);
    float fw = m_focus_width * width_scale;
    float d = (abs(lz - m_focus_centre * centre_scale));
    float r = saturate(smoothstep(d, -fw, fw));
    _output.colour = lerp(focus_colour, blur_colour, r);
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//post_process filter ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 texcoord_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 texcoord;
};
struct ps_output
{
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform src_info
{
    float4 inv_texel_size[8];
};
layout (std140) uniform filter_kernel
{
    float4 filter_info;
    float4 filter_offset_weight[16];
};
texture_2d( src_texture_0, 0 );
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.texcoord = texcoord_vs_output;
    ps_output _output;
    float2 inv_texel = inv_texel_size[0].xy;
    _output.colour = float4(0.0, 0.0, 0.0, 1.0);
    int lc = int(filter_info.z);
    for(int i = 0; i < lc; ++i)
    {
        float2 offset = (filter_offset_weight[i].x) * inv_texel * filter_info.xy;
        float w = filter_offset_weight[i].y;
        _output.colour += sample_texture( src_texture_0, _input.texcoord.xy + offset) * w;
    }
    _output.colour.a = 1.0;
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//post_process blit_colour_depth ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 texcoord_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 texcoord;
};
struct ps_output_colour_depth
{
    float4 colour;
    float depth;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
texture_2d( src_texture_0, 0 );
texture_2d( src_texture_1, 1 );
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.texcoord = texcoord_vs_output;
    ps_output_colour_depth _output;
    _output.colour = sample_texture( src_texture_0, _input.texcoord.xy );
    _output.depth = sample_texture( src_texture_1, _input.texcoord.xy ).r;
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
    depth_ps_output = _output.depth;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//post_process downsample_2x2 ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 texcoord_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 texcoord;
};
struct ps_output
{
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform src_info
{
    float4 inv_texel_size[8];
};
texture_2d( src_texture_0, 0 );
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.texcoord = texcoord_vs_output;
    ps_output _output;
    float2 inv_texel = inv_texel_size[0].xy;
    float2 offset[4];
    offset[0] = float2(0.0, 0.0) * inv_texel;
    offset[1] = float2(1.0, 0.0) * inv_texel;
    offset[2] = float2(1.0, 1.0) * inv_texel;
    offset[3] = float2(0.0, 1.0) * inv_texel;
    float2 tc = _input.texcoord.xy;
    _output.colour = float4(0.0, 0.0, 0.0, 1.0);
    _output.colour += sample_texture( src_texture_0, tc + offset[0]);
    _output.colour += sample_texture( src_texture_0, tc + offset[1]);
    _output.colour += sample_texture( src_texture_0, tc + offset[2]);
    _output.colour += sample_texture( src_texture_0, tc + offset[3]);
    _output.colour *= 0.25;
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//post_process blit_depth ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 texcoord_vs_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 texcoord;
};
struct ps_output_depth
{
    float depth;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
texture_2d( src_texture_0, 0 );
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.texcoord = texcoord_vs_output;
    ps_output_depth _output;
    _output.depth = sample_texture( src_texture_0, _input.texcoord.xy ).r;
    //assign glsl global outputs from structs
    depth_ps_output = _output.depth;
}
{
    "cmdline": "../third_party/pmbuild/scripts/pmfx-shader/build_pmfx.py -shader_platform gles -shader_version 300 -i assets/shaders ../assets/shaders -o build/web/data/pmfx/glsl -h shader_structs -t temp/shaders -v_flip -source ",
    "files": [
        {
            "name": "/Users/alex.dixon/dev/pmtech/third_party/pmbuild/scripts/pmfx-shader/build_pmfx.py",
            "timestamp": 1608637107.3205462
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/third_party/pmbuild/scripts/pmfx-shader/platform/pmfx.h",
            "timestamp": 1605953217.8167121
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/third_party/pmbuild/scripts/pmfx-shader/platform/glsl.h",
            "timestamp": 1608635330.6987193
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/examples/../assets/shaders/post_process.pmfx",
            "timestamp": 1608572067.1992607
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/examples/../assets/shaders/libs/globals.pmfx",
            "timestamp": 1608572067.200933
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/examples/../assets/shaders/libs/maths.pmfx",
            "timestamp": 1608572067.2011206
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/examples/../assets/shaders/libs/lighting.pmfx",
            "timestamp": 1608572067.1994717
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/examples/../assets/shaders/ray_march.pmfx",
            "timestamp": 1608572067.2020185
        }
    ],
    "techniques": [
        {
            "vs": "vs_ndc_quad",
            "ps": "ps_blit",
            "name": "blit",
            "texture_sampler_bindings": [
                {
                    "name": "src_texture_0",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "src_texture_1",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "src_texture_2",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "src_texture_3",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 3
                },
                {
                    "name": "src_texture_4",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 4
                },
                {
                    "name": "src_texture_5",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 5
                },
                {
                    "name": "src_texture_6",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 6
                },
                {
                    "name": "src_texture_7",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 7
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "src_info",
                    "location": 10
                },
                {
                    "name": "filter_kernel",
                    "location": 2
                },
                {
                    "name": "pp_info",
                    "location": 4
                },
                {
                    "name": "taa_cbuffer",
                    "location": 3
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "texcoord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "texcoord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "vs_file": "blit.vsc",
            "ps_file": "blit.psc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        },
        {
            "vs": "vs_ndc_quad",
            "ps": "ps_blit_rgb",
            "name": "blit_rgb",
            "texture_sampler_bindings": [
                {
                    "name": "src_texture_0",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "src_texture_1",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "src_texture_2",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "src_texture_3",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 3
                },
                {
                    "name": "src_texture_4",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 4
                },
                {
                    "name": "src_texture_5",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 5
                },
                {
                    "name": "src_texture_6",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 6
                },
                {
                    "name": "src_texture_7",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 7
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "src_info",
                    "location": 10
                },
                {
                    "name": "filter_kernel",
                    "location": 2
                },
                {
                    "name": "pp_info",
                    "location": 4
                },
                {
                    "name": "taa_cbuffer",
                    "location": 3
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "texcoord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "texcoord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "vs_file": "blit.vsc",
            "ps_file": "blit_rgb.psc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        },
        {
            "vs": "vs_ndc_quad",
            "ps": "ps_blit_depth",
            "name": "blit_depth",
            "texture_sampler_bindings": [
                {
                    "name": "src_texture_0",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "src_texture_1",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "src_texture_2",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "src_texture_3",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 3
                },
                {
                    "name": "src_texture_4",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 4
                },
                {
                    "name": "src_texture_5",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 5
                },
                {
                    "name": "src_texture_6",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 6
                },
                {
                    "name": "src_texture_7",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 7
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "src_info",
                    "location": 10
                },
                {
                    "name": "filter_kernel",
                    "location": 2
                },
                {
                    "name": "pp_info",
                    "location": 4
                },
                {
                    "name": "taa_cbuffer",
                    "location": 3
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "texcoord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "texcoord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "vs_file": "blit.vsc",
            "ps_file": "blit_depth.psc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        },
        {
            "vs": "vs_ndc_quad",
            "ps": "ps_blit_depth_unjittered",
            "name": "blit_depth_unjittered",
            "texture_sampler_bindings": [
                {
                    "name": "src_texture_0",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "src_texture_1",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "src_texture_2",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "src_texture_3",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 3
                },
                {
                    "name": "src_texture_4",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 4
                },
                {
                    "name": "src_texture_5",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 5
                },
                {
                    "name": "src_texture_6",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 6
                },
                {
                    "name": "src_texture_7",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 7
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "src_info",
                    "location": 10
                },
                {
                    "name": "filter_kernel",
                    "location": 2
                },
                {
                    "name": "pp_info",
                    "location": 4
                },
                {
                    "name": "taa_cbuffer",
                    "location": 3
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "texcoord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "texcoord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "vs_file": "blit.vsc",
            "ps_file": "blit_depth_unjittered.psc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        },
        {
            "vs": "vs_ndc_quad",
            "ps": "ps_blit_colour_depth",
            "name": "blit_colour_depth",
            "texture_sampler_bindings": [
                {
                    "name": "src_texture_0",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "src_texture_1",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "src_texture_2",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "src_texture_3",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 3
                },
                {
                    "name": "src_texture_4",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 4
                },
                {
                    "name": "src_texture_5",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 5
                },
                {
                    "name": "src_texture_6",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 6
                },
                {
                    "name": "src_texture_7",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 7
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "src_info",
                    "location": 10
                },
                {
                    "name": "filter_kernel",
                    "location": 2
                },
                {
                    "name": "pp_info",
                    "location": 4
                },
                {
                    "name": "taa_cbuffer",
                    "location": 3
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "texcoord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "texcoord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "vs_file": "blit.vsc",
            "ps_file": "blit_colour_depth.psc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        },
        {
            "vs": "vs_ndc_quad",
            "ps": "ps_debug",
            "name": "debug",
            "texture_sampler_bindings": [
                {
                    "name": "src_texture_0",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "src_texture_1",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "src_texture_2",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "src_texture_3",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 3
                },
                {
                    "name": "src_texture_4",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 4
                },
                {
                    "name": "src_texture_5",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 5
                },
                {
                    "name": "src_texture_6",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 6
                },
                {
                    "name": "src_texture_7",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 7
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "src_info",
                    "location": 10
                },
                {
                    "name": "filter_kernel",
                    "location": 2
                },
                {
                    "name": "pp_info",
                    "location": 4
                },
                {
                    "name": "taa_cbuffer",
                    "location": 3
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "texcoord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "texcoord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "vs_file": "blit.vsc",
            "ps_file": "debug.psc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        },
        {
            "vs": "vs_ndc_quad",
            "ps": "ps_colour_lut",
            "texture_samplers": {
                "lookup_texture": {
                    "type": "texture_2d",
                    "unit": 8,
                    "shader": "ps",
                    "sampler": "clamp_linear",
                    "default": "data/textures/luts/identity.dds"
                }
            },
            "name": "colour_lut",
            "texture_sampler_bindings": [
                {
                    "name": "src_texture_0",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "src_texture_1",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "src_texture_2",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "src_texture_3",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 3
                },
                {
                    "name": "src_texture_4",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 4
                },
                {
                    "name": "src_texture_5",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 5
                },
                {
                    "name": "src_texture_6",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 6
                },
                {
                    "name": "src_texture_7",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 7
                },
                {
                    "name": "lookup_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "src_info",
                    "location": 10
                },
                {
                    "name": "filter_kernel",
                    "location": 2
                },
                {
                    "name": "pp_info",
                    "location": 4
                },
                {
                    "name": "taa_cbuffer",
                    "location": 3
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "texcoord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "texcoord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "vs_file": "blit.vsc",
            "ps_file": "colour_lut.psc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        },
        {
            "vs": "vs_ndc_quad",
            "ps": "ps_high_pass",
            "constants": {
                "threshold": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.5,
                    "offset": 0,
                    "num_elements": 1
                },
                "smoothness": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.5,
                    "offset": 1,
                    "num_elements": 1
                }
            },
            "constants_used_bytes": 8,
            "constants_size_bytes": 16,
            "name": "high_pass",
            "texture_sampler_bindings": [
                {
                    "name": "src_texture_0",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "src_texture_1",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "src_texture_2",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "src_texture_3",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 3
                },
                {
                    "name": "src_texture_4",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 4
                },
                {
                    "name": "src_texture_5",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 5
                },
                {
                    "name": "src_texture_6",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 6
                },
                {
                    "name": "src_texture_7",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 7
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "src_info",
                    "location": 10
                },
                {
                    "name": "filter_kernel",
                    "location": 2
                },
                {
                    "name": "pp_info",
                    "location": 4
                },
                {
                    "name": "taa_cbuffer",
                    "location": 3
                },
                {
                    "name": "material_data",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "texcoord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "texcoord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "vs_file": "blit.vsc",
            "ps_file": "high_pass.psc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        },
        {
            "vs": "vs_ndc_quad",
            "ps": "ps_filter",
            "name": "filter",
            "texture_sampler_bindings": [
                {
                    "name": "src_texture_0",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "src_texture_1",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "src_texture_2",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "src_texture_3",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 3
                },
                {
                    "name": "src_texture_4",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 4
                },
                {
                    "name": "src_texture_5",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 5
                },
                {
                    "name": "src_texture_6",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 6
                },
                {
                    "name": "src_texture_7",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 7
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "src_info",
                    "location": 10
                },
                {
                    "name": "filter_kernel",
                    "location": 2
                },
                {
                    "name": "pp_info",
                    "location": 4
                },
                {
                    "name": "taa_cbuffer",
                    "location": 3
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "texcoord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "texcoord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "vs_file": "blit.vsc",
            "ps_file": "filter.psc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        },
        {
            "vs": "vs_ndc_quad",
            "ps": "ps_downsample_2x2",
            "name": "downsample_2x2",
            "texture_sampler_bindings": [
                {
                    "name": "src_texture_0",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "src_texture_1",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "src_texture_2",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "src_texture_3",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 3
                },
                {
                    "name": "src_texture_4",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 4
                },
                {
                    "name": "src_texture_5",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 5
                },
                {
                    "name": "src_texture_6",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 6
                },
                {
                    "name": "src_texture_7",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 7
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "src_info",
                    "location": 10
                },
                {
                    "name": "filter_kernel",
                    "location": 2
                },
                {
                    "name": "pp_info",
                    "location": 4
                },
                {
                    "name": "taa_cbuffer",
                    "location": 3
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "texcoord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "texcoord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "vs_file": "blit.vsc",
            "ps_file": "downsample_2x2.psc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        },
        {
            "vs": "vs_ndc_quad",
            "ps": "ps_downsample_average",
            "name": "downsample_average",
            "texture_sampler_bindings": [
                {
                    "name": "src_texture_0",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "src_texture_1",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "src_texture_2",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "src_texture_3",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 3
                },
                {
                    "name": "src_texture_4",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 4
                },
                {
                    "name": "src_texture_5",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 5
                },
                {
                    "name": "src_texture_6",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 6
                },
                {
                    "name": "src_texture_7",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 7
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "src_info",
                    "location": 10
                },
                {
                    "name": "filter_kernel",
                    "location": 2
                },
                {
                    "name": "pp_info",
                    "location": 4
                },
                {
                    "name": "taa_cbuffer",
                    "location": 3
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "texcoord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "texcoord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "vs_file": "blit.vsc",
            "ps_file": "downsample_average.psc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        },
        {
            "vs": "vs_ndc_quad",
            "ps": "ps_bloom_upsample",
            "constants": {
                "intensity": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.5,
                    "offset": 0,
                    "num_elements": 1
                }
            },
            "constants_used_bytes": 4,
            "constants_size_bytes": 16,
            "name": "bloom_upsample",
            "texture_sampler_bindings": [
                {
                    "name": "src_texture_0",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "src_texture_1",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "src_texture_2",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "src_texture_3",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 3
                },
                {
                    "name": "src_texture_4",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 4
                },
                {
                    "name": "src_texture_5",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 5
                },
                {
                    "name": "src_texture_6",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 6
                },
                {
                    "name": "src_texture_7",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 7
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "src_info",
                    "location": 10
                },
                {
                    "name": "filter_kernel",
                    "location": 2
                },
                {
                    "name": "pp_info",
                    "location": 4
                },
                {
                    "name": "taa_cbuffer",
                    "location": 3
                },
                {
                    "name": "material_data",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "texcoord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "texcoord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "vs_file": "blit.vsc",
            "ps_file": "bloom_upsample.psc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        },
        {
            "vs": "vs_ndc_quad",
            "ps": "ps_depth_of_field",
            "constants": {
                "focus_centre": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.5,
                    "offset": 0,
                    "num_elements": 1
                },
                "centre_range": {
                    "type": "float",
                    "widget": "input",
                    "default": 100,
                    "offset": 1,
                    "num_elements": 1
                },
                "focus_width": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.5,
                    "offset": 2,
                    "num_elements": 1
                },
                "width_range": {
                    "type": "float",
                    "widget": "input",
                    "default": 20,
                    "offset": 3,
                    "num_elements": 1
                }
            },
            "constants_used_bytes": 16,
            "constants_size_bytes": 16,
            "name": "depth_of_field",
            "texture_sampler_bindings": [
                {
                    "name": "src_texture_0",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "src_texture_1",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "src_texture_2",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "src_texture_3",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 3
                },
                {
                    "name": "src_texture_4",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 4
                },
                {
                    "name": "src_texture_5",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 5
                },
                {
                    "name": "src_texture_6",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 6
                },
                {
                    "name": "src_texture_7",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 7
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "src_info",
                    "location": 10
                },
                {
                    "name": "filter_kernel",
                    "location": 2
                },
                {
                    "name": "pp_info",
                    "location": 4
                },
                {
                    "name": "taa_cbuffer",
                    "location": 3
                },
                {
                    "name": "material_data",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "texcoord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "texcoord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "vs_file": "blit.vsc",
            "ps_file": "depth_of_field.psc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        },
        {
            "vs": "vs_ndc_quad",
            "ps": "ps_menger",
            "name": "menger_sponge",
            "texture_sampler_bindings": [
                {
                    "name": "src_texture_0",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "src_texture_1",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "src_texture_2",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "src_texture_3",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 3
                },
                {
                    "name": "src_texture_4",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 4
                },
                {
                    "name": "src_texture_5",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 5
                },
                {
                    "name": "src_texture_6",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 6
                },
                {
                    "name": "src_texture_7",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 7
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "src_info",
                    "location": 10
                },
                {
                    "name": "filter_kernel",
                    "location": 2
                },
                {
                    "name": "pp_info",
                    "location": 4
                },
                {
                    "name": "taa_cbuffer",
                    "location": 3
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "texcoord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "texcoord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "vs_file": "blit.vsc",
            "ps_file": "menger_sponge.psc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        },
        {
            "vs": "vs_ndc_quad",
            "ps": "ps_crt",
            "name": "crt",
            "texture_sampler_bindings": [
                {
                    "name": "src_texture_0",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "src_texture_1",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "src_texture_2",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "src_texture_3",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 3
                },
                {
                    "name": "src_texture_4",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 4
                },
                {
                    "name": "src_texture_5",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 5
                },
                {
                    "name": "src_texture_6",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 6
                },
                {
                    "name": "src_texture_7",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 7
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "src_info",
                    "location": 10
                },
                {
                    "name": "filter_kernel",
                    "location": 2
                },
                {
                    "name": "pp_info",
                    "location": 4
                },
                {
                    "name": "taa_cbuffer",
                    "location": 3
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "texcoord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "texcoord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "vs_file": "blit.vsc",
            "ps_file": "crt.psc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        },
        {
            "vs": "vs_ndc_quad",
            "ps": "ps_sss_reflectance",
            "name": "sss_reflectance",
            "texture_sampler_bindings": [
                {
                    "name": "src_texture_0",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "src_texture_1",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "src_texture_2",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "src_texture_3",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 3
                },
                {
                    "name": "src_texture_4",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 4
                },
                {
                    "name": "src_texture_5",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 5
                },
                {
                    "name": "src_texture_6",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 6
                },
                {
                    "name": "src_texture_7",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 7
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "src_info",
                    "location": 10
                },
                {
                    "name": "filter_kernel",
                    "location": 2
                },
                {
                    "name": "pp_info",
                    "location": 4
                },
                {
                    "name": "taa_cbuffer",
                    "location": 3
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "texcoord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "texcoord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "vs_file": "blit.vsc",
            "ps_file": "sss_reflectance.psc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        },
        {
            "vs": "vs_ndc_quad",
            "ps": "ps_taa_resolve",
            "name": "taa_resolve",
            "texture_sampler_bindings": [
                {
                    "name": "src_texture_0",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "src_texture_1",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "src_texture_2",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "src_texture_3",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 3
                },
                {
                    "name": "src_texture_4",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 4
                },
                {
                    "name": "src_texture_5",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 5
                },
                {
                    "name": "src_texture_6",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 6
                },
                {
                    "name": "src_texture_7",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 7
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "src_info",
                    "location": 10
                },
                {
                    "name": "filter_kernel",
                    "location": 2
                },
                {
                    "name": "pp_info",
                    "location": 4
                },
                {
                    "name": "taa_cbuffer",
                    "location": 3
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "texcoord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "texcoord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "vs_file": "blit.vsc",
            "ps_file": "taa_resolve.psc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        }
    ],
    "failures": {}
}#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//post_process colour_lut ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 texcoord_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 texcoord;
};
struct ps_output
{
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
texture_2d( src_texture_0, 0 );
texture_2d( lookup_texture, 8 );
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.texcoord = texcoord_vs_output;
    ps_output _output;
    float2 tc = _input.texcoord.xy;
    float4 input_colour = sample_texture(src_texture_0, tc);
    float input_b = input_colour.b * 63.0;
    float2 quad_1;
    quad_1.y = floor(floor(input_b) / 8.0);
    quad_1.x = floor(input_b) - (quad_1.y * 8.0);
    float2 quad_2;
    quad_2.y = floor(ceil(input_b) / 8.0);
    quad_2.x = ceil(input_b) - (quad_2.y * 8.0);
    float2 tc_1;
    tc_1.x = (quad_1.x * 0.125) + 0.5 / 512.0 + ((0.125 - 1.0 / 512.0) * input_colour.r);
    tc_1.y = (quad_1.y * 0.125) + 0.5 / 512.0 + ((0.125 - 1.0 / 512.0) * input_colour.g);
    float2 tc_2;
    tc_2.x = (quad_2.x * 0.125) + 0.5 / 512.0 + ((0.125 - 1.0 / 512.0) * input_colour.r);
    tc_2.y = (quad_2.y * 0.125) + 0.5 / 512.0 + ((0.125 - 1.0 / 512.0) * input_colour.g);
    float4 remapped_1 = sample_texture_level(lookup_texture, tc_1, 0.0);
    float4 remapped_2 = sample_texture_level(lookup_texture, tc_2, 0.0);
    _output.colour = lerp(remapped_1, remapped_2, frac(input_b));
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//post_process bloom_upsample ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 texcoord_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 texcoord;
};
struct ps_output
{
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform material_data
{
    float m_intensity;
    float3 m_padding;
};
texture_2d( src_texture_0, 0 );
texture_2d( src_texture_1, 1 );
texture_2d( src_texture_2, 2 );
texture_2d( src_texture_3, 3 );
texture_2d( src_texture_4, 4 );
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.texcoord = texcoord_vs_output;
    ps_output _output;
    float2 tc = _input.texcoord.xy;
    _output.colour = sample_texture( src_texture_0, tc);
    float4 bloom = float4(0.0, 0.0, 0.0, 0.0);
    bloom += sample_texture( src_texture_1, tc);
    bloom += sample_texture( src_texture_2, tc);
    bloom += sample_texture( src_texture_3, tc);
    bloom += sample_texture( src_texture_4, tc);
    bloom *= 0.25;
    _output.colour += bloom * m_intensity;
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//post_process blit ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 texcoord_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 texcoord;
};
struct ps_output
{
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
texture_2d( src_texture_0, 0 );
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.texcoord = texcoord_vs_output;
    ps_output _output;
    _output.colour = sample_texture( src_texture_0, _input.texcoord.xy );
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//post_process crt ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 texcoord_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 texcoord;
};
struct ps_output
{
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform src_info
{
    float4 inv_texel_size[8];
};
texture_2d( src_texture_0, 0 );
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.texcoord = texcoord_vs_output;
    ps_output _output;
    float2 tc = _input.texcoord.xy;
    float2 cc = tc - 0.5;
    float dist = dot(cc, cc) * 0.07;
    tc = tc * (tc + cc * (1.0 + dist) * dist) / tc;
    float2 inv_texel = inv_texel_size[0].xy;
    float2 ca = float2(inv_texel.x * 2.0, 0.0);
    _output.colour.r = sample_texture(src_texture_0, tc - ca).r;
    _output.colour.g = sample_texture(src_texture_0, tc).g;
    _output.colour.b = sample_texture(src_texture_0, tc + ca).b;
    _output.colour.a = 1.0;
    _output.colour.rgb *= abs(sin(tc.y / inv_texel.y));
    if(tc.x < 0.0 || tc.x > 1.0 || tc.y < 0.0 || tc.y > 1.0)
    _output.colour *= 0.0;
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//shader_toy default vs 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
layout(location = 0) in float4 position_vs_input;
layout(location = 1) in float2 tex_coord_vs_input;
out float2 tex_coord_vs_output;
out float time_vs_output;
uniform float v_flip;
struct vs_input
{
    float4 position;
    float2 tex_coord;
};
struct vs_output
{
    float4 position;
    float2 tex_coord;
    float time;
};
layout (std140) uniform per_pass_view
{
    float4x4 projection_matrix;
};
layout (std140) uniform per_pass_params
{
    float4 size_time;
    float4 test;
};
void main()
{
    //assign vs_input struct from glsl inputs
    vs_input _input;
    _input.position = position_vs_input;
    _input.tex_coord = tex_coord_vs_input;
    vs_output _output;
    _output.position = mul( projection_matrix, float4( _input.position.x * size_time.x, _input.position.y * size_time.y, 0.0f, 1.0f ) );
    _output.time = size_time.z;
    _output.tex_coord = _input.tex_coord;
    //assign glsl global outputs from structs
    gl_Position = _output.position;
    gl_Position.y *= v_flip;
    tex_coord_vs_output = _output.tex_coord;
    time_vs_output = _output.time;
}
{
    "cmdline": "../third_party/pmbuild/scripts/pmfx-shader/build_pmfx.py -shader_platform gles -shader_version 300 -i assets/shaders ../assets/shaders -o build/web/data/pmfx/glsl -h shader_structs -t temp/shaders -v_flip -source ",
    "files": [
        {
            "name": "/Users/alex.dixon/dev/pmtech/third_party/pmbuild/scripts/pmfx-shader/build_pmfx.py",
            "timestamp": 1608637107.3205462
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/third_party/pmbuild/scripts/pmfx-shader/platform/pmfx.h",
            "timestamp": 1605953217.8167121
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/third_party/pmbuild/scripts/pmfx-shader/platform/glsl.h",
            "timestamp": 1608635330.6987193
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/examples/assets/shaders/shader_toy.pmfx",
            "timestamp": 1608572067.195472
        }
    ],
    "techniques": [
        {
            "vs": "vs_main",
            "ps": "ps_main",
            "name": "default",
            "texture_sampler_bindings": [
                {
                    "name": "tex0",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "tex1",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "tex2",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_pass_params",
                    "location": 1
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "tex_coord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 8,
                    "element_size": 4,
                    "num_elements": 2,
                    "offset": 16
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "tex_coord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 8,
                    "element_size": 4,
                    "num_elements": 2,
                    "offset": 16
                },
                {
                    "name": "time",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 4,
                    "element_size": 4,
                    "num_elements": 1,
                    "offset": 24
                }
            ],
            "vs_file": "default.vsc",
            "ps_file": "default.psc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        }
    ],
    "failures": {}
}#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//shader_toy default ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float2 tex_coord_vs_output;
in float time_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float2 tex_coord;
    float time;
};
struct ps_output
{
    float4 colour;
};
texture_2d( tex0, 0 );
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.tex_coord = tex_coord_vs_output;
    _input.time = time_vs_output;
    ps_output _output;
    _output.colour = sample_texture( tex0, _input.tex_coord.xy ) * float4( sin( _input.time * 0.01 ), 1.0, 0.0, 1.0 );
    _output.colour.a = 1.0;
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//trace box vs 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
layout(location = 0) in float4 position_vs_input;
layout(location = 1) in float4 texcoord_vs_input;
out float4 texcoord_vs_output;
uniform float v_flip;
struct vs_input
{
    float4 position;
    float4 texcoord;
};
struct vs_output
{
    float4 position;
    float4 texcoord;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
void main()
{
    //assign vs_input struct from glsl inputs
    vs_input _input;
    _input.position = position_vs_input;
    _input.texcoord = texcoord_vs_input;
    vs_output _output;
    _output.position = _input.position;
    _output.texcoord = _input.texcoord;
    //assign glsl global outputs from structs
    gl_Position = _output.position;
    gl_Position.y *= v_flip;
    texcoord_vs_output = _output.texcoord;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//trace torus ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 texcoord_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 texcoord;
};
struct ps_output
{
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform per_draw_call
{
    float4x4 world_matrix;
    float4 user_data;
    float4 user_data2;
    float4x4 world_matrix_inv_transpose;
};
float sd_torus(float3 p, float2 t)
{
    float2 q = float2(length(p.xy) - t.x,p.z);
    return length(q)-t.y;
}
float3x3 create_camera( float3 ro, float3 ta, float cr )
{
    float3 cw = normalize(ta-ro);
    float3 cp = float3(sin(cr), cos(cr), 0.0);
    float3 cu = normalize( cross(cw,cp) );
    float3 cv = cross(cu,cw);
    return from_columns_3x3( cu, cv, cw );
}
float bsin(float v)
{
    return sin(v) * 0.5 + 1.0;
}
float bcos(float v)
{
    return cos(v) * 0.5 + 1.0;
}
float3 irrid(float3 n, float3 rd)
{
    float nv = dot(n, -rd);
    float3 col = float3(0.0, 0.0, 0.0);
    col += sin(nv * float3(0.0, 1.0, 0.0) * 10.0 * 1.5) * 0.5 + 0.5;
    col += sin(nv * float3(1.0, 0.0, 0.0) * 20.0 * 1.5) * 0.5 + 0.5;
    col += sin(nv * float3(0.0, 0.0, 1.0) * 5.0 * 1.5) * 0.5 + 0.5;
    return clamp(normalize(col), 0.0, 1.0);
}
void cam_anim(float2 uv, float time, out float3 ro, out float3 rd)
{
    ro = float3(cos(time) * 10.0, 0.0, sin(time) * 10.0);
    float3 ta = float3( -0.5, -0.4, 0.5 );
    float3x3 cam = create_camera( ro, ta, time );
    float2 p = (uv * 2.0) - 1.0;
    rd = mul( normalize( float3(p.x, p.y, 2.0) ), cam);
}
float2 bend_tc(float2 uv)
{
    float2 tc = uv;
    float2 cc = tc - 0.5;
    float dist = dot(cc, cc) * 0.07;
    tc = tc * (tc + cc * (1.0 + dist) * dist) / tc;
    return tc;
}
float3 crt_c(float3 src, float2 tc)
{
    float2 inv_texel = float2(1.0/640.0, 1.0/480.0);
    float2 ca = float2(inv_texel.x * 2.0, 0.0);
    src.rgb *= saturate(abs(sin(tc.y / inv_texel.y/2.0)) + 0.5);
    return src;
}
float3 sky(float3 v, float time)
{
    float3 grad_a = float3(0.5, 0.5, 0.0);
    float3 grad_b = float3(0.5, 0.0, 1.0);
    grad_a = float3(bcos(time), 0.2, bcos(-time));
    grad_b = float3(bsin(time), bsin(-time), 0.2);
    float grad_t = v.y * 0.5 + 0.5;
    return lerp(grad_b, grad_a, grad_t);
}
float map_torus(float3 p)
{
    return sd_torus(p, float2(2.5, 1.0));
}
float3 calc_normal_torus(float3 pos)
{
    float3 eps = float3(0.001, 0.0, 0.0);
    float3 nor;
    nor.x = map_torus(pos+eps.xyy) - map_torus(pos-eps.xyy);
    nor.y = map_torus(pos+eps.yxy) - map_torus(pos-eps.yxy);
    nor.z = map_torus(pos+eps.yyx) - map_torus(pos-eps.yyx);
    return normalize(nor);
}
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.texcoord = texcoord_vs_output;
    float2 uv = bend_tc(_input.texcoord.xy);
    float eps = 0.005;
    float iTime = mod(user_data.y * 0.003, 200.0);
    float2 iResolution = float2(640.0, 480.0);
    float3 ro;
    float3 rd;
    cam_anim(uv, iTime, ro, rd);
    float d = 10.0;
    float xt = 0.0;
    float3 pp = ro;
    for(float t = 0.0; t < 30.0; ++t)
    {
        pp = ro + rd * xt;
        d = map_torus(pp);
        if(d < eps)
        break;
        xt += d;
    }
    float3 n = calc_normal_torus(pp);
    float3 col = irrid(n, rd);
    float mask = step(d, eps);
    float inv_mask = 1.0 - mask;
    float3 csky = sky(rd, iTime + 10.0);
    csky = csky.zxy;
    float3 cc = crt_c(csky * inv_mask + col * mask, uv);
    ps_output _output;
    _output.colour = float4(cc, 1.0);
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
{
    "cmdline": "../third_party/pmbuild/scripts/pmfx-shader/build_pmfx.py -shader_platform gles -shader_version 300 -i assets/shaders ../assets/shaders -o build/web/data/pmfx/glsl -h shader_structs -t temp/shaders -v_flip -source ",
    "files": [
        {
            "name": "/Users/alex.dixon/dev/pmtech/third_party/pmbuild/scripts/pmfx-shader/build_pmfx.py",
            "timestamp": 1608637107.3205462
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/third_party/pmbuild/scripts/pmfx-shader/platform/pmfx.h",
            "timestamp": 1605953217.8167121
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/third_party/pmbuild/scripts/pmfx-shader/platform/glsl.h",
            "timestamp": 1608635330.6987193
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/examples/../assets/shaders/trace.pmfx",
            "timestamp": 1608721556.2873125
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/examples/../assets/shaders/libs/globals.pmfx",
            "timestamp": 1608572067.200933
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/examples/../assets/shaders/libs/maths.pmfx",
            "timestamp": 1608572067.2011206
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/examples/../assets/shaders/libs/lighting.pmfx",
            "timestamp": 1608572067.1994717
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/examples/../assets/shaders/ray_march.pmfx",
            "timestamp": 1608572067.2020185
        }
    ],
    "techniques": [
        {
            "vs": "vs_ndc_quad",
            "ps": "ps_box",
            "name": "box",
            "texture_sampler_bindings": [],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "texcoord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "texcoord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "vs_file": "box.vsc",
            "ps_file": "box.psc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        },
        {
            "vs": "vs_ndc_quad",
            "ps": "ps_octahedron",
            "name": "octahedron",
            "texture_sampler_bindings": [],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "texcoord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "texcoord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "vs_file": "box.vsc",
            "ps_file": "octahedron.psc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        },
        {
            "vs": "vs_ndc_quad",
            "ps": "ps_torus",
            "name": "torus",
            "texture_sampler_bindings": [],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "texcoord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "texcoord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "vs_file": "box.vsc",
            "ps_file": "torus.psc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        }
    ],
    "failures": {}
}#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//trace box ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 texcoord_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 texcoord;
};
struct ps_output
{
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform per_draw_call
{
    float4x4 world_matrix;
    float4 user_data;
    float4 user_data2;
    float4x4 world_matrix_inv_transpose;
};
float sd_box(float3 p, float3 b)
{
    float3 d = abs(p) - b;
    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
}
float3x3 create_camera( float3 ro, float3 ta, float cr )
{
    float3 cw = normalize(ta-ro);
    float3 cp = float3(sin(cr), cos(cr), 0.0);
    float3 cu = normalize( cross(cw,cp) );
    float3 cv = cross(cu,cw);
    return from_columns_3x3( cu, cv, cw );
}
float bsin(float v)
{
    return sin(v) * 0.5 + 1.0;
}
float bcos(float v)
{
    return cos(v) * 0.5 + 1.0;
}
float3 irrid(float3 n, float3 rd)
{
    float nv = dot(n, -rd);
    float3 col = float3(0.0, 0.0, 0.0);
    col += sin(nv * float3(0.0, 1.0, 0.0) * 10.0 * 1.5) * 0.5 + 0.5;
    col += sin(nv * float3(1.0, 0.0, 0.0) * 20.0 * 1.5) * 0.5 + 0.5;
    col += sin(nv * float3(0.0, 0.0, 1.0) * 5.0 * 1.5) * 0.5 + 0.5;
    return clamp(normalize(col), 0.0, 1.0);
}
void cam_anim(float2 uv, float time, out float3 ro, out float3 rd)
{
    ro = float3(cos(time) * 10.0, 0.0, sin(time) * 10.0);
    float3 ta = float3( -0.5, -0.4, 0.5 );
    float3x3 cam = create_camera( ro, ta, time );
    float2 p = (uv * 2.0) - 1.0;
    rd = mul( normalize( float3(p.x, p.y, 2.0) ), cam);
}
float2 bend_tc(float2 uv)
{
    float2 tc = uv;
    float2 cc = tc - 0.5;
    float dist = dot(cc, cc) * 0.07;
    tc = tc * (tc + cc * (1.0 + dist) * dist) / tc;
    return tc;
}
float3 crt_c(float3 src, float2 tc)
{
    float2 inv_texel = float2(1.0/640.0, 1.0/480.0);
    float2 ca = float2(inv_texel.x * 2.0, 0.0);
    src.rgb *= saturate(abs(sin(tc.y / inv_texel.y/2.0)) + 0.5);
    return src;
}
float3 sky(float3 v, float time)
{
    float3 grad_a = float3(0.5, 0.5, 0.0);
    float3 grad_b = float3(0.5, 0.0, 1.0);
    grad_a = float3(bcos(time), 0.2, bcos(-time));
    grad_b = float3(bsin(time), bsin(-time), 0.2);
    float grad_t = v.y * 0.5 + 0.5;
    return lerp(grad_b, grad_a, grad_t);
}
float map_box(float3 p)
{
    return sd_box(p, float3(2.5, 2.5, 2.5));
}
float3 calc_normal_box(float3 pos)
{
    float3 eps = float3(0.001, 0.0, 0.0);
    float3 nor;
    nor.x = map_box(pos+eps.xyy) - map_box(pos-eps.xyy);
    nor.y = map_box(pos+eps.yxy) - map_box(pos-eps.yxy);
    nor.z = map_box(pos+eps.yyx) - map_box(pos-eps.yyx);
    return normalize(nor);
}
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.texcoord = texcoord_vs_output;
    float2 uv = bend_tc(_input.texcoord.xy);
    float eps = 0.005;
    float iTime = mod(user_data.y * 0.003, 200.0);
    float2 iResolution = float2(640.0, 480.0);
    float3 ro;
    float3 rd;
    cam_anim(uv, iTime, ro, rd);
    float d = 10.0;
    float xt = 0.0;
    float3 pp = ro;
    for(float t = 0.0; t < 20.0; ++t)
    {
        pp = ro + rd * xt;
        d = map_box(pp);
        if(d < eps)
        break;
        xt += d;
    }
    float3 n = calc_normal_box(pp);
    float3 col = irrid(n, rd);
    float mask = step(d, eps);
    float inv_mask = 1.0 - mask;
    float3 csky = sky(rd, iTime + 10.0);
    float3 cc = crt_c(csky * inv_mask + col * mask, uv);
    ps_output _output;
    _output.colour = float4(cc, 1.0);
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//trace octahedron ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 texcoord_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 texcoord;
};
struct ps_output
{
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform per_draw_call
{
    float4x4 world_matrix;
    float4 user_data;
    float4 user_data2;
    float4x4 world_matrix_inv_transpose;
};
float sd_octahedron(float3 p, float s )
{
    p = abs(p);
    return (p.x + p.y + p.z - s)*0.57735027;
}
float3x3 create_camera( float3 ro, float3 ta, float cr )
{
    float3 cw = normalize(ta-ro);
    float3 cp = float3(sin(cr), cos(cr), 0.0);
    float3 cu = normalize( cross(cw,cp) );
    float3 cv = cross(cu,cw);
    return from_columns_3x3( cu, cv, cw );
}
float bsin(float v)
{
    return sin(v) * 0.5 + 1.0;
}
float bcos(float v)
{
    return cos(v) * 0.5 + 1.0;
}
float3 irrid(float3 n, float3 rd)
{
    float nv = dot(n, -rd);
    float3 col = float3(0.0, 0.0, 0.0);
    col += sin(nv * float3(0.0, 1.0, 0.0) * 10.0 * 1.5) * 0.5 + 0.5;
    col += sin(nv * float3(1.0, 0.0, 0.0) * 20.0 * 1.5) * 0.5 + 0.5;
    col += sin(nv * float3(0.0, 0.0, 1.0) * 5.0 * 1.5) * 0.5 + 0.5;
    return clamp(normalize(col), 0.0, 1.0);
}
void cam_anim(float2 uv, float time, out float3 ro, out float3 rd)
{
    ro = float3(cos(time) * 10.0, 0.0, sin(time) * 10.0);
    float3 ta = float3( -0.5, -0.4, 0.5 );
    float3x3 cam = create_camera( ro, ta, time );
    float2 p = (uv * 2.0) - 1.0;
    rd = mul( normalize( float3(p.x, p.y, 2.0) ), cam);
}
float2 bend_tc(float2 uv)
{
    float2 tc = uv;
    float2 cc = tc - 0.5;
    float dist = dot(cc, cc) * 0.07;
    tc = tc * (tc + cc * (1.0 + dist) * dist) / tc;
    return tc;
}
float3 crt_c(float3 src, float2 tc)
{
    float2 inv_texel = float2(1.0/640.0, 1.0/480.0);
    float2 ca = float2(inv_texel.x * 2.0, 0.0);
    src.rgb *= saturate(abs(sin(tc.y / inv_texel.y/2.0)) + 0.5);
    return src;
}
float3 sky(float3 v, float time)
{
    float3 grad_a = float3(0.5, 0.5, 0.0);
    float3 grad_b = float3(0.5, 0.0, 1.0);
    grad_a = float3(bcos(time), 0.2, bcos(-time));
    grad_b = float3(bsin(time), bsin(-time), 0.2);
    float grad_t = v.y * 0.5 + 0.5;
    return lerp(grad_b, grad_a, grad_t);
}
float map_octahedron(float3 p)
{
    return sd_octahedron(p, 4.0);
}
float3 calc_normal_octahedron(float3 pos)
{
    float3 eps = float3(0.001, 0.0, 0.0);
    float3 nor;
    nor.x = map_octahedron(pos+eps.xyy) - map_octahedron(pos-eps.xyy);
    nor.y = map_octahedron(pos+eps.yxy) - map_octahedron(pos-eps.yxy);
    nor.z = map_octahedron(pos+eps.yyx) - map_octahedron(pos-eps.yyx);
    return normalize(nor);
}
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.texcoord = texcoord_vs_output;
    float2 uv = bend_tc(_input.texcoord.xy);
    float eps = 0.005;
    float iTime = mod(user_data.y * 0.003, 200.0);
    float2 iResolution = float2(640.0, 480.0);
    float3 ro;
    float3 rd;
    cam_anim(uv, iTime, ro, rd);
    float d = 10.0;
    float xt = 0.0;
    float3 pp = ro;
    for(float t = 0.0; t < 20.0; ++t)
    {
        pp = ro + rd * xt;
        d = map_octahedron(pp);
        if(d < eps)
        break;
        xt += d;
    }
    float3 n = calc_normal_octahedron(pp);
    float3 col = irrid(n, rd);
    float mask = step(d, eps);
    float inv_mask = 1.0 - mask;
    float3 csky = sky(rd, iTime + 10.0);
    csky = csky.zyx;
    float3 cc = crt_c(csky * inv_mask + col * mask, uv);
    ps_output _output;
    _output.colour = float4(cc, 1.0);
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//vertex_colour default vs 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
layout(location = 0) in float4 position_vs_input;
layout(location = 1) in float4 colour_vs_input;
out float4 colour_vs_output;
uniform float v_flip;
struct vs_input
{
    float4 position;
    float4 colour;
};
struct vs_output
{
    float4 position;
    float4 colour;
};
void main()
{
    //assign vs_input struct from glsl inputs
    vs_input _input;
    _input.position = position_vs_input;
    _input.colour = colour_vs_input;
    vs_output _output;
    _output.position = _input.position;
    _output.colour = _input.colour;
    //assign glsl global outputs from structs
    gl_Position = _output.position;
    gl_Position.y *= v_flip;
    colour_vs_output = _output.colour;
}
{
    "cmdline": "../third_party/pmbuild/scripts/pmfx-shader/build_pmfx.py -shader_platform gles -shader_version 300 -i assets/shaders ../assets/shaders -o build/web/data/pmfx/glsl -h shader_structs -t temp/shaders -v_flip -source ",
    "files": [
        {
            "name": "/Users/alex.dixon/dev/pmtech/third_party/pmbuild/scripts/pmfx-shader/build_pmfx.py",
            "timestamp": 1608637107.3205462
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/third_party/pmbuild/scripts/pmfx-shader/platform/pmfx.h",
            "timestamp": 1605953217.8167121
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/third_party/pmbuild/scripts/pmfx-shader/platform/glsl.h",
            "timestamp": 1608635330.6987193
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/examples/assets/shaders/vertex_colour.pmfx",
            "timestamp": 1608572067.196568
        }
    ],
    "techniques": [
        {
            "vs": "vs_main",
            "ps": "ps_main",
            "name": "default",
            "texture_sampler_bindings": [],
            "structured_buffers": [],
            "cbuffers": [],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "colour",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "colour",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "vs_file": "default.vsc",
            "ps_file": "default.psc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        }
    ],
    "failures": {}
}#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//vertex_colour default ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 colour_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 colour;
};
struct ps_output
{
    float4 colour;
};
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.colour = colour_vs_output;
    ps_output _output;
    _output.colour = _input.colour;
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
{
    "cmdline": "../third_party/pmbuild/scripts/pmfx-shader/build_pmfx.py -shader_platform gles -shader_version 300 -i assets/shaders ../assets/shaders -o build/web/data/pmfx/glsl -h shader_structs -t temp/shaders -v_flip -source ",
    "files": [
        {
            "name": "/Users/alex.dixon/dev/pmtech/third_party/pmbuild/scripts/pmfx-shader/build_pmfx.py",
            "timestamp": 1608637107.3205462
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/third_party/pmbuild/scripts/pmfx-shader/platform/pmfx.h",
            "timestamp": 1605953217.8167121
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/third_party/pmbuild/scripts/pmfx-shader/platform/glsl.h",
            "timestamp": 1608635330.6987193
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/examples/assets/shaders/compute_demo.pmfx",
            "timestamp": 1608572067.196774
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/examples/assets/shaders/../../../assets/shaders/libs/globals.pmfx",
            "timestamp": 1608572067.200933
        }
    ],
    "techniques": [],
    "failures": {}
}#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//forward_render simple_lighting__1073741828__ ps 1073741828
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 world_pos_vs_output;
in float3 normal_vs_output;
in float3 tangent_vs_output;
in float3 bitangent_vs_output;
in float4 texcoord_vs_output;
in float4 colour_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 world_pos;
    float3 normal;
    float3 tangent;
    float3 bitangent;
    float4 texcoord;
    float4 colour;
};
struct ps_output
{
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
layout (std140) uniform per_draw_call
{
    float4x4 world_matrix;
    float4 user_data;
    float4 user_data2;
    float4x4 world_matrix_inv_transpose;
};
layout (std140) uniform per_pass_lights
{
    float4 light_info;
    light_data lights[100];
};
layout (std140) uniform per_pass_shadow
{
    float4x4 shadow_matrix[100];
};
layout (std140) uniform material_data
{
    float4 m_albedo;
    float m_roughness;
    float m_reflectivity;
    float m_sss_scale;
    float m_padding;
};
texture_2d( diffuse_texture, 0 );
texture_2d( normal_texture, 1 );
texture_2d( specular_texture, 2 );
depth_2d( single_shadowmap_texture, 7 );
texture_2d( shadowmap_texture_sss, 8);
float3 cook_torrence(
float4 light_pos_radius,
float3 light_colour,
float3 n,
float3 world_pos,
float3 view_pos,
float3 albedo,
float3 metalness,
float roughness,
float reflectivity
)
{
    float3 l = normalize( light_pos_radius.xyz - world_pos.xyz );
    float n_dot_l = dot( n, l );
    if( n_dot_l > 0.0f )
    {
        float roughness_sq = roughness * roughness;
        float k = reflectivity;
        float3 v_view = normalize( (view_pos.xyz - world_pos.xyz) );
        float3 hv = normalize( v_view + l );
        float n_dot_v = dot( n, v_view );
        float n_dot_h = dot( n, hv );
        float v_dot_h = dot( v_view, hv );
        float n_dot_h_2 = 2.0f * n_dot_h;
        float g1 = (n_dot_h_2 * n_dot_v) / v_dot_h;
        float g2 = (n_dot_h_2 * n_dot_l) / v_dot_h;
        float geom_atten = min(1.0, min(g1, g2));
        float r1 = 1.0f / ( 4.0f * roughness_sq * pow(n_dot_h, 4.0f));
        float r2 = (n_dot_h * n_dot_h - 1.0) / (roughness_sq * n_dot_h * n_dot_h);
        float roughness_atten = r1 * exp(r2);
        float fresnel = pow(1.0 - v_dot_h, 5.0);
        fresnel *= roughness;
        fresnel += reflectivity;
        float specular = (fresnel * geom_atten * roughness_atten) / (n_dot_v * n_dot_l * 3.1419);
        float3 lit_colour = metalness * light_colour * n_dot_l * ( k + specular * ( 1.0 - k ) );
        return saturate(lit_colour);
    }
    return float3( 0.0, 0.0, 0.0 );
}
float3 oren_nayar(
float4 light_pos_radius,
float3 light_colour,
float3 n,
float3 world_pos,
float3 view_pos,
float roughness,
float3 albedo)
{
    float3 v = normalize(view_pos-world_pos);
    float3 l = normalize(light_pos_radius.xyz-world_pos);
    float l_dot_v = dot(l, v);
    float n_dot_l = dot(n, l);
    float n_dot_v = dot(n, v);
    float s = l_dot_v - n_dot_l * n_dot_v;
    float t = lerp(1.0, max(n_dot_l, n_dot_v), step(0.0, s));
    float lum = length( albedo );
    float sigma2 = roughness * roughness;
    float A = 1.0 + sigma2 * (lum / (sigma2 + 0.13) + 0.5 / (sigma2 + 0.33));
    float B = 0.45 * sigma2 / (sigma2 + 0.09);
    return ( albedo * light_colour * max(0.0, n_dot_l) * (A + B * s / t) / 3.14159265 );
}
float sample_shadow_pcf_9(float3 sp)
{
    float2 samples[9];
    float2 inv_sm_size = float2(1.0/2048.0, 1.0/2048.0);
    samples[0] = float2(-1.0, -1.0) * inv_sm_size;
    samples[1] = float2(-1.0, 0.0) * inv_sm_size;
    samples[2] = float2(-1.0, 1.0) * inv_sm_size;
    samples[3] = float2(0.0, -1.0) * inv_sm_size;
    samples[4] = float2(0.0, 0.0) * inv_sm_size;
    samples[5] = float2(0.0, 1.0) * inv_sm_size;
    samples[6] = float2(1.0, -1.0) * inv_sm_size;
    samples[7] = float2(1.0, 0.0) * inv_sm_size;
    samples[8] = float2(1.0, 1.0) * inv_sm_size;
    float shadow = 0.0;
    for(int j = 0; j < 9; ++j)
    {
        shadow += sample_depth_compare(single_shadowmap_texture, sp.xy + samples[j], sp.z);
    }
    shadow /= 9.0;
    return shadow;
}
float3 transform_ts_normal( float3 t, float3 b, float3 n, float3 ts_normal )
{
    float3x3 tbn;
    tbn[0] = float3(t.x, b.x, n.x);
    tbn[1] = float3(t.y, b.y, n.y);
    tbn[2] = float3(t.z, b.z, n.z);
    return normalize( mul_tbn( tbn, ts_normal ) );
}
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.world_pos = world_pos_vs_output;
    _input.normal = normal_vs_output;
    _input.tangent = tangent_vs_output;
    _input.bitangent = bitangent_vs_output;
    _input.texcoord = texcoord_vs_output;
    _input.colour = colour_vs_output;
    ps_output _output;
    float4 albedo = sample_texture( diffuse_texture, _input.texcoord.xy );
    float3 normal_sample = sample_texture( normal_texture, _input.texcoord.xy ).rgb;
    float4 ro_sample = sample_texture( specular_texture, _input.texcoord.xy );
    float4 specular_sample = float4(1.0, 1.0, 1.0, 1.0);
    normal_sample = normal_sample * 2.0 - 1.0;
    float3 n = transform_ts_normal(
    _input.tangent,
    _input.bitangent,
    _input.normal,
    normal_sample );
    albedo *= _input.colour;
    float4 metalness = float4(1.0, 1.0, 1.0, 1.0);
    float3 lit_colour = float3( 0.0, 0.0, 0.0 );
    float reflectivity = saturate(user_data.z);
    float roughness = saturate(user_data.y);
    reflectivity = m_reflectivity;
    roughness = m_roughness;
    roughness = _input.colour.a;
    albedo.a = 1.0;
    float3 lll = float3(0.0, 0.0, 0.0);
    int shadow_map_index = 0;
    _pmfx_loop
    for(int i = 0; i < 1; ++i )
    {
        float3 light_col = float3( 0.0, 0.0, 0.0 );
        light_col += cook_torrence(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        albedo.rgb,
        metalness.rgb,
        roughness,
        reflectivity
        );
        light_col += oren_nayar(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        1.0 - roughness,
        albedo.rgb
        );
        if( lights[i].colour.a == 0.0 )
        {
            lit_colour += light_col;
            continue;
        }
        else
        {
            float shadow = 1.0;
            float d = 1.0;
            float4 offset_pos = float4(_input.world_pos.xyz + n.xyz * 0.01, 1.0);
            float4 sp = mul( offset_pos, shadow_matrix[i] );
            sp.xyz /= sp.w;
            sp.y *= -1.0;
            sp.xy = sp.xy * 0.5 + 0.5;
            sp.z = remap_depth(sp.z);
            shadow = sample_shadow_pcf_9(sp.xyz);
            lit_colour += light_col * shadow;
            float sss_offset = 0.1;
            float4 shrink_pos = float4(_input.world_pos.xyz - _input.normal.xyz * sss_offset, 1.0);
            sp = mul( shrink_pos, shadow_matrix[i] );
            sp.xyz /= sp.w;
            sp.y *= -1.0;
            sp.xy = sp.xy * 0.5 + 0.5;
            sp.z = remap_depth(sp.z);
            float4 sm = sample_texture_level( shadowmap_texture_sss, sp.xy, 0.0 );
            d = sm.r;
            float fp = 1.0;
            float3 light_dir = _input.world_pos.xyz - lights[i].pos_radius.xyz;
            float d1 = d;
            float d2 = sp.z;
            d1 *= fp;
            float sssd = m_sss_scale * abs(d1 - d2) * 0.5 + 0.5;
            float dd = -(sssd * sssd);
            float3 profile = float3(0.233, 0.455, 0.649) * exp(dd / 0.0064) +
            float3(0.1, 0.336, 0.344) * exp(dd / 0.0484) +
            float3(0.118, 0.198, 0.0) * exp(dd / 0.187) +
            float3(0.113, 0.007, 0.007) * exp(dd / 0.567) +
            float3(0.358, 0.004, 0.0) * exp(dd / 1.99) +
            float3(0.078, 0.0, 0.0) * exp(dd / 7.41);
            float sss = saturate(0.5 + dot(light_dir, n));
            profile *= albedo.rgb;
            lit_colour.rgb += profile * sss;
            lit_colour += albedo.rgb * 0.15;
            ++shadow_map_index;
        }
        lit_colour += oren_nayar(
        lights[i].pos_radius * -1.0,
        lights[i].colour.rgb * 0.25,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        1.0 - roughness,
        albedo.rgb
        );
    }
    _output.colour.rgb = lit_colour;
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//forward_render forward_lit__8__ ps 8
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 world_pos_vs_output;
in float3 normal_vs_output;
in float3 tangent_vs_output;
in float3 bitangent_vs_output;
in float4 texcoord_vs_output;
in float4 colour_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 world_pos;
    float3 normal;
    float3 tangent;
    float3 bitangent;
    float4 texcoord;
    float4 colour;
};
struct ps_output
{
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
layout (std140) uniform per_draw_call
{
    float4x4 world_matrix;
    float4 user_data;
    float4 user_data2;
    float4x4 world_matrix_inv_transpose;
};
layout (std140) uniform per_pass_lights
{
    float4 light_info;
    light_data lights[100];
};
layout (std140) uniform per_pass_shadow
{
    float4x4 shadow_matrix[100];
};
layout (std140) uniform per_pass_shadow_distance_fields
{
    distance_field_shadow sdf_shadow;
};
layout (std140) uniform per_pass_area_lights
{
    float4 area_light_info;
    area_light_data area_lights[10];
};
layout (std140) uniform material_data
{
    float4 m_albedo;
    float m_roughness;
    float m_reflectivity;
    float m_surface_offset;
    float m_padding;
};
texture_2d( diffuse_texture, 0 );
texture_2d( normal_texture, 1 );
texture_2d( specular_texture, 2 );
texture_3d( sdf_volume, 14 );
texture_2d( ltc_mat, 13 );
texture_2d( ltc_mag, 12 );
texture_2d_array( area_light_textures, 11 );
depth_2d_array( shadowmap_texture, 15 );
float3 cook_torrence(
float4 light_pos_radius,
float3 light_colour,
float3 n,
float3 world_pos,
float3 view_pos,
float3 albedo,
float3 metalness,
float roughness,
float reflectivity
)
{
    float3 l = normalize( light_pos_radius.xyz - world_pos.xyz );
    float n_dot_l = dot( n, l );
    if( n_dot_l > 0.0f )
    {
        float roughness_sq = roughness * roughness;
        float k = reflectivity;
        float3 v_view = normalize( (view_pos.xyz - world_pos.xyz) );
        float3 hv = normalize( v_view + l );
        float n_dot_v = dot( n, v_view );
        float n_dot_h = dot( n, hv );
        float v_dot_h = dot( v_view, hv );
        float n_dot_h_2 = 2.0f * n_dot_h;
        float g1 = (n_dot_h_2 * n_dot_v) / v_dot_h;
        float g2 = (n_dot_h_2 * n_dot_l) / v_dot_h;
        float geom_atten = min(1.0, min(g1, g2));
        float r1 = 1.0f / ( 4.0f * roughness_sq * pow(n_dot_h, 4.0f));
        float r2 = (n_dot_h * n_dot_h - 1.0) / (roughness_sq * n_dot_h * n_dot_h);
        float roughness_atten = r1 * exp(r2);
        float fresnel = pow(1.0 - v_dot_h, 5.0);
        fresnel *= roughness;
        fresnel += reflectivity;
        float specular = (fresnel * geom_atten * roughness_atten) / (n_dot_v * n_dot_l * 3.1419);
        float3 lit_colour = metalness * light_colour * n_dot_l * ( k + specular * ( 1.0 - k ) );
        return saturate(lit_colour);
    }
    return float3( 0.0, 0.0, 0.0 );
}
float3 oren_nayar(
float4 light_pos_radius,
float3 light_colour,
float3 n,
float3 world_pos,
float3 view_pos,
float roughness,
float3 albedo)
{
    float3 v = normalize(view_pos-world_pos);
    float3 l = normalize(light_pos_radius.xyz-world_pos);
    float l_dot_v = dot(l, v);
    float n_dot_l = dot(n, l);
    float n_dot_v = dot(n, v);
    float s = l_dot_v - n_dot_l * n_dot_v;
    float t = lerp(1.0, max(n_dot_l, n_dot_v), step(0.0, s));
    float lum = length( albedo );
    float sigma2 = roughness * roughness;
    float A = 1.0 + sigma2 * (lum / (sigma2 + 0.13) + 0.5 / (sigma2 + 0.33));
    float B = 0.45 * sigma2 / (sigma2 + 0.09);
    return ( albedo * light_colour * max(0.0, n_dot_l) * (A + B * s / t) / 3.14159265 );
}
float spot_light_attenuation(
float4 light_pos_radius,
float4 light_dir_cutoff,
float falloff,
float3 world_pos)
{
    float co = light_dir_cutoff.w;
    float3 vl = normalize(world_pos.xyz - light_pos_radius.xyz);
    float3 sd = normalize(light_dir_cutoff.xyz);
    float dp = (1.0 - dot(vl, sd));
    return smoothstep(co, co - falloff, dp);
}
float point_light_attenuation_cutoff(
float4 light_pos_radius,
float3 world_pos)
{
    float r = light_pos_radius.w;
    float d = length(world_pos.xyz - light_pos_radius.xyz);
    d = max(d - r, 0.0);
    float denom = d/r + 1.0;
    float attenuation = 1.0 / (denom*denom);
    float cutoff = 0.2;
    attenuation = (attenuation - cutoff) / (1.0 - cutoff);
    attenuation = max(attenuation, 0.0);
    return attenuation;
}
float sample_shadow_array_pcf_9(float array_slice, float3 sp)
{
    float2 samples[9];
    float2 inv_sm_size = float2(1.0/2048.0, 1.0/2048.0);
    samples[0] = float2(-1.0, -1.0) * inv_sm_size;
    samples[1] = float2(-1.0, 0.0) * inv_sm_size;
    samples[2] = float2(-1.0, 1.0) * inv_sm_size;
    samples[3] = float2(0.0, -1.0) * inv_sm_size;
    samples[4] = float2(0.0, 0.0) * inv_sm_size;
    samples[5] = float2(0.0, 1.0) * inv_sm_size;
    samples[6] = float2(1.0, -1.0) * inv_sm_size;
    samples[7] = float2(1.0, 0.0) * inv_sm_size;
    samples[8] = float2(1.0, 1.0) * inv_sm_size;
    float shadow = 0.0;
    for(int j = 0; j < 9; ++j)
    {
        shadow += sample_depth_compare_array(shadowmap_texture, sp.xy + samples[j], array_slice, sp.z);
    }
    shadow /= 9.0;
    return shadow;
}
bool ray_vs_aabb(float3 emin, float3 emax, float3 r1, float3 rv, out float3 intersection)
{
    float3 dirfrac = float3(1.0, 1.0, 1.0) / rv;
    float t1 = (emin.x - r1.x)*dirfrac.x;
    float t2 = (emax.x - r1.x)*dirfrac.x;
    float t3 = (emin.y - r1.y)*dirfrac.y;
    float t4 = (emax.y - r1.y)*dirfrac.y;
    float t5 = (emin.z - r1.z)*dirfrac.z;
    float t6 = (emax.z - r1.z)*dirfrac.z;
    float tmin = max(max(min(t1, t2), min(t3, t4)), min(t5, t6));
    float tmax = min(min(max(t1, t2), max(t3, t4)), max(t5, t6));
    float t = 0.0;
    if (tmax < 0.0)
    {
        t = tmax;
        return false;
    }
    if (tmin > tmax)
    {
        t = tmax;
        return false;
    }
    t = tmin;
    intersection = r1 + rv * t;
    return true;
}
float sdf_shadow_trace(float max_samples, float3 light_pos, float3 world_pos, float3 scale, float3 ray_origin, float4x4 inv_mat, float3x3 inv_rot)
{
    float3 ray_dir = normalize(light_pos - world_pos);
    ray_dir = normalize( mul( ray_dir, inv_rot ) );
    float closest = 1.0;
    float3 uvw = ray_origin;
    if(abs(uvw.x) >= 1.0 || abs(uvw.y) >= 1.0 || abs(uvw.z) >= 1.0)
    {
        float3 emin = float3(-1.0, -1.0, -1.0);
        float3 emax = float3(1.0, 1.0, 1.0);
        float3 ip = float3(0.0, 0.0, 0.0);
        bool hit = ray_vs_aabb( emin, emax, uvw, ray_dir, ip);
        uvw = ip;
        if(!hit)
        {
            return closest;
        }
    }
    float3 light_uvw = mul( float4(light_pos, 1.0), inv_mat ).xyz * 0.5 + 0.5;
    uvw = uvw * 0.5 + 0.5;
    float3 v1 = normalize(light_uvw - uvw);
    for( int s = 0; s < int(max_samples); ++s )
    {
        float d = sample_texture_level( sdf_volume, uvw, 0.0 ).r;
        closest = min(d, closest);
        ray_dir = normalize(light_uvw - uvw);
        float3 step = ray_dir.xyz * float3(d, d, d) / scale * 0.7;
        uvw += step;
        if( d <= 0.0 )
        {
            closest = max( d, 0.0 );
            break;
        }
        if(uvw.x >= 1.0 || uvw.x < 0.0)
        break;
        if(uvw.y >= 1.0 || uvw.y < 0.0)
        break;
        if(uvw.z >= 1.0 || uvw.z < 0.0)
        break;
    }
    return closest;
}
float integrate_edge(float3 v1, float3 v2)
{
    float cos_theta = dot(v1, v2);
    float theta = acos(cos_theta);
    float res = cross(v1, v2).z * ((theta > 0.001) ? theta/sin(theta) : 1.0);
    return res;
}
void clip_quad_to_horizon(inout float3 L[5], out int n)
{
    int config = 0;
    if (L[0].z > 0.0) config += 1;
    if (L[1].z > 0.0) config += 2;
    if (L[2].z > 0.0) config += 4;
    if (L[3].z > 0.0) config += 8;
    n = 0;
    if (config == 0)
    {
    }
    else if (config == 1)
    {
        n = 3;
        L[1] = -L[1].z * L[0] + L[0].z * L[1];
        L[2] = -L[3].z * L[0] + L[0].z * L[3];
    }
    else if (config == 2)
    {
        n = 3;
        L[0] = -L[0].z * L[1] + L[1].z * L[0];
        L[2] = -L[2].z * L[1] + L[1].z * L[2];
    }
    else if (config == 3)
    {
        n = 4;
        L[2] = -L[2].z * L[1] + L[1].z * L[2];
        L[3] = -L[3].z * L[0] + L[0].z * L[3];
    }
    else if (config == 4)
    {
        n = 3;
        L[0] = -L[3].z * L[2] + L[2].z * L[3];
        L[1] = -L[1].z * L[2] + L[2].z * L[1];
    }
    else if (config == 5)
    {
        n = 0;
    }
    else if (config == 6)
    {
        n = 4;
        L[0] = -L[0].z * L[1] + L[1].z * L[0];
        L[3] = -L[3].z * L[2] + L[2].z * L[3];
    }
    else if (config == 7)
    {
        n = 5;
        L[4] = -L[3].z * L[0] + L[0].z * L[3];
        L[3] = -L[3].z * L[2] + L[2].z * L[3];
    }
    else if (config == 8)
    {
        n = 3;
        L[0] = -L[0].z * L[3] + L[3].z * L[0];
        L[1] = -L[2].z * L[3] + L[3].z * L[2];
        L[2] = L[3];
    }
    else if (config == 9)
    {
        n = 4;
        L[1] = -L[1].z * L[0] + L[0].z * L[1];
        L[2] = -L[2].z * L[3] + L[3].z * L[2];
    }
    else if (config == 10)
    {
        n = 0;
    }
    else if (config == 11)
    {
        n = 5;
        L[4] = L[3];
        L[3] = -L[2].z * L[3] + L[3].z * L[2];
        L[2] = -L[2].z * L[1] + L[1].z * L[2];
    }
    else if (config == 12)
    {
        n = 4;
        L[1] = -L[1].z * L[2] + L[2].z * L[1];
        L[0] = -L[0].z * L[3] + L[3].z * L[0];
    }
    else if (config == 13)
    {
        n = 5;
        L[4] = L[3];
        L[3] = L[2];
        L[2] = -L[1].z * L[2] + L[2].z * L[1];
        L[1] = -L[1].z * L[0] + L[0].z * L[1];
    }
    else if (config == 14)
    {
        n = 5;
        L[4] = -L[0].z * L[3] + L[3].z * L[0];
        L[0] = -L[0].z * L[1] + L[1].z * L[0];
    }
    else if (config == 15)
    {
        n = 4;
    }
    if (n == 3)
    L[3] = L[0];
    if (n == 4)
    L[4] = L[0];
}
float3 ltc_uv_coord(float3 p[4])
{
    float3 v1 = p[1] - p[0];
    float3 v2 = p[3] - p[0];
    float3 plane_ortho = (cross(v1, v2));
    float plane_area_squared = dot(plane_ortho, plane_ortho);
    float plane_distx_plane_area = dot(plane_ortho, p[0]);
    float3 pp = plane_distx_plane_area * plane_ortho / plane_area_squared - p[0];
    float v1_dot_v2 = dot(v1, v2);
    float inv_v1_dot_v1 = 1.0 / dot(v1, v1);
    float3 vv2 = v2 - v1 * v1_dot_v2 * inv_v1_dot_v1;
    float2 puv;
    puv.y = dot(vv2, pp) / dot(vv2, vv2);
    puv.x = dot(v1, pp) * inv_v1_dot_v1 - v1_dot_v2 * inv_v1_dot_v1 * puv.y;
    float d = abs(plane_distx_plane_area) / pow(plane_area_squared, 0.75);
    return float3(puv, d);
}
float4 ltc_evaluate(
float3 n,
float3 v,
float3 p,
float3x3 minv,
float3 points[4],
bool two_sided)
{
    float3 t1, t2;
    t1 = normalize(v - n * dot(v, n));
    t2 = cross(n, t1);
    float3x3 ttn = from_columns_3x3(t1, t2, n);
    minv = mul(minv, ttn);
    float3 l[5];
    l[0] = mul(minv, points[0] - p);
    l[1] = mul(minv, points[1] - p);
    l[2] = mul(minv, points[2] - p);
    l[3] = mul(minv, points[3] - p);
    l[4] = l[3];
    float3 ll[4];
    ll[0] = l[0];
    ll[1] = l[1];
    ll[2] = l[2];
    ll[3] = l[3];
    float3 uvl = ltc_uv_coord(ll);
    int nc;
    clip_quad_to_horizon(l, nc);
    if (nc == 0)
    return float4(0, 0, 0, 0.0);
    l[0] = normalize(l[0]);
    l[1] = normalize(l[1]);
    l[2] = normalize(l[2]);
    l[3] = normalize(l[3]);
    l[4] = normalize(l[4]);
    float sum = 0.0;
    sum += integrate_edge(l[0], l[1]);
    sum += integrate_edge(l[1], l[2]);
    sum += integrate_edge(l[2], l[3]);
    if (nc >= 4)
    sum += integrate_edge(l[3], l[4]);
    if (nc == 5)
    sum += integrate_edge(l[4], l[0]);
    sum = two_sided ? abs(sum) : max(0.0, sum);
    float3 lo_i = float3(sum, sum, sum);
    return float4(uvl.x, uvl.y, uvl.z, sum);
}
float ltc_evaluate_cc(
float3 n,
float3 v,
float3 p,
float3x3 minv,
float3 points[4],
bool two_sided)
{
    float3 t1, t2;
    t1 = normalize(v - n * dot(v, n));
    t2 = cross(n, t1);
    float3x3 ttn = from_columns_3x3(t1, t2, n);
    minv = mul(minv, ttn);
    float3 l[5];
    for(int i = 0; i < 4; ++i)
    l[i] = mul(minv, points[i] - p);
    l[4] = l[3];
    int nc;
    clip_quad_to_horizon(l, nc);
    if (nc == 0)
    return 0.0;
    for(int i = 0; i < 5; ++i)
    l[i] = normalize(l[i]);
    float sum = 0.0;
    sum += integrate_edge(l[0], l[1]);
    sum += integrate_edge(l[1], l[2]);
    sum += integrate_edge(l[2], l[3]);
    if (nc >= 4)
    sum += integrate_edge(l[3], l[4]);
    if (nc == 5)
    sum += integrate_edge(l[4], l[0]);
    sum = two_sided ? abs(sum) : max(0.0, sum);
    return sum;
}
float4 area_light_specular_uv(
float3 points[4],
float3 pos,
float roughness,
float3 n,
float3 v)
{
    float pi = 3.14159265359;
    float lut_size = 64.0;
    float lut_scale = (lut_size - 1.0)/lut_size;
    float lut_bias = 0.5/lut_size;
    float theta = acos(dot(n, v));
    float2 uv = float2(roughness, theta / (0.5 * pi));
    uv = uv * lut_scale + lut_bias;
    float4 mat = sample_texture(ltc_mat, uv);
    float mag = sample_texture(ltc_mag, uv).w;
    float3x3 minv = from_rows_3x3(
    float3(1.0, 0.0, mat.y),
    float3(0.0, mat.z, 0.0),
    float3(mat.w, 0.0, mat.x)
    );
    float4 spec = ltc_evaluate(n, v, pos, minv, points, true);
    return spec;
}
float area_light_specular(
float3 points[4],
float3 pos,
float roughness,
float3 n,
float3 v)
{
    float pi = 3.14159265359;
    float lut_size = 64.0;
    float lut_scale = (lut_size - 1.0)/lut_size;
    float lut_bias = 0.5/lut_size;
    float theta = acos(dot(n, v));
    float2 uv = float2(roughness, theta / (0.5 * pi));
    uv = uv * lut_scale + lut_bias;
    float4 mat = sample_texture(ltc_mat, uv);
    float mag = sample_texture(ltc_mag, uv).w;
    float3x3 minv = from_rows_3x3(
    float3(1.0, 0.0, mat.y),
    float3(0.0, mat.z, 0.0),
    float3(mat.w, 0.0, mat.x)
    );
    float spec = ltc_evaluate_cc(n, v, pos, minv, points, true);
    return spec;
}
float4 area_light_diffuse_uv(
float3 points[4],
float3 pos,
float3 n,
float3 v)
{
    float3x3 difv = float3x3(
    float3(1.0, 0.0, 0.0),
    float3(0.0, 1.0, 0.0),
    float3(0.0, 0.0, 1.0)
    );
    float4 diff = ltc_evaluate(n, v, pos, difv, points, true);
    return diff;
}
float area_light_diffuse(
float3 points[4],
float3 pos,
float3 n,
float3 v)
{
    float3x3 difv = float3x3(
    float3(1.0, 0.0, 0.0),
    float3(0.0, 1.0, 0.0),
    float3(0.0, 0.0, 1.0)
    );
    float diff = ltc_evaluate_cc(n, v, pos, difv, points, true);
    return diff;
}
float3 transform_ts_normal( float3 t, float3 b, float3 n, float3 ts_normal )
{
    float3x3 tbn;
    tbn[0] = float3(t.x, b.x, n.x);
    tbn[1] = float3(t.y, b.y, n.y);
    tbn[2] = float3(t.z, b.z, n.z);
    return normalize( mul_tbn( tbn, ts_normal ) );
}
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.world_pos = world_pos_vs_output;
    _input.normal = normal_vs_output;
    _input.tangent = tangent_vs_output;
    _input.bitangent = bitangent_vs_output;
    _input.texcoord = texcoord_vs_output;
    _input.colour = colour_vs_output;
    ps_output _output;
    float4 albedo = sample_texture( diffuse_texture, _input.texcoord.xy );
    float3 normal_sample = sample_texture( normal_texture, _input.texcoord.xy ).rgb;
    float4 ro_sample = sample_texture( specular_texture, _input.texcoord.xy );
    float4 specular_sample = float4(1.0, 1.0, 1.0, 1.0);
    normal_sample = normal_sample * 2.0 - 1.0;
    float3 n = transform_ts_normal(
    _input.tangent,
    _input.bitangent,
    _input.normal,
    normal_sample );
    albedo *= _input.colour;
    float4 metalness = float4(1.0, 1.0, 1.0, 1.0);
    float3 lit_colour = float3( 0.0, 0.0, 0.0 );
    float reflectivity = saturate(user_data.z);
    float roughness = saturate(user_data.y);
    reflectivity = m_reflectivity;
    roughness = ro_sample.r;
    n = _input.normal.rgb;
    roughness = m_roughness;
    float max_samples = 128.0;
    float3x3 inv_rot = to_3x3(sdf_shadow.world_matrix_inv);
    float3 r1 = _input.world_pos.xyz + _input.normal.xyz * m_surface_offset;
    float3 tr1 = mul( float4(r1, 1.0), sdf_shadow.world_matrix_inv ).xyz;
    float3 scale = float3(length(sdf_shadow.world_matrix[0].xyz), length(sdf_shadow.world_matrix[1].xyz), length(sdf_shadow.world_matrix[2].xyz)) * 2.0;
    float3 vddx = ddx( r1 );
    float3 vddy = ddy( r1 );
    float t = 1.0;
    float3 lll = float3(0.0, 0.0, 0.0);
    int shadow_map_index = 0;
    _pmfx_loop
    for( int i = 0; i < int(light_info.x); ++i )
    {
        float3 light_col = float3( 0.0, 0.0, 0.0 );
        light_col += cook_torrence(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        albedo.rgb,
        metalness.rgb,
        roughness,
        reflectivity
        );
        light_col += oren_nayar(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        1.0 - roughness,
        albedo.rgb
        );
        float s = sdf_shadow_trace(max_samples, lights[i].pos_radius.xyz, _input.world_pos.xyz, scale, tr1, sdf_shadow.world_matrix_inv, inv_rot);
        light_col *= smoothstep( 0.0, 0.1, s);
        if( lights[i].colour.a == 0.0 )
        {
            lit_colour += light_col;
            continue;
        }
        else
        {
            float shadow = 1.0;
            float d = 1.0;
            float4 offset_pos = float4(_input.world_pos.xyz + n.xyz * 0.01, 1.0);
            float4 sp = mul( offset_pos, shadow_matrix[i] );
            sp.xyz /= sp.w;
            sp.y *= -1.0;
            sp.xy = sp.xy * 0.5 + 0.5;
            sp.z = remap_depth(sp.z);
            shadow = sample_shadow_array_pcf_9(float(shadow_map_index), sp.xyz);
            lit_colour += light_col * shadow;
            ++shadow_map_index;
        }
    }
    int point_start = int(light_info.x);
    int point_end = int(light_info.x) + int(light_info.y);
    int omni_shadow_index = 0;
    _pmfx_loop
    for( int i = point_start; i < point_end; ++i )
    {
        float3 light_col = float3( 0.0, 0.0, 0.0 );
        light_col += cook_torrence(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        albedo.rgb,
        metalness.rgb,
        roughness,
        reflectivity
        );
        light_col += oren_nayar(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        roughness,
        albedo.rgb
        );
        float a = point_light_attenuation_cutoff( lights[i].pos_radius, _input.world_pos.xyz );
        light_col *= a;
        float s = sdf_shadow_trace(max_samples, lights[i].pos_radius.xyz, _input.world_pos.xyz, scale, tr1, sdf_shadow.world_matrix_inv, inv_rot);
        light_col *= smoothstep( 0.0, 0.1, s);
        if( lights[i].colour.a == 0.0)
        {
            lit_colour += light_col;
            continue;
        }
        else
        {
            lit_colour += light_col;
            continue;
        }
    }
    int spot_start = point_end;
    int spot_end = spot_start + int(light_info.z);
    _pmfx_loop
    for(int i = spot_start; i < spot_end; ++i )
    {
        float3 light_col = float3( 0.0, 0.0, 0.0 );
        light_col += cook_torrence(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        albedo.rgb,
        metalness.rgb,
        roughness,
        reflectivity
        );
        light_col += oren_nayar(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        roughness,
        albedo.rgb
        );
        float a = spot_light_attenuation(lights[i].pos_radius,
        lights[i].dir_cutoff,
        lights[i].data.x,
        _input.world_pos.xyz );
        light_col *= a;
        float s = sdf_shadow_trace(max_samples, lights[i].pos_radius.xyz, _input.world_pos.xyz, scale, tr1, sdf_shadow.world_matrix_inv, inv_rot);
        light_col *= smoothstep( 0.0, 0.1, s);
        if( lights[i].colour.a == 0.0 )
        {
            lit_colour += light_col;
            continue;
        }
        else
        {
            float shadow = 1.0;
            float d = 1.0;
            float4 offset_pos = float4(_input.world_pos.xyz + n.xyz * 0.01, 1.0);
            float4 sp = mul( offset_pos, shadow_matrix[shadow_map_index] );
            sp.xyz /= sp.w;
            sp.y *= -1.0;
            sp.xy = sp.xy * 0.5 + 0.5;
            sp.z = remap_depth(sp.z);
            shadow = sample_shadow_array_pcf_9(float(shadow_map_index), sp.xyz);
            lit_colour += light_col * shadow;
            ++shadow_map_index;
        }
    }
    {
        float pi = 3.14159265359;
        int num_area_lights = int(area_light_info.x);
        for(int i = 0; i < num_area_lights; ++i)
        {
            float3 v = -normalize(_input.world_pos.xyz - camera_view_pos.xyz);
            float3 pos = _input.world_pos.xyz;
            float3 points[4];
            for(int j = 0; j < 4; ++j)
            points[j] = area_lights[i].corners[j].xyz;
            float diff_sum = area_light_diffuse(points, pos, n, v);
            float3 diff = area_lights[i].colour.rgb * diff_sum;
            float spec_sum = area_light_specular(points, pos, ro_sample.x, n, v);
            float3 spec = area_lights[i].colour.rgb * spec_sum;
            float3 light_col = (spec.rgb + diff.rgb) / (2.0 * pi);
            lit_colour += light_col;
        }
        int ts = num_area_lights;
        int num_area_lights_textured = int(area_light_info.y);
        for(int i = ts; i < ts + num_area_lights_textured; ++i)
        {
            float slice = area_lights[i].colour.w;
            float levels = 8.0;
            float2 inv_texel = float2(1.0/640.0, 1.0/480.0);
            float2 inv_texel_x = float2(1.0, 1.0) - inv_texel;
            float3 points[4];
            for(int j = 0; j < 4; ++j)
            points[j] = area_lights[i].corners[j].xyz;
            float3 v = -normalize(_input.world_pos.xyz - camera_view_pos.xyz);
            float3 pos = _input.world_pos.xyz;
            float4 diff_uv = area_light_diffuse_uv(points, pos, n, v);
            float2 duv = clamp(diff_uv.xy, inv_texel, inv_texel_x);
            float3 diff = sample_texture_array_level( area_light_textures, duv, slice, diff_uv.z * levels).rgb * diff_uv.w;
            float4 spec_uv = area_light_specular_uv(points, pos, ro_sample.x, n, v);
            float2 suv = clamp(spec_uv.xy, inv_texel, inv_texel_x);
            float3 spec = sample_texture_array_level(area_light_textures, suv, slice, spec_uv.z * levels).rgb * spec_uv.w;
            float3 light_col = (spec.rgb + diff.rgb) / (2.0 * pi);
            lit_colour += light_col;
        }
    }
    _output.colour.rgb = lit_colour.rgb * albedo.a;
    _output.colour.a = albedo.a;
    if(albedo.a <= 0.0)
    discard;
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//forward_render lambert__2147483648__ vs 2147483648
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
layout(location = 0) in float4 position_vs_input;
layout(location = 1) in float4 normal_vs_input;
layout(location = 2) in float4 texcoord_vs_input;
layout(location = 3) in float4 tangent_vs_input;
layout(location = 4) in float4 bitangent_vs_input;
layout(location = 5) in float4 blend_indices_vs_input;
layout(location = 6) in float4 blend_weights_vs_input;
out float4 world_pos_vs_output;
out float3 normal_vs_output;
out float3 tangent_vs_output;
out float3 bitangent_vs_output;
out float4 texcoord_vs_output;
out float4 colour_vs_output;
uniform float v_flip;
struct vs_input_multi
{
    float4 position;
    float4 normal;
    float4 texcoord;
    float4 tangent;
    float4 bitangent;
    float4 blend_indices;
    float4 blend_weights;
};
struct vs_output
{
    float4 position;
    float4 world_pos;
    float3 normal;
    float3 tangent;
    float3 bitangent;
    float4 texcoord;
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform skinning_info
{
    float4x4 bones[85];
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
layout (std140) uniform per_draw_call
{
    float4x4 world_matrix;
    float4 user_data;
    float4 user_data2;
    float4x4 world_matrix_inv_transpose;
};
layout (std140) uniform material_data
{
    float4 m_albedo;
};
float4 skin_pos(float4 pos, float4 weights, float4 indices)
{
    int bone_indices[4];
    bone_indices[0] = int(indices.x);
    bone_indices[1] = int(indices.y);
    bone_indices[2] = int(indices.z);
    bone_indices[3] = int(indices.w);
    float4 sp = float4( 0.0, 0.0, 0.0, 0.0 );
    float final_weight = 1.0;
    for(int i = 3; i >= 0; --i)
    {
        sp += mul( pos, bones[bone_indices[i]] ) * weights[i];
        final_weight -= weights[i];
    }
    sp += mul( pos, bones[bone_indices[0]] ) * final_weight;
    sp.w = 1.0;
    return sp;
}
void skin_tbn(inout float3 t, inout float3 b, inout float3 n, float4 weights, float4 indices)
{
    int bone_indices[4];
    bone_indices[0] = int(indices.x);
    bone_indices[1] = int(indices.y);
    bone_indices[2] = int(indices.z);
    bone_indices[3] = int(indices.w);
    float3 rt = float3( 0.0, 0.0, 0.0);
    float3 rb = float3( 0.0, 0.0, 0.0);
    float3 rn = float3( 0.0, 0.0, 0.0);
    float final_weight = 1.0;
    for( int i = 0; i < 3; ++i)
    {
        float3x3 rot_mat = to_3x3(bones[bone_indices[i]]);
        rt += mul(t, rot_mat) * weights[i];
        rb += mul(b, rot_mat) * weights[i];
        rn += mul(n, rot_mat) * weights[i];
        final_weight -= weights[i];
    }
    float3x3 rot_mat = to_3x3(bones[bone_indices[3]]);
    rt += mul(t, rot_mat) * final_weight;
    rb += mul(b, rot_mat) * final_weight;
    rn += mul(n, rot_mat) * final_weight;
    t = rt;
    b = rb;
    n = rn;
}
void main()
{
    //assign vs_input_multi struct from glsl inputs
    vs_input_multi _input;
    _input.position = position_vs_input;
    _input.normal = normal_vs_input;
    _input.texcoord = texcoord_vs_input;
    _input.tangent = tangent_vs_input;
    _input.bitangent = bitangent_vs_input;
    _input.blend_indices = blend_indices_vs_input;
    _input.blend_weights = blend_weights_vs_input;
    vs_output _output;
    float4x4 wvp = mul( world_matrix, vp_matrix );
    float4x4 wm = world_matrix;
    _output.texcoord = float4(_input.texcoord.x, 1.0 - _input.texcoord.y,
    _input.texcoord.z, 1.0 - _input.texcoord.w );
    _output.colour = m_albedo;
    float4 sp = skin_pos(_input.position, _input.blend_weights, _input.blend_indices);
    _output.tangent = _input.tangent.xyz;
    _output.bitangent = _input.bitangent.xyz;
    _output.normal = _input.normal.xyz;
    skin_tbn(_output.tangent, _output.bitangent, _output.normal, _input.blend_weights, _input.blend_indices);
    _output.position = mul( sp, vp_matrix );
    _output.world_pos = sp;
    //assign glsl global outputs from structs
    gl_Position = _output.position;
    gl_Position.y *= v_flip;
    world_pos_vs_output = _output.world_pos;
    normal_vs_output = _output.normal;
    tangent_vs_output = _output.tangent;
    bitangent_vs_output = _output.bitangent;
    texcoord_vs_output = _output.texcoord;
    colour_vs_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//forward_render forward_lit__1073741842__ ps 1073741842
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 world_pos_vs_output;
in float3 normal_vs_output;
in float3 tangent_vs_output;
in float3 bitangent_vs_output;
in float4 texcoord_vs_output;
in float4 colour_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 world_pos;
    float3 normal;
    float3 tangent;
    float3 bitangent;
    float4 texcoord;
    float4 colour;
};
struct ps_output
{
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
layout (std140) uniform per_draw_call
{
    float4x4 world_matrix;
    float4 user_data;
    float4 user_data2;
    float4x4 world_matrix_inv_transpose;
};
layout (std140) uniform per_pass_lights
{
    float4 light_info;
    light_data lights[100];
};
layout (std140) uniform per_pass_shadow
{
    float4x4 shadow_matrix[100];
};
layout (std140) uniform per_pass_area_lights
{
    float4 area_light_info;
    area_light_data area_lights[10];
};
layout (std140) uniform cbuffer_gi_volume
{
    float4 gi_scene_size;
    float4 gi_volume_size;
};
layout (std140) uniform material_data
{
    float4 m_albedo;
    float2 m_uv_scale;
    float m_roughness;
    float m_reflectivity;
};
texture_2d( diffuse_texture, 0 );
texture_2d( normal_texture, 1 );
texture_2d( specular_texture, 2 );
texture_2d( blue_noise, 5 );
texture_2d( ltc_mat, 13 );
texture_2d( ltc_mag, 12 );
texture_2d_array( area_light_textures, 11 );
texture_3d( volume_gi, 9 );
depth_2d_array( shadowmap_texture, 15 );
float3 cook_torrence(
float4 light_pos_radius,
float3 light_colour,
float3 n,
float3 world_pos,
float3 view_pos,
float3 albedo,
float3 metalness,
float roughness,
float reflectivity
)
{
    float3 l = normalize( light_pos_radius.xyz - world_pos.xyz );
    float n_dot_l = dot( n, l );
    if( n_dot_l > 0.0f )
    {
        float roughness_sq = roughness * roughness;
        float k = reflectivity;
        float3 v_view = normalize( (view_pos.xyz - world_pos.xyz) );
        float3 hv = normalize( v_view + l );
        float n_dot_v = dot( n, v_view );
        float n_dot_h = dot( n, hv );
        float v_dot_h = dot( v_view, hv );
        float n_dot_h_2 = 2.0f * n_dot_h;
        float g1 = (n_dot_h_2 * n_dot_v) / v_dot_h;
        float g2 = (n_dot_h_2 * n_dot_l) / v_dot_h;
        float geom_atten = min(1.0, min(g1, g2));
        float r1 = 1.0f / ( 4.0f * roughness_sq * pow(n_dot_h, 4.0f));
        float r2 = (n_dot_h * n_dot_h - 1.0) / (roughness_sq * n_dot_h * n_dot_h);
        float roughness_atten = r1 * exp(r2);
        float fresnel = pow(1.0 - v_dot_h, 5.0);
        fresnel *= roughness;
        fresnel += reflectivity;
        float specular = (fresnel * geom_atten * roughness_atten) / (n_dot_v * n_dot_l * 3.1419);
        float3 lit_colour = metalness * light_colour * n_dot_l * ( k + specular * ( 1.0 - k ) );
        return saturate(lit_colour);
    }
    return float3( 0.0, 0.0, 0.0 );
}
float3 oren_nayar(
float4 light_pos_radius,
float3 light_colour,
float3 n,
float3 world_pos,
float3 view_pos,
float roughness,
float3 albedo)
{
    float3 v = normalize(view_pos-world_pos);
    float3 l = normalize(light_pos_radius.xyz-world_pos);
    float l_dot_v = dot(l, v);
    float n_dot_l = dot(n, l);
    float n_dot_v = dot(n, v);
    float s = l_dot_v - n_dot_l * n_dot_v;
    float t = lerp(1.0, max(n_dot_l, n_dot_v), step(0.0, s));
    float lum = length( albedo );
    float sigma2 = roughness * roughness;
    float A = 1.0 + sigma2 * (lum / (sigma2 + 0.13) + 0.5 / (sigma2 + 0.33));
    float B = 0.45 * sigma2 / (sigma2 + 0.09);
    return ( albedo * light_colour * max(0.0, n_dot_l) * (A + B * s / t) / 3.14159265 );
}
float spot_light_attenuation(
float4 light_pos_radius,
float4 light_dir_cutoff,
float falloff,
float3 world_pos)
{
    float co = light_dir_cutoff.w;
    float3 vl = normalize(world_pos.xyz - light_pos_radius.xyz);
    float3 sd = normalize(light_dir_cutoff.xyz);
    float dp = (1.0 - dot(vl, sd));
    return smoothstep(co, co - falloff, dp);
}
float point_light_attenuation_cutoff(
float4 light_pos_radius,
float3 world_pos)
{
    float r = light_pos_radius.w;
    float d = length(world_pos.xyz - light_pos_radius.xyz);
    d = max(d - r, 0.0);
    float denom = d/r + 1.0;
    float attenuation = 1.0 / (denom*denom);
    float cutoff = 0.2;
    attenuation = (attenuation - cutoff) / (1.0 - cutoff);
    attenuation = max(attenuation, 0.0);
    return attenuation;
}
float sample_shadow_array_pcf_9(float array_slice, float3 sp)
{
    float2 samples[9];
    float2 inv_sm_size = float2(1.0/2048.0, 1.0/2048.0);
    samples[0] = float2(-1.0, -1.0) * inv_sm_size;
    samples[1] = float2(-1.0, 0.0) * inv_sm_size;
    samples[2] = float2(-1.0, 1.0) * inv_sm_size;
    samples[3] = float2(0.0, -1.0) * inv_sm_size;
    samples[4] = float2(0.0, 0.0) * inv_sm_size;
    samples[5] = float2(0.0, 1.0) * inv_sm_size;
    samples[6] = float2(1.0, -1.0) * inv_sm_size;
    samples[7] = float2(1.0, 0.0) * inv_sm_size;
    samples[8] = float2(1.0, 1.0) * inv_sm_size;
    float shadow = 0.0;
    for(int j = 0; j < 9; ++j)
    {
        shadow += sample_depth_compare_array(shadowmap_texture, sp.xy + samples[j], array_slice, sp.z);
    }
    shadow /= 9.0;
    return shadow;
}
float integrate_edge(float3 v1, float3 v2)
{
    float cos_theta = dot(v1, v2);
    float theta = acos(cos_theta);
    float res = cross(v1, v2).z * ((theta > 0.001) ? theta/sin(theta) : 1.0);
    return res;
}
void clip_quad_to_horizon(inout float3 L[5], out int n)
{
    int config = 0;
    if (L[0].z > 0.0) config += 1;
    if (L[1].z > 0.0) config += 2;
    if (L[2].z > 0.0) config += 4;
    if (L[3].z > 0.0) config += 8;
    n = 0;
    if (config == 0)
    {
    }
    else if (config == 1)
    {
        n = 3;
        L[1] = -L[1].z * L[0] + L[0].z * L[1];
        L[2] = -L[3].z * L[0] + L[0].z * L[3];
    }
    else if (config == 2)
    {
        n = 3;
        L[0] = -L[0].z * L[1] + L[1].z * L[0];
        L[2] = -L[2].z * L[1] + L[1].z * L[2];
    }
    else if (config == 3)
    {
        n = 4;
        L[2] = -L[2].z * L[1] + L[1].z * L[2];
        L[3] = -L[3].z * L[0] + L[0].z * L[3];
    }
    else if (config == 4)
    {
        n = 3;
        L[0] = -L[3].z * L[2] + L[2].z * L[3];
        L[1] = -L[1].z * L[2] + L[2].z * L[1];
    }
    else if (config == 5)
    {
        n = 0;
    }
    else if (config == 6)
    {
        n = 4;
        L[0] = -L[0].z * L[1] + L[1].z * L[0];
        L[3] = -L[3].z * L[2] + L[2].z * L[3];
    }
    else if (config == 7)
    {
        n = 5;
        L[4] = -L[3].z * L[0] + L[0].z * L[3];
        L[3] = -L[3].z * L[2] + L[2].z * L[3];
    }
    else if (config == 8)
    {
        n = 3;
        L[0] = -L[0].z * L[3] + L[3].z * L[0];
        L[1] = -L[2].z * L[3] + L[3].z * L[2];
        L[2] = L[3];
    }
    else if (config == 9)
    {
        n = 4;
        L[1] = -L[1].z * L[0] + L[0].z * L[1];
        L[2] = -L[2].z * L[3] + L[3].z * L[2];
    }
    else if (config == 10)
    {
        n = 0;
    }
    else if (config == 11)
    {
        n = 5;
        L[4] = L[3];
        L[3] = -L[2].z * L[3] + L[3].z * L[2];
        L[2] = -L[2].z * L[1] + L[1].z * L[2];
    }
    else if (config == 12)
    {
        n = 4;
        L[1] = -L[1].z * L[2] + L[2].z * L[1];
        L[0] = -L[0].z * L[3] + L[3].z * L[0];
    }
    else if (config == 13)
    {
        n = 5;
        L[4] = L[3];
        L[3] = L[2];
        L[2] = -L[1].z * L[2] + L[2].z * L[1];
        L[1] = -L[1].z * L[0] + L[0].z * L[1];
    }
    else if (config == 14)
    {
        n = 5;
        L[4] = -L[0].z * L[3] + L[3].z * L[0];
        L[0] = -L[0].z * L[1] + L[1].z * L[0];
    }
    else if (config == 15)
    {
        n = 4;
    }
    if (n == 3)
    L[3] = L[0];
    if (n == 4)
    L[4] = L[0];
}
float3 ltc_uv_coord(float3 p[4])
{
    float3 v1 = p[1] - p[0];
    float3 v2 = p[3] - p[0];
    float3 plane_ortho = (cross(v1, v2));
    float plane_area_squared = dot(plane_ortho, plane_ortho);
    float plane_distx_plane_area = dot(plane_ortho, p[0]);
    float3 pp = plane_distx_plane_area * plane_ortho / plane_area_squared - p[0];
    float v1_dot_v2 = dot(v1, v2);
    float inv_v1_dot_v1 = 1.0 / dot(v1, v1);
    float3 vv2 = v2 - v1 * v1_dot_v2 * inv_v1_dot_v1;
    float2 puv;
    puv.y = dot(vv2, pp) / dot(vv2, vv2);
    puv.x = dot(v1, pp) * inv_v1_dot_v1 - v1_dot_v2 * inv_v1_dot_v1 * puv.y;
    float d = abs(plane_distx_plane_area) / pow(plane_area_squared, 0.75);
    return float3(puv, d);
}
float4 ltc_evaluate(
float3 n,
float3 v,
float3 p,
float3x3 minv,
float3 points[4],
bool two_sided)
{
    float3 t1, t2;
    t1 = normalize(v - n * dot(v, n));
    t2 = cross(n, t1);
    float3x3 ttn = from_columns_3x3(t1, t2, n);
    minv = mul(minv, ttn);
    float3 l[5];
    l[0] = mul(minv, points[0] - p);
    l[1] = mul(minv, points[1] - p);
    l[2] = mul(minv, points[2] - p);
    l[3] = mul(minv, points[3] - p);
    l[4] = l[3];
    float3 ll[4];
    ll[0] = l[0];
    ll[1] = l[1];
    ll[2] = l[2];
    ll[3] = l[3];
    float3 uvl = ltc_uv_coord(ll);
    int nc;
    clip_quad_to_horizon(l, nc);
    if (nc == 0)
    return float4(0, 0, 0, 0.0);
    l[0] = normalize(l[0]);
    l[1] = normalize(l[1]);
    l[2] = normalize(l[2]);
    l[3] = normalize(l[3]);
    l[4] = normalize(l[4]);
    float sum = 0.0;
    sum += integrate_edge(l[0], l[1]);
    sum += integrate_edge(l[1], l[2]);
    sum += integrate_edge(l[2], l[3]);
    if (nc >= 4)
    sum += integrate_edge(l[3], l[4]);
    if (nc == 5)
    sum += integrate_edge(l[4], l[0]);
    sum = two_sided ? abs(sum) : max(0.0, sum);
    float3 lo_i = float3(sum, sum, sum);
    return float4(uvl.x, uvl.y, uvl.z, sum);
}
float ltc_evaluate_cc(
float3 n,
float3 v,
float3 p,
float3x3 minv,
float3 points[4],
bool two_sided)
{
    float3 t1, t2;
    t1 = normalize(v - n * dot(v, n));
    t2 = cross(n, t1);
    float3x3 ttn = from_columns_3x3(t1, t2, n);
    minv = mul(minv, ttn);
    float3 l[5];
    for(int i = 0; i < 4; ++i)
    l[i] = mul(minv, points[i] - p);
    l[4] = l[3];
    int nc;
    clip_quad_to_horizon(l, nc);
    if (nc == 0)
    return 0.0;
    for(int i = 0; i < 5; ++i)
    l[i] = normalize(l[i]);
    float sum = 0.0;
    sum += integrate_edge(l[0], l[1]);
    sum += integrate_edge(l[1], l[2]);
    sum += integrate_edge(l[2], l[3]);
    if (nc >= 4)
    sum += integrate_edge(l[3], l[4]);
    if (nc == 5)
    sum += integrate_edge(l[4], l[0]);
    sum = two_sided ? abs(sum) : max(0.0, sum);
    return sum;
}
float4 area_light_specular_uv(
float3 points[4],
float3 pos,
float roughness,
float3 n,
float3 v)
{
    float pi = 3.14159265359;
    float lut_size = 64.0;
    float lut_scale = (lut_size - 1.0)/lut_size;
    float lut_bias = 0.5/lut_size;
    float theta = acos(dot(n, v));
    float2 uv = float2(roughness, theta / (0.5 * pi));
    uv = uv * lut_scale + lut_bias;
    float4 mat = sample_texture(ltc_mat, uv);
    float mag = sample_texture(ltc_mag, uv).w;
    float3x3 minv = from_rows_3x3(
    float3(1.0, 0.0, mat.y),
    float3(0.0, mat.z, 0.0),
    float3(mat.w, 0.0, mat.x)
    );
    float4 spec = ltc_evaluate(n, v, pos, minv, points, true);
    return spec;
}
float area_light_specular(
float3 points[4],
float3 pos,
float roughness,
float3 n,
float3 v)
{
    float pi = 3.14159265359;
    float lut_size = 64.0;
    float lut_scale = (lut_size - 1.0)/lut_size;
    float lut_bias = 0.5/lut_size;
    float theta = acos(dot(n, v));
    float2 uv = float2(roughness, theta / (0.5 * pi));
    uv = uv * lut_scale + lut_bias;
    float4 mat = sample_texture(ltc_mat, uv);
    float mag = sample_texture(ltc_mag, uv).w;
    float3x3 minv = from_rows_3x3(
    float3(1.0, 0.0, mat.y),
    float3(0.0, mat.z, 0.0),
    float3(mat.w, 0.0, mat.x)
    );
    float spec = ltc_evaluate_cc(n, v, pos, minv, points, true);
    return spec;
}
float4 area_light_diffuse_uv(
float3 points[4],
float3 pos,
float3 n,
float3 v)
{
    float3x3 difv = float3x3(
    float3(1.0, 0.0, 0.0),
    float3(0.0, 1.0, 0.0),
    float3(0.0, 0.0, 1.0)
    );
    float4 diff = ltc_evaluate(n, v, pos, difv, points, true);
    return diff;
}
float area_light_diffuse(
float3 points[4],
float3 pos,
float3 n,
float3 v)
{
    float3x3 difv = float3x3(
    float3(1.0, 0.0, 0.0),
    float3(0.0, 1.0, 0.0),
    float3(0.0, 0.0, 1.0)
    );
    float diff = ltc_evaluate_cc(n, v, pos, difv, points, true);
    return diff;
}
float3 transform_ts_normal( float3 t, float3 b, float3 n, float3 ts_normal )
{
    float3x3 tbn;
    tbn[0] = float3(t.x, b.x, n.x);
    tbn[1] = float3(t.y, b.y, n.y);
    tbn[2] = float3(t.z, b.z, n.z);
    return normalize( mul_tbn( tbn, ts_normal ) );
}
float3 hash_33( float3 p )
{
    p = float3(dot(p,float3(127.1,311.7, 74.7)),
    dot(p,float3(269.5,183.3,246.1)),
    dot(p,float3(113.5,271.9,124.6)));
    return fract(sin(p)*43758.5453123) * 2.0 - 1.0;
}
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.world_pos = world_pos_vs_output;
    _input.normal = normal_vs_output;
    _input.tangent = tangent_vs_output;
    _input.bitangent = bitangent_vs_output;
    _input.texcoord = texcoord_vs_output;
    _input.colour = colour_vs_output;
    ps_output _output;
    float4 albedo = sample_texture( diffuse_texture, _input.texcoord.xy );
    float3 normal_sample = sample_texture( normal_texture, _input.texcoord.xy ).rgb;
    float4 ro_sample = sample_texture( specular_texture, _input.texcoord.xy );
    float4 specular_sample = float4(1.0, 1.0, 1.0, 1.0);
    normal_sample = normal_sample * 2.0 - 1.0;
    float3 n = transform_ts_normal(
    _input.tangent,
    _input.bitangent,
    _input.normal,
    normal_sample );
    albedo *= _input.colour;
    float4 metalness = float4(1.0, 1.0, 1.0, 1.0);
    float3 lit_colour = float3( 0.0, 0.0, 0.0 );
    float reflectivity = saturate(user_data.z);
    float roughness = saturate(user_data.y);
    reflectivity = m_reflectivity;
    roughness = ro_sample.r;
    roughness = _input.colour.a;
    albedo.a = 1.0;
    float t = 1.0;
    float3 lll = float3(0.0, 0.0, 0.0);
    int shadow_map_index = 0;
    _pmfx_loop
    for( int i = 0; i < int(light_info.x); ++i )
    {
        float3 light_col = float3( 0.0, 0.0, 0.0 );
        light_col += cook_torrence(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        albedo.rgb,
        metalness.rgb,
        roughness,
        reflectivity
        );
        light_col += oren_nayar(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        1.0 - roughness,
        albedo.rgb
        );
        if( lights[i].colour.a == 0.0 )
        {
            lit_colour += light_col;
            continue;
        }
        else
        {
            float shadow = 1.0;
            float d = 1.0;
            float4 offset_pos = float4(_input.world_pos.xyz + n.xyz * 0.01, 1.0);
            float4 sp = mul( offset_pos, shadow_matrix[i] );
            sp.xyz /= sp.w;
            sp.y *= -1.0;
            sp.xy = sp.xy * 0.5 + 0.5;
            sp.z = remap_depth(sp.z);
            shadow = sample_shadow_array_pcf_9(float(shadow_map_index), sp.xyz);
            lit_colour += light_col * shadow;
            ++shadow_map_index;
        }
    }
    int point_start = int(light_info.x);
    int point_end = int(light_info.x) + int(light_info.y);
    int omni_shadow_index = 0;
    _pmfx_loop
    for( int i = point_start; i < point_end; ++i )
    {
        float3 light_col = float3( 0.0, 0.0, 0.0 );
        light_col += cook_torrence(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        albedo.rgb,
        metalness.rgb,
        roughness,
        reflectivity
        );
        light_col += oren_nayar(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        roughness,
        albedo.rgb
        );
        float a = point_light_attenuation_cutoff( lights[i].pos_radius, _input.world_pos.xyz );
        light_col *= a;
        if( lights[i].colour.a == 0.0)
        {
            lit_colour += light_col;
            continue;
        }
        else
        {
            lit_colour += light_col;
            continue;
        }
    }
    int spot_start = point_end;
    int spot_end = spot_start + int(light_info.z);
    _pmfx_loop
    for(int i = spot_start; i < spot_end; ++i )
    {
        float3 light_col = float3( 0.0, 0.0, 0.0 );
        light_col += cook_torrence(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        albedo.rgb,
        metalness.rgb,
        roughness,
        reflectivity
        );
        light_col += oren_nayar(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        roughness,
        albedo.rgb
        );
        float a = spot_light_attenuation(lights[i].pos_radius,
        lights[i].dir_cutoff,
        lights[i].data.x,
        _input.world_pos.xyz );
        light_col *= a;
        if( lights[i].colour.a == 0.0 )
        {
            lit_colour += light_col;
            continue;
        }
        else
        {
            float shadow = 1.0;
            float d = 1.0;
            float4 offset_pos = float4(_input.world_pos.xyz + n.xyz * 0.01, 1.0);
            float4 sp = mul( offset_pos, shadow_matrix[shadow_map_index] );
            sp.xyz /= sp.w;
            sp.y *= -1.0;
            sp.xy = sp.xy * 0.5 + 0.5;
            sp.z = remap_depth(sp.z);
            shadow = sample_shadow_array_pcf_9(float(shadow_map_index), sp.xyz);
            lit_colour += light_col * shadow;
            ++shadow_map_index;
        }
    }
    {
        float pi = 3.14159265359;
        int num_area_lights = int(area_light_info.x);
        for(int i = 0; i < num_area_lights; ++i)
        {
            float3 v = -normalize(_input.world_pos.xyz - camera_view_pos.xyz);
            float3 pos = _input.world_pos.xyz;
            float3 points[4];
            for(int j = 0; j < 4; ++j)
            points[j] = area_lights[i].corners[j].xyz;
            float diff_sum = area_light_diffuse(points, pos, n, v);
            float3 diff = area_lights[i].colour.rgb * diff_sum;
            float spec_sum = area_light_specular(points, pos, ro_sample.x, n, v);
            float3 spec = area_lights[i].colour.rgb * spec_sum;
            float3 light_col = (spec.rgb + diff.rgb) / (2.0 * pi);
            lit_colour += light_col;
        }
        int ts = num_area_lights;
        int num_area_lights_textured = int(area_light_info.y);
        for(int i = ts; i < ts + num_area_lights_textured; ++i)
        {
            float slice = area_lights[i].colour.w;
            float levels = 8.0;
            float2 inv_texel = float2(1.0/640.0, 1.0/480.0);
            float2 inv_texel_x = float2(1.0, 1.0) - inv_texel;
            float3 points[4];
            for(int j = 0; j < 4; ++j)
            points[j] = area_lights[i].corners[j].xyz;
            float3 v = -normalize(_input.world_pos.xyz - camera_view_pos.xyz);
            float3 pos = _input.world_pos.xyz;
            float4 diff_uv = area_light_diffuse_uv(points, pos, n, v);
            float2 duv = clamp(diff_uv.xy, inv_texel, inv_texel_x);
            float3 diff = sample_texture_array_level( area_light_textures, duv, slice, diff_uv.z * levels).rgb * diff_uv.w;
            float4 spec_uv = area_light_specular_uv(points, pos, ro_sample.x, n, v);
            float2 suv = clamp(spec_uv.xy, inv_texel, inv_texel_x);
            float3 spec = sample_texture_array_level(area_light_textures, suv, slice, spec_uv.z * levels).rgb * spec_uv.w;
            float3 light_col = (spec.rgb + diff.rgb) / (2.0 * pi);
            lit_colour += light_col;
        }
    }
    _output.colour.rgb = lit_colour.rgb * albedo.a;
    _output.colour.a = albedo.a;
    float3 gn = _input.normal.xyz;
    float3 gt = _input.tangent.xyz;
    float3 gb = _input.bitangent.xyz;
    float3 dim = gi_scene_size.xyz;
    float3 to_uvx = dim * 0.5;
    int num_rays = 16;
    float3 rays[16];
    rays[0] = float3(0.57735, 0.57735, 0.57735);
    rays[1] = float3(0.57735, -0.57735, -0.57735);
    rays[2] = float3(-0.57735, 0.57735, -0.57735);
    rays[3] = float3(-0.57735, -0.57735, 0.57735);
    rays[4] = float3(-0.903007, -0.182696, -0.388844);
    rays[5] = float3(-0.903007, 0.182696, 0.388844);
    rays[6] = float3(0.903007, -0.182696, 0.388844);
    rays[7] = float3(0.903007, 0.182696, -0.388844);
    rays[8] = float3(-0.388844, -0.903007, -0.182696);
    rays[9] = float3(0.388844, -0.903007, 0.182696);
    rays[10] = float3(0.388844, 0.903007, -0.182696);
    rays[11] = float3(-0.388844, 0.903007, 0.182696);
    rays[12] = float3(-0.182696, -0.388844, -0.903007);
    rays[13] = float3(0.182696, 0.388844, -0.903007);
    rays[14] = float3(-0.182696, 0.388844, 0.903007);
    rays[15] = float3(0.182696, -0.388844, 0.903007);
    float4 gi = float4(0.0, 0.0, 0.0, 0.0);
    float4 sp = mul(_input.world_pos, vp_matrix);
    sp /= sp.w;
    sp.x *= (1280.0/512.0);
    sp.y *= (720.0/512.0);
    for(int i = 0; i < num_rays; ++i)
    {
        float3 noise = (hash_33(_input.world_pos.xyz + user_data.yyy));
        float3 noise2 = (sample_texture_level(blue_noise, sp.xy + noise.xy, 0.0).rgb * 2.0 - 1.0);
        float3 tex_size = gi_volume_size.xyz;
        float3 ray = chebyshev_normalize(noise2 + rays[i]);
        float3 cn = chebyshev_normalize(n);
        float3 step = (dim*2.0) / tex_size;
        float3 sp = _input.world_pos.xyz + (cn * step);
        ray *= dot(ray, gn) < 0.0 ? -1.0 : 1.0;
        float4 ray_gi = float4(0.0, 0.0, 0.0, 0.0);
        for(int j = 0; j < 4; ++j)
        {
            for(int k = 0; k < 2; ++k)
            {
                step = (dim*2.0) / tex_size;
                float3 uvw = saturate((sp / to_uvx) * 0.5 + 0.5);
                float4 g = sample_texture_level( volume_gi, uvw, float(j));
                float d = length(_input.world_pos.xyz - sp);
                d = smoothstep(0.0, 8.0, d);
                ray_gi.rgb = ray_gi.rgb + g.rgb * d;
                ray_gi.a += g.a;
                sp += ray * step.x;
            }
            tex_size /= 2.0;
            if(ray_gi.a >= 1.0 && j > 1)
            break;
        }
        gi += ray_gi;
    }
    gi /= float(num_rays);
    _output.colour.rgb = gi.rgb * 2.0 * m_albedo.rgb + lit_colour.rgb;
    if(albedo.a <= 0.0)
    discard;
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//forward_render forward_lit__1073741840__ ps 1073741840
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 world_pos_vs_output;
in float3 normal_vs_output;
in float3 tangent_vs_output;
in float3 bitangent_vs_output;
in float4 texcoord_vs_output;
in float4 colour_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 world_pos;
    float3 normal;
    float3 tangent;
    float3 bitangent;
    float4 texcoord;
    float4 colour;
};
struct ps_output
{
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
layout (std140) uniform per_draw_call
{
    float4x4 world_matrix;
    float4 user_data;
    float4 user_data2;
    float4x4 world_matrix_inv_transpose;
};
layout (std140) uniform per_pass_lights
{
    float4 light_info;
    light_data lights[100];
};
layout (std140) uniform per_pass_shadow
{
    float4x4 shadow_matrix[100];
};
layout (std140) uniform per_pass_area_lights
{
    float4 area_light_info;
    area_light_data area_lights[10];
};
layout (std140) uniform cbuffer_gi_volume
{
    float4 gi_scene_size;
    float4 gi_volume_size;
};
layout (std140) uniform material_data
{
    float4 m_albedo;
    float m_roughness;
    float m_reflectivity;
    float2 m_padding;
};
texture_2d( diffuse_texture, 0 );
texture_2d( normal_texture, 1 );
texture_2d( specular_texture, 2 );
texture_2d( blue_noise, 5 );
texture_2d( ltc_mat, 13 );
texture_2d( ltc_mag, 12 );
texture_2d_array( area_light_textures, 11 );
texture_3d( volume_gi, 9 );
depth_2d_array( shadowmap_texture, 15 );
float3 cook_torrence(
float4 light_pos_radius,
float3 light_colour,
float3 n,
float3 world_pos,
float3 view_pos,
float3 albedo,
float3 metalness,
float roughness,
float reflectivity
)
{
    float3 l = normalize( light_pos_radius.xyz - world_pos.xyz );
    float n_dot_l = dot( n, l );
    if( n_dot_l > 0.0f )
    {
        float roughness_sq = roughness * roughness;
        float k = reflectivity;
        float3 v_view = normalize( (view_pos.xyz - world_pos.xyz) );
        float3 hv = normalize( v_view + l );
        float n_dot_v = dot( n, v_view );
        float n_dot_h = dot( n, hv );
        float v_dot_h = dot( v_view, hv );
        float n_dot_h_2 = 2.0f * n_dot_h;
        float g1 = (n_dot_h_2 * n_dot_v) / v_dot_h;
        float g2 = (n_dot_h_2 * n_dot_l) / v_dot_h;
        float geom_atten = min(1.0, min(g1, g2));
        float r1 = 1.0f / ( 4.0f * roughness_sq * pow(n_dot_h, 4.0f));
        float r2 = (n_dot_h * n_dot_h - 1.0) / (roughness_sq * n_dot_h * n_dot_h);
        float roughness_atten = r1 * exp(r2);
        float fresnel = pow(1.0 - v_dot_h, 5.0);
        fresnel *= roughness;
        fresnel += reflectivity;
        float specular = (fresnel * geom_atten * roughness_atten) / (n_dot_v * n_dot_l * 3.1419);
        float3 lit_colour = metalness * light_colour * n_dot_l * ( k + specular * ( 1.0 - k ) );
        return saturate(lit_colour);
    }
    return float3( 0.0, 0.0, 0.0 );
}
float3 oren_nayar(
float4 light_pos_radius,
float3 light_colour,
float3 n,
float3 world_pos,
float3 view_pos,
float roughness,
float3 albedo)
{
    float3 v = normalize(view_pos-world_pos);
    float3 l = normalize(light_pos_radius.xyz-world_pos);
    float l_dot_v = dot(l, v);
    float n_dot_l = dot(n, l);
    float n_dot_v = dot(n, v);
    float s = l_dot_v - n_dot_l * n_dot_v;
    float t = lerp(1.0, max(n_dot_l, n_dot_v), step(0.0, s));
    float lum = length( albedo );
    float sigma2 = roughness * roughness;
    float A = 1.0 + sigma2 * (lum / (sigma2 + 0.13) + 0.5 / (sigma2 + 0.33));
    float B = 0.45 * sigma2 / (sigma2 + 0.09);
    return ( albedo * light_colour * max(0.0, n_dot_l) * (A + B * s / t) / 3.14159265 );
}
float spot_light_attenuation(
float4 light_pos_radius,
float4 light_dir_cutoff,
float falloff,
float3 world_pos)
{
    float co = light_dir_cutoff.w;
    float3 vl = normalize(world_pos.xyz - light_pos_radius.xyz);
    float3 sd = normalize(light_dir_cutoff.xyz);
    float dp = (1.0 - dot(vl, sd));
    return smoothstep(co, co - falloff, dp);
}
float point_light_attenuation_cutoff(
float4 light_pos_radius,
float3 world_pos)
{
    float r = light_pos_radius.w;
    float d = length(world_pos.xyz - light_pos_radius.xyz);
    d = max(d - r, 0.0);
    float denom = d/r + 1.0;
    float attenuation = 1.0 / (denom*denom);
    float cutoff = 0.2;
    attenuation = (attenuation - cutoff) / (1.0 - cutoff);
    attenuation = max(attenuation, 0.0);
    return attenuation;
}
float sample_shadow_array_pcf_9(float array_slice, float3 sp)
{
    float2 samples[9];
    float2 inv_sm_size = float2(1.0/2048.0, 1.0/2048.0);
    samples[0] = float2(-1.0, -1.0) * inv_sm_size;
    samples[1] = float2(-1.0, 0.0) * inv_sm_size;
    samples[2] = float2(-1.0, 1.0) * inv_sm_size;
    samples[3] = float2(0.0, -1.0) * inv_sm_size;
    samples[4] = float2(0.0, 0.0) * inv_sm_size;
    samples[5] = float2(0.0, 1.0) * inv_sm_size;
    samples[6] = float2(1.0, -1.0) * inv_sm_size;
    samples[7] = float2(1.0, 0.0) * inv_sm_size;
    samples[8] = float2(1.0, 1.0) * inv_sm_size;
    float shadow = 0.0;
    for(int j = 0; j < 9; ++j)
    {
        shadow += sample_depth_compare_array(shadowmap_texture, sp.xy + samples[j], array_slice, sp.z);
    }
    shadow /= 9.0;
    return shadow;
}
float integrate_edge(float3 v1, float3 v2)
{
    float cos_theta = dot(v1, v2);
    float theta = acos(cos_theta);
    float res = cross(v1, v2).z * ((theta > 0.001) ? theta/sin(theta) : 1.0);
    return res;
}
void clip_quad_to_horizon(inout float3 L[5], out int n)
{
    int config = 0;
    if (L[0].z > 0.0) config += 1;
    if (L[1].z > 0.0) config += 2;
    if (L[2].z > 0.0) config += 4;
    if (L[3].z > 0.0) config += 8;
    n = 0;
    if (config == 0)
    {
    }
    else if (config == 1)
    {
        n = 3;
        L[1] = -L[1].z * L[0] + L[0].z * L[1];
        L[2] = -L[3].z * L[0] + L[0].z * L[3];
    }
    else if (config == 2)
    {
        n = 3;
        L[0] = -L[0].z * L[1] + L[1].z * L[0];
        L[2] = -L[2].z * L[1] + L[1].z * L[2];
    }
    else if (config == 3)
    {
        n = 4;
        L[2] = -L[2].z * L[1] + L[1].z * L[2];
        L[3] = -L[3].z * L[0] + L[0].z * L[3];
    }
    else if (config == 4)
    {
        n = 3;
        L[0] = -L[3].z * L[2] + L[2].z * L[3];
        L[1] = -L[1].z * L[2] + L[2].z * L[1];
    }
    else if (config == 5)
    {
        n = 0;
    }
    else if (config == 6)
    {
        n = 4;
        L[0] = -L[0].z * L[1] + L[1].z * L[0];
        L[3] = -L[3].z * L[2] + L[2].z * L[3];
    }
    else if (config == 7)
    {
        n = 5;
        L[4] = -L[3].z * L[0] + L[0].z * L[3];
        L[3] = -L[3].z * L[2] + L[2].z * L[3];
    }
    else if (config == 8)
    {
        n = 3;
        L[0] = -L[0].z * L[3] + L[3].z * L[0];
        L[1] = -L[2].z * L[3] + L[3].z * L[2];
        L[2] = L[3];
    }
    else if (config == 9)
    {
        n = 4;
        L[1] = -L[1].z * L[0] + L[0].z * L[1];
        L[2] = -L[2].z * L[3] + L[3].z * L[2];
    }
    else if (config == 10)
    {
        n = 0;
    }
    else if (config == 11)
    {
        n = 5;
        L[4] = L[3];
        L[3] = -L[2].z * L[3] + L[3].z * L[2];
        L[2] = -L[2].z * L[1] + L[1].z * L[2];
    }
    else if (config == 12)
    {
        n = 4;
        L[1] = -L[1].z * L[2] + L[2].z * L[1];
        L[0] = -L[0].z * L[3] + L[3].z * L[0];
    }
    else if (config == 13)
    {
        n = 5;
        L[4] = L[3];
        L[3] = L[2];
        L[2] = -L[1].z * L[2] + L[2].z * L[1];
        L[1] = -L[1].z * L[0] + L[0].z * L[1];
    }
    else if (config == 14)
    {
        n = 5;
        L[4] = -L[0].z * L[3] + L[3].z * L[0];
        L[0] = -L[0].z * L[1] + L[1].z * L[0];
    }
    else if (config == 15)
    {
        n = 4;
    }
    if (n == 3)
    L[3] = L[0];
    if (n == 4)
    L[4] = L[0];
}
float3 ltc_uv_coord(float3 p[4])
{
    float3 v1 = p[1] - p[0];
    float3 v2 = p[3] - p[0];
    float3 plane_ortho = (cross(v1, v2));
    float plane_area_squared = dot(plane_ortho, plane_ortho);
    float plane_distx_plane_area = dot(plane_ortho, p[0]);
    float3 pp = plane_distx_plane_area * plane_ortho / plane_area_squared - p[0];
    float v1_dot_v2 = dot(v1, v2);
    float inv_v1_dot_v1 = 1.0 / dot(v1, v1);
    float3 vv2 = v2 - v1 * v1_dot_v2 * inv_v1_dot_v1;
    float2 puv;
    puv.y = dot(vv2, pp) / dot(vv2, vv2);
    puv.x = dot(v1, pp) * inv_v1_dot_v1 - v1_dot_v2 * inv_v1_dot_v1 * puv.y;
    float d = abs(plane_distx_plane_area) / pow(plane_area_squared, 0.75);
    return float3(puv, d);
}
float4 ltc_evaluate(
float3 n,
float3 v,
float3 p,
float3x3 minv,
float3 points[4],
bool two_sided)
{
    float3 t1, t2;
    t1 = normalize(v - n * dot(v, n));
    t2 = cross(n, t1);
    float3x3 ttn = from_columns_3x3(t1, t2, n);
    minv = mul(minv, ttn);
    float3 l[5];
    l[0] = mul(minv, points[0] - p);
    l[1] = mul(minv, points[1] - p);
    l[2] = mul(minv, points[2] - p);
    l[3] = mul(minv, points[3] - p);
    l[4] = l[3];
    float3 ll[4];
    ll[0] = l[0];
    ll[1] = l[1];
    ll[2] = l[2];
    ll[3] = l[3];
    float3 uvl = ltc_uv_coord(ll);
    int nc;
    clip_quad_to_horizon(l, nc);
    if (nc == 0)
    return float4(0, 0, 0, 0.0);
    l[0] = normalize(l[0]);
    l[1] = normalize(l[1]);
    l[2] = normalize(l[2]);
    l[3] = normalize(l[3]);
    l[4] = normalize(l[4]);
    float sum = 0.0;
    sum += integrate_edge(l[0], l[1]);
    sum += integrate_edge(l[1], l[2]);
    sum += integrate_edge(l[2], l[3]);
    if (nc >= 4)
    sum += integrate_edge(l[3], l[4]);
    if (nc == 5)
    sum += integrate_edge(l[4], l[0]);
    sum = two_sided ? abs(sum) : max(0.0, sum);
    float3 lo_i = float3(sum, sum, sum);
    return float4(uvl.x, uvl.y, uvl.z, sum);
}
float ltc_evaluate_cc(
float3 n,
float3 v,
float3 p,
float3x3 minv,
float3 points[4],
bool two_sided)
{
    float3 t1, t2;
    t1 = normalize(v - n * dot(v, n));
    t2 = cross(n, t1);
    float3x3 ttn = from_columns_3x3(t1, t2, n);
    minv = mul(minv, ttn);
    float3 l[5];
    for(int i = 0; i < 4; ++i)
    l[i] = mul(minv, points[i] - p);
    l[4] = l[3];
    int nc;
    clip_quad_to_horizon(l, nc);
    if (nc == 0)
    return 0.0;
    for(int i = 0; i < 5; ++i)
    l[i] = normalize(l[i]);
    float sum = 0.0;
    sum += integrate_edge(l[0], l[1]);
    sum += integrate_edge(l[1], l[2]);
    sum += integrate_edge(l[2], l[3]);
    if (nc >= 4)
    sum += integrate_edge(l[3], l[4]);
    if (nc == 5)
    sum += integrate_edge(l[4], l[0]);
    sum = two_sided ? abs(sum) : max(0.0, sum);
    return sum;
}
float4 area_light_specular_uv(
float3 points[4],
float3 pos,
float roughness,
float3 n,
float3 v)
{
    float pi = 3.14159265359;
    float lut_size = 64.0;
    float lut_scale = (lut_size - 1.0)/lut_size;
    float lut_bias = 0.5/lut_size;
    float theta = acos(dot(n, v));
    float2 uv = float2(roughness, theta / (0.5 * pi));
    uv = uv * lut_scale + lut_bias;
    float4 mat = sample_texture(ltc_mat, uv);
    float mag = sample_texture(ltc_mag, uv).w;
    float3x3 minv = from_rows_3x3(
    float3(1.0, 0.0, mat.y),
    float3(0.0, mat.z, 0.0),
    float3(mat.w, 0.0, mat.x)
    );
    float4 spec = ltc_evaluate(n, v, pos, minv, points, true);
    return spec;
}
float area_light_specular(
float3 points[4],
float3 pos,
float roughness,
float3 n,
float3 v)
{
    float pi = 3.14159265359;
    float lut_size = 64.0;
    float lut_scale = (lut_size - 1.0)/lut_size;
    float lut_bias = 0.5/lut_size;
    float theta = acos(dot(n, v));
    float2 uv = float2(roughness, theta / (0.5 * pi));
    uv = uv * lut_scale + lut_bias;
    float4 mat = sample_texture(ltc_mat, uv);
    float mag = sample_texture(ltc_mag, uv).w;
    float3x3 minv = from_rows_3x3(
    float3(1.0, 0.0, mat.y),
    float3(0.0, mat.z, 0.0),
    float3(mat.w, 0.0, mat.x)
    );
    float spec = ltc_evaluate_cc(n, v, pos, minv, points, true);
    return spec;
}
float4 area_light_diffuse_uv(
float3 points[4],
float3 pos,
float3 n,
float3 v)
{
    float3x3 difv = float3x3(
    float3(1.0, 0.0, 0.0),
    float3(0.0, 1.0, 0.0),
    float3(0.0, 0.0, 1.0)
    );
    float4 diff = ltc_evaluate(n, v, pos, difv, points, true);
    return diff;
}
float area_light_diffuse(
float3 points[4],
float3 pos,
float3 n,
float3 v)
{
    float3x3 difv = float3x3(
    float3(1.0, 0.0, 0.0),
    float3(0.0, 1.0, 0.0),
    float3(0.0, 0.0, 1.0)
    );
    float diff = ltc_evaluate_cc(n, v, pos, difv, points, true);
    return diff;
}
float3 transform_ts_normal( float3 t, float3 b, float3 n, float3 ts_normal )
{
    float3x3 tbn;
    tbn[0] = float3(t.x, b.x, n.x);
    tbn[1] = float3(t.y, b.y, n.y);
    tbn[2] = float3(t.z, b.z, n.z);
    return normalize( mul_tbn( tbn, ts_normal ) );
}
float3 hash_33( float3 p )
{
    p = float3(dot(p,float3(127.1,311.7, 74.7)),
    dot(p,float3(269.5,183.3,246.1)),
    dot(p,float3(113.5,271.9,124.6)));
    return fract(sin(p)*43758.5453123) * 2.0 - 1.0;
}
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.world_pos = world_pos_vs_output;
    _input.normal = normal_vs_output;
    _input.tangent = tangent_vs_output;
    _input.bitangent = bitangent_vs_output;
    _input.texcoord = texcoord_vs_output;
    _input.colour = colour_vs_output;
    ps_output _output;
    float4 albedo = sample_texture( diffuse_texture, _input.texcoord.xy );
    float3 normal_sample = sample_texture( normal_texture, _input.texcoord.xy ).rgb;
    float4 ro_sample = sample_texture( specular_texture, _input.texcoord.xy );
    float4 specular_sample = float4(1.0, 1.0, 1.0, 1.0);
    normal_sample = normal_sample * 2.0 - 1.0;
    float3 n = transform_ts_normal(
    _input.tangent,
    _input.bitangent,
    _input.normal,
    normal_sample );
    albedo *= _input.colour;
    float4 metalness = float4(1.0, 1.0, 1.0, 1.0);
    float3 lit_colour = float3( 0.0, 0.0, 0.0 );
    float reflectivity = saturate(user_data.z);
    float roughness = saturate(user_data.y);
    reflectivity = m_reflectivity;
    roughness = ro_sample.r;
    roughness = _input.colour.a;
    albedo.a = 1.0;
    float t = 1.0;
    float3 lll = float3(0.0, 0.0, 0.0);
    int shadow_map_index = 0;
    _pmfx_loop
    for( int i = 0; i < int(light_info.x); ++i )
    {
        float3 light_col = float3( 0.0, 0.0, 0.0 );
        light_col += cook_torrence(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        albedo.rgb,
        metalness.rgb,
        roughness,
        reflectivity
        );
        light_col += oren_nayar(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        1.0 - roughness,
        albedo.rgb
        );
        if( lights[i].colour.a == 0.0 )
        {
            lit_colour += light_col;
            continue;
        }
        else
        {
            float shadow = 1.0;
            float d = 1.0;
            float4 offset_pos = float4(_input.world_pos.xyz + n.xyz * 0.01, 1.0);
            float4 sp = mul( offset_pos, shadow_matrix[i] );
            sp.xyz /= sp.w;
            sp.y *= -1.0;
            sp.xy = sp.xy * 0.5 + 0.5;
            sp.z = remap_depth(sp.z);
            shadow = sample_shadow_array_pcf_9(float(shadow_map_index), sp.xyz);
            lit_colour += light_col * shadow;
            ++shadow_map_index;
        }
    }
    int point_start = int(light_info.x);
    int point_end = int(light_info.x) + int(light_info.y);
    int omni_shadow_index = 0;
    _pmfx_loop
    for( int i = point_start; i < point_end; ++i )
    {
        float3 light_col = float3( 0.0, 0.0, 0.0 );
        light_col += cook_torrence(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        albedo.rgb,
        metalness.rgb,
        roughness,
        reflectivity
        );
        light_col += oren_nayar(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        roughness,
        albedo.rgb
        );
        float a = point_light_attenuation_cutoff( lights[i].pos_radius, _input.world_pos.xyz );
        light_col *= a;
        if( lights[i].colour.a == 0.0)
        {
            lit_colour += light_col;
            continue;
        }
        else
        {
            lit_colour += light_col;
            continue;
        }
    }
    int spot_start = point_end;
    int spot_end = spot_start + int(light_info.z);
    _pmfx_loop
    for(int i = spot_start; i < spot_end; ++i )
    {
        float3 light_col = float3( 0.0, 0.0, 0.0 );
        light_col += cook_torrence(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        albedo.rgb,
        metalness.rgb,
        roughness,
        reflectivity
        );
        light_col += oren_nayar(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        roughness,
        albedo.rgb
        );
        float a = spot_light_attenuation(lights[i].pos_radius,
        lights[i].dir_cutoff,
        lights[i].data.x,
        _input.world_pos.xyz );
        light_col *= a;
        if( lights[i].colour.a == 0.0 )
        {
            lit_colour += light_col;
            continue;
        }
        else
        {
            float shadow = 1.0;
            float d = 1.0;
            float4 offset_pos = float4(_input.world_pos.xyz + n.xyz * 0.01, 1.0);
            float4 sp = mul( offset_pos, shadow_matrix[shadow_map_index] );
            sp.xyz /= sp.w;
            sp.y *= -1.0;
            sp.xy = sp.xy * 0.5 + 0.5;
            sp.z = remap_depth(sp.z);
            shadow = sample_shadow_array_pcf_9(float(shadow_map_index), sp.xyz);
            lit_colour += light_col * shadow;
            ++shadow_map_index;
        }
    }
    {
        float pi = 3.14159265359;
        int num_area_lights = int(area_light_info.x);
        for(int i = 0; i < num_area_lights; ++i)
        {
            float3 v = -normalize(_input.world_pos.xyz - camera_view_pos.xyz);
            float3 pos = _input.world_pos.xyz;
            float3 points[4];
            for(int j = 0; j < 4; ++j)
            points[j] = area_lights[i].corners[j].xyz;
            float diff_sum = area_light_diffuse(points, pos, n, v);
            float3 diff = area_lights[i].colour.rgb * diff_sum;
            float spec_sum = area_light_specular(points, pos, ro_sample.x, n, v);
            float3 spec = area_lights[i].colour.rgb * spec_sum;
            float3 light_col = (spec.rgb + diff.rgb) / (2.0 * pi);
            lit_colour += light_col;
        }
        int ts = num_area_lights;
        int num_area_lights_textured = int(area_light_info.y);
        for(int i = ts; i < ts + num_area_lights_textured; ++i)
        {
            float slice = area_lights[i].colour.w;
            float levels = 8.0;
            float2 inv_texel = float2(1.0/640.0, 1.0/480.0);
            float2 inv_texel_x = float2(1.0, 1.0) - inv_texel;
            float3 points[4];
            for(int j = 0; j < 4; ++j)
            points[j] = area_lights[i].corners[j].xyz;
            float3 v = -normalize(_input.world_pos.xyz - camera_view_pos.xyz);
            float3 pos = _input.world_pos.xyz;
            float4 diff_uv = area_light_diffuse_uv(points, pos, n, v);
            float2 duv = clamp(diff_uv.xy, inv_texel, inv_texel_x);
            float3 diff = sample_texture_array_level( area_light_textures, duv, slice, diff_uv.z * levels).rgb * diff_uv.w;
            float4 spec_uv = area_light_specular_uv(points, pos, ro_sample.x, n, v);
            float2 suv = clamp(spec_uv.xy, inv_texel, inv_texel_x);
            float3 spec = sample_texture_array_level(area_light_textures, suv, slice, spec_uv.z * levels).rgb * spec_uv.w;
            float3 light_col = (spec.rgb + diff.rgb) / (2.0 * pi);
            lit_colour += light_col;
        }
    }
    _output.colour.rgb = lit_colour.rgb * albedo.a;
    _output.colour.a = albedo.a;
    float3 gn = _input.normal.xyz;
    float3 gt = _input.tangent.xyz;
    float3 gb = _input.bitangent.xyz;
    float3 dim = gi_scene_size.xyz;
    float3 to_uvx = dim * 0.5;
    int num_rays = 16;
    float3 rays[16];
    rays[0] = float3(0.57735, 0.57735, 0.57735);
    rays[1] = float3(0.57735, -0.57735, -0.57735);
    rays[2] = float3(-0.57735, 0.57735, -0.57735);
    rays[3] = float3(-0.57735, -0.57735, 0.57735);
    rays[4] = float3(-0.903007, -0.182696, -0.388844);
    rays[5] = float3(-0.903007, 0.182696, 0.388844);
    rays[6] = float3(0.903007, -0.182696, 0.388844);
    rays[7] = float3(0.903007, 0.182696, -0.388844);
    rays[8] = float3(-0.388844, -0.903007, -0.182696);
    rays[9] = float3(0.388844, -0.903007, 0.182696);
    rays[10] = float3(0.388844, 0.903007, -0.182696);
    rays[11] = float3(-0.388844, 0.903007, 0.182696);
    rays[12] = float3(-0.182696, -0.388844, -0.903007);
    rays[13] = float3(0.182696, 0.388844, -0.903007);
    rays[14] = float3(-0.182696, 0.388844, 0.903007);
    rays[15] = float3(0.182696, -0.388844, 0.903007);
    float4 gi = float4(0.0, 0.0, 0.0, 0.0);
    float4 sp = mul(_input.world_pos, vp_matrix);
    sp /= sp.w;
    sp.x *= (1280.0/512.0);
    sp.y *= (720.0/512.0);
    for(int i = 0; i < num_rays; ++i)
    {
        float3 noise = (hash_33(_input.world_pos.xyz + user_data.yyy));
        float3 noise2 = (sample_texture_level(blue_noise, sp.xy + noise.xy, 0.0).rgb * 2.0 - 1.0);
        float3 tex_size = gi_volume_size.xyz;
        float3 ray = chebyshev_normalize(noise2 + rays[i]);
        float3 cn = chebyshev_normalize(n);
        float3 step = (dim*2.0) / tex_size;
        float3 sp = _input.world_pos.xyz + (cn * step);
        ray *= dot(ray, gn) < 0.0 ? -1.0 : 1.0;
        float4 ray_gi = float4(0.0, 0.0, 0.0, 0.0);
        for(int j = 0; j < 4; ++j)
        {
            for(int k = 0; k < 2; ++k)
            {
                step = (dim*2.0) / tex_size;
                float3 uvw = saturate((sp / to_uvx) * 0.5 + 0.5);
                float4 g = sample_texture_level( volume_gi, uvw, float(j));
                float d = length(_input.world_pos.xyz - sp);
                d = smoothstep(0.0, 8.0, d);
                ray_gi.rgb = ray_gi.rgb + g.rgb * d;
                ray_gi.a += g.a;
                sp += ray * step.x;
            }
            tex_size /= 2.0;
            if(ray_gi.a >= 1.0 && j > 1)
            break;
        }
        gi += ray_gi;
    }
    gi /= float(num_rays);
    _output.colour.rgb = gi.rgb * 2.0 * m_albedo.rgb + lit_colour.rgb;
    if(albedo.a <= 0.0)
    discard;
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//forward_render omni_shadow ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 world_pos_vs_output;
uniform float v_flip;
struct vs_output_zonly_wp
{
    float4 position;
    float4 world_pos;
};
struct ps_output_depth
{
    float depth;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform cbuffer_single_light
{
    light_data single_light;
};
void main()
{
    //assign vs_output_zonly_wp struct from glsl inputs
    vs_output_zonly_wp _input;
    _input.world_pos = world_pos_vs_output;
    ps_output_depth _output;
    float d = length(_input.world_pos.xyz - single_light.pos_radius.xyz) / single_light.pos_radius.w;
    _output.depth = d / 2.0;
    //assign glsl global outputs from structs
    depth_ps_output = _output.depth;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//forward_render simple_lighting__4__ ps 4
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 world_pos_vs_output;
in float3 normal_vs_output;
in float3 tangent_vs_output;
in float3 bitangent_vs_output;
in float4 texcoord_vs_output;
in float4 colour_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 world_pos;
    float3 normal;
    float3 tangent;
    float3 bitangent;
    float4 texcoord;
    float4 colour;
};
struct ps_output
{
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
layout (std140) uniform per_draw_call
{
    float4x4 world_matrix;
    float4 user_data;
    float4 user_data2;
    float4x4 world_matrix_inv_transpose;
};
layout (std140) uniform per_pass_lights
{
    float4 light_info;
    light_data lights[100];
};
layout (std140) uniform per_pass_shadow
{
    float4x4 shadow_matrix[100];
};
layout (std140) uniform material_data
{
    float4 m_albedo;
    float m_roughness;
    float m_reflectivity;
    float m_sss_scale;
    float m_padding;
};
texture_2d( diffuse_texture, 0 );
texture_2d( normal_texture, 1 );
texture_2d( specular_texture, 2 );
depth_2d( single_shadowmap_texture, 7 );
texture_2d( shadowmap_texture_sss, 8);
float3 cook_torrence(
float4 light_pos_radius,
float3 light_colour,
float3 n,
float3 world_pos,
float3 view_pos,
float3 albedo,
float3 metalness,
float roughness,
float reflectivity
)
{
    float3 l = normalize( light_pos_radius.xyz - world_pos.xyz );
    float n_dot_l = dot( n, l );
    if( n_dot_l > 0.0f )
    {
        float roughness_sq = roughness * roughness;
        float k = reflectivity;
        float3 v_view = normalize( (view_pos.xyz - world_pos.xyz) );
        float3 hv = normalize( v_view + l );
        float n_dot_v = dot( n, v_view );
        float n_dot_h = dot( n, hv );
        float v_dot_h = dot( v_view, hv );
        float n_dot_h_2 = 2.0f * n_dot_h;
        float g1 = (n_dot_h_2 * n_dot_v) / v_dot_h;
        float g2 = (n_dot_h_2 * n_dot_l) / v_dot_h;
        float geom_atten = min(1.0, min(g1, g2));
        float r1 = 1.0f / ( 4.0f * roughness_sq * pow(n_dot_h, 4.0f));
        float r2 = (n_dot_h * n_dot_h - 1.0) / (roughness_sq * n_dot_h * n_dot_h);
        float roughness_atten = r1 * exp(r2);
        float fresnel = pow(1.0 - v_dot_h, 5.0);
        fresnel *= roughness;
        fresnel += reflectivity;
        float specular = (fresnel * geom_atten * roughness_atten) / (n_dot_v * n_dot_l * 3.1419);
        float3 lit_colour = metalness * light_colour * n_dot_l * ( k + specular * ( 1.0 - k ) );
        return saturate(lit_colour);
    }
    return float3( 0.0, 0.0, 0.0 );
}
float3 oren_nayar(
float4 light_pos_radius,
float3 light_colour,
float3 n,
float3 world_pos,
float3 view_pos,
float roughness,
float3 albedo)
{
    float3 v = normalize(view_pos-world_pos);
    float3 l = normalize(light_pos_radius.xyz-world_pos);
    float l_dot_v = dot(l, v);
    float n_dot_l = dot(n, l);
    float n_dot_v = dot(n, v);
    float s = l_dot_v - n_dot_l * n_dot_v;
    float t = lerp(1.0, max(n_dot_l, n_dot_v), step(0.0, s));
    float lum = length( albedo );
    float sigma2 = roughness * roughness;
    float A = 1.0 + sigma2 * (lum / (sigma2 + 0.13) + 0.5 / (sigma2 + 0.33));
    float B = 0.45 * sigma2 / (sigma2 + 0.09);
    return ( albedo * light_colour * max(0.0, n_dot_l) * (A + B * s / t) / 3.14159265 );
}
float sample_shadow_pcf_9(float3 sp)
{
    float2 samples[9];
    float2 inv_sm_size = float2(1.0/2048.0, 1.0/2048.0);
    samples[0] = float2(-1.0, -1.0) * inv_sm_size;
    samples[1] = float2(-1.0, 0.0) * inv_sm_size;
    samples[2] = float2(-1.0, 1.0) * inv_sm_size;
    samples[3] = float2(0.0, -1.0) * inv_sm_size;
    samples[4] = float2(0.0, 0.0) * inv_sm_size;
    samples[5] = float2(0.0, 1.0) * inv_sm_size;
    samples[6] = float2(1.0, -1.0) * inv_sm_size;
    samples[7] = float2(1.0, 0.0) * inv_sm_size;
    samples[8] = float2(1.0, 1.0) * inv_sm_size;
    float shadow = 0.0;
    for(int j = 0; j < 9; ++j)
    {
        shadow += sample_depth_compare(single_shadowmap_texture, sp.xy + samples[j], sp.z);
    }
    shadow /= 9.0;
    return shadow;
}
float3 transform_ts_normal( float3 t, float3 b, float3 n, float3 ts_normal )
{
    float3x3 tbn;
    tbn[0] = float3(t.x, b.x, n.x);
    tbn[1] = float3(t.y, b.y, n.y);
    tbn[2] = float3(t.z, b.z, n.z);
    return normalize( mul_tbn( tbn, ts_normal ) );
}
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.world_pos = world_pos_vs_output;
    _input.normal = normal_vs_output;
    _input.tangent = tangent_vs_output;
    _input.bitangent = bitangent_vs_output;
    _input.texcoord = texcoord_vs_output;
    _input.colour = colour_vs_output;
    ps_output _output;
    float4 albedo = sample_texture( diffuse_texture, _input.texcoord.xy );
    float3 normal_sample = sample_texture( normal_texture, _input.texcoord.xy ).rgb;
    float4 ro_sample = sample_texture( specular_texture, _input.texcoord.xy );
    float4 specular_sample = float4(1.0, 1.0, 1.0, 1.0);
    normal_sample = normal_sample * 2.0 - 1.0;
    float3 n = transform_ts_normal(
    _input.tangent,
    _input.bitangent,
    _input.normal,
    normal_sample );
    albedo *= _input.colour;
    float4 metalness = float4(1.0, 1.0, 1.0, 1.0);
    float3 lit_colour = float3( 0.0, 0.0, 0.0 );
    float reflectivity = saturate(user_data.z);
    float roughness = saturate(user_data.y);
    reflectivity = m_reflectivity;
    roughness = m_roughness;
    float3 lll = float3(0.0, 0.0, 0.0);
    int shadow_map_index = 0;
    _pmfx_loop
    for(int i = 0; i < 1; ++i )
    {
        float3 light_col = float3( 0.0, 0.0, 0.0 );
        light_col += cook_torrence(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        albedo.rgb,
        metalness.rgb,
        roughness,
        reflectivity
        );
        light_col += oren_nayar(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        1.0 - roughness,
        albedo.rgb
        );
        if( lights[i].colour.a == 0.0 )
        {
            lit_colour += light_col;
            continue;
        }
        else
        {
            float shadow = 1.0;
            float d = 1.0;
            float4 offset_pos = float4(_input.world_pos.xyz + n.xyz * 0.01, 1.0);
            float4 sp = mul( offset_pos, shadow_matrix[i] );
            sp.xyz /= sp.w;
            sp.y *= -1.0;
            sp.xy = sp.xy * 0.5 + 0.5;
            sp.z = remap_depth(sp.z);
            shadow = sample_shadow_pcf_9(sp.xyz);
            lit_colour += light_col * shadow;
            float sss_offset = 0.1;
            float4 shrink_pos = float4(_input.world_pos.xyz - _input.normal.xyz * sss_offset, 1.0);
            sp = mul( shrink_pos, shadow_matrix[i] );
            sp.xyz /= sp.w;
            sp.y *= -1.0;
            sp.xy = sp.xy * 0.5 + 0.5;
            sp.z = remap_depth(sp.z);
            float4 sm = sample_texture_level( shadowmap_texture_sss, sp.xy, 0.0 );
            d = sm.r;
            float fp = 1.0;
            float3 light_dir = _input.world_pos.xyz - lights[i].pos_radius.xyz;
            float d1 = d;
            float d2 = sp.z;
            d1 *= fp;
            float sssd = m_sss_scale * abs(d1 - d2) * 0.5 + 0.5;
            float dd = -(sssd * sssd);
            float3 profile = float3(0.233, 0.455, 0.649) * exp(dd / 0.0064) +
            float3(0.1, 0.336, 0.344) * exp(dd / 0.0484) +
            float3(0.118, 0.198, 0.0) * exp(dd / 0.187) +
            float3(0.113, 0.007, 0.007) * exp(dd / 0.567) +
            float3(0.358, 0.004, 0.0) * exp(dd / 1.99) +
            float3(0.078, 0.0, 0.0) * exp(dd / 7.41);
            float sss = saturate(0.5 + dot(light_dir, n));
            profile *= albedo.rgb;
            lit_colour.rgb += profile * sss;
            lit_colour += albedo.rgb * 0.15;
            ++shadow_map_index;
        }
        lit_colour += oren_nayar(
        lights[i].pos_radius * -1.0,
        lights[i].colour.rgb * 0.25,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        1.0 - roughness,
        albedo.rgb
        );
    }
    _output.colour.rgb = lit_colour;
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//forward_render zonly__3221225472__ vs 3221225472
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
layout(location = 0) in float4 position_vs_input;
layout(location = 1) in float4 normal_vs_input;
layout(location = 2) in float4 texcoord_vs_input;
layout(location = 3) in float4 tangent_vs_input;
layout(location = 4) in float4 bitangent_vs_input;
layout(location = 5) in float4 blend_indices_vs_input;
layout(location = 6) in float4 blend_weights_vs_input;
layout(location = 7) in float4 world_matrix_0_instance_input;
layout(location = 8) in float4 world_matrix_1_instance_input;
layout(location = 9) in float4 world_matrix_2_instance_input;
layout(location = 10) in float4 world_matrix_3_instance_input;
layout(location = 11) in float4 user_data_instance_input;
layout(location = 12) in float4 user_data2_instance_input;
uniform float v_flip;
struct vs_input_position_only
{
    float4 position;
    float4 normal;
    float4 texcoord;
    float4 tangent;
    float4 bitangent;
    float4 blend_indices;
    float4 blend_weights;
};
struct vs_instance_input
{
    float4 world_matrix_0;
    float4 world_matrix_1;
    float4 world_matrix_2;
    float4 world_matrix_3;
    float4 user_data;
    float4 user_data2;
};
struct vs_output_zonly
{
    float4 position;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform skinning_info
{
    float4x4 bones[85];
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
float4 skin_pos(float4 pos, float4 weights, float4 indices)
{
    int bone_indices[4];
    bone_indices[0] = int(indices.x);
    bone_indices[1] = int(indices.y);
    bone_indices[2] = int(indices.z);
    bone_indices[3] = int(indices.w);
    float4 sp = float4( 0.0, 0.0, 0.0, 0.0 );
    float final_weight = 1.0;
    for(int i = 3; i >= 0; --i)
    {
        sp += mul( pos, bones[bone_indices[i]] ) * weights[i];
        final_weight -= weights[i];
    }
    sp += mul( pos, bones[bone_indices[0]] ) * final_weight;
    sp.w = 1.0;
    return sp;
}
void main()
{
    //assign vs_input_position_only struct from glsl inputs
    vs_input_position_only _input;
    _input.position = position_vs_input;
    _input.normal = normal_vs_input;
    _input.texcoord = texcoord_vs_input;
    _input.tangent = tangent_vs_input;
    _input.bitangent = bitangent_vs_input;
    _input.blend_indices = blend_indices_vs_input;
    _input.blend_weights = blend_weights_vs_input;
    //assign vs_instance_input struct from glsl inputs
    vs_instance_input instance_input;
    instance_input.world_matrix_0 = world_matrix_0_instance_input;
    instance_input.world_matrix_1 = world_matrix_1_instance_input;
    instance_input.world_matrix_2 = world_matrix_2_instance_input;
    instance_input.world_matrix_3 = world_matrix_3_instance_input;
    instance_input.user_data = user_data_instance_input;
    instance_input.user_data2 = user_data2_instance_input;
    vs_output_zonly _output;
    float4x4 wvp;
    float4x4 instance_world_mat;
    unpack_vb_instance_mat(
    instance_world_mat,
    instance_input.world_matrix_0,
    instance_input.world_matrix_1,
    instance_input.world_matrix_2,
    instance_input.world_matrix_3
    );
    wvp = mul( instance_world_mat, vp_matrix );
    float4 sp = skin_pos(_input.position, _input.blend_weights, _input.blend_indices);
    _output.position = mul( sp, vp_matrix );
    //assign glsl global outputs from structs
    gl_Position = _output.position;
    gl_Position.y *= v_flip;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//forward_render omni_shadow__3221225472__ vs 3221225472
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
layout(location = 0) in float4 position_vs_input;
layout(location = 1) in float4 normal_vs_input;
layout(location = 2) in float4 texcoord_vs_input;
layout(location = 3) in float4 tangent_vs_input;
layout(location = 4) in float4 bitangent_vs_input;
layout(location = 5) in float4 blend_indices_vs_input;
layout(location = 6) in float4 blend_weights_vs_input;
layout(location = 7) in float4 world_matrix_0_instance_input;
layout(location = 8) in float4 world_matrix_1_instance_input;
layout(location = 9) in float4 world_matrix_2_instance_input;
layout(location = 10) in float4 world_matrix_3_instance_input;
layout(location = 11) in float4 user_data_instance_input;
layout(location = 12) in float4 user_data2_instance_input;
out float4 world_pos_vs_output;
uniform float v_flip;
struct vs_input_position_only
{
    float4 position;
    float4 normal;
    float4 texcoord;
    float4 tangent;
    float4 bitangent;
    float4 blend_indices;
    float4 blend_weights;
};
struct vs_instance_input
{
    float4 world_matrix_0;
    float4 world_matrix_1;
    float4 world_matrix_2;
    float4 world_matrix_3;
    float4 user_data;
    float4 user_data2;
};
struct vs_output_zonly_wp
{
    float4 position;
    float4 world_pos;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform skinning_info
{
    float4x4 bones[85];
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
layout (std140) uniform per_draw_call
{
    float4x4 world_matrix;
    float4 user_data;
    float4 user_data2;
    float4x4 world_matrix_inv_transpose;
};
float4 skin_pos(float4 pos, float4 weights, float4 indices)
{
    int bone_indices[4];
    bone_indices[0] = int(indices.x);
    bone_indices[1] = int(indices.y);
    bone_indices[2] = int(indices.z);
    bone_indices[3] = int(indices.w);
    float4 sp = float4( 0.0, 0.0, 0.0, 0.0 );
    float final_weight = 1.0;
    for(int i = 3; i >= 0; --i)
    {
        sp += mul( pos, bones[bone_indices[i]] ) * weights[i];
        final_weight -= weights[i];
    }
    sp += mul( pos, bones[bone_indices[0]] ) * final_weight;
    sp.w = 1.0;
    return sp;
}
void main()
{
    //assign vs_input_position_only struct from glsl inputs
    vs_input_position_only _input;
    _input.position = position_vs_input;
    _input.normal = normal_vs_input;
    _input.texcoord = texcoord_vs_input;
    _input.tangent = tangent_vs_input;
    _input.bitangent = bitangent_vs_input;
    _input.blend_indices = blend_indices_vs_input;
    _input.blend_weights = blend_weights_vs_input;
    //assign vs_instance_input struct from glsl inputs
    vs_instance_input instance_input;
    instance_input.world_matrix_0 = world_matrix_0_instance_input;
    instance_input.world_matrix_1 = world_matrix_1_instance_input;
    instance_input.world_matrix_2 = world_matrix_2_instance_input;
    instance_input.world_matrix_3 = world_matrix_3_instance_input;
    instance_input.user_data = user_data_instance_input;
    instance_input.user_data2 = user_data2_instance_input;
    vs_output_zonly_wp _output;
    float4x4 wvp = mul( world_matrix, vp_matrix );
    float4x4 wm = world_matrix;
    float4x4 instance_world_mat;
    unpack_vb_instance_mat(
    instance_world_mat,
    instance_input.world_matrix_0,
    instance_input.world_matrix_1,
    instance_input.world_matrix_2,
    instance_input.world_matrix_3
    );
    wvp = mul( instance_world_mat, vp_matrix );
    wm = instance_world_mat;
    float4 sp = skin_pos(_input.position, _input.blend_weights, _input.blend_indices);
    _output.position = mul( sp, vp_matrix );
    _output.world_pos = sp;
    //assign glsl global outputs from structs
    gl_Position = _output.position;
    gl_Position.y *= v_flip;
    world_pos_vs_output = _output.world_pos;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//forward_render forward_lit__10__ vs 10
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
layout(location = 0) in float4 position_vs_input;
layout(location = 1) in float4 normal_vs_input;
layout(location = 2) in float4 texcoord_vs_input;
layout(location = 3) in float4 tangent_vs_input;
layout(location = 4) in float4 bitangent_vs_input;
out float4 world_pos_vs_output;
out float3 normal_vs_output;
out float3 tangent_vs_output;
out float3 bitangent_vs_output;
out float4 texcoord_vs_output;
out float4 colour_vs_output;
uniform float v_flip;
struct vs_input_multi
{
    float4 position;
    float4 normal;
    float4 texcoord;
    float4 tangent;
    float4 bitangent;
};
struct vs_output
{
    float4 position;
    float4 world_pos;
    float3 normal;
    float3 tangent;
    float3 bitangent;
    float4 texcoord;
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
layout (std140) uniform per_draw_call
{
    float4x4 world_matrix;
    float4 user_data;
    float4 user_data2;
    float4x4 world_matrix_inv_transpose;
};
layout (std140) uniform material_data
{
    float4 m_albedo;
    float2 m_uv_scale;
    float m_roughness;
    float m_reflectivity;
    float m_surface_offset;
    float3 m_padding;
};
void main()
{
    //assign vs_input_multi struct from glsl inputs
    vs_input_multi _input;
    _input.position = position_vs_input;
    _input.normal = normal_vs_input;
    _input.texcoord = texcoord_vs_input;
    _input.tangent = tangent_vs_input;
    _input.bitangent = bitangent_vs_input;
    vs_output _output;
    float4x4 wvp = mul( world_matrix, vp_matrix );
    float4x4 wm = world_matrix;
    _output.texcoord = float4(_input.texcoord.x, 1.0 - _input.texcoord.y,
    _input.texcoord.z, 1.0 - _input.texcoord.w );
    _output.colour = m_albedo;
    _output.position = mul( _input.position, wvp );
    _output.world_pos = mul( _input.position, wm );
    float3x3 wrm = to_3x3(wm);
    wrm[0] = normalize(wrm[0]);
    wrm[1] = normalize(wrm[1]);
    wrm[2] = normalize(wrm[2]);
    _output.normal = mul( _input.normal.xyz, wrm );
    _output.tangent = mul( _input.tangent.xyz, wrm );
    _output.bitangent = mul( _input.bitangent.xyz, wrm );
    float3 scale = float3(length(world_matrix[0].xyz),
    length(world_matrix[1].xyz),
    length(world_matrix[2].xyz));
    float xs = length(_input.tangent.xyz * scale);
    float ys = length(_input.bitangent.xyz * scale);
    _output.texcoord *= float4(m_uv_scale.x * xs, m_uv_scale.y * ys, m_uv_scale.x, m_uv_scale.y);
    //assign glsl global outputs from structs
    gl_Position = _output.position;
    gl_Position.y *= v_flip;
    world_pos_vs_output = _output.world_pos;
    normal_vs_output = _output.normal;
    tangent_vs_output = _output.tangent;
    bitangent_vs_output = _output.bitangent;
    texcoord_vs_output = _output.texcoord;
    colour_vs_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//forward_render forward_lit__2147483648__ vs 2147483648
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
layout(location = 0) in float4 position_vs_input;
layout(location = 1) in float4 normal_vs_input;
layout(location = 2) in float4 texcoord_vs_input;
layout(location = 3) in float4 tangent_vs_input;
layout(location = 4) in float4 bitangent_vs_input;
layout(location = 5) in float4 blend_indices_vs_input;
layout(location = 6) in float4 blend_weights_vs_input;
out float4 world_pos_vs_output;
out float3 normal_vs_output;
out float3 tangent_vs_output;
out float3 bitangent_vs_output;
out float4 texcoord_vs_output;
out float4 colour_vs_output;
uniform float v_flip;
struct vs_input_multi
{
    float4 position;
    float4 normal;
    float4 texcoord;
    float4 tangent;
    float4 bitangent;
    float4 blend_indices;
    float4 blend_weights;
};
struct vs_output
{
    float4 position;
    float4 world_pos;
    float3 normal;
    float3 tangent;
    float3 bitangent;
    float4 texcoord;
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform skinning_info
{
    float4x4 bones[85];
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
layout (std140) uniform per_draw_call
{
    float4x4 world_matrix;
    float4 user_data;
    float4 user_data2;
    float4x4 world_matrix_inv_transpose;
};
layout (std140) uniform material_data
{
    float4 m_albedo;
    float m_roughness;
    float m_reflectivity;
    float2 m_padding;
};
float4 skin_pos(float4 pos, float4 weights, float4 indices)
{
    int bone_indices[4];
    bone_indices[0] = int(indices.x);
    bone_indices[1] = int(indices.y);
    bone_indices[2] = int(indices.z);
    bone_indices[3] = int(indices.w);
    float4 sp = float4( 0.0, 0.0, 0.0, 0.0 );
    float final_weight = 1.0;
    for(int i = 3; i >= 0; --i)
    {
        sp += mul( pos, bones[bone_indices[i]] ) * weights[i];
        final_weight -= weights[i];
    }
    sp += mul( pos, bones[bone_indices[0]] ) * final_weight;
    sp.w = 1.0;
    return sp;
}
void skin_tbn(inout float3 t, inout float3 b, inout float3 n, float4 weights, float4 indices)
{
    int bone_indices[4];
    bone_indices[0] = int(indices.x);
    bone_indices[1] = int(indices.y);
    bone_indices[2] = int(indices.z);
    bone_indices[3] = int(indices.w);
    float3 rt = float3( 0.0, 0.0, 0.0);
    float3 rb = float3( 0.0, 0.0, 0.0);
    float3 rn = float3( 0.0, 0.0, 0.0);
    float final_weight = 1.0;
    for( int i = 0; i < 3; ++i)
    {
        float3x3 rot_mat = to_3x3(bones[bone_indices[i]]);
        rt += mul(t, rot_mat) * weights[i];
        rb += mul(b, rot_mat) * weights[i];
        rn += mul(n, rot_mat) * weights[i];
        final_weight -= weights[i];
    }
    float3x3 rot_mat = to_3x3(bones[bone_indices[3]]);
    rt += mul(t, rot_mat) * final_weight;
    rb += mul(b, rot_mat) * final_weight;
    rn += mul(n, rot_mat) * final_weight;
    t = rt;
    b = rb;
    n = rn;
}
void main()
{
    //assign vs_input_multi struct from glsl inputs
    vs_input_multi _input;
    _input.position = position_vs_input;
    _input.normal = normal_vs_input;
    _input.texcoord = texcoord_vs_input;
    _input.tangent = tangent_vs_input;
    _input.bitangent = bitangent_vs_input;
    _input.blend_indices = blend_indices_vs_input;
    _input.blend_weights = blend_weights_vs_input;
    vs_output _output;
    float4x4 wvp = mul( world_matrix, vp_matrix );
    float4x4 wm = world_matrix;
    _output.texcoord = float4(_input.texcoord.x, 1.0 - _input.texcoord.y,
    _input.texcoord.z, 1.0 - _input.texcoord.w );
    _output.colour = m_albedo;
    float4 sp = skin_pos(_input.position, _input.blend_weights, _input.blend_indices);
    _output.tangent = _input.tangent.xyz;
    _output.bitangent = _input.bitangent.xyz;
    _output.normal = _input.normal.xyz;
    skin_tbn(_output.tangent, _output.bitangent, _output.normal, _input.blend_weights, _input.blend_indices);
    _output.position = mul( sp, vp_matrix );
    _output.world_pos = sp;
    //assign glsl global outputs from structs
    gl_Position = _output.position;
    gl_Position.y *= v_flip;
    world_pos_vs_output = _output.world_pos;
    normal_vs_output = _output.normal;
    tangent_vs_output = _output.tangent;
    bitangent_vs_output = _output.bitangent;
    texcoord_vs_output = _output.texcoord;
    colour_vs_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//forward_render forward_lit__24__ ps 24
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 world_pos_vs_output;
in float3 normal_vs_output;
in float3 tangent_vs_output;
in float3 bitangent_vs_output;
in float4 texcoord_vs_output;
in float4 colour_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 world_pos;
    float3 normal;
    float3 tangent;
    float3 bitangent;
    float4 texcoord;
    float4 colour;
};
struct ps_output
{
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
layout (std140) uniform per_draw_call
{
    float4x4 world_matrix;
    float4 user_data;
    float4 user_data2;
    float4x4 world_matrix_inv_transpose;
};
layout (std140) uniform per_pass_lights
{
    float4 light_info;
    light_data lights[100];
};
layout (std140) uniform per_pass_shadow
{
    float4x4 shadow_matrix[100];
};
layout (std140) uniform per_pass_shadow_distance_fields
{
    distance_field_shadow sdf_shadow;
};
layout (std140) uniform per_pass_area_lights
{
    float4 area_light_info;
    area_light_data area_lights[10];
};
layout (std140) uniform cbuffer_gi_volume
{
    float4 gi_scene_size;
    float4 gi_volume_size;
};
layout (std140) uniform material_data
{
    float4 m_albedo;
    float m_roughness;
    float m_reflectivity;
    float m_surface_offset;
    float m_padding;
};
texture_2d( diffuse_texture, 0 );
texture_2d( normal_texture, 1 );
texture_2d( specular_texture, 2 );
texture_2d( blue_noise, 5 );
texture_3d( sdf_volume, 14 );
texture_2d( ltc_mat, 13 );
texture_2d( ltc_mag, 12 );
texture_2d_array( area_light_textures, 11 );
texture_3d( volume_gi, 9 );
depth_2d_array( shadowmap_texture, 15 );
float3 cook_torrence(
float4 light_pos_radius,
float3 light_colour,
float3 n,
float3 world_pos,
float3 view_pos,
float3 albedo,
float3 metalness,
float roughness,
float reflectivity
)
{
    float3 l = normalize( light_pos_radius.xyz - world_pos.xyz );
    float n_dot_l = dot( n, l );
    if( n_dot_l > 0.0f )
    {
        float roughness_sq = roughness * roughness;
        float k = reflectivity;
        float3 v_view = normalize( (view_pos.xyz - world_pos.xyz) );
        float3 hv = normalize( v_view + l );
        float n_dot_v = dot( n, v_view );
        float n_dot_h = dot( n, hv );
        float v_dot_h = dot( v_view, hv );
        float n_dot_h_2 = 2.0f * n_dot_h;
        float g1 = (n_dot_h_2 * n_dot_v) / v_dot_h;
        float g2 = (n_dot_h_2 * n_dot_l) / v_dot_h;
        float geom_atten = min(1.0, min(g1, g2));
        float r1 = 1.0f / ( 4.0f * roughness_sq * pow(n_dot_h, 4.0f));
        float r2 = (n_dot_h * n_dot_h - 1.0) / (roughness_sq * n_dot_h * n_dot_h);
        float roughness_atten = r1 * exp(r2);
        float fresnel = pow(1.0 - v_dot_h, 5.0);
        fresnel *= roughness;
        fresnel += reflectivity;
        float specular = (fresnel * geom_atten * roughness_atten) / (n_dot_v * n_dot_l * 3.1419);
        float3 lit_colour = metalness * light_colour * n_dot_l * ( k + specular * ( 1.0 - k ) );
        return saturate(lit_colour);
    }
    return float3( 0.0, 0.0, 0.0 );
}
float3 oren_nayar(
float4 light_pos_radius,
float3 light_colour,
float3 n,
float3 world_pos,
float3 view_pos,
float roughness,
float3 albedo)
{
    float3 v = normalize(view_pos-world_pos);
    float3 l = normalize(light_pos_radius.xyz-world_pos);
    float l_dot_v = dot(l, v);
    float n_dot_l = dot(n, l);
    float n_dot_v = dot(n, v);
    float s = l_dot_v - n_dot_l * n_dot_v;
    float t = lerp(1.0, max(n_dot_l, n_dot_v), step(0.0, s));
    float lum = length( albedo );
    float sigma2 = roughness * roughness;
    float A = 1.0 + sigma2 * (lum / (sigma2 + 0.13) + 0.5 / (sigma2 + 0.33));
    float B = 0.45 * sigma2 / (sigma2 + 0.09);
    return ( albedo * light_colour * max(0.0, n_dot_l) * (A + B * s / t) / 3.14159265 );
}
float spot_light_attenuation(
float4 light_pos_radius,
float4 light_dir_cutoff,
float falloff,
float3 world_pos)
{
    float co = light_dir_cutoff.w;
    float3 vl = normalize(world_pos.xyz - light_pos_radius.xyz);
    float3 sd = normalize(light_dir_cutoff.xyz);
    float dp = (1.0 - dot(vl, sd));
    return smoothstep(co, co - falloff, dp);
}
float point_light_attenuation_cutoff(
float4 light_pos_radius,
float3 world_pos)
{
    float r = light_pos_radius.w;
    float d = length(world_pos.xyz - light_pos_radius.xyz);
    d = max(d - r, 0.0);
    float denom = d/r + 1.0;
    float attenuation = 1.0 / (denom*denom);
    float cutoff = 0.2;
    attenuation = (attenuation - cutoff) / (1.0 - cutoff);
    attenuation = max(attenuation, 0.0);
    return attenuation;
}
float sample_shadow_array_pcf_9(float array_slice, float3 sp)
{
    float2 samples[9];
    float2 inv_sm_size = float2(1.0/2048.0, 1.0/2048.0);
    samples[0] = float2(-1.0, -1.0) * inv_sm_size;
    samples[1] = float2(-1.0, 0.0) * inv_sm_size;
    samples[2] = float2(-1.0, 1.0) * inv_sm_size;
    samples[3] = float2(0.0, -1.0) * inv_sm_size;
    samples[4] = float2(0.0, 0.0) * inv_sm_size;
    samples[5] = float2(0.0, 1.0) * inv_sm_size;
    samples[6] = float2(1.0, -1.0) * inv_sm_size;
    samples[7] = float2(1.0, 0.0) * inv_sm_size;
    samples[8] = float2(1.0, 1.0) * inv_sm_size;
    float shadow = 0.0;
    for(int j = 0; j < 9; ++j)
    {
        shadow += sample_depth_compare_array(shadowmap_texture, sp.xy + samples[j], array_slice, sp.z);
    }
    shadow /= 9.0;
    return shadow;
}
bool ray_vs_aabb(float3 emin, float3 emax, float3 r1, float3 rv, out float3 intersection)
{
    float3 dirfrac = float3(1.0, 1.0, 1.0) / rv;
    float t1 = (emin.x - r1.x)*dirfrac.x;
    float t2 = (emax.x - r1.x)*dirfrac.x;
    float t3 = (emin.y - r1.y)*dirfrac.y;
    float t4 = (emax.y - r1.y)*dirfrac.y;
    float t5 = (emin.z - r1.z)*dirfrac.z;
    float t6 = (emax.z - r1.z)*dirfrac.z;
    float tmin = max(max(min(t1, t2), min(t3, t4)), min(t5, t6));
    float tmax = min(min(max(t1, t2), max(t3, t4)), max(t5, t6));
    float t = 0.0;
    if (tmax < 0.0)
    {
        t = tmax;
        return false;
    }
    if (tmin > tmax)
    {
        t = tmax;
        return false;
    }
    t = tmin;
    intersection = r1 + rv * t;
    return true;
}
float sdf_shadow_trace(float max_samples, float3 light_pos, float3 world_pos, float3 scale, float3 ray_origin, float4x4 inv_mat, float3x3 inv_rot)
{
    float3 ray_dir = normalize(light_pos - world_pos);
    ray_dir = normalize( mul( ray_dir, inv_rot ) );
    float closest = 1.0;
    float3 uvw = ray_origin;
    if(abs(uvw.x) >= 1.0 || abs(uvw.y) >= 1.0 || abs(uvw.z) >= 1.0)
    {
        float3 emin = float3(-1.0, -1.0, -1.0);
        float3 emax = float3(1.0, 1.0, 1.0);
        float3 ip = float3(0.0, 0.0, 0.0);
        bool hit = ray_vs_aabb( emin, emax, uvw, ray_dir, ip);
        uvw = ip;
        if(!hit)
        {
            return closest;
        }
    }
    float3 light_uvw = mul( float4(light_pos, 1.0), inv_mat ).xyz * 0.5 + 0.5;
    uvw = uvw * 0.5 + 0.5;
    float3 v1 = normalize(light_uvw - uvw);
    for( int s = 0; s < int(max_samples); ++s )
    {
        float d = sample_texture_level( sdf_volume, uvw, 0.0 ).r;
        closest = min(d, closest);
        ray_dir = normalize(light_uvw - uvw);
        float3 step = ray_dir.xyz * float3(d, d, d) / scale * 0.7;
        uvw += step;
        if( d <= 0.0 )
        {
            closest = max( d, 0.0 );
            break;
        }
        if(uvw.x >= 1.0 || uvw.x < 0.0)
        break;
        if(uvw.y >= 1.0 || uvw.y < 0.0)
        break;
        if(uvw.z >= 1.0 || uvw.z < 0.0)
        break;
    }
    return closest;
}
float integrate_edge(float3 v1, float3 v2)
{
    float cos_theta = dot(v1, v2);
    float theta = acos(cos_theta);
    float res = cross(v1, v2).z * ((theta > 0.001) ? theta/sin(theta) : 1.0);
    return res;
}
void clip_quad_to_horizon(inout float3 L[5], out int n)
{
    int config = 0;
    if (L[0].z > 0.0) config += 1;
    if (L[1].z > 0.0) config += 2;
    if (L[2].z > 0.0) config += 4;
    if (L[3].z > 0.0) config += 8;
    n = 0;
    if (config == 0)
    {
    }
    else if (config == 1)
    {
        n = 3;
        L[1] = -L[1].z * L[0] + L[0].z * L[1];
        L[2] = -L[3].z * L[0] + L[0].z * L[3];
    }
    else if (config == 2)
    {
        n = 3;
        L[0] = -L[0].z * L[1] + L[1].z * L[0];
        L[2] = -L[2].z * L[1] + L[1].z * L[2];
    }
    else if (config == 3)
    {
        n = 4;
        L[2] = -L[2].z * L[1] + L[1].z * L[2];
        L[3] = -L[3].z * L[0] + L[0].z * L[3];
    }
    else if (config == 4)
    {
        n = 3;
        L[0] = -L[3].z * L[2] + L[2].z * L[3];
        L[1] = -L[1].z * L[2] + L[2].z * L[1];
    }
    else if (config == 5)
    {
        n = 0;
    }
    else if (config == 6)
    {
        n = 4;
        L[0] = -L[0].z * L[1] + L[1].z * L[0];
        L[3] = -L[3].z * L[2] + L[2].z * L[3];
    }
    else if (config == 7)
    {
        n = 5;
        L[4] = -L[3].z * L[0] + L[0].z * L[3];
        L[3] = -L[3].z * L[2] + L[2].z * L[3];
    }
    else if (config == 8)
    {
        n = 3;
        L[0] = -L[0].z * L[3] + L[3].z * L[0];
        L[1] = -L[2].z * L[3] + L[3].z * L[2];
        L[2] = L[3];
    }
    else if (config == 9)
    {
        n = 4;
        L[1] = -L[1].z * L[0] + L[0].z * L[1];
        L[2] = -L[2].z * L[3] + L[3].z * L[2];
    }
    else if (config == 10)
    {
        n = 0;
    }
    else if (config == 11)
    {
        n = 5;
        L[4] = L[3];
        L[3] = -L[2].z * L[3] + L[3].z * L[2];
        L[2] = -L[2].z * L[1] + L[1].z * L[2];
    }
    else if (config == 12)
    {
        n = 4;
        L[1] = -L[1].z * L[2] + L[2].z * L[1];
        L[0] = -L[0].z * L[3] + L[3].z * L[0];
    }
    else if (config == 13)
    {
        n = 5;
        L[4] = L[3];
        L[3] = L[2];
        L[2] = -L[1].z * L[2] + L[2].z * L[1];
        L[1] = -L[1].z * L[0] + L[0].z * L[1];
    }
    else if (config == 14)
    {
        n = 5;
        L[4] = -L[0].z * L[3] + L[3].z * L[0];
        L[0] = -L[0].z * L[1] + L[1].z * L[0];
    }
    else if (config == 15)
    {
        n = 4;
    }
    if (n == 3)
    L[3] = L[0];
    if (n == 4)
    L[4] = L[0];
}
float3 ltc_uv_coord(float3 p[4])
{
    float3 v1 = p[1] - p[0];
    float3 v2 = p[3] - p[0];
    float3 plane_ortho = (cross(v1, v2));
    float plane_area_squared = dot(plane_ortho, plane_ortho);
    float plane_distx_plane_area = dot(plane_ortho, p[0]);
    float3 pp = plane_distx_plane_area * plane_ortho / plane_area_squared - p[0];
    float v1_dot_v2 = dot(v1, v2);
    float inv_v1_dot_v1 = 1.0 / dot(v1, v1);
    float3 vv2 = v2 - v1 * v1_dot_v2 * inv_v1_dot_v1;
    float2 puv;
    puv.y = dot(vv2, pp) / dot(vv2, vv2);
    puv.x = dot(v1, pp) * inv_v1_dot_v1 - v1_dot_v2 * inv_v1_dot_v1 * puv.y;
    float d = abs(plane_distx_plane_area) / pow(plane_area_squared, 0.75);
    return float3(puv, d);
}
float4 ltc_evaluate(
float3 n,
float3 v,
float3 p,
float3x3 minv,
float3 points[4],
bool two_sided)
{
    float3 t1, t2;
    t1 = normalize(v - n * dot(v, n));
    t2 = cross(n, t1);
    float3x3 ttn = from_columns_3x3(t1, t2, n);
    minv = mul(minv, ttn);
    float3 l[5];
    l[0] = mul(minv, points[0] - p);
    l[1] = mul(minv, points[1] - p);
    l[2] = mul(minv, points[2] - p);
    l[3] = mul(minv, points[3] - p);
    l[4] = l[3];
    float3 ll[4];
    ll[0] = l[0];
    ll[1] = l[1];
    ll[2] = l[2];
    ll[3] = l[3];
    float3 uvl = ltc_uv_coord(ll);
    int nc;
    clip_quad_to_horizon(l, nc);
    if (nc == 0)
    return float4(0, 0, 0, 0.0);
    l[0] = normalize(l[0]);
    l[1] = normalize(l[1]);
    l[2] = normalize(l[2]);
    l[3] = normalize(l[3]);
    l[4] = normalize(l[4]);
    float sum = 0.0;
    sum += integrate_edge(l[0], l[1]);
    sum += integrate_edge(l[1], l[2]);
    sum += integrate_edge(l[2], l[3]);
    if (nc >= 4)
    sum += integrate_edge(l[3], l[4]);
    if (nc == 5)
    sum += integrate_edge(l[4], l[0]);
    sum = two_sided ? abs(sum) : max(0.0, sum);
    float3 lo_i = float3(sum, sum, sum);
    return float4(uvl.x, uvl.y, uvl.z, sum);
}
float ltc_evaluate_cc(
float3 n,
float3 v,
float3 p,
float3x3 minv,
float3 points[4],
bool two_sided)
{
    float3 t1, t2;
    t1 = normalize(v - n * dot(v, n));
    t2 = cross(n, t1);
    float3x3 ttn = from_columns_3x3(t1, t2, n);
    minv = mul(minv, ttn);
    float3 l[5];
    for(int i = 0; i < 4; ++i)
    l[i] = mul(minv, points[i] - p);
    l[4] = l[3];
    int nc;
    clip_quad_to_horizon(l, nc);
    if (nc == 0)
    return 0.0;
    for(int i = 0; i < 5; ++i)
    l[i] = normalize(l[i]);
    float sum = 0.0;
    sum += integrate_edge(l[0], l[1]);
    sum += integrate_edge(l[1], l[2]);
    sum += integrate_edge(l[2], l[3]);
    if (nc >= 4)
    sum += integrate_edge(l[3], l[4]);
    if (nc == 5)
    sum += integrate_edge(l[4], l[0]);
    sum = two_sided ? abs(sum) : max(0.0, sum);
    return sum;
}
float4 area_light_specular_uv(
float3 points[4],
float3 pos,
float roughness,
float3 n,
float3 v)
{
    float pi = 3.14159265359;
    float lut_size = 64.0;
    float lut_scale = (lut_size - 1.0)/lut_size;
    float lut_bias = 0.5/lut_size;
    float theta = acos(dot(n, v));
    float2 uv = float2(roughness, theta / (0.5 * pi));
    uv = uv * lut_scale + lut_bias;
    float4 mat = sample_texture(ltc_mat, uv);
    float mag = sample_texture(ltc_mag, uv).w;
    float3x3 minv = from_rows_3x3(
    float3(1.0, 0.0, mat.y),
    float3(0.0, mat.z, 0.0),
    float3(mat.w, 0.0, mat.x)
    );
    float4 spec = ltc_evaluate(n, v, pos, minv, points, true);
    return spec;
}
float area_light_specular(
float3 points[4],
float3 pos,
float roughness,
float3 n,
float3 v)
{
    float pi = 3.14159265359;
    float lut_size = 64.0;
    float lut_scale = (lut_size - 1.0)/lut_size;
    float lut_bias = 0.5/lut_size;
    float theta = acos(dot(n, v));
    float2 uv = float2(roughness, theta / (0.5 * pi));
    uv = uv * lut_scale + lut_bias;
    float4 mat = sample_texture(ltc_mat, uv);
    float mag = sample_texture(ltc_mag, uv).w;
    float3x3 minv = from_rows_3x3(
    float3(1.0, 0.0, mat.y),
    float3(0.0, mat.z, 0.0),
    float3(mat.w, 0.0, mat.x)
    );
    float spec = ltc_evaluate_cc(n, v, pos, minv, points, true);
    return spec;
}
float4 area_light_diffuse_uv(
float3 points[4],
float3 pos,
float3 n,
float3 v)
{
    float3x3 difv = float3x3(
    float3(1.0, 0.0, 0.0),
    float3(0.0, 1.0, 0.0),
    float3(0.0, 0.0, 1.0)
    );
    float4 diff = ltc_evaluate(n, v, pos, difv, points, true);
    return diff;
}
float area_light_diffuse(
float3 points[4],
float3 pos,
float3 n,
float3 v)
{
    float3x3 difv = float3x3(
    float3(1.0, 0.0, 0.0),
    float3(0.0, 1.0, 0.0),
    float3(0.0, 0.0, 1.0)
    );
    float diff = ltc_evaluate_cc(n, v, pos, difv, points, true);
    return diff;
}
float3 transform_ts_normal( float3 t, float3 b, float3 n, float3 ts_normal )
{
    float3x3 tbn;
    tbn[0] = float3(t.x, b.x, n.x);
    tbn[1] = float3(t.y, b.y, n.y);
    tbn[2] = float3(t.z, b.z, n.z);
    return normalize( mul_tbn( tbn, ts_normal ) );
}
float3 hash_33( float3 p )
{
    p = float3(dot(p,float3(127.1,311.7, 74.7)),
    dot(p,float3(269.5,183.3,246.1)),
    dot(p,float3(113.5,271.9,124.6)));
    return fract(sin(p)*43758.5453123) * 2.0 - 1.0;
}
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.world_pos = world_pos_vs_output;
    _input.normal = normal_vs_output;
    _input.tangent = tangent_vs_output;
    _input.bitangent = bitangent_vs_output;
    _input.texcoord = texcoord_vs_output;
    _input.colour = colour_vs_output;
    ps_output _output;
    float4 albedo = sample_texture( diffuse_texture, _input.texcoord.xy );
    float3 normal_sample = sample_texture( normal_texture, _input.texcoord.xy ).rgb;
    float4 ro_sample = sample_texture( specular_texture, _input.texcoord.xy );
    float4 specular_sample = float4(1.0, 1.0, 1.0, 1.0);
    normal_sample = normal_sample * 2.0 - 1.0;
    float3 n = transform_ts_normal(
    _input.tangent,
    _input.bitangent,
    _input.normal,
    normal_sample );
    albedo *= _input.colour;
    float4 metalness = float4(1.0, 1.0, 1.0, 1.0);
    float3 lit_colour = float3( 0.0, 0.0, 0.0 );
    float reflectivity = saturate(user_data.z);
    float roughness = saturate(user_data.y);
    reflectivity = m_reflectivity;
    roughness = ro_sample.r;
    n = _input.normal.rgb;
    roughness = m_roughness;
    float max_samples = 128.0;
    float3x3 inv_rot = to_3x3(sdf_shadow.world_matrix_inv);
    float3 r1 = _input.world_pos.xyz + _input.normal.xyz * m_surface_offset;
    float3 tr1 = mul( float4(r1, 1.0), sdf_shadow.world_matrix_inv ).xyz;
    float3 scale = float3(length(sdf_shadow.world_matrix[0].xyz), length(sdf_shadow.world_matrix[1].xyz), length(sdf_shadow.world_matrix[2].xyz)) * 2.0;
    float3 vddx = ddx( r1 );
    float3 vddy = ddy( r1 );
    float t = 1.0;
    float3 lll = float3(0.0, 0.0, 0.0);
    int shadow_map_index = 0;
    _pmfx_loop
    for( int i = 0; i < int(light_info.x); ++i )
    {
        float3 light_col = float3( 0.0, 0.0, 0.0 );
        light_col += cook_torrence(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        albedo.rgb,
        metalness.rgb,
        roughness,
        reflectivity
        );
        light_col += oren_nayar(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        1.0 - roughness,
        albedo.rgb
        );
        float s = sdf_shadow_trace(max_samples, lights[i].pos_radius.xyz, _input.world_pos.xyz, scale, tr1, sdf_shadow.world_matrix_inv, inv_rot);
        light_col *= smoothstep( 0.0, 0.1, s);
        if( lights[i].colour.a == 0.0 )
        {
            lit_colour += light_col;
            continue;
        }
        else
        {
            float shadow = 1.0;
            float d = 1.0;
            float4 offset_pos = float4(_input.world_pos.xyz + n.xyz * 0.01, 1.0);
            float4 sp = mul( offset_pos, shadow_matrix[i] );
            sp.xyz /= sp.w;
            sp.y *= -1.0;
            sp.xy = sp.xy * 0.5 + 0.5;
            sp.z = remap_depth(sp.z);
            shadow = sample_shadow_array_pcf_9(float(shadow_map_index), sp.xyz);
            lit_colour += light_col * shadow;
            ++shadow_map_index;
        }
    }
    int point_start = int(light_info.x);
    int point_end = int(light_info.x) + int(light_info.y);
    int omni_shadow_index = 0;
    _pmfx_loop
    for( int i = point_start; i < point_end; ++i )
    {
        float3 light_col = float3( 0.0, 0.0, 0.0 );
        light_col += cook_torrence(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        albedo.rgb,
        metalness.rgb,
        roughness,
        reflectivity
        );
        light_col += oren_nayar(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        roughness,
        albedo.rgb
        );
        float a = point_light_attenuation_cutoff( lights[i].pos_radius, _input.world_pos.xyz );
        light_col *= a;
        float s = sdf_shadow_trace(max_samples, lights[i].pos_radius.xyz, _input.world_pos.xyz, scale, tr1, sdf_shadow.world_matrix_inv, inv_rot);
        light_col *= smoothstep( 0.0, 0.1, s);
        if( lights[i].colour.a == 0.0)
        {
            lit_colour += light_col;
            continue;
        }
        else
        {
            lit_colour += light_col;
            continue;
        }
    }
    int spot_start = point_end;
    int spot_end = spot_start + int(light_info.z);
    _pmfx_loop
    for(int i = spot_start; i < spot_end; ++i )
    {
        float3 light_col = float3( 0.0, 0.0, 0.0 );
        light_col += cook_torrence(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        albedo.rgb,
        metalness.rgb,
        roughness,
        reflectivity
        );
        light_col += oren_nayar(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        roughness,
        albedo.rgb
        );
        float a = spot_light_attenuation(lights[i].pos_radius,
        lights[i].dir_cutoff,
        lights[i].data.x,
        _input.world_pos.xyz );
        light_col *= a;
        float s = sdf_shadow_trace(max_samples, lights[i].pos_radius.xyz, _input.world_pos.xyz, scale, tr1, sdf_shadow.world_matrix_inv, inv_rot);
        light_col *= smoothstep( 0.0, 0.1, s);
        if( lights[i].colour.a == 0.0 )
        {
            lit_colour += light_col;
            continue;
        }
        else
        {
            float shadow = 1.0;
            float d = 1.0;
            float4 offset_pos = float4(_input.world_pos.xyz + n.xyz * 0.01, 1.0);
            float4 sp = mul( offset_pos, shadow_matrix[shadow_map_index] );
            sp.xyz /= sp.w;
            sp.y *= -1.0;
            sp.xy = sp.xy * 0.5 + 0.5;
            sp.z = remap_depth(sp.z);
            shadow = sample_shadow_array_pcf_9(float(shadow_map_index), sp.xyz);
            lit_colour += light_col * shadow;
            ++shadow_map_index;
        }
    }
    {
        float pi = 3.14159265359;
        int num_area_lights = int(area_light_info.x);
        for(int i = 0; i < num_area_lights; ++i)
        {
            float3 v = -normalize(_input.world_pos.xyz - camera_view_pos.xyz);
            float3 pos = _input.world_pos.xyz;
            float3 points[4];
            for(int j = 0; j < 4; ++j)
            points[j] = area_lights[i].corners[j].xyz;
            float diff_sum = area_light_diffuse(points, pos, n, v);
            float3 diff = area_lights[i].colour.rgb * diff_sum;
            float spec_sum = area_light_specular(points, pos, ro_sample.x, n, v);
            float3 spec = area_lights[i].colour.rgb * spec_sum;
            float3 light_col = (spec.rgb + diff.rgb) / (2.0 * pi);
            lit_colour += light_col;
        }
        int ts = num_area_lights;
        int num_area_lights_textured = int(area_light_info.y);
        for(int i = ts; i < ts + num_area_lights_textured; ++i)
        {
            float slice = area_lights[i].colour.w;
            float levels = 8.0;
            float2 inv_texel = float2(1.0/640.0, 1.0/480.0);
            float2 inv_texel_x = float2(1.0, 1.0) - inv_texel;
            float3 points[4];
            for(int j = 0; j < 4; ++j)
            points[j] = area_lights[i].corners[j].xyz;
            float3 v = -normalize(_input.world_pos.xyz - camera_view_pos.xyz);
            float3 pos = _input.world_pos.xyz;
            float4 diff_uv = area_light_diffuse_uv(points, pos, n, v);
            float2 duv = clamp(diff_uv.xy, inv_texel, inv_texel_x);
            float3 diff = sample_texture_array_level( area_light_textures, duv, slice, diff_uv.z * levels).rgb * diff_uv.w;
            float4 spec_uv = area_light_specular_uv(points, pos, ro_sample.x, n, v);
            float2 suv = clamp(spec_uv.xy, inv_texel, inv_texel_x);
            float3 spec = sample_texture_array_level(area_light_textures, suv, slice, spec_uv.z * levels).rgb * spec_uv.w;
            float3 light_col = (spec.rgb + diff.rgb) / (2.0 * pi);
            lit_colour += light_col;
        }
    }
    _output.colour.rgb = lit_colour.rgb * albedo.a;
    _output.colour.a = albedo.a;
    float3 gn = _input.normal.xyz;
    float3 gt = _input.tangent.xyz;
    float3 gb = _input.bitangent.xyz;
    float3 dim = gi_scene_size.xyz;
    float3 to_uvx = dim * 0.5;
    int num_rays = 16;
    float3 rays[16];
    rays[0] = float3(0.57735, 0.57735, 0.57735);
    rays[1] = float3(0.57735, -0.57735, -0.57735);
    rays[2] = float3(-0.57735, 0.57735, -0.57735);
    rays[3] = float3(-0.57735, -0.57735, 0.57735);
    rays[4] = float3(-0.903007, -0.182696, -0.388844);
    rays[5] = float3(-0.903007, 0.182696, 0.388844);
    rays[6] = float3(0.903007, -0.182696, 0.388844);
    rays[7] = float3(0.903007, 0.182696, -0.388844);
    rays[8] = float3(-0.388844, -0.903007, -0.182696);
    rays[9] = float3(0.388844, -0.903007, 0.182696);
    rays[10] = float3(0.388844, 0.903007, -0.182696);
    rays[11] = float3(-0.388844, 0.903007, 0.182696);
    rays[12] = float3(-0.182696, -0.388844, -0.903007);
    rays[13] = float3(0.182696, 0.388844, -0.903007);
    rays[14] = float3(-0.182696, 0.388844, 0.903007);
    rays[15] = float3(0.182696, -0.388844, 0.903007);
    float4 gi = float4(0.0, 0.0, 0.0, 0.0);
    float4 sp = mul(_input.world_pos, vp_matrix);
    sp /= sp.w;
    sp.x *= (1280.0/512.0);
    sp.y *= (720.0/512.0);
    for(int i = 0; i < num_rays; ++i)
    {
        float3 noise = (hash_33(_input.world_pos.xyz + user_data.yyy));
        float3 noise2 = (sample_texture_level(blue_noise, sp.xy + noise.xy, 0.0).rgb * 2.0 - 1.0);
        float3 tex_size = gi_volume_size.xyz;
        float3 ray = chebyshev_normalize(noise2 + rays[i]);
        float3 cn = chebyshev_normalize(n);
        float3 step = (dim*2.0) / tex_size;
        float3 sp = _input.world_pos.xyz + (cn * step);
        ray *= dot(ray, gn) < 0.0 ? -1.0 : 1.0;
        float4 ray_gi = float4(0.0, 0.0, 0.0, 0.0);
        for(int j = 0; j < 4; ++j)
        {
            for(int k = 0; k < 2; ++k)
            {
                step = (dim*2.0) / tex_size;
                float3 uvw = saturate((sp / to_uvx) * 0.5 + 0.5);
                float4 g = sample_texture_level( volume_gi, uvw, float(j));
                float d = length(_input.world_pos.xyz - sp);
                d = smoothstep(0.0, 8.0, d);
                ray_gi.rgb = ray_gi.rgb + g.rgb * d;
                ray_gi.a += g.a;
                sp += ray * step.x;
            }
            tex_size /= 2.0;
            if(ray_gi.a >= 1.0 && j > 1)
            break;
        }
        gi += ray_gi;
    }
    gi /= float(num_rays);
    _output.colour.rgb = gi.rgb * 2.0 * m_albedo.rgb + lit_colour.rgb;
    if(albedo.a <= 0.0)
    discard;
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//forward_render forward_lit__3221225482__ vs 3221225482
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
layout(location = 0) in float4 position_vs_input;
layout(location = 1) in float4 normal_vs_input;
layout(location = 2) in float4 texcoord_vs_input;
layout(location = 3) in float4 tangent_vs_input;
layout(location = 4) in float4 bitangent_vs_input;
layout(location = 5) in float4 blend_indices_vs_input;
layout(location = 6) in float4 blend_weights_vs_input;
layout(location = 7) in float4 world_matrix_0_instance_input;
layout(location = 8) in float4 world_matrix_1_instance_input;
layout(location = 9) in float4 world_matrix_2_instance_input;
layout(location = 10) in float4 world_matrix_3_instance_input;
layout(location = 11) in float4 user_data_instance_input;
layout(location = 12) in float4 user_data2_instance_input;
out float4 world_pos_vs_output;
out float3 normal_vs_output;
out float3 tangent_vs_output;
out float3 bitangent_vs_output;
out float4 texcoord_vs_output;
out float4 colour_vs_output;
uniform float v_flip;
struct vs_input_multi
{
    float4 position;
    float4 normal;
    float4 texcoord;
    float4 tangent;
    float4 bitangent;
    float4 blend_indices;
    float4 blend_weights;
};
struct vs_instance_input
{
    float4 world_matrix_0;
    float4 world_matrix_1;
    float4 world_matrix_2;
    float4 world_matrix_3;
    float4 user_data;
    float4 user_data2;
};
struct vs_output
{
    float4 position;
    float4 world_pos;
    float3 normal;
    float3 tangent;
    float3 bitangent;
    float4 texcoord;
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform skinning_info
{
    float4x4 bones[85];
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
layout (std140) uniform per_draw_call
{
    float4x4 world_matrix;
    float4 user_data;
    float4 user_data2;
    float4x4 world_matrix_inv_transpose;
};
layout (std140) uniform material_data
{
    float4 m_albedo;
    float2 m_uv_scale;
    float m_roughness;
    float m_reflectivity;
    float m_surface_offset;
    float3 m_padding;
};
float4 skin_pos(float4 pos, float4 weights, float4 indices)
{
    int bone_indices[4];
    bone_indices[0] = int(indices.x);
    bone_indices[1] = int(indices.y);
    bone_indices[2] = int(indices.z);
    bone_indices[3] = int(indices.w);
    float4 sp = float4( 0.0, 0.0, 0.0, 0.0 );
    float final_weight = 1.0;
    for(int i = 3; i >= 0; --i)
    {
        sp += mul( pos, bones[bone_indices[i]] ) * weights[i];
        final_weight -= weights[i];
    }
    sp += mul( pos, bones[bone_indices[0]] ) * final_weight;
    sp.w = 1.0;
    return sp;
}
void skin_tbn(inout float3 t, inout float3 b, inout float3 n, float4 weights, float4 indices)
{
    int bone_indices[4];
    bone_indices[0] = int(indices.x);
    bone_indices[1] = int(indices.y);
    bone_indices[2] = int(indices.z);
    bone_indices[3] = int(indices.w);
    float3 rt = float3( 0.0, 0.0, 0.0);
    float3 rb = float3( 0.0, 0.0, 0.0);
    float3 rn = float3( 0.0, 0.0, 0.0);
    float final_weight = 1.0;
    for( int i = 0; i < 3; ++i)
    {
        float3x3 rot_mat = to_3x3(bones[bone_indices[i]]);
        rt += mul(t, rot_mat) * weights[i];
        rb += mul(b, rot_mat) * weights[i];
        rn += mul(n, rot_mat) * weights[i];
        final_weight -= weights[i];
    }
    float3x3 rot_mat = to_3x3(bones[bone_indices[3]]);
    rt += mul(t, rot_mat) * final_weight;
    rb += mul(b, rot_mat) * final_weight;
    rn += mul(n, rot_mat) * final_weight;
    t = rt;
    b = rb;
    n = rn;
}
void main()
{
    //assign vs_input_multi struct from glsl inputs
    vs_input_multi _input;
    _input.position = position_vs_input;
    _input.normal = normal_vs_input;
    _input.texcoord = texcoord_vs_input;
    _input.tangent = tangent_vs_input;
    _input.bitangent = bitangent_vs_input;
    _input.blend_indices = blend_indices_vs_input;
    _input.blend_weights = blend_weights_vs_input;
    //assign vs_instance_input struct from glsl inputs
    vs_instance_input instance_input;
    instance_input.world_matrix_0 = world_matrix_0_instance_input;
    instance_input.world_matrix_1 = world_matrix_1_instance_input;
    instance_input.world_matrix_2 = world_matrix_2_instance_input;
    instance_input.world_matrix_3 = world_matrix_3_instance_input;
    instance_input.user_data = user_data_instance_input;
    instance_input.user_data2 = user_data2_instance_input;
    vs_output _output;
    float4x4 wvp = mul( world_matrix, vp_matrix );
    float4x4 wm = world_matrix;
    _output.texcoord = float4(_input.texcoord.x, 1.0 - _input.texcoord.y,
    _input.texcoord.z, 1.0 - _input.texcoord.w );
    float4x4 instance_world_mat;
    unpack_vb_instance_mat(
    instance_world_mat,
    instance_input.world_matrix_0,
    instance_input.world_matrix_1,
    instance_input.world_matrix_2,
    instance_input.world_matrix_3
    );
    wvp = mul( instance_world_mat, vp_matrix );
    wm = instance_world_mat;
    _output.colour = instance_input.user_data2;
    float4 sp = skin_pos(_input.position, _input.blend_weights, _input.blend_indices);
    _output.tangent = _input.tangent.xyz;
    _output.bitangent = _input.bitangent.xyz;
    _output.normal = _input.normal.xyz;
    skin_tbn(_output.tangent, _output.bitangent, _output.normal, _input.blend_weights, _input.blend_indices);
    _output.position = mul( sp, vp_matrix );
    _output.world_pos = sp;
    float3 scale = float3(length(world_matrix[0].xyz),
    length(world_matrix[1].xyz),
    length(world_matrix[2].xyz));
    float xs = length(_input.tangent.xyz * scale);
    float ys = length(_input.bitangent.xyz * scale);
    _output.texcoord *= float4(m_uv_scale.x * xs, m_uv_scale.y * ys, m_uv_scale.x, m_uv_scale.y);
    //assign glsl global outputs from structs
    gl_Position = _output.position;
    gl_Position.y *= v_flip;
    world_pos_vs_output = _output.world_pos;
    normal_vs_output = _output.normal;
    tangent_vs_output = _output.tangent;
    bitangent_vs_output = _output.bitangent;
    texcoord_vs_output = _output.texcoord;
    colour_vs_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//forward_render forward_lit__26__ ps 26
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 world_pos_vs_output;
in float3 normal_vs_output;
in float3 tangent_vs_output;
in float3 bitangent_vs_output;
in float4 texcoord_vs_output;
in float4 colour_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 world_pos;
    float3 normal;
    float3 tangent;
    float3 bitangent;
    float4 texcoord;
    float4 colour;
};
struct ps_output
{
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
layout (std140) uniform per_draw_call
{
    float4x4 world_matrix;
    float4 user_data;
    float4 user_data2;
    float4x4 world_matrix_inv_transpose;
};
layout (std140) uniform per_pass_lights
{
    float4 light_info;
    light_data lights[100];
};
layout (std140) uniform per_pass_shadow
{
    float4x4 shadow_matrix[100];
};
layout (std140) uniform per_pass_shadow_distance_fields
{
    distance_field_shadow sdf_shadow;
};
layout (std140) uniform per_pass_area_lights
{
    float4 area_light_info;
    area_light_data area_lights[10];
};
layout (std140) uniform cbuffer_gi_volume
{
    float4 gi_scene_size;
    float4 gi_volume_size;
};
layout (std140) uniform material_data
{
    float4 m_albedo;
    float2 m_uv_scale;
    float m_roughness;
    float m_reflectivity;
    float m_surface_offset;
    float3 m_padding;
};
texture_2d( diffuse_texture, 0 );
texture_2d( normal_texture, 1 );
texture_2d( specular_texture, 2 );
texture_2d( blue_noise, 5 );
texture_3d( sdf_volume, 14 );
texture_2d( ltc_mat, 13 );
texture_2d( ltc_mag, 12 );
texture_2d_array( area_light_textures, 11 );
texture_3d( volume_gi, 9 );
depth_2d_array( shadowmap_texture, 15 );
float3 cook_torrence(
float4 light_pos_radius,
float3 light_colour,
float3 n,
float3 world_pos,
float3 view_pos,
float3 albedo,
float3 metalness,
float roughness,
float reflectivity
)
{
    float3 l = normalize( light_pos_radius.xyz - world_pos.xyz );
    float n_dot_l = dot( n, l );
    if( n_dot_l > 0.0f )
    {
        float roughness_sq = roughness * roughness;
        float k = reflectivity;
        float3 v_view = normalize( (view_pos.xyz - world_pos.xyz) );
        float3 hv = normalize( v_view + l );
        float n_dot_v = dot( n, v_view );
        float n_dot_h = dot( n, hv );
        float v_dot_h = dot( v_view, hv );
        float n_dot_h_2 = 2.0f * n_dot_h;
        float g1 = (n_dot_h_2 * n_dot_v) / v_dot_h;
        float g2 = (n_dot_h_2 * n_dot_l) / v_dot_h;
        float geom_atten = min(1.0, min(g1, g2));
        float r1 = 1.0f / ( 4.0f * roughness_sq * pow(n_dot_h, 4.0f));
        float r2 = (n_dot_h * n_dot_h - 1.0) / (roughness_sq * n_dot_h * n_dot_h);
        float roughness_atten = r1 * exp(r2);
        float fresnel = pow(1.0 - v_dot_h, 5.0);
        fresnel *= roughness;
        fresnel += reflectivity;
        float specular = (fresnel * geom_atten * roughness_atten) / (n_dot_v * n_dot_l * 3.1419);
        float3 lit_colour = metalness * light_colour * n_dot_l * ( k + specular * ( 1.0 - k ) );
        return saturate(lit_colour);
    }
    return float3( 0.0, 0.0, 0.0 );
}
float3 oren_nayar(
float4 light_pos_radius,
float3 light_colour,
float3 n,
float3 world_pos,
float3 view_pos,
float roughness,
float3 albedo)
{
    float3 v = normalize(view_pos-world_pos);
    float3 l = normalize(light_pos_radius.xyz-world_pos);
    float l_dot_v = dot(l, v);
    float n_dot_l = dot(n, l);
    float n_dot_v = dot(n, v);
    float s = l_dot_v - n_dot_l * n_dot_v;
    float t = lerp(1.0, max(n_dot_l, n_dot_v), step(0.0, s));
    float lum = length( albedo );
    float sigma2 = roughness * roughness;
    float A = 1.0 + sigma2 * (lum / (sigma2 + 0.13) + 0.5 / (sigma2 + 0.33));
    float B = 0.45 * sigma2 / (sigma2 + 0.09);
    return ( albedo * light_colour * max(0.0, n_dot_l) * (A + B * s / t) / 3.14159265 );
}
float spot_light_attenuation(
float4 light_pos_radius,
float4 light_dir_cutoff,
float falloff,
float3 world_pos)
{
    float co = light_dir_cutoff.w;
    float3 vl = normalize(world_pos.xyz - light_pos_radius.xyz);
    float3 sd = normalize(light_dir_cutoff.xyz);
    float dp = (1.0 - dot(vl, sd));
    return smoothstep(co, co - falloff, dp);
}
float point_light_attenuation_cutoff(
float4 light_pos_radius,
float3 world_pos)
{
    float r = light_pos_radius.w;
    float d = length(world_pos.xyz - light_pos_radius.xyz);
    d = max(d - r, 0.0);
    float denom = d/r + 1.0;
    float attenuation = 1.0 / (denom*denom);
    float cutoff = 0.2;
    attenuation = (attenuation - cutoff) / (1.0 - cutoff);
    attenuation = max(attenuation, 0.0);
    return attenuation;
}
float sample_shadow_array_pcf_9(float array_slice, float3 sp)
{
    float2 samples[9];
    float2 inv_sm_size = float2(1.0/2048.0, 1.0/2048.0);
    samples[0] = float2(-1.0, -1.0) * inv_sm_size;
    samples[1] = float2(-1.0, 0.0) * inv_sm_size;
    samples[2] = float2(-1.0, 1.0) * inv_sm_size;
    samples[3] = float2(0.0, -1.0) * inv_sm_size;
    samples[4] = float2(0.0, 0.0) * inv_sm_size;
    samples[5] = float2(0.0, 1.0) * inv_sm_size;
    samples[6] = float2(1.0, -1.0) * inv_sm_size;
    samples[7] = float2(1.0, 0.0) * inv_sm_size;
    samples[8] = float2(1.0, 1.0) * inv_sm_size;
    float shadow = 0.0;
    for(int j = 0; j < 9; ++j)
    {
        shadow += sample_depth_compare_array(shadowmap_texture, sp.xy + samples[j], array_slice, sp.z);
    }
    shadow /= 9.0;
    return shadow;
}
bool ray_vs_aabb(float3 emin, float3 emax, float3 r1, float3 rv, out float3 intersection)
{
    float3 dirfrac = float3(1.0, 1.0, 1.0) / rv;
    float t1 = (emin.x - r1.x)*dirfrac.x;
    float t2 = (emax.x - r1.x)*dirfrac.x;
    float t3 = (emin.y - r1.y)*dirfrac.y;
    float t4 = (emax.y - r1.y)*dirfrac.y;
    float t5 = (emin.z - r1.z)*dirfrac.z;
    float t6 = (emax.z - r1.z)*dirfrac.z;
    float tmin = max(max(min(t1, t2), min(t3, t4)), min(t5, t6));
    float tmax = min(min(max(t1, t2), max(t3, t4)), max(t5, t6));
    float t = 0.0;
    if (tmax < 0.0)
    {
        t = tmax;
        return false;
    }
    if (tmin > tmax)
    {
        t = tmax;
        return false;
    }
    t = tmin;
    intersection = r1 + rv * t;
    return true;
}
float sdf_shadow_trace(float max_samples, float3 light_pos, float3 world_pos, float3 scale, float3 ray_origin, float4x4 inv_mat, float3x3 inv_rot)
{
    float3 ray_dir = normalize(light_pos - world_pos);
    ray_dir = normalize( mul( ray_dir, inv_rot ) );
    float closest = 1.0;
    float3 uvw = ray_origin;
    if(abs(uvw.x) >= 1.0 || abs(uvw.y) >= 1.0 || abs(uvw.z) >= 1.0)
    {
        float3 emin = float3(-1.0, -1.0, -1.0);
        float3 emax = float3(1.0, 1.0, 1.0);
        float3 ip = float3(0.0, 0.0, 0.0);
        bool hit = ray_vs_aabb( emin, emax, uvw, ray_dir, ip);
        uvw = ip;
        if(!hit)
        {
            return closest;
        }
    }
    float3 light_uvw = mul( float4(light_pos, 1.0), inv_mat ).xyz * 0.5 + 0.5;
    uvw = uvw * 0.5 + 0.5;
    float3 v1 = normalize(light_uvw - uvw);
    for( int s = 0; s < int(max_samples); ++s )
    {
        float d = sample_texture_level( sdf_volume, uvw, 0.0 ).r;
        closest = min(d, closest);
        ray_dir = normalize(light_uvw - uvw);
        float3 step = ray_dir.xyz * float3(d, d, d) / scale * 0.7;
        uvw += step;
        if( d <= 0.0 )
        {
            closest = max( d, 0.0 );
            break;
        }
        if(uvw.x >= 1.0 || uvw.x < 0.0)
        break;
        if(uvw.y >= 1.0 || uvw.y < 0.0)
        break;
        if(uvw.z >= 1.0 || uvw.z < 0.0)
        break;
    }
    return closest;
}
float integrate_edge(float3 v1, float3 v2)
{
    float cos_theta = dot(v1, v2);
    float theta = acos(cos_theta);
    float res = cross(v1, v2).z * ((theta > 0.001) ? theta/sin(theta) : 1.0);
    return res;
}
void clip_quad_to_horizon(inout float3 L[5], out int n)
{
    int config = 0;
    if (L[0].z > 0.0) config += 1;
    if (L[1].z > 0.0) config += 2;
    if (L[2].z > 0.0) config += 4;
    if (L[3].z > 0.0) config += 8;
    n = 0;
    if (config == 0)
    {
    }
    else if (config == 1)
    {
        n = 3;
        L[1] = -L[1].z * L[0] + L[0].z * L[1];
        L[2] = -L[3].z * L[0] + L[0].z * L[3];
    }
    else if (config == 2)
    {
        n = 3;
        L[0] = -L[0].z * L[1] + L[1].z * L[0];
        L[2] = -L[2].z * L[1] + L[1].z * L[2];
    }
    else if (config == 3)
    {
        n = 4;
        L[2] = -L[2].z * L[1] + L[1].z * L[2];
        L[3] = -L[3].z * L[0] + L[0].z * L[3];
    }
    else if (config == 4)
    {
        n = 3;
        L[0] = -L[3].z * L[2] + L[2].z * L[3];
        L[1] = -L[1].z * L[2] + L[2].z * L[1];
    }
    else if (config == 5)
    {
        n = 0;
    }
    else if (config == 6)
    {
        n = 4;
        L[0] = -L[0].z * L[1] + L[1].z * L[0];
        L[3] = -L[3].z * L[2] + L[2].z * L[3];
    }
    else if (config == 7)
    {
        n = 5;
        L[4] = -L[3].z * L[0] + L[0].z * L[3];
        L[3] = -L[3].z * L[2] + L[2].z * L[3];
    }
    else if (config == 8)
    {
        n = 3;
        L[0] = -L[0].z * L[3] + L[3].z * L[0];
        L[1] = -L[2].z * L[3] + L[3].z * L[2];
        L[2] = L[3];
    }
    else if (config == 9)
    {
        n = 4;
        L[1] = -L[1].z * L[0] + L[0].z * L[1];
        L[2] = -L[2].z * L[3] + L[3].z * L[2];
    }
    else if (config == 10)
    {
        n = 0;
    }
    else if (config == 11)
    {
        n = 5;
        L[4] = L[3];
        L[3] = -L[2].z * L[3] + L[3].z * L[2];
        L[2] = -L[2].z * L[1] + L[1].z * L[2];
    }
    else if (config == 12)
    {
        n = 4;
        L[1] = -L[1].z * L[2] + L[2].z * L[1];
        L[0] = -L[0].z * L[3] + L[3].z * L[0];
    }
    else if (config == 13)
    {
        n = 5;
        L[4] = L[3];
        L[3] = L[2];
        L[2] = -L[1].z * L[2] + L[2].z * L[1];
        L[1] = -L[1].z * L[0] + L[0].z * L[1];
    }
    else if (config == 14)
    {
        n = 5;
        L[4] = -L[0].z * L[3] + L[3].z * L[0];
        L[0] = -L[0].z * L[1] + L[1].z * L[0];
    }
    else if (config == 15)
    {
        n = 4;
    }
    if (n == 3)
    L[3] = L[0];
    if (n == 4)
    L[4] = L[0];
}
float3 ltc_uv_coord(float3 p[4])
{
    float3 v1 = p[1] - p[0];
    float3 v2 = p[3] - p[0];
    float3 plane_ortho = (cross(v1, v2));
    float plane_area_squared = dot(plane_ortho, plane_ortho);
    float plane_distx_plane_area = dot(plane_ortho, p[0]);
    float3 pp = plane_distx_plane_area * plane_ortho / plane_area_squared - p[0];
    float v1_dot_v2 = dot(v1, v2);
    float inv_v1_dot_v1 = 1.0 / dot(v1, v1);
    float3 vv2 = v2 - v1 * v1_dot_v2 * inv_v1_dot_v1;
    float2 puv;
    puv.y = dot(vv2, pp) / dot(vv2, vv2);
    puv.x = dot(v1, pp) * inv_v1_dot_v1 - v1_dot_v2 * inv_v1_dot_v1 * puv.y;
    float d = abs(plane_distx_plane_area) / pow(plane_area_squared, 0.75);
    return float3(puv, d);
}
float4 ltc_evaluate(
float3 n,
float3 v,
float3 p,
float3x3 minv,
float3 points[4],
bool two_sided)
{
    float3 t1, t2;
    t1 = normalize(v - n * dot(v, n));
    t2 = cross(n, t1);
    float3x3 ttn = from_columns_3x3(t1, t2, n);
    minv = mul(minv, ttn);
    float3 l[5];
    l[0] = mul(minv, points[0] - p);
    l[1] = mul(minv, points[1] - p);
    l[2] = mul(minv, points[2] - p);
    l[3] = mul(minv, points[3] - p);
    l[4] = l[3];
    float3 ll[4];
    ll[0] = l[0];
    ll[1] = l[1];
    ll[2] = l[2];
    ll[3] = l[3];
    float3 uvl = ltc_uv_coord(ll);
    int nc;
    clip_quad_to_horizon(l, nc);
    if (nc == 0)
    return float4(0, 0, 0, 0.0);
    l[0] = normalize(l[0]);
    l[1] = normalize(l[1]);
    l[2] = normalize(l[2]);
    l[3] = normalize(l[3]);
    l[4] = normalize(l[4]);
    float sum = 0.0;
    sum += integrate_edge(l[0], l[1]);
    sum += integrate_edge(l[1], l[2]);
    sum += integrate_edge(l[2], l[3]);
    if (nc >= 4)
    sum += integrate_edge(l[3], l[4]);
    if (nc == 5)
    sum += integrate_edge(l[4], l[0]);
    sum = two_sided ? abs(sum) : max(0.0, sum);
    float3 lo_i = float3(sum, sum, sum);
    return float4(uvl.x, uvl.y, uvl.z, sum);
}
float ltc_evaluate_cc(
float3 n,
float3 v,
float3 p,
float3x3 minv,
float3 points[4],
bool two_sided)
{
    float3 t1, t2;
    t1 = normalize(v - n * dot(v, n));
    t2 = cross(n, t1);
    float3x3 ttn = from_columns_3x3(t1, t2, n);
    minv = mul(minv, ttn);
    float3 l[5];
    for(int i = 0; i < 4; ++i)
    l[i] = mul(minv, points[i] - p);
    l[4] = l[3];
    int nc;
    clip_quad_to_horizon(l, nc);
    if (nc == 0)
    return 0.0;
    for(int i = 0; i < 5; ++i)
    l[i] = normalize(l[i]);
    float sum = 0.0;
    sum += integrate_edge(l[0], l[1]);
    sum += integrate_edge(l[1], l[2]);
    sum += integrate_edge(l[2], l[3]);
    if (nc >= 4)
    sum += integrate_edge(l[3], l[4]);
    if (nc == 5)
    sum += integrate_edge(l[4], l[0]);
    sum = two_sided ? abs(sum) : max(0.0, sum);
    return sum;
}
float4 area_light_specular_uv(
float3 points[4],
float3 pos,
float roughness,
float3 n,
float3 v)
{
    float pi = 3.14159265359;
    float lut_size = 64.0;
    float lut_scale = (lut_size - 1.0)/lut_size;
    float lut_bias = 0.5/lut_size;
    float theta = acos(dot(n, v));
    float2 uv = float2(roughness, theta / (0.5 * pi));
    uv = uv * lut_scale + lut_bias;
    float4 mat = sample_texture(ltc_mat, uv);
    float mag = sample_texture(ltc_mag, uv).w;
    float3x3 minv = from_rows_3x3(
    float3(1.0, 0.0, mat.y),
    float3(0.0, mat.z, 0.0),
    float3(mat.w, 0.0, mat.x)
    );
    float4 spec = ltc_evaluate(n, v, pos, minv, points, true);
    return spec;
}
float area_light_specular(
float3 points[4],
float3 pos,
float roughness,
float3 n,
float3 v)
{
    float pi = 3.14159265359;
    float lut_size = 64.0;
    float lut_scale = (lut_size - 1.0)/lut_size;
    float lut_bias = 0.5/lut_size;
    float theta = acos(dot(n, v));
    float2 uv = float2(roughness, theta / (0.5 * pi));
    uv = uv * lut_scale + lut_bias;
    float4 mat = sample_texture(ltc_mat, uv);
    float mag = sample_texture(ltc_mag, uv).w;
    float3x3 minv = from_rows_3x3(
    float3(1.0, 0.0, mat.y),
    float3(0.0, mat.z, 0.0),
    float3(mat.w, 0.0, mat.x)
    );
    float spec = ltc_evaluate_cc(n, v, pos, minv, points, true);
    return spec;
}
float4 area_light_diffuse_uv(
float3 points[4],
float3 pos,
float3 n,
float3 v)
{
    float3x3 difv = float3x3(
    float3(1.0, 0.0, 0.0),
    float3(0.0, 1.0, 0.0),
    float3(0.0, 0.0, 1.0)
    );
    float4 diff = ltc_evaluate(n, v, pos, difv, points, true);
    return diff;
}
float area_light_diffuse(
float3 points[4],
float3 pos,
float3 n,
float3 v)
{
    float3x3 difv = float3x3(
    float3(1.0, 0.0, 0.0),
    float3(0.0, 1.0, 0.0),
    float3(0.0, 0.0, 1.0)
    );
    float diff = ltc_evaluate_cc(n, v, pos, difv, points, true);
    return diff;
}
float3 transform_ts_normal( float3 t, float3 b, float3 n, float3 ts_normal )
{
    float3x3 tbn;
    tbn[0] = float3(t.x, b.x, n.x);
    tbn[1] = float3(t.y, b.y, n.y);
    tbn[2] = float3(t.z, b.z, n.z);
    return normalize( mul_tbn( tbn, ts_normal ) );
}
float3 hash_33( float3 p )
{
    p = float3(dot(p,float3(127.1,311.7, 74.7)),
    dot(p,float3(269.5,183.3,246.1)),
    dot(p,float3(113.5,271.9,124.6)));
    return fract(sin(p)*43758.5453123) * 2.0 - 1.0;
}
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.world_pos = world_pos_vs_output;
    _input.normal = normal_vs_output;
    _input.tangent = tangent_vs_output;
    _input.bitangent = bitangent_vs_output;
    _input.texcoord = texcoord_vs_output;
    _input.colour = colour_vs_output;
    ps_output _output;
    float4 albedo = sample_texture( diffuse_texture, _input.texcoord.xy );
    float3 normal_sample = sample_texture( normal_texture, _input.texcoord.xy ).rgb;
    float4 ro_sample = sample_texture( specular_texture, _input.texcoord.xy );
    float4 specular_sample = float4(1.0, 1.0, 1.0, 1.0);
    normal_sample = normal_sample * 2.0 - 1.0;
    float3 n = transform_ts_normal(
    _input.tangent,
    _input.bitangent,
    _input.normal,
    normal_sample );
    albedo *= _input.colour;
    float4 metalness = float4(1.0, 1.0, 1.0, 1.0);
    float3 lit_colour = float3( 0.0, 0.0, 0.0 );
    float reflectivity = saturate(user_data.z);
    float roughness = saturate(user_data.y);
    reflectivity = m_reflectivity;
    roughness = ro_sample.r;
    n = _input.normal.rgb;
    roughness = m_roughness;
    float max_samples = 128.0;
    float3x3 inv_rot = to_3x3(sdf_shadow.world_matrix_inv);
    float3 r1 = _input.world_pos.xyz + _input.normal.xyz * m_surface_offset;
    float3 tr1 = mul( float4(r1, 1.0), sdf_shadow.world_matrix_inv ).xyz;
    float3 scale = float3(length(sdf_shadow.world_matrix[0].xyz), length(sdf_shadow.world_matrix[1].xyz), length(sdf_shadow.world_matrix[2].xyz)) * 2.0;
    float3 vddx = ddx( r1 );
    float3 vddy = ddy( r1 );
    float t = 1.0;
    float3 lll = float3(0.0, 0.0, 0.0);
    int shadow_map_index = 0;
    _pmfx_loop
    for( int i = 0; i < int(light_info.x); ++i )
    {
        float3 light_col = float3( 0.0, 0.0, 0.0 );
        light_col += cook_torrence(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        albedo.rgb,
        metalness.rgb,
        roughness,
        reflectivity
        );
        light_col += oren_nayar(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        1.0 - roughness,
        albedo.rgb
        );
        float s = sdf_shadow_trace(max_samples, lights[i].pos_radius.xyz, _input.world_pos.xyz, scale, tr1, sdf_shadow.world_matrix_inv, inv_rot);
        light_col *= smoothstep( 0.0, 0.1, s);
        if( lights[i].colour.a == 0.0 )
        {
            lit_colour += light_col;
            continue;
        }
        else
        {
            float shadow = 1.0;
            float d = 1.0;
            float4 offset_pos = float4(_input.world_pos.xyz + n.xyz * 0.01, 1.0);
            float4 sp = mul( offset_pos, shadow_matrix[i] );
            sp.xyz /= sp.w;
            sp.y *= -1.0;
            sp.xy = sp.xy * 0.5 + 0.5;
            sp.z = remap_depth(sp.z);
            shadow = sample_shadow_array_pcf_9(float(shadow_map_index), sp.xyz);
            lit_colour += light_col * shadow;
            ++shadow_map_index;
        }
    }
    int point_start = int(light_info.x);
    int point_end = int(light_info.x) + int(light_info.y);
    int omni_shadow_index = 0;
    _pmfx_loop
    for( int i = point_start; i < point_end; ++i )
    {
        float3 light_col = float3( 0.0, 0.0, 0.0 );
        light_col += cook_torrence(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        albedo.rgb,
        metalness.rgb,
        roughness,
        reflectivity
        );
        light_col += oren_nayar(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        roughness,
        albedo.rgb
        );
        float a = point_light_attenuation_cutoff( lights[i].pos_radius, _input.world_pos.xyz );
        light_col *= a;
        float s = sdf_shadow_trace(max_samples, lights[i].pos_radius.xyz, _input.world_pos.xyz, scale, tr1, sdf_shadow.world_matrix_inv, inv_rot);
        light_col *= smoothstep( 0.0, 0.1, s);
        if( lights[i].colour.a == 0.0)
        {
            lit_colour += light_col;
            continue;
        }
        else
        {
            lit_colour += light_col;
            continue;
        }
    }
    int spot_start = point_end;
    int spot_end = spot_start + int(light_info.z);
    _pmfx_loop
    for(int i = spot_start; i < spot_end; ++i )
    {
        float3 light_col = float3( 0.0, 0.0, 0.0 );
        light_col += cook_torrence(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        albedo.rgb,
        metalness.rgb,
        roughness,
        reflectivity
        );
        light_col += oren_nayar(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        roughness,
        albedo.rgb
        );
        float a = spot_light_attenuation(lights[i].pos_radius,
        lights[i].dir_cutoff,
        lights[i].data.x,
        _input.world_pos.xyz );
        light_col *= a;
        float s = sdf_shadow_trace(max_samples, lights[i].pos_radius.xyz, _input.world_pos.xyz, scale, tr1, sdf_shadow.world_matrix_inv, inv_rot);
        light_col *= smoothstep( 0.0, 0.1, s);
        if( lights[i].colour.a == 0.0 )
        {
            lit_colour += light_col;
            continue;
        }
        else
        {
            float shadow = 1.0;
            float d = 1.0;
            float4 offset_pos = float4(_input.world_pos.xyz + n.xyz * 0.01, 1.0);
            float4 sp = mul( offset_pos, shadow_matrix[shadow_map_index] );
            sp.xyz /= sp.w;
            sp.y *= -1.0;
            sp.xy = sp.xy * 0.5 + 0.5;
            sp.z = remap_depth(sp.z);
            shadow = sample_shadow_array_pcf_9(float(shadow_map_index), sp.xyz);
            lit_colour += light_col * shadow;
            ++shadow_map_index;
        }
    }
    {
        float pi = 3.14159265359;
        int num_area_lights = int(area_light_info.x);
        for(int i = 0; i < num_area_lights; ++i)
        {
            float3 v = -normalize(_input.world_pos.xyz - camera_view_pos.xyz);
            float3 pos = _input.world_pos.xyz;
            float3 points[4];
            for(int j = 0; j < 4; ++j)
            points[j] = area_lights[i].corners[j].xyz;
            float diff_sum = area_light_diffuse(points, pos, n, v);
            float3 diff = area_lights[i].colour.rgb * diff_sum;
            float spec_sum = area_light_specular(points, pos, ro_sample.x, n, v);
            float3 spec = area_lights[i].colour.rgb * spec_sum;
            float3 light_col = (spec.rgb + diff.rgb) / (2.0 * pi);
            lit_colour += light_col;
        }
        int ts = num_area_lights;
        int num_area_lights_textured = int(area_light_info.y);
        for(int i = ts; i < ts + num_area_lights_textured; ++i)
        {
            float slice = area_lights[i].colour.w;
            float levels = 8.0;
            float2 inv_texel = float2(1.0/640.0, 1.0/480.0);
            float2 inv_texel_x = float2(1.0, 1.0) - inv_texel;
            float3 points[4];
            for(int j = 0; j < 4; ++j)
            points[j] = area_lights[i].corners[j].xyz;
            float3 v = -normalize(_input.world_pos.xyz - camera_view_pos.xyz);
            float3 pos = _input.world_pos.xyz;
            float4 diff_uv = area_light_diffuse_uv(points, pos, n, v);
            float2 duv = clamp(diff_uv.xy, inv_texel, inv_texel_x);
            float3 diff = sample_texture_array_level( area_light_textures, duv, slice, diff_uv.z * levels).rgb * diff_uv.w;
            float4 spec_uv = area_light_specular_uv(points, pos, ro_sample.x, n, v);
            float2 suv = clamp(spec_uv.xy, inv_texel, inv_texel_x);
            float3 spec = sample_texture_array_level(area_light_textures, suv, slice, spec_uv.z * levels).rgb * spec_uv.w;
            float3 light_col = (spec.rgb + diff.rgb) / (2.0 * pi);
            lit_colour += light_col;
        }
    }
    _output.colour.rgb = lit_colour.rgb * albedo.a;
    _output.colour.a = albedo.a;
    float3 gn = _input.normal.xyz;
    float3 gt = _input.tangent.xyz;
    float3 gb = _input.bitangent.xyz;
    float3 dim = gi_scene_size.xyz;
    float3 to_uvx = dim * 0.5;
    int num_rays = 16;
    float3 rays[16];
    rays[0] = float3(0.57735, 0.57735, 0.57735);
    rays[1] = float3(0.57735, -0.57735, -0.57735);
    rays[2] = float3(-0.57735, 0.57735, -0.57735);
    rays[3] = float3(-0.57735, -0.57735, 0.57735);
    rays[4] = float3(-0.903007, -0.182696, -0.388844);
    rays[5] = float3(-0.903007, 0.182696, 0.388844);
    rays[6] = float3(0.903007, -0.182696, 0.388844);
    rays[7] = float3(0.903007, 0.182696, -0.388844);
    rays[8] = float3(-0.388844, -0.903007, -0.182696);
    rays[9] = float3(0.388844, -0.903007, 0.182696);
    rays[10] = float3(0.388844, 0.903007, -0.182696);
    rays[11] = float3(-0.388844, 0.903007, 0.182696);
    rays[12] = float3(-0.182696, -0.388844, -0.903007);
    rays[13] = float3(0.182696, 0.388844, -0.903007);
    rays[14] = float3(-0.182696, 0.388844, 0.903007);
    rays[15] = float3(0.182696, -0.388844, 0.903007);
    float4 gi = float4(0.0, 0.0, 0.0, 0.0);
    float4 sp = mul(_input.world_pos, vp_matrix);
    sp /= sp.w;
    sp.x *= (1280.0/512.0);
    sp.y *= (720.0/512.0);
    for(int i = 0; i < num_rays; ++i)
    {
        float3 noise = (hash_33(_input.world_pos.xyz + user_data.yyy));
        float3 noise2 = (sample_texture_level(blue_noise, sp.xy + noise.xy, 0.0).rgb * 2.0 - 1.0);
        float3 tex_size = gi_volume_size.xyz;
        float3 ray = chebyshev_normalize(noise2 + rays[i]);
        float3 cn = chebyshev_normalize(n);
        float3 step = (dim*2.0) / tex_size;
        float3 sp = _input.world_pos.xyz + (cn * step);
        ray *= dot(ray, gn) < 0.0 ? -1.0 : 1.0;
        float4 ray_gi = float4(0.0, 0.0, 0.0, 0.0);
        for(int j = 0; j < 4; ++j)
        {
            for(int k = 0; k < 2; ++k)
            {
                step = (dim*2.0) / tex_size;
                float3 uvw = saturate((sp / to_uvx) * 0.5 + 0.5);
                float4 g = sample_texture_level( volume_gi, uvw, float(j));
                float d = length(_input.world_pos.xyz - sp);
                d = smoothstep(0.0, 8.0, d);
                ray_gi.rgb = ray_gi.rgb + g.rgb * d;
                ray_gi.a += g.a;
                sp += ray * step.x;
            }
            tex_size /= 2.0;
            if(ray_gi.a >= 1.0 && j > 1)
            break;
        }
        gi += ray_gi;
    }
    gi /= float(num_rays);
    _output.colour.rgb = gi.rgb * 2.0 * m_albedo.rgb + lit_colour.rgb;
    if(albedo.a <= 0.0)
    discard;
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//forward_render gbuffer__2__ ps 2
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 world_pos_vs_output;
in float3 normal_vs_output;
in float3 tangent_vs_output;
in float3 bitangent_vs_output;
in float4 texcoord_vs_output;
in float4 colour_vs_output;
layout(location = 0) out float4 albedo_ps_output;
layout(location = 1) out float4 normal_ps_output;
layout(location = 2) out float4 world_pos_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 world_pos;
    float3 normal;
    float3 tangent;
    float3 bitangent;
    float4 texcoord;
    float4 colour;
};
struct ps_output_multi
{
    float4 albedo;
    float4 normal;
    float4 world_pos;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform material_data
{
    float4 m_albedo;
    float2 m_uv_scale;
    float m_roughness;
    float m_reflectivity;
};
texture_2d( diffuse_texture, 0 );
texture_2d( normal_texture, 1 );
texture_2d( specular_texture, 2 );
float3 transform_ts_normal( float3 t, float3 b, float3 n, float3 ts_normal )
{
    float3x3 tbn;
    tbn[0] = float3(t.x, b.x, n.x);
    tbn[1] = float3(t.y, b.y, n.y);
    tbn[2] = float3(t.z, b.z, n.z);
    return normalize( mul_tbn( tbn, ts_normal ) );
}
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.world_pos = world_pos_vs_output;
    _input.normal = normal_vs_output;
    _input.tangent = tangent_vs_output;
    _input.bitangent = bitangent_vs_output;
    _input.texcoord = texcoord_vs_output;
    _input.colour = colour_vs_output;
    ps_output_multi _output;
    float4 albedo = sample_texture(diffuse_texture, _input.texcoord.xy);
    float4 metalness = sample_texture(specular_texture, _input.texcoord.xy);
    float3 normal_sample = sample_texture( normal_texture, _input.texcoord.xy ).rgb;
    normal_sample = normal_sample * 2.0 - 1.0;
    float4 ro_sample = sample_texture( specular_texture, _input.texcoord.xy );
    float3 n = transform_ts_normal(
    _input.tangent,
    _input.bitangent,
    _input.normal,
    normal_sample );
    float roughness = ro_sample.x;
    float reflectivity = m_reflectivity;
    _output.albedo = float4(albedo.rgb * _input.colour.rgb, roughness);
    _output.normal = float4(n, reflectivity);
    _output.world_pos = float4(_input.world_pos.xyz, metalness.r);
    //assign glsl global outputs from structs
    albedo_ps_output = _output.albedo;
    normal_ps_output = _output.normal;
    world_pos_ps_output = _output.world_pos;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//forward_render zonly ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
uniform float v_flip;
struct vs_output_zonly
{
    float4 position;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
void main()
{
    //assign vs_output_zonly struct from glsl inputs
    vs_output_zonly _input;
    //assign glsl global outputs from structs
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//forward_render lambert vs 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
layout(location = 0) in float4 position_vs_input;
layout(location = 1) in float4 normal_vs_input;
layout(location = 2) in float4 texcoord_vs_input;
layout(location = 3) in float4 tangent_vs_input;
layout(location = 4) in float4 bitangent_vs_input;
out float4 world_pos_vs_output;
out float3 normal_vs_output;
out float3 tangent_vs_output;
out float3 bitangent_vs_output;
out float4 texcoord_vs_output;
out float4 colour_vs_output;
uniform float v_flip;
struct vs_input_multi
{
    float4 position;
    float4 normal;
    float4 texcoord;
    float4 tangent;
    float4 bitangent;
};
struct vs_output
{
    float4 position;
    float4 world_pos;
    float3 normal;
    float3 tangent;
    float3 bitangent;
    float4 texcoord;
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
layout (std140) uniform per_draw_call
{
    float4x4 world_matrix;
    float4 user_data;
    float4 user_data2;
    float4x4 world_matrix_inv_transpose;
};
layout (std140) uniform material_data
{
    float4 m_albedo;
};
void main()
{
    //assign vs_input_multi struct from glsl inputs
    vs_input_multi _input;
    _input.position = position_vs_input;
    _input.normal = normal_vs_input;
    _input.texcoord = texcoord_vs_input;
    _input.tangent = tangent_vs_input;
    _input.bitangent = bitangent_vs_input;
    vs_output _output;
    float4x4 wvp = mul( world_matrix, vp_matrix );
    float4x4 wm = world_matrix;
    _output.texcoord = float4(_input.texcoord.x, 1.0 - _input.texcoord.y,
    _input.texcoord.z, 1.0 - _input.texcoord.w );
    _output.colour = m_albedo;
    _output.position = mul( _input.position, wvp );
    _output.world_pos = mul( _input.position, wm );
    float3x3 wrm = to_3x3(wm);
    wrm[0] = normalize(wrm[0]);
    wrm[1] = normalize(wrm[1]);
    wrm[2] = normalize(wrm[2]);
    _output.normal = mul( _input.normal.xyz, wrm );
    _output.tangent = mul( _input.tangent.xyz, wrm );
    _output.bitangent = mul( _input.bitangent.xyz, wrm );
    //assign glsl global outputs from structs
    gl_Position = _output.position;
    gl_Position.y *= v_flip;
    world_pos_vs_output = _output.world_pos;
    normal_vs_output = _output.normal;
    tangent_vs_output = _output.tangent;
    bitangent_vs_output = _output.bitangent;
    texcoord_vs_output = _output.texcoord;
    colour_vs_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//forward_render forward_lit__2__ vs 2
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
layout(location = 0) in float4 position_vs_input;
layout(location = 1) in float4 normal_vs_input;
layout(location = 2) in float4 texcoord_vs_input;
layout(location = 3) in float4 tangent_vs_input;
layout(location = 4) in float4 bitangent_vs_input;
out float4 world_pos_vs_output;
out float3 normal_vs_output;
out float3 tangent_vs_output;
out float3 bitangent_vs_output;
out float4 texcoord_vs_output;
out float4 colour_vs_output;
uniform float v_flip;
struct vs_input_multi
{
    float4 position;
    float4 normal;
    float4 texcoord;
    float4 tangent;
    float4 bitangent;
};
struct vs_output
{
    float4 position;
    float4 world_pos;
    float3 normal;
    float3 tangent;
    float3 bitangent;
    float4 texcoord;
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
layout (std140) uniform per_draw_call
{
    float4x4 world_matrix;
    float4 user_data;
    float4 user_data2;
    float4x4 world_matrix_inv_transpose;
};
layout (std140) uniform material_data
{
    float4 m_albedo;
    float2 m_uv_scale;
    float m_roughness;
    float m_reflectivity;
};
void main()
{
    //assign vs_input_multi struct from glsl inputs
    vs_input_multi _input;
    _input.position = position_vs_input;
    _input.normal = normal_vs_input;
    _input.texcoord = texcoord_vs_input;
    _input.tangent = tangent_vs_input;
    _input.bitangent = bitangent_vs_input;
    vs_output _output;
    float4x4 wvp = mul( world_matrix, vp_matrix );
    float4x4 wm = world_matrix;
    _output.texcoord = float4(_input.texcoord.x, 1.0 - _input.texcoord.y,
    _input.texcoord.z, 1.0 - _input.texcoord.w );
    _output.colour = m_albedo;
    _output.position = mul( _input.position, wvp );
    _output.world_pos = mul( _input.position, wm );
    float3x3 wrm = to_3x3(wm);
    wrm[0] = normalize(wrm[0]);
    wrm[1] = normalize(wrm[1]);
    wrm[2] = normalize(wrm[2]);
    _output.normal = mul( _input.normal.xyz, wrm );
    _output.tangent = mul( _input.tangent.xyz, wrm );
    _output.bitangent = mul( _input.bitangent.xyz, wrm );
    float3 scale = float3(length(world_matrix[0].xyz),
    length(world_matrix[1].xyz),
    length(world_matrix[2].xyz));
    float xs = length(_input.tangent.xyz * scale);
    float ys = length(_input.bitangent.xyz * scale);
    _output.texcoord *= float4(m_uv_scale.x * xs, m_uv_scale.y * ys, m_uv_scale.x, m_uv_scale.y);
    //assign glsl global outputs from structs
    gl_Position = _output.position;
    gl_Position.y *= v_flip;
    world_pos_vs_output = _output.world_pos;
    normal_vs_output = _output.normal;
    tangent_vs_output = _output.tangent;
    bitangent_vs_output = _output.bitangent;
    texcoord_vs_output = _output.texcoord;
    colour_vs_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//forward_render gbuffer ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 world_pos_vs_output;
in float3 normal_vs_output;
in float3 tangent_vs_output;
in float3 bitangent_vs_output;
in float4 texcoord_vs_output;
in float4 colour_vs_output;
layout(location = 0) out float4 albedo_ps_output;
layout(location = 1) out float4 normal_ps_output;
layout(location = 2) out float4 world_pos_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 world_pos;
    float3 normal;
    float3 tangent;
    float3 bitangent;
    float4 texcoord;
    float4 colour;
};
struct ps_output_multi
{
    float4 albedo;
    float4 normal;
    float4 world_pos;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform material_data
{
    float4 m_albedo;
    float m_roughness;
    float m_reflectivity;
    float2 m_padding;
};
texture_2d( diffuse_texture, 0 );
texture_2d( normal_texture, 1 );
texture_2d( specular_texture, 2 );
float3 transform_ts_normal( float3 t, float3 b, float3 n, float3 ts_normal )
{
    float3x3 tbn;
    tbn[0] = float3(t.x, b.x, n.x);
    tbn[1] = float3(t.y, b.y, n.y);
    tbn[2] = float3(t.z, b.z, n.z);
    return normalize( mul_tbn( tbn, ts_normal ) );
}
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.world_pos = world_pos_vs_output;
    _input.normal = normal_vs_output;
    _input.tangent = tangent_vs_output;
    _input.bitangent = bitangent_vs_output;
    _input.texcoord = texcoord_vs_output;
    _input.colour = colour_vs_output;
    ps_output_multi _output;
    float4 albedo = sample_texture(diffuse_texture, _input.texcoord.xy);
    float4 metalness = sample_texture(specular_texture, _input.texcoord.xy);
    float3 normal_sample = sample_texture( normal_texture, _input.texcoord.xy ).rgb;
    normal_sample = normal_sample * 2.0 - 1.0;
    float4 ro_sample = sample_texture( specular_texture, _input.texcoord.xy );
    float3 n = transform_ts_normal(
    _input.tangent,
    _input.bitangent,
    _input.normal,
    normal_sample );
    float roughness = ro_sample.x;
    float reflectivity = m_reflectivity;
    _output.albedo = float4(albedo.rgb * _input.colour.rgb, roughness);
    _output.normal = float4(n, reflectivity);
    _output.world_pos = float4(_input.world_pos.xyz, metalness.r);
    //assign glsl global outputs from structs
    albedo_ps_output = _output.albedo;
    normal_ps_output = _output.normal;
    world_pos_ps_output = _output.world_pos;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//forward_render forward_lit__2147483656__ vs 2147483656
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
layout(location = 0) in float4 position_vs_input;
layout(location = 1) in float4 normal_vs_input;
layout(location = 2) in float4 texcoord_vs_input;
layout(location = 3) in float4 tangent_vs_input;
layout(location = 4) in float4 bitangent_vs_input;
layout(location = 5) in float4 blend_indices_vs_input;
layout(location = 6) in float4 blend_weights_vs_input;
out float4 world_pos_vs_output;
out float3 normal_vs_output;
out float3 tangent_vs_output;
out float3 bitangent_vs_output;
out float4 texcoord_vs_output;
out float4 colour_vs_output;
uniform float v_flip;
struct vs_input_multi
{
    float4 position;
    float4 normal;
    float4 texcoord;
    float4 tangent;
    float4 bitangent;
    float4 blend_indices;
    float4 blend_weights;
};
struct vs_output
{
    float4 position;
    float4 world_pos;
    float3 normal;
    float3 tangent;
    float3 bitangent;
    float4 texcoord;
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform skinning_info
{
    float4x4 bones[85];
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
layout (std140) uniform per_draw_call
{
    float4x4 world_matrix;
    float4 user_data;
    float4 user_data2;
    float4x4 world_matrix_inv_transpose;
};
layout (std140) uniform material_data
{
    float4 m_albedo;
    float m_roughness;
    float m_reflectivity;
    float m_surface_offset;
    float m_padding;
};
float4 skin_pos(float4 pos, float4 weights, float4 indices)
{
    int bone_indices[4];
    bone_indices[0] = int(indices.x);
    bone_indices[1] = int(indices.y);
    bone_indices[2] = int(indices.z);
    bone_indices[3] = int(indices.w);
    float4 sp = float4( 0.0, 0.0, 0.0, 0.0 );
    float final_weight = 1.0;
    for(int i = 3; i >= 0; --i)
    {
        sp += mul( pos, bones[bone_indices[i]] ) * weights[i];
        final_weight -= weights[i];
    }
    sp += mul( pos, bones[bone_indices[0]] ) * final_weight;
    sp.w = 1.0;
    return sp;
}
void skin_tbn(inout float3 t, inout float3 b, inout float3 n, float4 weights, float4 indices)
{
    int bone_indices[4];
    bone_indices[0] = int(indices.x);
    bone_indices[1] = int(indices.y);
    bone_indices[2] = int(indices.z);
    bone_indices[3] = int(indices.w);
    float3 rt = float3( 0.0, 0.0, 0.0);
    float3 rb = float3( 0.0, 0.0, 0.0);
    float3 rn = float3( 0.0, 0.0, 0.0);
    float final_weight = 1.0;
    for( int i = 0; i < 3; ++i)
    {
        float3x3 rot_mat = to_3x3(bones[bone_indices[i]]);
        rt += mul(t, rot_mat) * weights[i];
        rb += mul(b, rot_mat) * weights[i];
        rn += mul(n, rot_mat) * weights[i];
        final_weight -= weights[i];
    }
    float3x3 rot_mat = to_3x3(bones[bone_indices[3]]);
    rt += mul(t, rot_mat) * final_weight;
    rb += mul(b, rot_mat) * final_weight;
    rn += mul(n, rot_mat) * final_weight;
    t = rt;
    b = rb;
    n = rn;
}
void main()
{
    //assign vs_input_multi struct from glsl inputs
    vs_input_multi _input;
    _input.position = position_vs_input;
    _input.normal = normal_vs_input;
    _input.texcoord = texcoord_vs_input;
    _input.tangent = tangent_vs_input;
    _input.bitangent = bitangent_vs_input;
    _input.blend_indices = blend_indices_vs_input;
    _input.blend_weights = blend_weights_vs_input;
    vs_output _output;
    float4x4 wvp = mul( world_matrix, vp_matrix );
    float4x4 wm = world_matrix;
    _output.texcoord = float4(_input.texcoord.x, 1.0 - _input.texcoord.y,
    _input.texcoord.z, 1.0 - _input.texcoord.w );
    _output.colour = m_albedo;
    float4 sp = skin_pos(_input.position, _input.blend_weights, _input.blend_indices);
    _output.tangent = _input.tangent.xyz;
    _output.bitangent = _input.bitangent.xyz;
    _output.normal = _input.normal.xyz;
    skin_tbn(_output.tangent, _output.bitangent, _output.normal, _input.blend_weights, _input.blend_indices);
    _output.position = mul( sp, vp_matrix );
    _output.world_pos = sp;
    //assign glsl global outputs from structs
    gl_Position = _output.position;
    gl_Position.y *= v_flip;
    world_pos_vs_output = _output.world_pos;
    normal_vs_output = _output.normal;
    tangent_vs_output = _output.tangent;
    bitangent_vs_output = _output.bitangent;
    texcoord_vs_output = _output.texcoord;
    colour_vs_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//forward_render zonly__1073741824__ vs 1073741824
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
layout(location = 0) in float4 position_vs_input;
layout(location = 1) in float4 world_matrix_0_instance_input;
layout(location = 2) in float4 world_matrix_1_instance_input;
layout(location = 3) in float4 world_matrix_2_instance_input;
layout(location = 4) in float4 world_matrix_3_instance_input;
layout(location = 5) in float4 user_data_instance_input;
layout(location = 6) in float4 user_data2_instance_input;
uniform float v_flip;
struct vs_input_position_only
{
    float4 position;
};
struct vs_instance_input
{
    float4 world_matrix_0;
    float4 world_matrix_1;
    float4 world_matrix_2;
    float4 world_matrix_3;
    float4 user_data;
    float4 user_data2;
};
struct vs_output_zonly
{
    float4 position;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
void main()
{
    //assign vs_input_position_only struct from glsl inputs
    vs_input_position_only _input;
    _input.position = position_vs_input;
    //assign vs_instance_input struct from glsl inputs
    vs_instance_input instance_input;
    instance_input.world_matrix_0 = world_matrix_0_instance_input;
    instance_input.world_matrix_1 = world_matrix_1_instance_input;
    instance_input.world_matrix_2 = world_matrix_2_instance_input;
    instance_input.world_matrix_3 = world_matrix_3_instance_input;
    instance_input.user_data = user_data_instance_input;
    instance_input.user_data2 = user_data2_instance_input;
    vs_output_zonly _output;
    float4x4 wvp;
    float4x4 instance_world_mat;
    unpack_vb_instance_mat(
    instance_world_mat,
    instance_input.world_matrix_0,
    instance_input.world_matrix_1,
    instance_input.world_matrix_2,
    instance_input.world_matrix_3
    );
    wvp = mul( instance_world_mat, vp_matrix );
    _output.position = mul( _input.position, wvp );
    //assign glsl global outputs from structs
    gl_Position = _output.position;
    gl_Position.y *= v_flip;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//forward_render omni_shadow__1073741824__ vs 1073741824
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
layout(location = 0) in float4 position_vs_input;
layout(location = 1) in float4 world_matrix_0_instance_input;
layout(location = 2) in float4 world_matrix_1_instance_input;
layout(location = 3) in float4 world_matrix_2_instance_input;
layout(location = 4) in float4 world_matrix_3_instance_input;
layout(location = 5) in float4 user_data_instance_input;
layout(location = 6) in float4 user_data2_instance_input;
out float4 world_pos_vs_output;
uniform float v_flip;
struct vs_input_position_only
{
    float4 position;
};
struct vs_instance_input
{
    float4 world_matrix_0;
    float4 world_matrix_1;
    float4 world_matrix_2;
    float4 world_matrix_3;
    float4 user_data;
    float4 user_data2;
};
struct vs_output_zonly_wp
{
    float4 position;
    float4 world_pos;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
layout (std140) uniform per_draw_call
{
    float4x4 world_matrix;
    float4 user_data;
    float4 user_data2;
    float4x4 world_matrix_inv_transpose;
};
void main()
{
    //assign vs_input_position_only struct from glsl inputs
    vs_input_position_only _input;
    _input.position = position_vs_input;
    //assign vs_instance_input struct from glsl inputs
    vs_instance_input instance_input;
    instance_input.world_matrix_0 = world_matrix_0_instance_input;
    instance_input.world_matrix_1 = world_matrix_1_instance_input;
    instance_input.world_matrix_2 = world_matrix_2_instance_input;
    instance_input.world_matrix_3 = world_matrix_3_instance_input;
    instance_input.user_data = user_data_instance_input;
    instance_input.user_data2 = user_data2_instance_input;
    vs_output_zonly_wp _output;
    float4x4 wvp = mul( world_matrix, vp_matrix );
    float4x4 wm = world_matrix;
    float4x4 instance_world_mat;
    unpack_vb_instance_mat(
    instance_world_mat,
    instance_input.world_matrix_0,
    instance_input.world_matrix_1,
    instance_input.world_matrix_2,
    instance_input.world_matrix_3
    );
    wvp = mul( instance_world_mat, vp_matrix );
    wm = instance_world_mat;
    _output.position = mul( _input.position, wvp );
    _output.world_pos = mul( _input.position, wm );
    //assign glsl global outputs from structs
    gl_Position = _output.position;
    gl_Position.y *= v_flip;
    world_pos_vs_output = _output.world_pos;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//forward_render shadow_extrude ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 world_pos_vs_output;
in float3 normal_vs_output;
in float3 tangent_vs_output;
in float3 bitangent_vs_output;
in float4 texcoord_vs_output;
in float4 colour_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 world_pos;
    float3 normal;
    float3 tangent;
    float3 bitangent;
    float4 texcoord;
    float4 colour;
};
struct ps_output
{
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.world_pos = world_pos_vs_output;
    _input.normal = normal_vs_output;
    _input.tangent = tangent_vs_output;
    _input.bitangent = bitangent_vs_output;
    _input.texcoord = texcoord_vs_output;
    _input.colour = colour_vs_output;
    ps_output _output;
    _output.colour = float4(1.0, 0.0, 1.0, 1.0);
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//forward_render forward_lit__1073741826__ ps 1073741826
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 world_pos_vs_output;
in float3 normal_vs_output;
in float3 tangent_vs_output;
in float3 bitangent_vs_output;
in float4 texcoord_vs_output;
in float4 colour_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 world_pos;
    float3 normal;
    float3 tangent;
    float3 bitangent;
    float4 texcoord;
    float4 colour;
};
struct ps_output
{
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
layout (std140) uniform per_draw_call
{
    float4x4 world_matrix;
    float4 user_data;
    float4 user_data2;
    float4x4 world_matrix_inv_transpose;
};
layout (std140) uniform per_pass_lights
{
    float4 light_info;
    light_data lights[100];
};
layout (std140) uniform per_pass_shadow
{
    float4x4 shadow_matrix[100];
};
layout (std140) uniform per_pass_area_lights
{
    float4 area_light_info;
    area_light_data area_lights[10];
};
layout (std140) uniform material_data
{
    float4 m_albedo;
    float2 m_uv_scale;
    float m_roughness;
    float m_reflectivity;
};
texture_2d( diffuse_texture, 0 );
texture_2d( normal_texture, 1 );
texture_2d( specular_texture, 2 );
texture_2d( ltc_mat, 13 );
texture_2d( ltc_mag, 12 );
texture_2d_array( area_light_textures, 11 );
depth_2d_array( shadowmap_texture, 15 );
float3 cook_torrence(
float4 light_pos_radius,
float3 light_colour,
float3 n,
float3 world_pos,
float3 view_pos,
float3 albedo,
float3 metalness,
float roughness,
float reflectivity
)
{
    float3 l = normalize( light_pos_radius.xyz - world_pos.xyz );
    float n_dot_l = dot( n, l );
    if( n_dot_l > 0.0f )
    {
        float roughness_sq = roughness * roughness;
        float k = reflectivity;
        float3 v_view = normalize( (view_pos.xyz - world_pos.xyz) );
        float3 hv = normalize( v_view + l );
        float n_dot_v = dot( n, v_view );
        float n_dot_h = dot( n, hv );
        float v_dot_h = dot( v_view, hv );
        float n_dot_h_2 = 2.0f * n_dot_h;
        float g1 = (n_dot_h_2 * n_dot_v) / v_dot_h;
        float g2 = (n_dot_h_2 * n_dot_l) / v_dot_h;
        float geom_atten = min(1.0, min(g1, g2));
        float r1 = 1.0f / ( 4.0f * roughness_sq * pow(n_dot_h, 4.0f));
        float r2 = (n_dot_h * n_dot_h - 1.0) / (roughness_sq * n_dot_h * n_dot_h);
        float roughness_atten = r1 * exp(r2);
        float fresnel = pow(1.0 - v_dot_h, 5.0);
        fresnel *= roughness;
        fresnel += reflectivity;
        float specular = (fresnel * geom_atten * roughness_atten) / (n_dot_v * n_dot_l * 3.1419);
        float3 lit_colour = metalness * light_colour * n_dot_l * ( k + specular * ( 1.0 - k ) );
        return saturate(lit_colour);
    }
    return float3( 0.0, 0.0, 0.0 );
}
float3 oren_nayar(
float4 light_pos_radius,
float3 light_colour,
float3 n,
float3 world_pos,
float3 view_pos,
float roughness,
float3 albedo)
{
    float3 v = normalize(view_pos-world_pos);
    float3 l = normalize(light_pos_radius.xyz-world_pos);
    float l_dot_v = dot(l, v);
    float n_dot_l = dot(n, l);
    float n_dot_v = dot(n, v);
    float s = l_dot_v - n_dot_l * n_dot_v;
    float t = lerp(1.0, max(n_dot_l, n_dot_v), step(0.0, s));
    float lum = length( albedo );
    float sigma2 = roughness * roughness;
    float A = 1.0 + sigma2 * (lum / (sigma2 + 0.13) + 0.5 / (sigma2 + 0.33));
    float B = 0.45 * sigma2 / (sigma2 + 0.09);
    return ( albedo * light_colour * max(0.0, n_dot_l) * (A + B * s / t) / 3.14159265 );
}
float spot_light_attenuation(
float4 light_pos_radius,
float4 light_dir_cutoff,
float falloff,
float3 world_pos)
{
    float co = light_dir_cutoff.w;
    float3 vl = normalize(world_pos.xyz - light_pos_radius.xyz);
    float3 sd = normalize(light_dir_cutoff.xyz);
    float dp = (1.0 - dot(vl, sd));
    return smoothstep(co, co - falloff, dp);
}
float point_light_attenuation_cutoff(
float4 light_pos_radius,
float3 world_pos)
{
    float r = light_pos_radius.w;
    float d = length(world_pos.xyz - light_pos_radius.xyz);
    d = max(d - r, 0.0);
    float denom = d/r + 1.0;
    float attenuation = 1.0 / (denom*denom);
    float cutoff = 0.2;
    attenuation = (attenuation - cutoff) / (1.0 - cutoff);
    attenuation = max(attenuation, 0.0);
    return attenuation;
}
float sample_shadow_array_pcf_9(float array_slice, float3 sp)
{
    float2 samples[9];
    float2 inv_sm_size = float2(1.0/2048.0, 1.0/2048.0);
    samples[0] = float2(-1.0, -1.0) * inv_sm_size;
    samples[1] = float2(-1.0, 0.0) * inv_sm_size;
    samples[2] = float2(-1.0, 1.0) * inv_sm_size;
    samples[3] = float2(0.0, -1.0) * inv_sm_size;
    samples[4] = float2(0.0, 0.0) * inv_sm_size;
    samples[5] = float2(0.0, 1.0) * inv_sm_size;
    samples[6] = float2(1.0, -1.0) * inv_sm_size;
    samples[7] = float2(1.0, 0.0) * inv_sm_size;
    samples[8] = float2(1.0, 1.0) * inv_sm_size;
    float shadow = 0.0;
    for(int j = 0; j < 9; ++j)
    {
        shadow += sample_depth_compare_array(shadowmap_texture, sp.xy + samples[j], array_slice, sp.z);
    }
    shadow /= 9.0;
    return shadow;
}
float integrate_edge(float3 v1, float3 v2)
{
    float cos_theta = dot(v1, v2);
    float theta = acos(cos_theta);
    float res = cross(v1, v2).z * ((theta > 0.001) ? theta/sin(theta) : 1.0);
    return res;
}
void clip_quad_to_horizon(inout float3 L[5], out int n)
{
    int config = 0;
    if (L[0].z > 0.0) config += 1;
    if (L[1].z > 0.0) config += 2;
    if (L[2].z > 0.0) config += 4;
    if (L[3].z > 0.0) config += 8;
    n = 0;
    if (config == 0)
    {
    }
    else if (config == 1)
    {
        n = 3;
        L[1] = -L[1].z * L[0] + L[0].z * L[1];
        L[2] = -L[3].z * L[0] + L[0].z * L[3];
    }
    else if (config == 2)
    {
        n = 3;
        L[0] = -L[0].z * L[1] + L[1].z * L[0];
        L[2] = -L[2].z * L[1] + L[1].z * L[2];
    }
    else if (config == 3)
    {
        n = 4;
        L[2] = -L[2].z * L[1] + L[1].z * L[2];
        L[3] = -L[3].z * L[0] + L[0].z * L[3];
    }
    else if (config == 4)
    {
        n = 3;
        L[0] = -L[3].z * L[2] + L[2].z * L[3];
        L[1] = -L[1].z * L[2] + L[2].z * L[1];
    }
    else if (config == 5)
    {
        n = 0;
    }
    else if (config == 6)
    {
        n = 4;
        L[0] = -L[0].z * L[1] + L[1].z * L[0];
        L[3] = -L[3].z * L[2] + L[2].z * L[3];
    }
    else if (config == 7)
    {
        n = 5;
        L[4] = -L[3].z * L[0] + L[0].z * L[3];
        L[3] = -L[3].z * L[2] + L[2].z * L[3];
    }
    else if (config == 8)
    {
        n = 3;
        L[0] = -L[0].z * L[3] + L[3].z * L[0];
        L[1] = -L[2].z * L[3] + L[3].z * L[2];
        L[2] = L[3];
    }
    else if (config == 9)
    {
        n = 4;
        L[1] = -L[1].z * L[0] + L[0].z * L[1];
        L[2] = -L[2].z * L[3] + L[3].z * L[2];
    }
    else if (config == 10)
    {
        n = 0;
    }
    else if (config == 11)
    {
        n = 5;
        L[4] = L[3];
        L[3] = -L[2].z * L[3] + L[3].z * L[2];
        L[2] = -L[2].z * L[1] + L[1].z * L[2];
    }
    else if (config == 12)
    {
        n = 4;
        L[1] = -L[1].z * L[2] + L[2].z * L[1];
        L[0] = -L[0].z * L[3] + L[3].z * L[0];
    }
    else if (config == 13)
    {
        n = 5;
        L[4] = L[3];
        L[3] = L[2];
        L[2] = -L[1].z * L[2] + L[2].z * L[1];
        L[1] = -L[1].z * L[0] + L[0].z * L[1];
    }
    else if (config == 14)
    {
        n = 5;
        L[4] = -L[0].z * L[3] + L[3].z * L[0];
        L[0] = -L[0].z * L[1] + L[1].z * L[0];
    }
    else if (config == 15)
    {
        n = 4;
    }
    if (n == 3)
    L[3] = L[0];
    if (n == 4)
    L[4] = L[0];
}
float3 ltc_uv_coord(float3 p[4])
{
    float3 v1 = p[1] - p[0];
    float3 v2 = p[3] - p[0];
    float3 plane_ortho = (cross(v1, v2));
    float plane_area_squared = dot(plane_ortho, plane_ortho);
    float plane_distx_plane_area = dot(plane_ortho, p[0]);
    float3 pp = plane_distx_plane_area * plane_ortho / plane_area_squared - p[0];
    float v1_dot_v2 = dot(v1, v2);
    float inv_v1_dot_v1 = 1.0 / dot(v1, v1);
    float3 vv2 = v2 - v1 * v1_dot_v2 * inv_v1_dot_v1;
    float2 puv;
    puv.y = dot(vv2, pp) / dot(vv2, vv2);
    puv.x = dot(v1, pp) * inv_v1_dot_v1 - v1_dot_v2 * inv_v1_dot_v1 * puv.y;
    float d = abs(plane_distx_plane_area) / pow(plane_area_squared, 0.75);
    return float3(puv, d);
}
float4 ltc_evaluate(
float3 n,
float3 v,
float3 p,
float3x3 minv,
float3 points[4],
bool two_sided)
{
    float3 t1, t2;
    t1 = normalize(v - n * dot(v, n));
    t2 = cross(n, t1);
    float3x3 ttn = from_columns_3x3(t1, t2, n);
    minv = mul(minv, ttn);
    float3 l[5];
    l[0] = mul(minv, points[0] - p);
    l[1] = mul(minv, points[1] - p);
    l[2] = mul(minv, points[2] - p);
    l[3] = mul(minv, points[3] - p);
    l[4] = l[3];
    float3 ll[4];
    ll[0] = l[0];
    ll[1] = l[1];
    ll[2] = l[2];
    ll[3] = l[3];
    float3 uvl = ltc_uv_coord(ll);
    int nc;
    clip_quad_to_horizon(l, nc);
    if (nc == 0)
    return float4(0, 0, 0, 0.0);
    l[0] = normalize(l[0]);
    l[1] = normalize(l[1]);
    l[2] = normalize(l[2]);
    l[3] = normalize(l[3]);
    l[4] = normalize(l[4]);
    float sum = 0.0;
    sum += integrate_edge(l[0], l[1]);
    sum += integrate_edge(l[1], l[2]);
    sum += integrate_edge(l[2], l[3]);
    if (nc >= 4)
    sum += integrate_edge(l[3], l[4]);
    if (nc == 5)
    sum += integrate_edge(l[4], l[0]);
    sum = two_sided ? abs(sum) : max(0.0, sum);
    float3 lo_i = float3(sum, sum, sum);
    return float4(uvl.x, uvl.y, uvl.z, sum);
}
float ltc_evaluate_cc(
float3 n,
float3 v,
float3 p,
float3x3 minv,
float3 points[4],
bool two_sided)
{
    float3 t1, t2;
    t1 = normalize(v - n * dot(v, n));
    t2 = cross(n, t1);
    float3x3 ttn = from_columns_3x3(t1, t2, n);
    minv = mul(minv, ttn);
    float3 l[5];
    for(int i = 0; i < 4; ++i)
    l[i] = mul(minv, points[i] - p);
    l[4] = l[3];
    int nc;
    clip_quad_to_horizon(l, nc);
    if (nc == 0)
    return 0.0;
    for(int i = 0; i < 5; ++i)
    l[i] = normalize(l[i]);
    float sum = 0.0;
    sum += integrate_edge(l[0], l[1]);
    sum += integrate_edge(l[1], l[2]);
    sum += integrate_edge(l[2], l[3]);
    if (nc >= 4)
    sum += integrate_edge(l[3], l[4]);
    if (nc == 5)
    sum += integrate_edge(l[4], l[0]);
    sum = two_sided ? abs(sum) : max(0.0, sum);
    return sum;
}
float4 area_light_specular_uv(
float3 points[4],
float3 pos,
float roughness,
float3 n,
float3 v)
{
    float pi = 3.14159265359;
    float lut_size = 64.0;
    float lut_scale = (lut_size - 1.0)/lut_size;
    float lut_bias = 0.5/lut_size;
    float theta = acos(dot(n, v));
    float2 uv = float2(roughness, theta / (0.5 * pi));
    uv = uv * lut_scale + lut_bias;
    float4 mat = sample_texture(ltc_mat, uv);
    float mag = sample_texture(ltc_mag, uv).w;
    float3x3 minv = from_rows_3x3(
    float3(1.0, 0.0, mat.y),
    float3(0.0, mat.z, 0.0),
    float3(mat.w, 0.0, mat.x)
    );
    float4 spec = ltc_evaluate(n, v, pos, minv, points, true);
    return spec;
}
float area_light_specular(
float3 points[4],
float3 pos,
float roughness,
float3 n,
float3 v)
{
    float pi = 3.14159265359;
    float lut_size = 64.0;
    float lut_scale = (lut_size - 1.0)/lut_size;
    float lut_bias = 0.5/lut_size;
    float theta = acos(dot(n, v));
    float2 uv = float2(roughness, theta / (0.5 * pi));
    uv = uv * lut_scale + lut_bias;
    float4 mat = sample_texture(ltc_mat, uv);
    float mag = sample_texture(ltc_mag, uv).w;
    float3x3 minv = from_rows_3x3(
    float3(1.0, 0.0, mat.y),
    float3(0.0, mat.z, 0.0),
    float3(mat.w, 0.0, mat.x)
    );
    float spec = ltc_evaluate_cc(n, v, pos, minv, points, true);
    return spec;
}
float4 area_light_diffuse_uv(
float3 points[4],
float3 pos,
float3 n,
float3 v)
{
    float3x3 difv = float3x3(
    float3(1.0, 0.0, 0.0),
    float3(0.0, 1.0, 0.0),
    float3(0.0, 0.0, 1.0)
    );
    float4 diff = ltc_evaluate(n, v, pos, difv, points, true);
    return diff;
}
float area_light_diffuse(
float3 points[4],
float3 pos,
float3 n,
float3 v)
{
    float3x3 difv = float3x3(
    float3(1.0, 0.0, 0.0),
    float3(0.0, 1.0, 0.0),
    float3(0.0, 0.0, 1.0)
    );
    float diff = ltc_evaluate_cc(n, v, pos, difv, points, true);
    return diff;
}
float3 transform_ts_normal( float3 t, float3 b, float3 n, float3 ts_normal )
{
    float3x3 tbn;
    tbn[0] = float3(t.x, b.x, n.x);
    tbn[1] = float3(t.y, b.y, n.y);
    tbn[2] = float3(t.z, b.z, n.z);
    return normalize( mul_tbn( tbn, ts_normal ) );
}
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.world_pos = world_pos_vs_output;
    _input.normal = normal_vs_output;
    _input.tangent = tangent_vs_output;
    _input.bitangent = bitangent_vs_output;
    _input.texcoord = texcoord_vs_output;
    _input.colour = colour_vs_output;
    ps_output _output;
    float4 albedo = sample_texture( diffuse_texture, _input.texcoord.xy );
    float3 normal_sample = sample_texture( normal_texture, _input.texcoord.xy ).rgb;
    float4 ro_sample = sample_texture( specular_texture, _input.texcoord.xy );
    float4 specular_sample = float4(1.0, 1.0, 1.0, 1.0);
    normal_sample = normal_sample * 2.0 - 1.0;
    float3 n = transform_ts_normal(
    _input.tangent,
    _input.bitangent,
    _input.normal,
    normal_sample );
    albedo *= _input.colour;
    float4 metalness = float4(1.0, 1.0, 1.0, 1.0);
    float3 lit_colour = float3( 0.0, 0.0, 0.0 );
    float reflectivity = saturate(user_data.z);
    float roughness = saturate(user_data.y);
    reflectivity = m_reflectivity;
    roughness = ro_sample.r;
    roughness = _input.colour.a;
    albedo.a = 1.0;
    float t = 1.0;
    float3 lll = float3(0.0, 0.0, 0.0);
    int shadow_map_index = 0;
    _pmfx_loop
    for( int i = 0; i < int(light_info.x); ++i )
    {
        float3 light_col = float3( 0.0, 0.0, 0.0 );
        light_col += cook_torrence(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        albedo.rgb,
        metalness.rgb,
        roughness,
        reflectivity
        );
        light_col += oren_nayar(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        1.0 - roughness,
        albedo.rgb
        );
        if( lights[i].colour.a == 0.0 )
        {
            lit_colour += light_col;
            continue;
        }
        else
        {
            float shadow = 1.0;
            float d = 1.0;
            float4 offset_pos = float4(_input.world_pos.xyz + n.xyz * 0.01, 1.0);
            float4 sp = mul( offset_pos, shadow_matrix[i] );
            sp.xyz /= sp.w;
            sp.y *= -1.0;
            sp.xy = sp.xy * 0.5 + 0.5;
            sp.z = remap_depth(sp.z);
            shadow = sample_shadow_array_pcf_9(float(shadow_map_index), sp.xyz);
            lit_colour += light_col * shadow;
            ++shadow_map_index;
        }
    }
    int point_start = int(light_info.x);
    int point_end = int(light_info.x) + int(light_info.y);
    int omni_shadow_index = 0;
    _pmfx_loop
    for( int i = point_start; i < point_end; ++i )
    {
        float3 light_col = float3( 0.0, 0.0, 0.0 );
        light_col += cook_torrence(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        albedo.rgb,
        metalness.rgb,
        roughness,
        reflectivity
        );
        light_col += oren_nayar(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        roughness,
        albedo.rgb
        );
        float a = point_light_attenuation_cutoff( lights[i].pos_radius, _input.world_pos.xyz );
        light_col *= a;
        if( lights[i].colour.a == 0.0)
        {
            lit_colour += light_col;
            continue;
        }
        else
        {
            lit_colour += light_col;
            continue;
        }
    }
    int spot_start = point_end;
    int spot_end = spot_start + int(light_info.z);
    _pmfx_loop
    for(int i = spot_start; i < spot_end; ++i )
    {
        float3 light_col = float3( 0.0, 0.0, 0.0 );
        light_col += cook_torrence(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        albedo.rgb,
        metalness.rgb,
        roughness,
        reflectivity
        );
        light_col += oren_nayar(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        roughness,
        albedo.rgb
        );
        float a = spot_light_attenuation(lights[i].pos_radius,
        lights[i].dir_cutoff,
        lights[i].data.x,
        _input.world_pos.xyz );
        light_col *= a;
        if( lights[i].colour.a == 0.0 )
        {
            lit_colour += light_col;
            continue;
        }
        else
        {
            float shadow = 1.0;
            float d = 1.0;
            float4 offset_pos = float4(_input.world_pos.xyz + n.xyz * 0.01, 1.0);
            float4 sp = mul( offset_pos, shadow_matrix[shadow_map_index] );
            sp.xyz /= sp.w;
            sp.y *= -1.0;
            sp.xy = sp.xy * 0.5 + 0.5;
            sp.z = remap_depth(sp.z);
            shadow = sample_shadow_array_pcf_9(float(shadow_map_index), sp.xyz);
            lit_colour += light_col * shadow;
            ++shadow_map_index;
        }
    }
    {
        float pi = 3.14159265359;
        int num_area_lights = int(area_light_info.x);
        for(int i = 0; i < num_area_lights; ++i)
        {
            float3 v = -normalize(_input.world_pos.xyz - camera_view_pos.xyz);
            float3 pos = _input.world_pos.xyz;
            float3 points[4];
            for(int j = 0; j < 4; ++j)
            points[j] = area_lights[i].corners[j].xyz;
            float diff_sum = area_light_diffuse(points, pos, n, v);
            float3 diff = area_lights[i].colour.rgb * diff_sum;
            float spec_sum = area_light_specular(points, pos, ro_sample.x, n, v);
            float3 spec = area_lights[i].colour.rgb * spec_sum;
            float3 light_col = (spec.rgb + diff.rgb) / (2.0 * pi);
            lit_colour += light_col;
        }
        int ts = num_area_lights;
        int num_area_lights_textured = int(area_light_info.y);
        for(int i = ts; i < ts + num_area_lights_textured; ++i)
        {
            float slice = area_lights[i].colour.w;
            float levels = 8.0;
            float2 inv_texel = float2(1.0/640.0, 1.0/480.0);
            float2 inv_texel_x = float2(1.0, 1.0) - inv_texel;
            float3 points[4];
            for(int j = 0; j < 4; ++j)
            points[j] = area_lights[i].corners[j].xyz;
            float3 v = -normalize(_input.world_pos.xyz - camera_view_pos.xyz);
            float3 pos = _input.world_pos.xyz;
            float4 diff_uv = area_light_diffuse_uv(points, pos, n, v);
            float2 duv = clamp(diff_uv.xy, inv_texel, inv_texel_x);
            float3 diff = sample_texture_array_level( area_light_textures, duv, slice, diff_uv.z * levels).rgb * diff_uv.w;
            float4 spec_uv = area_light_specular_uv(points, pos, ro_sample.x, n, v);
            float2 suv = clamp(spec_uv.xy, inv_texel, inv_texel_x);
            float3 spec = sample_texture_array_level(area_light_textures, suv, slice, spec_uv.z * levels).rgb * spec_uv.w;
            float3 light_col = (spec.rgb + diff.rgb) / (2.0 * pi);
            lit_colour += light_col;
        }
    }
    _output.colour.rgb = lit_colour.rgb * albedo.a;
    _output.colour.a = albedo.a;
    if(albedo.a <= 0.0)
    discard;
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//forward_render forward_lit ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 world_pos_vs_output;
in float3 normal_vs_output;
in float3 tangent_vs_output;
in float3 bitangent_vs_output;
in float4 texcoord_vs_output;
in float4 colour_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 world_pos;
    float3 normal;
    float3 tangent;
    float3 bitangent;
    float4 texcoord;
    float4 colour;
};
struct ps_output
{
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
layout (std140) uniform per_draw_call
{
    float4x4 world_matrix;
    float4 user_data;
    float4 user_data2;
    float4x4 world_matrix_inv_transpose;
};
layout (std140) uniform per_pass_lights
{
    float4 light_info;
    light_data lights[100];
};
layout (std140) uniform per_pass_shadow
{
    float4x4 shadow_matrix[100];
};
layout (std140) uniform per_pass_area_lights
{
    float4 area_light_info;
    area_light_data area_lights[10];
};
layout (std140) uniform material_data
{
    float4 m_albedo;
    float m_roughness;
    float m_reflectivity;
    float2 m_padding;
};
texture_2d( diffuse_texture, 0 );
texture_2d( normal_texture, 1 );
texture_2d( specular_texture, 2 );
texture_2d( ltc_mat, 13 );
texture_2d( ltc_mag, 12 );
texture_2d_array( area_light_textures, 11 );
depth_2d_array( shadowmap_texture, 15 );
float3 cook_torrence(
float4 light_pos_radius,
float3 light_colour,
float3 n,
float3 world_pos,
float3 view_pos,
float3 albedo,
float3 metalness,
float roughness,
float reflectivity
)
{
    float3 l = normalize( light_pos_radius.xyz - world_pos.xyz );
    float n_dot_l = dot( n, l );
    if( n_dot_l > 0.0f )
    {
        float roughness_sq = roughness * roughness;
        float k = reflectivity;
        float3 v_view = normalize( (view_pos.xyz - world_pos.xyz) );
        float3 hv = normalize( v_view + l );
        float n_dot_v = dot( n, v_view );
        float n_dot_h = dot( n, hv );
        float v_dot_h = dot( v_view, hv );
        float n_dot_h_2 = 2.0f * n_dot_h;
        float g1 = (n_dot_h_2 * n_dot_v) / v_dot_h;
        float g2 = (n_dot_h_2 * n_dot_l) / v_dot_h;
        float geom_atten = min(1.0, min(g1, g2));
        float r1 = 1.0f / ( 4.0f * roughness_sq * pow(n_dot_h, 4.0f));
        float r2 = (n_dot_h * n_dot_h - 1.0) / (roughness_sq * n_dot_h * n_dot_h);
        float roughness_atten = r1 * exp(r2);
        float fresnel = pow(1.0 - v_dot_h, 5.0);
        fresnel *= roughness;
        fresnel += reflectivity;
        float specular = (fresnel * geom_atten * roughness_atten) / (n_dot_v * n_dot_l * 3.1419);
        float3 lit_colour = metalness * light_colour * n_dot_l * ( k + specular * ( 1.0 - k ) );
        return saturate(lit_colour);
    }
    return float3( 0.0, 0.0, 0.0 );
}
float3 oren_nayar(
float4 light_pos_radius,
float3 light_colour,
float3 n,
float3 world_pos,
float3 view_pos,
float roughness,
float3 albedo)
{
    float3 v = normalize(view_pos-world_pos);
    float3 l = normalize(light_pos_radius.xyz-world_pos);
    float l_dot_v = dot(l, v);
    float n_dot_l = dot(n, l);
    float n_dot_v = dot(n, v);
    float s = l_dot_v - n_dot_l * n_dot_v;
    float t = lerp(1.0, max(n_dot_l, n_dot_v), step(0.0, s));
    float lum = length( albedo );
    float sigma2 = roughness * roughness;
    float A = 1.0 + sigma2 * (lum / (sigma2 + 0.13) + 0.5 / (sigma2 + 0.33));
    float B = 0.45 * sigma2 / (sigma2 + 0.09);
    return ( albedo * light_colour * max(0.0, n_dot_l) * (A + B * s / t) / 3.14159265 );
}
float spot_light_attenuation(
float4 light_pos_radius,
float4 light_dir_cutoff,
float falloff,
float3 world_pos)
{
    float co = light_dir_cutoff.w;
    float3 vl = normalize(world_pos.xyz - light_pos_radius.xyz);
    float3 sd = normalize(light_dir_cutoff.xyz);
    float dp = (1.0 - dot(vl, sd));
    return smoothstep(co, co - falloff, dp);
}
float point_light_attenuation_cutoff(
float4 light_pos_radius,
float3 world_pos)
{
    float r = light_pos_radius.w;
    float d = length(world_pos.xyz - light_pos_radius.xyz);
    d = max(d - r, 0.0);
    float denom = d/r + 1.0;
    float attenuation = 1.0 / (denom*denom);
    float cutoff = 0.2;
    attenuation = (attenuation - cutoff) / (1.0 - cutoff);
    attenuation = max(attenuation, 0.0);
    return attenuation;
}
float sample_shadow_array_pcf_9(float array_slice, float3 sp)
{
    float2 samples[9];
    float2 inv_sm_size = float2(1.0/2048.0, 1.0/2048.0);
    samples[0] = float2(-1.0, -1.0) * inv_sm_size;
    samples[1] = float2(-1.0, 0.0) * inv_sm_size;
    samples[2] = float2(-1.0, 1.0) * inv_sm_size;
    samples[3] = float2(0.0, -1.0) * inv_sm_size;
    samples[4] = float2(0.0, 0.0) * inv_sm_size;
    samples[5] = float2(0.0, 1.0) * inv_sm_size;
    samples[6] = float2(1.0, -1.0) * inv_sm_size;
    samples[7] = float2(1.0, 0.0) * inv_sm_size;
    samples[8] = float2(1.0, 1.0) * inv_sm_size;
    float shadow = 0.0;
    for(int j = 0; j < 9; ++j)
    {
        shadow += sample_depth_compare_array(shadowmap_texture, sp.xy + samples[j], array_slice, sp.z);
    }
    shadow /= 9.0;
    return shadow;
}
float integrate_edge(float3 v1, float3 v2)
{
    float cos_theta = dot(v1, v2);
    float theta = acos(cos_theta);
    float res = cross(v1, v2).z * ((theta > 0.001) ? theta/sin(theta) : 1.0);
    return res;
}
void clip_quad_to_horizon(inout float3 L[5], out int n)
{
    int config = 0;
    if (L[0].z > 0.0) config += 1;
    if (L[1].z > 0.0) config += 2;
    if (L[2].z > 0.0) config += 4;
    if (L[3].z > 0.0) config += 8;
    n = 0;
    if (config == 0)
    {
    }
    else if (config == 1)
    {
        n = 3;
        L[1] = -L[1].z * L[0] + L[0].z * L[1];
        L[2] = -L[3].z * L[0] + L[0].z * L[3];
    }
    else if (config == 2)
    {
        n = 3;
        L[0] = -L[0].z * L[1] + L[1].z * L[0];
        L[2] = -L[2].z * L[1] + L[1].z * L[2];
    }
    else if (config == 3)
    {
        n = 4;
        L[2] = -L[2].z * L[1] + L[1].z * L[2];
        L[3] = -L[3].z * L[0] + L[0].z * L[3];
    }
    else if (config == 4)
    {
        n = 3;
        L[0] = -L[3].z * L[2] + L[2].z * L[3];
        L[1] = -L[1].z * L[2] + L[2].z * L[1];
    }
    else if (config == 5)
    {
        n = 0;
    }
    else if (config == 6)
    {
        n = 4;
        L[0] = -L[0].z * L[1] + L[1].z * L[0];
        L[3] = -L[3].z * L[2] + L[2].z * L[3];
    }
    else if (config == 7)
    {
        n = 5;
        L[4] = -L[3].z * L[0] + L[0].z * L[3];
        L[3] = -L[3].z * L[2] + L[2].z * L[3];
    }
    else if (config == 8)
    {
        n = 3;
        L[0] = -L[0].z * L[3] + L[3].z * L[0];
        L[1] = -L[2].z * L[3] + L[3].z * L[2];
        L[2] = L[3];
    }
    else if (config == 9)
    {
        n = 4;
        L[1] = -L[1].z * L[0] + L[0].z * L[1];
        L[2] = -L[2].z * L[3] + L[3].z * L[2];
    }
    else if (config == 10)
    {
        n = 0;
    }
    else if (config == 11)
    {
        n = 5;
        L[4] = L[3];
        L[3] = -L[2].z * L[3] + L[3].z * L[2];
        L[2] = -L[2].z * L[1] + L[1].z * L[2];
    }
    else if (config == 12)
    {
        n = 4;
        L[1] = -L[1].z * L[2] + L[2].z * L[1];
        L[0] = -L[0].z * L[3] + L[3].z * L[0];
    }
    else if (config == 13)
    {
        n = 5;
        L[4] = L[3];
        L[3] = L[2];
        L[2] = -L[1].z * L[2] + L[2].z * L[1];
        L[1] = -L[1].z * L[0] + L[0].z * L[1];
    }
    else if (config == 14)
    {
        n = 5;
        L[4] = -L[0].z * L[3] + L[3].z * L[0];
        L[0] = -L[0].z * L[1] + L[1].z * L[0];
    }
    else if (config == 15)
    {
        n = 4;
    }
    if (n == 3)
    L[3] = L[0];
    if (n == 4)
    L[4] = L[0];
}
float3 ltc_uv_coord(float3 p[4])
{
    float3 v1 = p[1] - p[0];
    float3 v2 = p[3] - p[0];
    float3 plane_ortho = (cross(v1, v2));
    float plane_area_squared = dot(plane_ortho, plane_ortho);
    float plane_distx_plane_area = dot(plane_ortho, p[0]);
    float3 pp = plane_distx_plane_area * plane_ortho / plane_area_squared - p[0];
    float v1_dot_v2 = dot(v1, v2);
    float inv_v1_dot_v1 = 1.0 / dot(v1, v1);
    float3 vv2 = v2 - v1 * v1_dot_v2 * inv_v1_dot_v1;
    float2 puv;
    puv.y = dot(vv2, pp) / dot(vv2, vv2);
    puv.x = dot(v1, pp) * inv_v1_dot_v1 - v1_dot_v2 * inv_v1_dot_v1 * puv.y;
    float d = abs(plane_distx_plane_area) / pow(plane_area_squared, 0.75);
    return float3(puv, d);
}
float4 ltc_evaluate(
float3 n,
float3 v,
float3 p,
float3x3 minv,
float3 points[4],
bool two_sided)
{
    float3 t1, t2;
    t1 = normalize(v - n * dot(v, n));
    t2 = cross(n, t1);
    float3x3 ttn = from_columns_3x3(t1, t2, n);
    minv = mul(minv, ttn);
    float3 l[5];
    l[0] = mul(minv, points[0] - p);
    l[1] = mul(minv, points[1] - p);
    l[2] = mul(minv, points[2] - p);
    l[3] = mul(minv, points[3] - p);
    l[4] = l[3];
    float3 ll[4];
    ll[0] = l[0];
    ll[1] = l[1];
    ll[2] = l[2];
    ll[3] = l[3];
    float3 uvl = ltc_uv_coord(ll);
    int nc;
    clip_quad_to_horizon(l, nc);
    if (nc == 0)
    return float4(0, 0, 0, 0.0);
    l[0] = normalize(l[0]);
    l[1] = normalize(l[1]);
    l[2] = normalize(l[2]);
    l[3] = normalize(l[3]);
    l[4] = normalize(l[4]);
    float sum = 0.0;
    sum += integrate_edge(l[0], l[1]);
    sum += integrate_edge(l[1], l[2]);
    sum += integrate_edge(l[2], l[3]);
    if (nc >= 4)
    sum += integrate_edge(l[3], l[4]);
    if (nc == 5)
    sum += integrate_edge(l[4], l[0]);
    sum = two_sided ? abs(sum) : max(0.0, sum);
    float3 lo_i = float3(sum, sum, sum);
    return float4(uvl.x, uvl.y, uvl.z, sum);
}
float ltc_evaluate_cc(
float3 n,
float3 v,
float3 p,
float3x3 minv,
float3 points[4],
bool two_sided)
{
    float3 t1, t2;
    t1 = normalize(v - n * dot(v, n));
    t2 = cross(n, t1);
    float3x3 ttn = from_columns_3x3(t1, t2, n);
    minv = mul(minv, ttn);
    float3 l[5];
    for(int i = 0; i < 4; ++i)
    l[i] = mul(minv, points[i] - p);
    l[4] = l[3];
    int nc;
    clip_quad_to_horizon(l, nc);
    if (nc == 0)
    return 0.0;
    for(int i = 0; i < 5; ++i)
    l[i] = normalize(l[i]);
    float sum = 0.0;
    sum += integrate_edge(l[0], l[1]);
    sum += integrate_edge(l[1], l[2]);
    sum += integrate_edge(l[2], l[3]);
    if (nc >= 4)
    sum += integrate_edge(l[3], l[4]);
    if (nc == 5)
    sum += integrate_edge(l[4], l[0]);
    sum = two_sided ? abs(sum) : max(0.0, sum);
    return sum;
}
float4 area_light_specular_uv(
float3 points[4],
float3 pos,
float roughness,
float3 n,
float3 v)
{
    float pi = 3.14159265359;
    float lut_size = 64.0;
    float lut_scale = (lut_size - 1.0)/lut_size;
    float lut_bias = 0.5/lut_size;
    float theta = acos(dot(n, v));
    float2 uv = float2(roughness, theta / (0.5 * pi));
    uv = uv * lut_scale + lut_bias;
    float4 mat = sample_texture(ltc_mat, uv);
    float mag = sample_texture(ltc_mag, uv).w;
    float3x3 minv = from_rows_3x3(
    float3(1.0, 0.0, mat.y),
    float3(0.0, mat.z, 0.0),
    float3(mat.w, 0.0, mat.x)
    );
    float4 spec = ltc_evaluate(n, v, pos, minv, points, true);
    return spec;
}
float area_light_specular(
float3 points[4],
float3 pos,
float roughness,
float3 n,
float3 v)
{
    float pi = 3.14159265359;
    float lut_size = 64.0;
    float lut_scale = (lut_size - 1.0)/lut_size;
    float lut_bias = 0.5/lut_size;
    float theta = acos(dot(n, v));
    float2 uv = float2(roughness, theta / (0.5 * pi));
    uv = uv * lut_scale + lut_bias;
    float4 mat = sample_texture(ltc_mat, uv);
    float mag = sample_texture(ltc_mag, uv).w;
    float3x3 minv = from_rows_3x3(
    float3(1.0, 0.0, mat.y),
    float3(0.0, mat.z, 0.0),
    float3(mat.w, 0.0, mat.x)
    );
    float spec = ltc_evaluate_cc(n, v, pos, minv, points, true);
    return spec;
}
float4 area_light_diffuse_uv(
float3 points[4],
float3 pos,
float3 n,
float3 v)
{
    float3x3 difv = float3x3(
    float3(1.0, 0.0, 0.0),
    float3(0.0, 1.0, 0.0),
    float3(0.0, 0.0, 1.0)
    );
    float4 diff = ltc_evaluate(n, v, pos, difv, points, true);
    return diff;
}
float area_light_diffuse(
float3 points[4],
float3 pos,
float3 n,
float3 v)
{
    float3x3 difv = float3x3(
    float3(1.0, 0.0, 0.0),
    float3(0.0, 1.0, 0.0),
    float3(0.0, 0.0, 1.0)
    );
    float diff = ltc_evaluate_cc(n, v, pos, difv, points, true);
    return diff;
}
float3 transform_ts_normal( float3 t, float3 b, float3 n, float3 ts_normal )
{
    float3x3 tbn;
    tbn[0] = float3(t.x, b.x, n.x);
    tbn[1] = float3(t.y, b.y, n.y);
    tbn[2] = float3(t.z, b.z, n.z);
    return normalize( mul_tbn( tbn, ts_normal ) );
}
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.world_pos = world_pos_vs_output;
    _input.normal = normal_vs_output;
    _input.tangent = tangent_vs_output;
    _input.bitangent = bitangent_vs_output;
    _input.texcoord = texcoord_vs_output;
    _input.colour = colour_vs_output;
    ps_output _output;
    float4 albedo = sample_texture( diffuse_texture, _input.texcoord.xy );
    float3 normal_sample = sample_texture( normal_texture, _input.texcoord.xy ).rgb;
    float4 ro_sample = sample_texture( specular_texture, _input.texcoord.xy );
    float4 specular_sample = float4(1.0, 1.0, 1.0, 1.0);
    normal_sample = normal_sample * 2.0 - 1.0;
    float3 n = transform_ts_normal(
    _input.tangent,
    _input.bitangent,
    _input.normal,
    normal_sample );
    albedo *= _input.colour;
    float4 metalness = float4(1.0, 1.0, 1.0, 1.0);
    float3 lit_colour = float3( 0.0, 0.0, 0.0 );
    float reflectivity = saturate(user_data.z);
    float roughness = saturate(user_data.y);
    reflectivity = m_reflectivity;
    roughness = ro_sample.r;
    float t = 1.0;
    float3 lll = float3(0.0, 0.0, 0.0);
    int shadow_map_index = 0;
    _pmfx_loop
    for( int i = 0; i < int(light_info.x); ++i )
    {
        float3 light_col = float3( 0.0, 0.0, 0.0 );
        light_col += cook_torrence(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        albedo.rgb,
        metalness.rgb,
        roughness,
        reflectivity
        );
        light_col += oren_nayar(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        1.0 - roughness,
        albedo.rgb
        );
        if( lights[i].colour.a == 0.0 )
        {
            lit_colour += light_col;
            continue;
        }
        else
        {
            float shadow = 1.0;
            float d = 1.0;
            float4 offset_pos = float4(_input.world_pos.xyz + n.xyz * 0.01, 1.0);
            float4 sp = mul( offset_pos, shadow_matrix[i] );
            sp.xyz /= sp.w;
            sp.y *= -1.0;
            sp.xy = sp.xy * 0.5 + 0.5;
            sp.z = remap_depth(sp.z);
            shadow = sample_shadow_array_pcf_9(float(shadow_map_index), sp.xyz);
            lit_colour += light_col * shadow;
            ++shadow_map_index;
        }
    }
    int point_start = int(light_info.x);
    int point_end = int(light_info.x) + int(light_info.y);
    int omni_shadow_index = 0;
    _pmfx_loop
    for( int i = point_start; i < point_end; ++i )
    {
        float3 light_col = float3( 0.0, 0.0, 0.0 );
        light_col += cook_torrence(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        albedo.rgb,
        metalness.rgb,
        roughness,
        reflectivity
        );
        light_col += oren_nayar(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        roughness,
        albedo.rgb
        );
        float a = point_light_attenuation_cutoff( lights[i].pos_radius, _input.world_pos.xyz );
        light_col *= a;
        if( lights[i].colour.a == 0.0)
        {
            lit_colour += light_col;
            continue;
        }
        else
        {
            lit_colour += light_col;
            continue;
        }
    }
    int spot_start = point_end;
    int spot_end = spot_start + int(light_info.z);
    _pmfx_loop
    for(int i = spot_start; i < spot_end; ++i )
    {
        float3 light_col = float3( 0.0, 0.0, 0.0 );
        light_col += cook_torrence(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        albedo.rgb,
        metalness.rgb,
        roughness,
        reflectivity
        );
        light_col += oren_nayar(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        roughness,
        albedo.rgb
        );
        float a = spot_light_attenuation(lights[i].pos_radius,
        lights[i].dir_cutoff,
        lights[i].data.x,
        _input.world_pos.xyz );
        light_col *= a;
        if( lights[i].colour.a == 0.0 )
        {
            lit_colour += light_col;
            continue;
        }
        else
        {
            float shadow = 1.0;
            float d = 1.0;
            float4 offset_pos = float4(_input.world_pos.xyz + n.xyz * 0.01, 1.0);
            float4 sp = mul( offset_pos, shadow_matrix[shadow_map_index] );
            sp.xyz /= sp.w;
            sp.y *= -1.0;
            sp.xy = sp.xy * 0.5 + 0.5;
            sp.z = remap_depth(sp.z);
            shadow = sample_shadow_array_pcf_9(float(shadow_map_index), sp.xyz);
            lit_colour += light_col * shadow;
            ++shadow_map_index;
        }
    }
    {
        float pi = 3.14159265359;
        int num_area_lights = int(area_light_info.x);
        for(int i = 0; i < num_area_lights; ++i)
        {
            float3 v = -normalize(_input.world_pos.xyz - camera_view_pos.xyz);
            float3 pos = _input.world_pos.xyz;
            float3 points[4];
            for(int j = 0; j < 4; ++j)
            points[j] = area_lights[i].corners[j].xyz;
            float diff_sum = area_light_diffuse(points, pos, n, v);
            float3 diff = area_lights[i].colour.rgb * diff_sum;
            float spec_sum = area_light_specular(points, pos, ro_sample.x, n, v);
            float3 spec = area_lights[i].colour.rgb * spec_sum;
            float3 light_col = (spec.rgb + diff.rgb) / (2.0 * pi);
            lit_colour += light_col;
        }
        int ts = num_area_lights;
        int num_area_lights_textured = int(area_light_info.y);
        for(int i = ts; i < ts + num_area_lights_textured; ++i)
        {
            float slice = area_lights[i].colour.w;
            float levels = 8.0;
            float2 inv_texel = float2(1.0/640.0, 1.0/480.0);
            float2 inv_texel_x = float2(1.0, 1.0) - inv_texel;
            float3 points[4];
            for(int j = 0; j < 4; ++j)
            points[j] = area_lights[i].corners[j].xyz;
            float3 v = -normalize(_input.world_pos.xyz - camera_view_pos.xyz);
            float3 pos = _input.world_pos.xyz;
            float4 diff_uv = area_light_diffuse_uv(points, pos, n, v);
            float2 duv = clamp(diff_uv.xy, inv_texel, inv_texel_x);
            float3 diff = sample_texture_array_level( area_light_textures, duv, slice, diff_uv.z * levels).rgb * diff_uv.w;
            float4 spec_uv = area_light_specular_uv(points, pos, ro_sample.x, n, v);
            float2 suv = clamp(spec_uv.xy, inv_texel, inv_texel_x);
            float3 spec = sample_texture_array_level(area_light_textures, suv, slice, spec_uv.z * levels).rgb * spec_uv.w;
            float3 light_col = (spec.rgb + diff.rgb) / (2.0 * pi);
            lit_colour += light_col;
        }
    }
    _output.colour.rgb = lit_colour.rgb * albedo.a;
    _output.colour.a = albedo.a;
    if(albedo.a <= 0.0)
    discard;
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//forward_render forward_lit__1073741824__ ps 1073741824
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 world_pos_vs_output;
in float3 normal_vs_output;
in float3 tangent_vs_output;
in float3 bitangent_vs_output;
in float4 texcoord_vs_output;
in float4 colour_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 world_pos;
    float3 normal;
    float3 tangent;
    float3 bitangent;
    float4 texcoord;
    float4 colour;
};
struct ps_output
{
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
layout (std140) uniform per_draw_call
{
    float4x4 world_matrix;
    float4 user_data;
    float4 user_data2;
    float4x4 world_matrix_inv_transpose;
};
layout (std140) uniform per_pass_lights
{
    float4 light_info;
    light_data lights[100];
};
layout (std140) uniform per_pass_shadow
{
    float4x4 shadow_matrix[100];
};
layout (std140) uniform per_pass_area_lights
{
    float4 area_light_info;
    area_light_data area_lights[10];
};
layout (std140) uniform material_data
{
    float4 m_albedo;
    float m_roughness;
    float m_reflectivity;
    float2 m_padding;
};
texture_2d( diffuse_texture, 0 );
texture_2d( normal_texture, 1 );
texture_2d( specular_texture, 2 );
texture_2d( ltc_mat, 13 );
texture_2d( ltc_mag, 12 );
texture_2d_array( area_light_textures, 11 );
depth_2d_array( shadowmap_texture, 15 );
float3 cook_torrence(
float4 light_pos_radius,
float3 light_colour,
float3 n,
float3 world_pos,
float3 view_pos,
float3 albedo,
float3 metalness,
float roughness,
float reflectivity
)
{
    float3 l = normalize( light_pos_radius.xyz - world_pos.xyz );
    float n_dot_l = dot( n, l );
    if( n_dot_l > 0.0f )
    {
        float roughness_sq = roughness * roughness;
        float k = reflectivity;
        float3 v_view = normalize( (view_pos.xyz - world_pos.xyz) );
        float3 hv = normalize( v_view + l );
        float n_dot_v = dot( n, v_view );
        float n_dot_h = dot( n, hv );
        float v_dot_h = dot( v_view, hv );
        float n_dot_h_2 = 2.0f * n_dot_h;
        float g1 = (n_dot_h_2 * n_dot_v) / v_dot_h;
        float g2 = (n_dot_h_2 * n_dot_l) / v_dot_h;
        float geom_atten = min(1.0, min(g1, g2));
        float r1 = 1.0f / ( 4.0f * roughness_sq * pow(n_dot_h, 4.0f));
        float r2 = (n_dot_h * n_dot_h - 1.0) / (roughness_sq * n_dot_h * n_dot_h);
        float roughness_atten = r1 * exp(r2);
        float fresnel = pow(1.0 - v_dot_h, 5.0);
        fresnel *= roughness;
        fresnel += reflectivity;
        float specular = (fresnel * geom_atten * roughness_atten) / (n_dot_v * n_dot_l * 3.1419);
        float3 lit_colour = metalness * light_colour * n_dot_l * ( k + specular * ( 1.0 - k ) );
        return saturate(lit_colour);
    }
    return float3( 0.0, 0.0, 0.0 );
}
float3 oren_nayar(
float4 light_pos_radius,
float3 light_colour,
float3 n,
float3 world_pos,
float3 view_pos,
float roughness,
float3 albedo)
{
    float3 v = normalize(view_pos-world_pos);
    float3 l = normalize(light_pos_radius.xyz-world_pos);
    float l_dot_v = dot(l, v);
    float n_dot_l = dot(n, l);
    float n_dot_v = dot(n, v);
    float s = l_dot_v - n_dot_l * n_dot_v;
    float t = lerp(1.0, max(n_dot_l, n_dot_v), step(0.0, s));
    float lum = length( albedo );
    float sigma2 = roughness * roughness;
    float A = 1.0 + sigma2 * (lum / (sigma2 + 0.13) + 0.5 / (sigma2 + 0.33));
    float B = 0.45 * sigma2 / (sigma2 + 0.09);
    return ( albedo * light_colour * max(0.0, n_dot_l) * (A + B * s / t) / 3.14159265 );
}
float spot_light_attenuation(
float4 light_pos_radius,
float4 light_dir_cutoff,
float falloff,
float3 world_pos)
{
    float co = light_dir_cutoff.w;
    float3 vl = normalize(world_pos.xyz - light_pos_radius.xyz);
    float3 sd = normalize(light_dir_cutoff.xyz);
    float dp = (1.0 - dot(vl, sd));
    return smoothstep(co, co - falloff, dp);
}
float point_light_attenuation_cutoff(
float4 light_pos_radius,
float3 world_pos)
{
    float r = light_pos_radius.w;
    float d = length(world_pos.xyz - light_pos_radius.xyz);
    d = max(d - r, 0.0);
    float denom = d/r + 1.0;
    float attenuation = 1.0 / (denom*denom);
    float cutoff = 0.2;
    attenuation = (attenuation - cutoff) / (1.0 - cutoff);
    attenuation = max(attenuation, 0.0);
    return attenuation;
}
float sample_shadow_array_pcf_9(float array_slice, float3 sp)
{
    float2 samples[9];
    float2 inv_sm_size = float2(1.0/2048.0, 1.0/2048.0);
    samples[0] = float2(-1.0, -1.0) * inv_sm_size;
    samples[1] = float2(-1.0, 0.0) * inv_sm_size;
    samples[2] = float2(-1.0, 1.0) * inv_sm_size;
    samples[3] = float2(0.0, -1.0) * inv_sm_size;
    samples[4] = float2(0.0, 0.0) * inv_sm_size;
    samples[5] = float2(0.0, 1.0) * inv_sm_size;
    samples[6] = float2(1.0, -1.0) * inv_sm_size;
    samples[7] = float2(1.0, 0.0) * inv_sm_size;
    samples[8] = float2(1.0, 1.0) * inv_sm_size;
    float shadow = 0.0;
    for(int j = 0; j < 9; ++j)
    {
        shadow += sample_depth_compare_array(shadowmap_texture, sp.xy + samples[j], array_slice, sp.z);
    }
    shadow /= 9.0;
    return shadow;
}
float integrate_edge(float3 v1, float3 v2)
{
    float cos_theta = dot(v1, v2);
    float theta = acos(cos_theta);
    float res = cross(v1, v2).z * ((theta > 0.001) ? theta/sin(theta) : 1.0);
    return res;
}
void clip_quad_to_horizon(inout float3 L[5], out int n)
{
    int config = 0;
    if (L[0].z > 0.0) config += 1;
    if (L[1].z > 0.0) config += 2;
    if (L[2].z > 0.0) config += 4;
    if (L[3].z > 0.0) config += 8;
    n = 0;
    if (config == 0)
    {
    }
    else if (config == 1)
    {
        n = 3;
        L[1] = -L[1].z * L[0] + L[0].z * L[1];
        L[2] = -L[3].z * L[0] + L[0].z * L[3];
    }
    else if (config == 2)
    {
        n = 3;
        L[0] = -L[0].z * L[1] + L[1].z * L[0];
        L[2] = -L[2].z * L[1] + L[1].z * L[2];
    }
    else if (config == 3)
    {
        n = 4;
        L[2] = -L[2].z * L[1] + L[1].z * L[2];
        L[3] = -L[3].z * L[0] + L[0].z * L[3];
    }
    else if (config == 4)
    {
        n = 3;
        L[0] = -L[3].z * L[2] + L[2].z * L[3];
        L[1] = -L[1].z * L[2] + L[2].z * L[1];
    }
    else if (config == 5)
    {
        n = 0;
    }
    else if (config == 6)
    {
        n = 4;
        L[0] = -L[0].z * L[1] + L[1].z * L[0];
        L[3] = -L[3].z * L[2] + L[2].z * L[3];
    }
    else if (config == 7)
    {
        n = 5;
        L[4] = -L[3].z * L[0] + L[0].z * L[3];
        L[3] = -L[3].z * L[2] + L[2].z * L[3];
    }
    else if (config == 8)
    {
        n = 3;
        L[0] = -L[0].z * L[3] + L[3].z * L[0];
        L[1] = -L[2].z * L[3] + L[3].z * L[2];
        L[2] = L[3];
    }
    else if (config == 9)
    {
        n = 4;
        L[1] = -L[1].z * L[0] + L[0].z * L[1];
        L[2] = -L[2].z * L[3] + L[3].z * L[2];
    }
    else if (config == 10)
    {
        n = 0;
    }
    else if (config == 11)
    {
        n = 5;
        L[4] = L[3];
        L[3] = -L[2].z * L[3] + L[3].z * L[2];
        L[2] = -L[2].z * L[1] + L[1].z * L[2];
    }
    else if (config == 12)
    {
        n = 4;
        L[1] = -L[1].z * L[2] + L[2].z * L[1];
        L[0] = -L[0].z * L[3] + L[3].z * L[0];
    }
    else if (config == 13)
    {
        n = 5;
        L[4] = L[3];
        L[3] = L[2];
        L[2] = -L[1].z * L[2] + L[2].z * L[1];
        L[1] = -L[1].z * L[0] + L[0].z * L[1];
    }
    else if (config == 14)
    {
        n = 5;
        L[4] = -L[0].z * L[3] + L[3].z * L[0];
        L[0] = -L[0].z * L[1] + L[1].z * L[0];
    }
    else if (config == 15)
    {
        n = 4;
    }
    if (n == 3)
    L[3] = L[0];
    if (n == 4)
    L[4] = L[0];
}
float3 ltc_uv_coord(float3 p[4])
{
    float3 v1 = p[1] - p[0];
    float3 v2 = p[3] - p[0];
    float3 plane_ortho = (cross(v1, v2));
    float plane_area_squared = dot(plane_ortho, plane_ortho);
    float plane_distx_plane_area = dot(plane_ortho, p[0]);
    float3 pp = plane_distx_plane_area * plane_ortho / plane_area_squared - p[0];
    float v1_dot_v2 = dot(v1, v2);
    float inv_v1_dot_v1 = 1.0 / dot(v1, v1);
    float3 vv2 = v2 - v1 * v1_dot_v2 * inv_v1_dot_v1;
    float2 puv;
    puv.y = dot(vv2, pp) / dot(vv2, vv2);
    puv.x = dot(v1, pp) * inv_v1_dot_v1 - v1_dot_v2 * inv_v1_dot_v1 * puv.y;
    float d = abs(plane_distx_plane_area) / pow(plane_area_squared, 0.75);
    return float3(puv, d);
}
float4 ltc_evaluate(
float3 n,
float3 v,
float3 p,
float3x3 minv,
float3 points[4],
bool two_sided)
{
    float3 t1, t2;
    t1 = normalize(v - n * dot(v, n));
    t2 = cross(n, t1);
    float3x3 ttn = from_columns_3x3(t1, t2, n);
    minv = mul(minv, ttn);
    float3 l[5];
    l[0] = mul(minv, points[0] - p);
    l[1] = mul(minv, points[1] - p);
    l[2] = mul(minv, points[2] - p);
    l[3] = mul(minv, points[3] - p);
    l[4] = l[3];
    float3 ll[4];
    ll[0] = l[0];
    ll[1] = l[1];
    ll[2] = l[2];
    ll[3] = l[3];
    float3 uvl = ltc_uv_coord(ll);
    int nc;
    clip_quad_to_horizon(l, nc);
    if (nc == 0)
    return float4(0, 0, 0, 0.0);
    l[0] = normalize(l[0]);
    l[1] = normalize(l[1]);
    l[2] = normalize(l[2]);
    l[3] = normalize(l[3]);
    l[4] = normalize(l[4]);
    float sum = 0.0;
    sum += integrate_edge(l[0], l[1]);
    sum += integrate_edge(l[1], l[2]);
    sum += integrate_edge(l[2], l[3]);
    if (nc >= 4)
    sum += integrate_edge(l[3], l[4]);
    if (nc == 5)
    sum += integrate_edge(l[4], l[0]);
    sum = two_sided ? abs(sum) : max(0.0, sum);
    float3 lo_i = float3(sum, sum, sum);
    return float4(uvl.x, uvl.y, uvl.z, sum);
}
float ltc_evaluate_cc(
float3 n,
float3 v,
float3 p,
float3x3 minv,
float3 points[4],
bool two_sided)
{
    float3 t1, t2;
    t1 = normalize(v - n * dot(v, n));
    t2 = cross(n, t1);
    float3x3 ttn = from_columns_3x3(t1, t2, n);
    minv = mul(minv, ttn);
    float3 l[5];
    for(int i = 0; i < 4; ++i)
    l[i] = mul(minv, points[i] - p);
    l[4] = l[3];
    int nc;
    clip_quad_to_horizon(l, nc);
    if (nc == 0)
    return 0.0;
    for(int i = 0; i < 5; ++i)
    l[i] = normalize(l[i]);
    float sum = 0.0;
    sum += integrate_edge(l[0], l[1]);
    sum += integrate_edge(l[1], l[2]);
    sum += integrate_edge(l[2], l[3]);
    if (nc >= 4)
    sum += integrate_edge(l[3], l[4]);
    if (nc == 5)
    sum += integrate_edge(l[4], l[0]);
    sum = two_sided ? abs(sum) : max(0.0, sum);
    return sum;
}
float4 area_light_specular_uv(
float3 points[4],
float3 pos,
float roughness,
float3 n,
float3 v)
{
    float pi = 3.14159265359;
    float lut_size = 64.0;
    float lut_scale = (lut_size - 1.0)/lut_size;
    float lut_bias = 0.5/lut_size;
    float theta = acos(dot(n, v));
    float2 uv = float2(roughness, theta / (0.5 * pi));
    uv = uv * lut_scale + lut_bias;
    float4 mat = sample_texture(ltc_mat, uv);
    float mag = sample_texture(ltc_mag, uv).w;
    float3x3 minv = from_rows_3x3(
    float3(1.0, 0.0, mat.y),
    float3(0.0, mat.z, 0.0),
    float3(mat.w, 0.0, mat.x)
    );
    float4 spec = ltc_evaluate(n, v, pos, minv, points, true);
    return spec;
}
float area_light_specular(
float3 points[4],
float3 pos,
float roughness,
float3 n,
float3 v)
{
    float pi = 3.14159265359;
    float lut_size = 64.0;
    float lut_scale = (lut_size - 1.0)/lut_size;
    float lut_bias = 0.5/lut_size;
    float theta = acos(dot(n, v));
    float2 uv = float2(roughness, theta / (0.5 * pi));
    uv = uv * lut_scale + lut_bias;
    float4 mat = sample_texture(ltc_mat, uv);
    float mag = sample_texture(ltc_mag, uv).w;
    float3x3 minv = from_rows_3x3(
    float3(1.0, 0.0, mat.y),
    float3(0.0, mat.z, 0.0),
    float3(mat.w, 0.0, mat.x)
    );
    float spec = ltc_evaluate_cc(n, v, pos, minv, points, true);
    return spec;
}
float4 area_light_diffuse_uv(
float3 points[4],
float3 pos,
float3 n,
float3 v)
{
    float3x3 difv = float3x3(
    float3(1.0, 0.0, 0.0),
    float3(0.0, 1.0, 0.0),
    float3(0.0, 0.0, 1.0)
    );
    float4 diff = ltc_evaluate(n, v, pos, difv, points, true);
    return diff;
}
float area_light_diffuse(
float3 points[4],
float3 pos,
float3 n,
float3 v)
{
    float3x3 difv = float3x3(
    float3(1.0, 0.0, 0.0),
    float3(0.0, 1.0, 0.0),
    float3(0.0, 0.0, 1.0)
    );
    float diff = ltc_evaluate_cc(n, v, pos, difv, points, true);
    return diff;
}
float3 transform_ts_normal( float3 t, float3 b, float3 n, float3 ts_normal )
{
    float3x3 tbn;
    tbn[0] = float3(t.x, b.x, n.x);
    tbn[1] = float3(t.y, b.y, n.y);
    tbn[2] = float3(t.z, b.z, n.z);
    return normalize( mul_tbn( tbn, ts_normal ) );
}
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.world_pos = world_pos_vs_output;
    _input.normal = normal_vs_output;
    _input.tangent = tangent_vs_output;
    _input.bitangent = bitangent_vs_output;
    _input.texcoord = texcoord_vs_output;
    _input.colour = colour_vs_output;
    ps_output _output;
    float4 albedo = sample_texture( diffuse_texture, _input.texcoord.xy );
    float3 normal_sample = sample_texture( normal_texture, _input.texcoord.xy ).rgb;
    float4 ro_sample = sample_texture( specular_texture, _input.texcoord.xy );
    float4 specular_sample = float4(1.0, 1.0, 1.0, 1.0);
    normal_sample = normal_sample * 2.0 - 1.0;
    float3 n = transform_ts_normal(
    _input.tangent,
    _input.bitangent,
    _input.normal,
    normal_sample );
    albedo *= _input.colour;
    float4 metalness = float4(1.0, 1.0, 1.0, 1.0);
    float3 lit_colour = float3( 0.0, 0.0, 0.0 );
    float reflectivity = saturate(user_data.z);
    float roughness = saturate(user_data.y);
    reflectivity = m_reflectivity;
    roughness = ro_sample.r;
    roughness = _input.colour.a;
    albedo.a = 1.0;
    float t = 1.0;
    float3 lll = float3(0.0, 0.0, 0.0);
    int shadow_map_index = 0;
    _pmfx_loop
    for( int i = 0; i < int(light_info.x); ++i )
    {
        float3 light_col = float3( 0.0, 0.0, 0.0 );
        light_col += cook_torrence(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        albedo.rgb,
        metalness.rgb,
        roughness,
        reflectivity
        );
        light_col += oren_nayar(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        1.0 - roughness,
        albedo.rgb
        );
        if( lights[i].colour.a == 0.0 )
        {
            lit_colour += light_col;
            continue;
        }
        else
        {
            float shadow = 1.0;
            float d = 1.0;
            float4 offset_pos = float4(_input.world_pos.xyz + n.xyz * 0.01, 1.0);
            float4 sp = mul( offset_pos, shadow_matrix[i] );
            sp.xyz /= sp.w;
            sp.y *= -1.0;
            sp.xy = sp.xy * 0.5 + 0.5;
            sp.z = remap_depth(sp.z);
            shadow = sample_shadow_array_pcf_9(float(shadow_map_index), sp.xyz);
            lit_colour += light_col * shadow;
            ++shadow_map_index;
        }
    }
    int point_start = int(light_info.x);
    int point_end = int(light_info.x) + int(light_info.y);
    int omni_shadow_index = 0;
    _pmfx_loop
    for( int i = point_start; i < point_end; ++i )
    {
        float3 light_col = float3( 0.0, 0.0, 0.0 );
        light_col += cook_torrence(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        albedo.rgb,
        metalness.rgb,
        roughness,
        reflectivity
        );
        light_col += oren_nayar(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        roughness,
        albedo.rgb
        );
        float a = point_light_attenuation_cutoff( lights[i].pos_radius, _input.world_pos.xyz );
        light_col *= a;
        if( lights[i].colour.a == 0.0)
        {
            lit_colour += light_col;
            continue;
        }
        else
        {
            lit_colour += light_col;
            continue;
        }
    }
    int spot_start = point_end;
    int spot_end = spot_start + int(light_info.z);
    _pmfx_loop
    for(int i = spot_start; i < spot_end; ++i )
    {
        float3 light_col = float3( 0.0, 0.0, 0.0 );
        light_col += cook_torrence(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        albedo.rgb,
        metalness.rgb,
        roughness,
        reflectivity
        );
        light_col += oren_nayar(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        roughness,
        albedo.rgb
        );
        float a = spot_light_attenuation(lights[i].pos_radius,
        lights[i].dir_cutoff,
        lights[i].data.x,
        _input.world_pos.xyz );
        light_col *= a;
        if( lights[i].colour.a == 0.0 )
        {
            lit_colour += light_col;
            continue;
        }
        else
        {
            float shadow = 1.0;
            float d = 1.0;
            float4 offset_pos = float4(_input.world_pos.xyz + n.xyz * 0.01, 1.0);
            float4 sp = mul( offset_pos, shadow_matrix[shadow_map_index] );
            sp.xyz /= sp.w;
            sp.y *= -1.0;
            sp.xy = sp.xy * 0.5 + 0.5;
            sp.z = remap_depth(sp.z);
            shadow = sample_shadow_array_pcf_9(float(shadow_map_index), sp.xyz);
            lit_colour += light_col * shadow;
            ++shadow_map_index;
        }
    }
    {
        float pi = 3.14159265359;
        int num_area_lights = int(area_light_info.x);
        for(int i = 0; i < num_area_lights; ++i)
        {
            float3 v = -normalize(_input.world_pos.xyz - camera_view_pos.xyz);
            float3 pos = _input.world_pos.xyz;
            float3 points[4];
            for(int j = 0; j < 4; ++j)
            points[j] = area_lights[i].corners[j].xyz;
            float diff_sum = area_light_diffuse(points, pos, n, v);
            float3 diff = area_lights[i].colour.rgb * diff_sum;
            float spec_sum = area_light_specular(points, pos, ro_sample.x, n, v);
            float3 spec = area_lights[i].colour.rgb * spec_sum;
            float3 light_col = (spec.rgb + diff.rgb) / (2.0 * pi);
            lit_colour += light_col;
        }
        int ts = num_area_lights;
        int num_area_lights_textured = int(area_light_info.y);
        for(int i = ts; i < ts + num_area_lights_textured; ++i)
        {
            float slice = area_lights[i].colour.w;
            float levels = 8.0;
            float2 inv_texel = float2(1.0/640.0, 1.0/480.0);
            float2 inv_texel_x = float2(1.0, 1.0) - inv_texel;
            float3 points[4];
            for(int j = 0; j < 4; ++j)
            points[j] = area_lights[i].corners[j].xyz;
            float3 v = -normalize(_input.world_pos.xyz - camera_view_pos.xyz);
            float3 pos = _input.world_pos.xyz;
            float4 diff_uv = area_light_diffuse_uv(points, pos, n, v);
            float2 duv = clamp(diff_uv.xy, inv_texel, inv_texel_x);
            float3 diff = sample_texture_array_level( area_light_textures, duv, slice, diff_uv.z * levels).rgb * diff_uv.w;
            float4 spec_uv = area_light_specular_uv(points, pos, ro_sample.x, n, v);
            float2 suv = clamp(spec_uv.xy, inv_texel, inv_texel_x);
            float3 spec = sample_texture_array_level(area_light_textures, suv, slice, spec_uv.z * levels).rgb * spec_uv.w;
            float3 light_col = (spec.rgb + diff.rgb) / (2.0 * pi);
            lit_colour += light_col;
        }
    }
    _output.colour.rgb = lit_colour.rgb * albedo.a;
    _output.colour.a = albedo.a;
    if(albedo.a <= 0.0)
    discard;
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//forward_render forward_lit__18__ ps 18
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 world_pos_vs_output;
in float3 normal_vs_output;
in float3 tangent_vs_output;
in float3 bitangent_vs_output;
in float4 texcoord_vs_output;
in float4 colour_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 world_pos;
    float3 normal;
    float3 tangent;
    float3 bitangent;
    float4 texcoord;
    float4 colour;
};
struct ps_output
{
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
layout (std140) uniform per_draw_call
{
    float4x4 world_matrix;
    float4 user_data;
    float4 user_data2;
    float4x4 world_matrix_inv_transpose;
};
layout (std140) uniform per_pass_lights
{
    float4 light_info;
    light_data lights[100];
};
layout (std140) uniform per_pass_shadow
{
    float4x4 shadow_matrix[100];
};
layout (std140) uniform per_pass_area_lights
{
    float4 area_light_info;
    area_light_data area_lights[10];
};
layout (std140) uniform cbuffer_gi_volume
{
    float4 gi_scene_size;
    float4 gi_volume_size;
};
layout (std140) uniform material_data
{
    float4 m_albedo;
    float2 m_uv_scale;
    float m_roughness;
    float m_reflectivity;
};
texture_2d( diffuse_texture, 0 );
texture_2d( normal_texture, 1 );
texture_2d( specular_texture, 2 );
texture_2d( blue_noise, 5 );
texture_2d( ltc_mat, 13 );
texture_2d( ltc_mag, 12 );
texture_2d_array( area_light_textures, 11 );
texture_3d( volume_gi, 9 );
depth_2d_array( shadowmap_texture, 15 );
float3 cook_torrence(
float4 light_pos_radius,
float3 light_colour,
float3 n,
float3 world_pos,
float3 view_pos,
float3 albedo,
float3 metalness,
float roughness,
float reflectivity
)
{
    float3 l = normalize( light_pos_radius.xyz - world_pos.xyz );
    float n_dot_l = dot( n, l );
    if( n_dot_l > 0.0f )
    {
        float roughness_sq = roughness * roughness;
        float k = reflectivity;
        float3 v_view = normalize( (view_pos.xyz - world_pos.xyz) );
        float3 hv = normalize( v_view + l );
        float n_dot_v = dot( n, v_view );
        float n_dot_h = dot( n, hv );
        float v_dot_h = dot( v_view, hv );
        float n_dot_h_2 = 2.0f * n_dot_h;
        float g1 = (n_dot_h_2 * n_dot_v) / v_dot_h;
        float g2 = (n_dot_h_2 * n_dot_l) / v_dot_h;
        float geom_atten = min(1.0, min(g1, g2));
        float r1 = 1.0f / ( 4.0f * roughness_sq * pow(n_dot_h, 4.0f));
        float r2 = (n_dot_h * n_dot_h - 1.0) / (roughness_sq * n_dot_h * n_dot_h);
        float roughness_atten = r1 * exp(r2);
        float fresnel = pow(1.0 - v_dot_h, 5.0);
        fresnel *= roughness;
        fresnel += reflectivity;
        float specular = (fresnel * geom_atten * roughness_atten) / (n_dot_v * n_dot_l * 3.1419);
        float3 lit_colour = metalness * light_colour * n_dot_l * ( k + specular * ( 1.0 - k ) );
        return saturate(lit_colour);
    }
    return float3( 0.0, 0.0, 0.0 );
}
float3 oren_nayar(
float4 light_pos_radius,
float3 light_colour,
float3 n,
float3 world_pos,
float3 view_pos,
float roughness,
float3 albedo)
{
    float3 v = normalize(view_pos-world_pos);
    float3 l = normalize(light_pos_radius.xyz-world_pos);
    float l_dot_v = dot(l, v);
    float n_dot_l = dot(n, l);
    float n_dot_v = dot(n, v);
    float s = l_dot_v - n_dot_l * n_dot_v;
    float t = lerp(1.0, max(n_dot_l, n_dot_v), step(0.0, s));
    float lum = length( albedo );
    float sigma2 = roughness * roughness;
    float A = 1.0 + sigma2 * (lum / (sigma2 + 0.13) + 0.5 / (sigma2 + 0.33));
    float B = 0.45 * sigma2 / (sigma2 + 0.09);
    return ( albedo * light_colour * max(0.0, n_dot_l) * (A + B * s / t) / 3.14159265 );
}
float spot_light_attenuation(
float4 light_pos_radius,
float4 light_dir_cutoff,
float falloff,
float3 world_pos)
{
    float co = light_dir_cutoff.w;
    float3 vl = normalize(world_pos.xyz - light_pos_radius.xyz);
    float3 sd = normalize(light_dir_cutoff.xyz);
    float dp = (1.0 - dot(vl, sd));
    return smoothstep(co, co - falloff, dp);
}
float point_light_attenuation_cutoff(
float4 light_pos_radius,
float3 world_pos)
{
    float r = light_pos_radius.w;
    float d = length(world_pos.xyz - light_pos_radius.xyz);
    d = max(d - r, 0.0);
    float denom = d/r + 1.0;
    float attenuation = 1.0 / (denom*denom);
    float cutoff = 0.2;
    attenuation = (attenuation - cutoff) / (1.0 - cutoff);
    attenuation = max(attenuation, 0.0);
    return attenuation;
}
float sample_shadow_array_pcf_9(float array_slice, float3 sp)
{
    float2 samples[9];
    float2 inv_sm_size = float2(1.0/2048.0, 1.0/2048.0);
    samples[0] = float2(-1.0, -1.0) * inv_sm_size;
    samples[1] = float2(-1.0, 0.0) * inv_sm_size;
    samples[2] = float2(-1.0, 1.0) * inv_sm_size;
    samples[3] = float2(0.0, -1.0) * inv_sm_size;
    samples[4] = float2(0.0, 0.0) * inv_sm_size;
    samples[5] = float2(0.0, 1.0) * inv_sm_size;
    samples[6] = float2(1.0, -1.0) * inv_sm_size;
    samples[7] = float2(1.0, 0.0) * inv_sm_size;
    samples[8] = float2(1.0, 1.0) * inv_sm_size;
    float shadow = 0.0;
    for(int j = 0; j < 9; ++j)
    {
        shadow += sample_depth_compare_array(shadowmap_texture, sp.xy + samples[j], array_slice, sp.z);
    }
    shadow /= 9.0;
    return shadow;
}
float integrate_edge(float3 v1, float3 v2)
{
    float cos_theta = dot(v1, v2);
    float theta = acos(cos_theta);
    float res = cross(v1, v2).z * ((theta > 0.001) ? theta/sin(theta) : 1.0);
    return res;
}
void clip_quad_to_horizon(inout float3 L[5], out int n)
{
    int config = 0;
    if (L[0].z > 0.0) config += 1;
    if (L[1].z > 0.0) config += 2;
    if (L[2].z > 0.0) config += 4;
    if (L[3].z > 0.0) config += 8;
    n = 0;
    if (config == 0)
    {
    }
    else if (config == 1)
    {
        n = 3;
        L[1] = -L[1].z * L[0] + L[0].z * L[1];
        L[2] = -L[3].z * L[0] + L[0].z * L[3];
    }
    else if (config == 2)
    {
        n = 3;
        L[0] = -L[0].z * L[1] + L[1].z * L[0];
        L[2] = -L[2].z * L[1] + L[1].z * L[2];
    }
    else if (config == 3)
    {
        n = 4;
        L[2] = -L[2].z * L[1] + L[1].z * L[2];
        L[3] = -L[3].z * L[0] + L[0].z * L[3];
    }
    else if (config == 4)
    {
        n = 3;
        L[0] = -L[3].z * L[2] + L[2].z * L[3];
        L[1] = -L[1].z * L[2] + L[2].z * L[1];
    }
    else if (config == 5)
    {
        n = 0;
    }
    else if (config == 6)
    {
        n = 4;
        L[0] = -L[0].z * L[1] + L[1].z * L[0];
        L[3] = -L[3].z * L[2] + L[2].z * L[3];
    }
    else if (config == 7)
    {
        n = 5;
        L[4] = -L[3].z * L[0] + L[0].z * L[3];
        L[3] = -L[3].z * L[2] + L[2].z * L[3];
    }
    else if (config == 8)
    {
        n = 3;
        L[0] = -L[0].z * L[3] + L[3].z * L[0];
        L[1] = -L[2].z * L[3] + L[3].z * L[2];
        L[2] = L[3];
    }
    else if (config == 9)
    {
        n = 4;
        L[1] = -L[1].z * L[0] + L[0].z * L[1];
        L[2] = -L[2].z * L[3] + L[3].z * L[2];
    }
    else if (config == 10)
    {
        n = 0;
    }
    else if (config == 11)
    {
        n = 5;
        L[4] = L[3];
        L[3] = -L[2].z * L[3] + L[3].z * L[2];
        L[2] = -L[2].z * L[1] + L[1].z * L[2];
    }
    else if (config == 12)
    {
        n = 4;
        L[1] = -L[1].z * L[2] + L[2].z * L[1];
        L[0] = -L[0].z * L[3] + L[3].z * L[0];
    }
    else if (config == 13)
    {
        n = 5;
        L[4] = L[3];
        L[3] = L[2];
        L[2] = -L[1].z * L[2] + L[2].z * L[1];
        L[1] = -L[1].z * L[0] + L[0].z * L[1];
    }
    else if (config == 14)
    {
        n = 5;
        L[4] = -L[0].z * L[3] + L[3].z * L[0];
        L[0] = -L[0].z * L[1] + L[1].z * L[0];
    }
    else if (config == 15)
    {
        n = 4;
    }
    if (n == 3)
    L[3] = L[0];
    if (n == 4)
    L[4] = L[0];
}
float3 ltc_uv_coord(float3 p[4])
{
    float3 v1 = p[1] - p[0];
    float3 v2 = p[3] - p[0];
    float3 plane_ortho = (cross(v1, v2));
    float plane_area_squared = dot(plane_ortho, plane_ortho);
    float plane_distx_plane_area = dot(plane_ortho, p[0]);
    float3 pp = plane_distx_plane_area * plane_ortho / plane_area_squared - p[0];
    float v1_dot_v2 = dot(v1, v2);
    float inv_v1_dot_v1 = 1.0 / dot(v1, v1);
    float3 vv2 = v2 - v1 * v1_dot_v2 * inv_v1_dot_v1;
    float2 puv;
    puv.y = dot(vv2, pp) / dot(vv2, vv2);
    puv.x = dot(v1, pp) * inv_v1_dot_v1 - v1_dot_v2 * inv_v1_dot_v1 * puv.y;
    float d = abs(plane_distx_plane_area) / pow(plane_area_squared, 0.75);
    return float3(puv, d);
}
float4 ltc_evaluate(
float3 n,
float3 v,
float3 p,
float3x3 minv,
float3 points[4],
bool two_sided)
{
    float3 t1, t2;
    t1 = normalize(v - n * dot(v, n));
    t2 = cross(n, t1);
    float3x3 ttn = from_columns_3x3(t1, t2, n);
    minv = mul(minv, ttn);
    float3 l[5];
    l[0] = mul(minv, points[0] - p);
    l[1] = mul(minv, points[1] - p);
    l[2] = mul(minv, points[2] - p);
    l[3] = mul(minv, points[3] - p);
    l[4] = l[3];
    float3 ll[4];
    ll[0] = l[0];
    ll[1] = l[1];
    ll[2] = l[2];
    ll[3] = l[3];
    float3 uvl = ltc_uv_coord(ll);
    int nc;
    clip_quad_to_horizon(l, nc);
    if (nc == 0)
    return float4(0, 0, 0, 0.0);
    l[0] = normalize(l[0]);
    l[1] = normalize(l[1]);
    l[2] = normalize(l[2]);
    l[3] = normalize(l[3]);
    l[4] = normalize(l[4]);
    float sum = 0.0;
    sum += integrate_edge(l[0], l[1]);
    sum += integrate_edge(l[1], l[2]);
    sum += integrate_edge(l[2], l[3]);
    if (nc >= 4)
    sum += integrate_edge(l[3], l[4]);
    if (nc == 5)
    sum += integrate_edge(l[4], l[0]);
    sum = two_sided ? abs(sum) : max(0.0, sum);
    float3 lo_i = float3(sum, sum, sum);
    return float4(uvl.x, uvl.y, uvl.z, sum);
}
float ltc_evaluate_cc(
float3 n,
float3 v,
float3 p,
float3x3 minv,
float3 points[4],
bool two_sided)
{
    float3 t1, t2;
    t1 = normalize(v - n * dot(v, n));
    t2 = cross(n, t1);
    float3x3 ttn = from_columns_3x3(t1, t2, n);
    minv = mul(minv, ttn);
    float3 l[5];
    for(int i = 0; i < 4; ++i)
    l[i] = mul(minv, points[i] - p);
    l[4] = l[3];
    int nc;
    clip_quad_to_horizon(l, nc);
    if (nc == 0)
    return 0.0;
    for(int i = 0; i < 5; ++i)
    l[i] = normalize(l[i]);
    float sum = 0.0;
    sum += integrate_edge(l[0], l[1]);
    sum += integrate_edge(l[1], l[2]);
    sum += integrate_edge(l[2], l[3]);
    if (nc >= 4)
    sum += integrate_edge(l[3], l[4]);
    if (nc == 5)
    sum += integrate_edge(l[4], l[0]);
    sum = two_sided ? abs(sum) : max(0.0, sum);
    return sum;
}
float4 area_light_specular_uv(
float3 points[4],
float3 pos,
float roughness,
float3 n,
float3 v)
{
    float pi = 3.14159265359;
    float lut_size = 64.0;
    float lut_scale = (lut_size - 1.0)/lut_size;
    float lut_bias = 0.5/lut_size;
    float theta = acos(dot(n, v));
    float2 uv = float2(roughness, theta / (0.5 * pi));
    uv = uv * lut_scale + lut_bias;
    float4 mat = sample_texture(ltc_mat, uv);
    float mag = sample_texture(ltc_mag, uv).w;
    float3x3 minv = from_rows_3x3(
    float3(1.0, 0.0, mat.y),
    float3(0.0, mat.z, 0.0),
    float3(mat.w, 0.0, mat.x)
    );
    float4 spec = ltc_evaluate(n, v, pos, minv, points, true);
    return spec;
}
float area_light_specular(
float3 points[4],
float3 pos,
float roughness,
float3 n,
float3 v)
{
    float pi = 3.14159265359;
    float lut_size = 64.0;
    float lut_scale = (lut_size - 1.0)/lut_size;
    float lut_bias = 0.5/lut_size;
    float theta = acos(dot(n, v));
    float2 uv = float2(roughness, theta / (0.5 * pi));
    uv = uv * lut_scale + lut_bias;
    float4 mat = sample_texture(ltc_mat, uv);
    float mag = sample_texture(ltc_mag, uv).w;
    float3x3 minv = from_rows_3x3(
    float3(1.0, 0.0, mat.y),
    float3(0.0, mat.z, 0.0),
    float3(mat.w, 0.0, mat.x)
    );
    float spec = ltc_evaluate_cc(n, v, pos, minv, points, true);
    return spec;
}
float4 area_light_diffuse_uv(
float3 points[4],
float3 pos,
float3 n,
float3 v)
{
    float3x3 difv = float3x3(
    float3(1.0, 0.0, 0.0),
    float3(0.0, 1.0, 0.0),
    float3(0.0, 0.0, 1.0)
    );
    float4 diff = ltc_evaluate(n, v, pos, difv, points, true);
    return diff;
}
float area_light_diffuse(
float3 points[4],
float3 pos,
float3 n,
float3 v)
{
    float3x3 difv = float3x3(
    float3(1.0, 0.0, 0.0),
    float3(0.0, 1.0, 0.0),
    float3(0.0, 0.0, 1.0)
    );
    float diff = ltc_evaluate_cc(n, v, pos, difv, points, true);
    return diff;
}
float3 transform_ts_normal( float3 t, float3 b, float3 n, float3 ts_normal )
{
    float3x3 tbn;
    tbn[0] = float3(t.x, b.x, n.x);
    tbn[1] = float3(t.y, b.y, n.y);
    tbn[2] = float3(t.z, b.z, n.z);
    return normalize( mul_tbn( tbn, ts_normal ) );
}
float3 hash_33( float3 p )
{
    p = float3(dot(p,float3(127.1,311.7, 74.7)),
    dot(p,float3(269.5,183.3,246.1)),
    dot(p,float3(113.5,271.9,124.6)));
    return fract(sin(p)*43758.5453123) * 2.0 - 1.0;
}
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.world_pos = world_pos_vs_output;
    _input.normal = normal_vs_output;
    _input.tangent = tangent_vs_output;
    _input.bitangent = bitangent_vs_output;
    _input.texcoord = texcoord_vs_output;
    _input.colour = colour_vs_output;
    ps_output _output;
    float4 albedo = sample_texture( diffuse_texture, _input.texcoord.xy );
    float3 normal_sample = sample_texture( normal_texture, _input.texcoord.xy ).rgb;
    float4 ro_sample = sample_texture( specular_texture, _input.texcoord.xy );
    float4 specular_sample = float4(1.0, 1.0, 1.0, 1.0);
    normal_sample = normal_sample * 2.0 - 1.0;
    float3 n = transform_ts_normal(
    _input.tangent,
    _input.bitangent,
    _input.normal,
    normal_sample );
    albedo *= _input.colour;
    float4 metalness = float4(1.0, 1.0, 1.0, 1.0);
    float3 lit_colour = float3( 0.0, 0.0, 0.0 );
    float reflectivity = saturate(user_data.z);
    float roughness = saturate(user_data.y);
    reflectivity = m_reflectivity;
    roughness = ro_sample.r;
    float t = 1.0;
    float3 lll = float3(0.0, 0.0, 0.0);
    int shadow_map_index = 0;
    _pmfx_loop
    for( int i = 0; i < int(light_info.x); ++i )
    {
        float3 light_col = float3( 0.0, 0.0, 0.0 );
        light_col += cook_torrence(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        albedo.rgb,
        metalness.rgb,
        roughness,
        reflectivity
        );
        light_col += oren_nayar(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        1.0 - roughness,
        albedo.rgb
        );
        if( lights[i].colour.a == 0.0 )
        {
            lit_colour += light_col;
            continue;
        }
        else
        {
            float shadow = 1.0;
            float d = 1.0;
            float4 offset_pos = float4(_input.world_pos.xyz + n.xyz * 0.01, 1.0);
            float4 sp = mul( offset_pos, shadow_matrix[i] );
            sp.xyz /= sp.w;
            sp.y *= -1.0;
            sp.xy = sp.xy * 0.5 + 0.5;
            sp.z = remap_depth(sp.z);
            shadow = sample_shadow_array_pcf_9(float(shadow_map_index), sp.xyz);
            lit_colour += light_col * shadow;
            ++shadow_map_index;
        }
    }
    int point_start = int(light_info.x);
    int point_end = int(light_info.x) + int(light_info.y);
    int omni_shadow_index = 0;
    _pmfx_loop
    for( int i = point_start; i < point_end; ++i )
    {
        float3 light_col = float3( 0.0, 0.0, 0.0 );
        light_col += cook_torrence(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        albedo.rgb,
        metalness.rgb,
        roughness,
        reflectivity
        );
        light_col += oren_nayar(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        roughness,
        albedo.rgb
        );
        float a = point_light_attenuation_cutoff( lights[i].pos_radius, _input.world_pos.xyz );
        light_col *= a;
        if( lights[i].colour.a == 0.0)
        {
            lit_colour += light_col;
            continue;
        }
        else
        {
            lit_colour += light_col;
            continue;
        }
    }
    int spot_start = point_end;
    int spot_end = spot_start + int(light_info.z);
    _pmfx_loop
    for(int i = spot_start; i < spot_end; ++i )
    {
        float3 light_col = float3( 0.0, 0.0, 0.0 );
        light_col += cook_torrence(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        albedo.rgb,
        metalness.rgb,
        roughness,
        reflectivity
        );
        light_col += oren_nayar(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        roughness,
        albedo.rgb
        );
        float a = spot_light_attenuation(lights[i].pos_radius,
        lights[i].dir_cutoff,
        lights[i].data.x,
        _input.world_pos.xyz );
        light_col *= a;
        if( lights[i].colour.a == 0.0 )
        {
            lit_colour += light_col;
            continue;
        }
        else
        {
            float shadow = 1.0;
            float d = 1.0;
            float4 offset_pos = float4(_input.world_pos.xyz + n.xyz * 0.01, 1.0);
            float4 sp = mul( offset_pos, shadow_matrix[shadow_map_index] );
            sp.xyz /= sp.w;
            sp.y *= -1.0;
            sp.xy = sp.xy * 0.5 + 0.5;
            sp.z = remap_depth(sp.z);
            shadow = sample_shadow_array_pcf_9(float(shadow_map_index), sp.xyz);
            lit_colour += light_col * shadow;
            ++shadow_map_index;
        }
    }
    {
        float pi = 3.14159265359;
        int num_area_lights = int(area_light_info.x);
        for(int i = 0; i < num_area_lights; ++i)
        {
            float3 v = -normalize(_input.world_pos.xyz - camera_view_pos.xyz);
            float3 pos = _input.world_pos.xyz;
            float3 points[4];
            for(int j = 0; j < 4; ++j)
            points[j] = area_lights[i].corners[j].xyz;
            float diff_sum = area_light_diffuse(points, pos, n, v);
            float3 diff = area_lights[i].colour.rgb * diff_sum;
            float spec_sum = area_light_specular(points, pos, ro_sample.x, n, v);
            float3 spec = area_lights[i].colour.rgb * spec_sum;
            float3 light_col = (spec.rgb + diff.rgb) / (2.0 * pi);
            lit_colour += light_col;
        }
        int ts = num_area_lights;
        int num_area_lights_textured = int(area_light_info.y);
        for(int i = ts; i < ts + num_area_lights_textured; ++i)
        {
            float slice = area_lights[i].colour.w;
            float levels = 8.0;
            float2 inv_texel = float2(1.0/640.0, 1.0/480.0);
            float2 inv_texel_x = float2(1.0, 1.0) - inv_texel;
            float3 points[4];
            for(int j = 0; j < 4; ++j)
            points[j] = area_lights[i].corners[j].xyz;
            float3 v = -normalize(_input.world_pos.xyz - camera_view_pos.xyz);
            float3 pos = _input.world_pos.xyz;
            float4 diff_uv = area_light_diffuse_uv(points, pos, n, v);
            float2 duv = clamp(diff_uv.xy, inv_texel, inv_texel_x);
            float3 diff = sample_texture_array_level( area_light_textures, duv, slice, diff_uv.z * levels).rgb * diff_uv.w;
            float4 spec_uv = area_light_specular_uv(points, pos, ro_sample.x, n, v);
            float2 suv = clamp(spec_uv.xy, inv_texel, inv_texel_x);
            float3 spec = sample_texture_array_level(area_light_textures, suv, slice, spec_uv.z * levels).rgb * spec_uv.w;
            float3 light_col = (spec.rgb + diff.rgb) / (2.0 * pi);
            lit_colour += light_col;
        }
    }
    _output.colour.rgb = lit_colour.rgb * albedo.a;
    _output.colour.a = albedo.a;
    float3 gn = _input.normal.xyz;
    float3 gt = _input.tangent.xyz;
    float3 gb = _input.bitangent.xyz;
    float3 dim = gi_scene_size.xyz;
    float3 to_uvx = dim * 0.5;
    int num_rays = 16;
    float3 rays[16];
    rays[0] = float3(0.57735, 0.57735, 0.57735);
    rays[1] = float3(0.57735, -0.57735, -0.57735);
    rays[2] = float3(-0.57735, 0.57735, -0.57735);
    rays[3] = float3(-0.57735, -0.57735, 0.57735);
    rays[4] = float3(-0.903007, -0.182696, -0.388844);
    rays[5] = float3(-0.903007, 0.182696, 0.388844);
    rays[6] = float3(0.903007, -0.182696, 0.388844);
    rays[7] = float3(0.903007, 0.182696, -0.388844);
    rays[8] = float3(-0.388844, -0.903007, -0.182696);
    rays[9] = float3(0.388844, -0.903007, 0.182696);
    rays[10] = float3(0.388844, 0.903007, -0.182696);
    rays[11] = float3(-0.388844, 0.903007, 0.182696);
    rays[12] = float3(-0.182696, -0.388844, -0.903007);
    rays[13] = float3(0.182696, 0.388844, -0.903007);
    rays[14] = float3(-0.182696, 0.388844, 0.903007);
    rays[15] = float3(0.182696, -0.388844, 0.903007);
    float4 gi = float4(0.0, 0.0, 0.0, 0.0);
    float4 sp = mul(_input.world_pos, vp_matrix);
    sp /= sp.w;
    sp.x *= (1280.0/512.0);
    sp.y *= (720.0/512.0);
    for(int i = 0; i < num_rays; ++i)
    {
        float3 noise = (hash_33(_input.world_pos.xyz + user_data.yyy));
        float3 noise2 = (sample_texture_level(blue_noise, sp.xy + noise.xy, 0.0).rgb * 2.0 - 1.0);
        float3 tex_size = gi_volume_size.xyz;
        float3 ray = chebyshev_normalize(noise2 + rays[i]);
        float3 cn = chebyshev_normalize(n);
        float3 step = (dim*2.0) / tex_size;
        float3 sp = _input.world_pos.xyz + (cn * step);
        ray *= dot(ray, gn) < 0.0 ? -1.0 : 1.0;
        float4 ray_gi = float4(0.0, 0.0, 0.0, 0.0);
        for(int j = 0; j < 4; ++j)
        {
            for(int k = 0; k < 2; ++k)
            {
                step = (dim*2.0) / tex_size;
                float3 uvw = saturate((sp / to_uvx) * 0.5 + 0.5);
                float4 g = sample_texture_level( volume_gi, uvw, float(j));
                float d = length(_input.world_pos.xyz - sp);
                d = smoothstep(0.0, 8.0, d);
                ray_gi.rgb = ray_gi.rgb + g.rgb * d;
                ray_gi.a += g.a;
                sp += ray * step.x;
            }
            tex_size /= 2.0;
            if(ray_gi.a >= 1.0 && j > 1)
            break;
        }
        gi += ray_gi;
    }
    gi /= float(num_rays);
    _output.colour.rgb = gi.rgb * 2.0 * m_albedo.rgb + lit_colour.rgb;
    if(albedo.a <= 0.0)
    discard;
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//forward_render forward_lit__1073741834__ vs 1073741834
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
layout(location = 0) in float4 position_vs_input;
layout(location = 1) in float4 normal_vs_input;
layout(location = 2) in float4 texcoord_vs_input;
layout(location = 3) in float4 tangent_vs_input;
layout(location = 4) in float4 bitangent_vs_input;
layout(location = 5) in float4 world_matrix_0_instance_input;
layout(location = 6) in float4 world_matrix_1_instance_input;
layout(location = 7) in float4 world_matrix_2_instance_input;
layout(location = 8) in float4 world_matrix_3_instance_input;
layout(location = 9) in float4 user_data_instance_input;
layout(location = 10) in float4 user_data2_instance_input;
out float4 world_pos_vs_output;
out float3 normal_vs_output;
out float3 tangent_vs_output;
out float3 bitangent_vs_output;
out float4 texcoord_vs_output;
out float4 colour_vs_output;
uniform float v_flip;
struct vs_input_multi
{
    float4 position;
    float4 normal;
    float4 texcoord;
    float4 tangent;
    float4 bitangent;
};
struct vs_instance_input
{
    float4 world_matrix_0;
    float4 world_matrix_1;
    float4 world_matrix_2;
    float4 world_matrix_3;
    float4 user_data;
    float4 user_data2;
};
struct vs_output
{
    float4 position;
    float4 world_pos;
    float3 normal;
    float3 tangent;
    float3 bitangent;
    float4 texcoord;
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
layout (std140) uniform per_draw_call
{
    float4x4 world_matrix;
    float4 user_data;
    float4 user_data2;
    float4x4 world_matrix_inv_transpose;
};
layout (std140) uniform material_data
{
    float4 m_albedo;
    float2 m_uv_scale;
    float m_roughness;
    float m_reflectivity;
    float m_surface_offset;
    float3 m_padding;
};
void main()
{
    //assign vs_input_multi struct from glsl inputs
    vs_input_multi _input;
    _input.position = position_vs_input;
    _input.normal = normal_vs_input;
    _input.texcoord = texcoord_vs_input;
    _input.tangent = tangent_vs_input;
    _input.bitangent = bitangent_vs_input;
    //assign vs_instance_input struct from glsl inputs
    vs_instance_input instance_input;
    instance_input.world_matrix_0 = world_matrix_0_instance_input;
    instance_input.world_matrix_1 = world_matrix_1_instance_input;
    instance_input.world_matrix_2 = world_matrix_2_instance_input;
    instance_input.world_matrix_3 = world_matrix_3_instance_input;
    instance_input.user_data = user_data_instance_input;
    instance_input.user_data2 = user_data2_instance_input;
    vs_output _output;
    float4x4 wvp = mul( world_matrix, vp_matrix );
    float4x4 wm = world_matrix;
    _output.texcoord = float4(_input.texcoord.x, 1.0 - _input.texcoord.y,
    _input.texcoord.z, 1.0 - _input.texcoord.w );
    float4x4 instance_world_mat;
    unpack_vb_instance_mat(
    instance_world_mat,
    instance_input.world_matrix_0,
    instance_input.world_matrix_1,
    instance_input.world_matrix_2,
    instance_input.world_matrix_3
    );
    wvp = mul( instance_world_mat, vp_matrix );
    wm = instance_world_mat;
    _output.colour = instance_input.user_data2;
    _output.position = mul( _input.position, wvp );
    _output.world_pos = mul( _input.position, wm );
    float3x3 wrm = to_3x3(wm);
    wrm[0] = normalize(wrm[0]);
    wrm[1] = normalize(wrm[1]);
    wrm[2] = normalize(wrm[2]);
    _output.normal = mul( _input.normal.xyz, wrm );
    _output.tangent = mul( _input.tangent.xyz, wrm );
    _output.bitangent = mul( _input.bitangent.xyz, wrm );
    float3 scale = float3(length(world_matrix[0].xyz),
    length(world_matrix[1].xyz),
    length(world_matrix[2].xyz));
    float xs = length(_input.tangent.xyz * scale);
    float ys = length(_input.bitangent.xyz * scale);
    _output.texcoord *= float4(m_uv_scale.x * xs, m_uv_scale.y * ys, m_uv_scale.x, m_uv_scale.y);
    //assign glsl global outputs from structs
    gl_Position = _output.position;
    gl_Position.y *= v_flip;
    world_pos_vs_output = _output.world_pos;
    normal_vs_output = _output.normal;
    tangent_vs_output = _output.tangent;
    bitangent_vs_output = _output.bitangent;
    texcoord_vs_output = _output.texcoord;
    colour_vs_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//forward_render forward_lit__2147483650__ vs 2147483650
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
layout(location = 0) in float4 position_vs_input;
layout(location = 1) in float4 normal_vs_input;
layout(location = 2) in float4 texcoord_vs_input;
layout(location = 3) in float4 tangent_vs_input;
layout(location = 4) in float4 bitangent_vs_input;
layout(location = 5) in float4 blend_indices_vs_input;
layout(location = 6) in float4 blend_weights_vs_input;
out float4 world_pos_vs_output;
out float3 normal_vs_output;
out float3 tangent_vs_output;
out float3 bitangent_vs_output;
out float4 texcoord_vs_output;
out float4 colour_vs_output;
uniform float v_flip;
struct vs_input_multi
{
    float4 position;
    float4 normal;
    float4 texcoord;
    float4 tangent;
    float4 bitangent;
    float4 blend_indices;
    float4 blend_weights;
};
struct vs_output
{
    float4 position;
    float4 world_pos;
    float3 normal;
    float3 tangent;
    float3 bitangent;
    float4 texcoord;
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform skinning_info
{
    float4x4 bones[85];
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
layout (std140) uniform per_draw_call
{
    float4x4 world_matrix;
    float4 user_data;
    float4 user_data2;
    float4x4 world_matrix_inv_transpose;
};
layout (std140) uniform material_data
{
    float4 m_albedo;
    float2 m_uv_scale;
    float m_roughness;
    float m_reflectivity;
};
float4 skin_pos(float4 pos, float4 weights, float4 indices)
{
    int bone_indices[4];
    bone_indices[0] = int(indices.x);
    bone_indices[1] = int(indices.y);
    bone_indices[2] = int(indices.z);
    bone_indices[3] = int(indices.w);
    float4 sp = float4( 0.0, 0.0, 0.0, 0.0 );
    float final_weight = 1.0;
    for(int i = 3; i >= 0; --i)
    {
        sp += mul( pos, bones[bone_indices[i]] ) * weights[i];
        final_weight -= weights[i];
    }
    sp += mul( pos, bones[bone_indices[0]] ) * final_weight;
    sp.w = 1.0;
    return sp;
}
void skin_tbn(inout float3 t, inout float3 b, inout float3 n, float4 weights, float4 indices)
{
    int bone_indices[4];
    bone_indices[0] = int(indices.x);
    bone_indices[1] = int(indices.y);
    bone_indices[2] = int(indices.z);
    bone_indices[3] = int(indices.w);
    float3 rt = float3( 0.0, 0.0, 0.0);
    float3 rb = float3( 0.0, 0.0, 0.0);
    float3 rn = float3( 0.0, 0.0, 0.0);
    float final_weight = 1.0;
    for( int i = 0; i < 3; ++i)
    {
        float3x3 rot_mat = to_3x3(bones[bone_indices[i]]);
        rt += mul(t, rot_mat) * weights[i];
        rb += mul(b, rot_mat) * weights[i];
        rn += mul(n, rot_mat) * weights[i];
        final_weight -= weights[i];
    }
    float3x3 rot_mat = to_3x3(bones[bone_indices[3]]);
    rt += mul(t, rot_mat) * final_weight;
    rb += mul(b, rot_mat) * final_weight;
    rn += mul(n, rot_mat) * final_weight;
    t = rt;
    b = rb;
    n = rn;
}
void main()
{
    //assign vs_input_multi struct from glsl inputs
    vs_input_multi _input;
    _input.position = position_vs_input;
    _input.normal = normal_vs_input;
    _input.texcoord = texcoord_vs_input;
    _input.tangent = tangent_vs_input;
    _input.bitangent = bitangent_vs_input;
    _input.blend_indices = blend_indices_vs_input;
    _input.blend_weights = blend_weights_vs_input;
    vs_output _output;
    float4x4 wvp = mul( world_matrix, vp_matrix );
    float4x4 wm = world_matrix;
    _output.texcoord = float4(_input.texcoord.x, 1.0 - _input.texcoord.y,
    _input.texcoord.z, 1.0 - _input.texcoord.w );
    _output.colour = m_albedo;
    float4 sp = skin_pos(_input.position, _input.blend_weights, _input.blend_indices);
    _output.tangent = _input.tangent.xyz;
    _output.bitangent = _input.bitangent.xyz;
    _output.normal = _input.normal.xyz;
    skin_tbn(_output.tangent, _output.bitangent, _output.normal, _input.blend_weights, _input.blend_indices);
    _output.position = mul( sp, vp_matrix );
    _output.world_pos = sp;
    float3 scale = float3(length(world_matrix[0].xyz),
    length(world_matrix[1].xyz),
    length(world_matrix[2].xyz));
    float xs = length(_input.tangent.xyz * scale);
    float ys = length(_input.bitangent.xyz * scale);
    _output.texcoord *= float4(m_uv_scale.x * xs, m_uv_scale.y * ys, m_uv_scale.x, m_uv_scale.y);
    //assign glsl global outputs from structs
    gl_Position = _output.position;
    gl_Position.y *= v_flip;
    world_pos_vs_output = _output.world_pos;
    normal_vs_output = _output.normal;
    tangent_vs_output = _output.tangent;
    bitangent_vs_output = _output.bitangent;
    texcoord_vs_output = _output.texcoord;
    colour_vs_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//forward_render omni_shadow vs 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
layout(location = 0) in float4 position_vs_input;
out float4 world_pos_vs_output;
uniform float v_flip;
struct vs_input_position_only
{
    float4 position;
};
struct vs_output_zonly_wp
{
    float4 position;
    float4 world_pos;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
layout (std140) uniform per_draw_call
{
    float4x4 world_matrix;
    float4 user_data;
    float4 user_data2;
    float4x4 world_matrix_inv_transpose;
};
void main()
{
    //assign vs_input_position_only struct from glsl inputs
    vs_input_position_only _input;
    _input.position = position_vs_input;
    vs_output_zonly_wp _output;
    float4x4 wvp = mul( world_matrix, vp_matrix );
    float4x4 wm = world_matrix;
    _output.position = mul( _input.position, wvp );
    _output.world_pos = mul( _input.position, wm );
    //assign glsl global outputs from structs
    gl_Position = _output.position;
    gl_Position.y *= v_flip;
    world_pos_vs_output = _output.world_pos;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//forward_render gi ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 world_pos_vs_output;
in float3 normal_vs_output;
in float3 tangent_vs_output;
in float3 bitangent_vs_output;
in float4 texcoord_vs_output;
in float4 colour_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 world_pos;
    float3 normal;
    float3 tangent;
    float3 bitangent;
    float4 texcoord;
    float4 colour;
};
struct ps_output
{
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform cbuffer_single_light
{
    light_data single_light;
};
layout (std140) uniform material_data
{
    float4 m_albedo;
    float m_roughness;
    float m_reflectivity;
    float2 m_padding;
};
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.world_pos = world_pos_vs_output;
    _input.normal = normal_vs_output;
    _input.tangent = tangent_vs_output;
    _input.bitangent = bitangent_vs_output;
    _input.texcoord = texcoord_vs_output;
    _input.colour = colour_vs_output;
    ps_output _output;
    float3 l = normalize(single_light.pos_radius.xyz - _input.world_pos.xyz);
    float3 lc = single_light.colour.rgb;
    _output.colour.rgb = (m_albedo.rgb * dot(_input.normal, l) * lc);
    _output.colour.rgb += m_albedo.rgb * 0.3;
    _output.colour.a = 1.0;
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//forward_render forward_lit__1073741850__ ps 1073741850
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 world_pos_vs_output;
in float3 normal_vs_output;
in float3 tangent_vs_output;
in float3 bitangent_vs_output;
in float4 texcoord_vs_output;
in float4 colour_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 world_pos;
    float3 normal;
    float3 tangent;
    float3 bitangent;
    float4 texcoord;
    float4 colour;
};
struct ps_output
{
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
layout (std140) uniform per_draw_call
{
    float4x4 world_matrix;
    float4 user_data;
    float4 user_data2;
    float4x4 world_matrix_inv_transpose;
};
layout (std140) uniform per_pass_lights
{
    float4 light_info;
    light_data lights[100];
};
layout (std140) uniform per_pass_shadow
{
    float4x4 shadow_matrix[100];
};
layout (std140) uniform per_pass_shadow_distance_fields
{
    distance_field_shadow sdf_shadow;
};
layout (std140) uniform per_pass_area_lights
{
    float4 area_light_info;
    area_light_data area_lights[10];
};
layout (std140) uniform cbuffer_gi_volume
{
    float4 gi_scene_size;
    float4 gi_volume_size;
};
layout (std140) uniform material_data
{
    float4 m_albedo;
    float2 m_uv_scale;
    float m_roughness;
    float m_reflectivity;
    float m_surface_offset;
    float3 m_padding;
};
texture_2d( diffuse_texture, 0 );
texture_2d( normal_texture, 1 );
texture_2d( specular_texture, 2 );
texture_2d( blue_noise, 5 );
texture_3d( sdf_volume, 14 );
texture_2d( ltc_mat, 13 );
texture_2d( ltc_mag, 12 );
texture_2d_array( area_light_textures, 11 );
texture_3d( volume_gi, 9 );
depth_2d_array( shadowmap_texture, 15 );
float3 cook_torrence(
float4 light_pos_radius,
float3 light_colour,
float3 n,
float3 world_pos,
float3 view_pos,
float3 albedo,
float3 metalness,
float roughness,
float reflectivity
)
{
    float3 l = normalize( light_pos_radius.xyz - world_pos.xyz );
    float n_dot_l = dot( n, l );
    if( n_dot_l > 0.0f )
    {
        float roughness_sq = roughness * roughness;
        float k = reflectivity;
        float3 v_view = normalize( (view_pos.xyz - world_pos.xyz) );
        float3 hv = normalize( v_view + l );
        float n_dot_v = dot( n, v_view );
        float n_dot_h = dot( n, hv );
        float v_dot_h = dot( v_view, hv );
        float n_dot_h_2 = 2.0f * n_dot_h;
        float g1 = (n_dot_h_2 * n_dot_v) / v_dot_h;
        float g2 = (n_dot_h_2 * n_dot_l) / v_dot_h;
        float geom_atten = min(1.0, min(g1, g2));
        float r1 = 1.0f / ( 4.0f * roughness_sq * pow(n_dot_h, 4.0f));
        float r2 = (n_dot_h * n_dot_h - 1.0) / (roughness_sq * n_dot_h * n_dot_h);
        float roughness_atten = r1 * exp(r2);
        float fresnel = pow(1.0 - v_dot_h, 5.0);
        fresnel *= roughness;
        fresnel += reflectivity;
        float specular = (fresnel * geom_atten * roughness_atten) / (n_dot_v * n_dot_l * 3.1419);
        float3 lit_colour = metalness * light_colour * n_dot_l * ( k + specular * ( 1.0 - k ) );
        return saturate(lit_colour);
    }
    return float3( 0.0, 0.0, 0.0 );
}
float3 oren_nayar(
float4 light_pos_radius,
float3 light_colour,
float3 n,
float3 world_pos,
float3 view_pos,
float roughness,
float3 albedo)
{
    float3 v = normalize(view_pos-world_pos);
    float3 l = normalize(light_pos_radius.xyz-world_pos);
    float l_dot_v = dot(l, v);
    float n_dot_l = dot(n, l);
    float n_dot_v = dot(n, v);
    float s = l_dot_v - n_dot_l * n_dot_v;
    float t = lerp(1.0, max(n_dot_l, n_dot_v), step(0.0, s));
    float lum = length( albedo );
    float sigma2 = roughness * roughness;
    float A = 1.0 + sigma2 * (lum / (sigma2 + 0.13) + 0.5 / (sigma2 + 0.33));
    float B = 0.45 * sigma2 / (sigma2 + 0.09);
    return ( albedo * light_colour * max(0.0, n_dot_l) * (A + B * s / t) / 3.14159265 );
}
float spot_light_attenuation(
float4 light_pos_radius,
float4 light_dir_cutoff,
float falloff,
float3 world_pos)
{
    float co = light_dir_cutoff.w;
    float3 vl = normalize(world_pos.xyz - light_pos_radius.xyz);
    float3 sd = normalize(light_dir_cutoff.xyz);
    float dp = (1.0 - dot(vl, sd));
    return smoothstep(co, co - falloff, dp);
}
float point_light_attenuation_cutoff(
float4 light_pos_radius,
float3 world_pos)
{
    float r = light_pos_radius.w;
    float d = length(world_pos.xyz - light_pos_radius.xyz);
    d = max(d - r, 0.0);
    float denom = d/r + 1.0;
    float attenuation = 1.0 / (denom*denom);
    float cutoff = 0.2;
    attenuation = (attenuation - cutoff) / (1.0 - cutoff);
    attenuation = max(attenuation, 0.0);
    return attenuation;
}
float sample_shadow_array_pcf_9(float array_slice, float3 sp)
{
    float2 samples[9];
    float2 inv_sm_size = float2(1.0/2048.0, 1.0/2048.0);
    samples[0] = float2(-1.0, -1.0) * inv_sm_size;
    samples[1] = float2(-1.0, 0.0) * inv_sm_size;
    samples[2] = float2(-1.0, 1.0) * inv_sm_size;
    samples[3] = float2(0.0, -1.0) * inv_sm_size;
    samples[4] = float2(0.0, 0.0) * inv_sm_size;
    samples[5] = float2(0.0, 1.0) * inv_sm_size;
    samples[6] = float2(1.0, -1.0) * inv_sm_size;
    samples[7] = float2(1.0, 0.0) * inv_sm_size;
    samples[8] = float2(1.0, 1.0) * inv_sm_size;
    float shadow = 0.0;
    for(int j = 0; j < 9; ++j)
    {
        shadow += sample_depth_compare_array(shadowmap_texture, sp.xy + samples[j], array_slice, sp.z);
    }
    shadow /= 9.0;
    return shadow;
}
bool ray_vs_aabb(float3 emin, float3 emax, float3 r1, float3 rv, out float3 intersection)
{
    float3 dirfrac = float3(1.0, 1.0, 1.0) / rv;
    float t1 = (emin.x - r1.x)*dirfrac.x;
    float t2 = (emax.x - r1.x)*dirfrac.x;
    float t3 = (emin.y - r1.y)*dirfrac.y;
    float t4 = (emax.y - r1.y)*dirfrac.y;
    float t5 = (emin.z - r1.z)*dirfrac.z;
    float t6 = (emax.z - r1.z)*dirfrac.z;
    float tmin = max(max(min(t1, t2), min(t3, t4)), min(t5, t6));
    float tmax = min(min(max(t1, t2), max(t3, t4)), max(t5, t6));
    float t = 0.0;
    if (tmax < 0.0)
    {
        t = tmax;
        return false;
    }
    if (tmin > tmax)
    {
        t = tmax;
        return false;
    }
    t = tmin;
    intersection = r1 + rv * t;
    return true;
}
float sdf_shadow_trace(float max_samples, float3 light_pos, float3 world_pos, float3 scale, float3 ray_origin, float4x4 inv_mat, float3x3 inv_rot)
{
    float3 ray_dir = normalize(light_pos - world_pos);
    ray_dir = normalize( mul( ray_dir, inv_rot ) );
    float closest = 1.0;
    float3 uvw = ray_origin;
    if(abs(uvw.x) >= 1.0 || abs(uvw.y) >= 1.0 || abs(uvw.z) >= 1.0)
    {
        float3 emin = float3(-1.0, -1.0, -1.0);
        float3 emax = float3(1.0, 1.0, 1.0);
        float3 ip = float3(0.0, 0.0, 0.0);
        bool hit = ray_vs_aabb( emin, emax, uvw, ray_dir, ip);
        uvw = ip;
        if(!hit)
        {
            return closest;
        }
    }
    float3 light_uvw = mul( float4(light_pos, 1.0), inv_mat ).xyz * 0.5 + 0.5;
    uvw = uvw * 0.5 + 0.5;
    float3 v1 = normalize(light_uvw - uvw);
    for( int s = 0; s < int(max_samples); ++s )
    {
        float d = sample_texture_level( sdf_volume, uvw, 0.0 ).r;
        closest = min(d, closest);
        ray_dir = normalize(light_uvw - uvw);
        float3 step = ray_dir.xyz * float3(d, d, d) / scale * 0.7;
        uvw += step;
        if( d <= 0.0 )
        {
            closest = max( d, 0.0 );
            break;
        }
        if(uvw.x >= 1.0 || uvw.x < 0.0)
        break;
        if(uvw.y >= 1.0 || uvw.y < 0.0)
        break;
        if(uvw.z >= 1.0 || uvw.z < 0.0)
        break;
    }
    return closest;
}
float integrate_edge(float3 v1, float3 v2)
{
    float cos_theta = dot(v1, v2);
    float theta = acos(cos_theta);
    float res = cross(v1, v2).z * ((theta > 0.001) ? theta/sin(theta) : 1.0);
    return res;
}
void clip_quad_to_horizon(inout float3 L[5], out int n)
{
    int config = 0;
    if (L[0].z > 0.0) config += 1;
    if (L[1].z > 0.0) config += 2;
    if (L[2].z > 0.0) config += 4;
    if (L[3].z > 0.0) config += 8;
    n = 0;
    if (config == 0)
    {
    }
    else if (config == 1)
    {
        n = 3;
        L[1] = -L[1].z * L[0] + L[0].z * L[1];
        L[2] = -L[3].z * L[0] + L[0].z * L[3];
    }
    else if (config == 2)
    {
        n = 3;
        L[0] = -L[0].z * L[1] + L[1].z * L[0];
        L[2] = -L[2].z * L[1] + L[1].z * L[2];
    }
    else if (config == 3)
    {
        n = 4;
        L[2] = -L[2].z * L[1] + L[1].z * L[2];
        L[3] = -L[3].z * L[0] + L[0].z * L[3];
    }
    else if (config == 4)
    {
        n = 3;
        L[0] = -L[3].z * L[2] + L[2].z * L[3];
        L[1] = -L[1].z * L[2] + L[2].z * L[1];
    }
    else if (config == 5)
    {
        n = 0;
    }
    else if (config == 6)
    {
        n = 4;
        L[0] = -L[0].z * L[1] + L[1].z * L[0];
        L[3] = -L[3].z * L[2] + L[2].z * L[3];
    }
    else if (config == 7)
    {
        n = 5;
        L[4] = -L[3].z * L[0] + L[0].z * L[3];
        L[3] = -L[3].z * L[2] + L[2].z * L[3];
    }
    else if (config == 8)
    {
        n = 3;
        L[0] = -L[0].z * L[3] + L[3].z * L[0];
        L[1] = -L[2].z * L[3] + L[3].z * L[2];
        L[2] = L[3];
    }
    else if (config == 9)
    {
        n = 4;
        L[1] = -L[1].z * L[0] + L[0].z * L[1];
        L[2] = -L[2].z * L[3] + L[3].z * L[2];
    }
    else if (config == 10)
    {
        n = 0;
    }
    else if (config == 11)
    {
        n = 5;
        L[4] = L[3];
        L[3] = -L[2].z * L[3] + L[3].z * L[2];
        L[2] = -L[2].z * L[1] + L[1].z * L[2];
    }
    else if (config == 12)
    {
        n = 4;
        L[1] = -L[1].z * L[2] + L[2].z * L[1];
        L[0] = -L[0].z * L[3] + L[3].z * L[0];
    }
    else if (config == 13)
    {
        n = 5;
        L[4] = L[3];
        L[3] = L[2];
        L[2] = -L[1].z * L[2] + L[2].z * L[1];
        L[1] = -L[1].z * L[0] + L[0].z * L[1];
    }
    else if (config == 14)
    {
        n = 5;
        L[4] = -L[0].z * L[3] + L[3].z * L[0];
        L[0] = -L[0].z * L[1] + L[1].z * L[0];
    }
    else if (config == 15)
    {
        n = 4;
    }
    if (n == 3)
    L[3] = L[0];
    if (n == 4)
    L[4] = L[0];
}
float3 ltc_uv_coord(float3 p[4])
{
    float3 v1 = p[1] - p[0];
    float3 v2 = p[3] - p[0];
    float3 plane_ortho = (cross(v1, v2));
    float plane_area_squared = dot(plane_ortho, plane_ortho);
    float plane_distx_plane_area = dot(plane_ortho, p[0]);
    float3 pp = plane_distx_plane_area * plane_ortho / plane_area_squared - p[0];
    float v1_dot_v2 = dot(v1, v2);
    float inv_v1_dot_v1 = 1.0 / dot(v1, v1);
    float3 vv2 = v2 - v1 * v1_dot_v2 * inv_v1_dot_v1;
    float2 puv;
    puv.y = dot(vv2, pp) / dot(vv2, vv2);
    puv.x = dot(v1, pp) * inv_v1_dot_v1 - v1_dot_v2 * inv_v1_dot_v1 * puv.y;
    float d = abs(plane_distx_plane_area) / pow(plane_area_squared, 0.75);
    return float3(puv, d);
}
float4 ltc_evaluate(
float3 n,
float3 v,
float3 p,
float3x3 minv,
float3 points[4],
bool two_sided)
{
    float3 t1, t2;
    t1 = normalize(v - n * dot(v, n));
    t2 = cross(n, t1);
    float3x3 ttn = from_columns_3x3(t1, t2, n);
    minv = mul(minv, ttn);
    float3 l[5];
    l[0] = mul(minv, points[0] - p);
    l[1] = mul(minv, points[1] - p);
    l[2] = mul(minv, points[2] - p);
    l[3] = mul(minv, points[3] - p);
    l[4] = l[3];
    float3 ll[4];
    ll[0] = l[0];
    ll[1] = l[1];
    ll[2] = l[2];
    ll[3] = l[3];
    float3 uvl = ltc_uv_coord(ll);
    int nc;
    clip_quad_to_horizon(l, nc);
    if (nc == 0)
    return float4(0, 0, 0, 0.0);
    l[0] = normalize(l[0]);
    l[1] = normalize(l[1]);
    l[2] = normalize(l[2]);
    l[3] = normalize(l[3]);
    l[4] = normalize(l[4]);
    float sum = 0.0;
    sum += integrate_edge(l[0], l[1]);
    sum += integrate_edge(l[1], l[2]);
    sum += integrate_edge(l[2], l[3]);
    if (nc >= 4)
    sum += integrate_edge(l[3], l[4]);
    if (nc == 5)
    sum += integrate_edge(l[4], l[0]);
    sum = two_sided ? abs(sum) : max(0.0, sum);
    float3 lo_i = float3(sum, sum, sum);
    return float4(uvl.x, uvl.y, uvl.z, sum);
}
float ltc_evaluate_cc(
float3 n,
float3 v,
float3 p,
float3x3 minv,
float3 points[4],
bool two_sided)
{
    float3 t1, t2;
    t1 = normalize(v - n * dot(v, n));
    t2 = cross(n, t1);
    float3x3 ttn = from_columns_3x3(t1, t2, n);
    minv = mul(minv, ttn);
    float3 l[5];
    for(int i = 0; i < 4; ++i)
    l[i] = mul(minv, points[i] - p);
    l[4] = l[3];
    int nc;
    clip_quad_to_horizon(l, nc);
    if (nc == 0)
    return 0.0;
    for(int i = 0; i < 5; ++i)
    l[i] = normalize(l[i]);
    float sum = 0.0;
    sum += integrate_edge(l[0], l[1]);
    sum += integrate_edge(l[1], l[2]);
    sum += integrate_edge(l[2], l[3]);
    if (nc >= 4)
    sum += integrate_edge(l[3], l[4]);
    if (nc == 5)
    sum += integrate_edge(l[4], l[0]);
    sum = two_sided ? abs(sum) : max(0.0, sum);
    return sum;
}
float4 area_light_specular_uv(
float3 points[4],
float3 pos,
float roughness,
float3 n,
float3 v)
{
    float pi = 3.14159265359;
    float lut_size = 64.0;
    float lut_scale = (lut_size - 1.0)/lut_size;
    float lut_bias = 0.5/lut_size;
    float theta = acos(dot(n, v));
    float2 uv = float2(roughness, theta / (0.5 * pi));
    uv = uv * lut_scale + lut_bias;
    float4 mat = sample_texture(ltc_mat, uv);
    float mag = sample_texture(ltc_mag, uv).w;
    float3x3 minv = from_rows_3x3(
    float3(1.0, 0.0, mat.y),
    float3(0.0, mat.z, 0.0),
    float3(mat.w, 0.0, mat.x)
    );
    float4 spec = ltc_evaluate(n, v, pos, minv, points, true);
    return spec;
}
float area_light_specular(
float3 points[4],
float3 pos,
float roughness,
float3 n,
float3 v)
{
    float pi = 3.14159265359;
    float lut_size = 64.0;
    float lut_scale = (lut_size - 1.0)/lut_size;
    float lut_bias = 0.5/lut_size;
    float theta = acos(dot(n, v));
    float2 uv = float2(roughness, theta / (0.5 * pi));
    uv = uv * lut_scale + lut_bias;
    float4 mat = sample_texture(ltc_mat, uv);
    float mag = sample_texture(ltc_mag, uv).w;
    float3x3 minv = from_rows_3x3(
    float3(1.0, 0.0, mat.y),
    float3(0.0, mat.z, 0.0),
    float3(mat.w, 0.0, mat.x)
    );
    float spec = ltc_evaluate_cc(n, v, pos, minv, points, true);
    return spec;
}
float4 area_light_diffuse_uv(
float3 points[4],
float3 pos,
float3 n,
float3 v)
{
    float3x3 difv = float3x3(
    float3(1.0, 0.0, 0.0),
    float3(0.0, 1.0, 0.0),
    float3(0.0, 0.0, 1.0)
    );
    float4 diff = ltc_evaluate(n, v, pos, difv, points, true);
    return diff;
}
float area_light_diffuse(
float3 points[4],
float3 pos,
float3 n,
float3 v)
{
    float3x3 difv = float3x3(
    float3(1.0, 0.0, 0.0),
    float3(0.0, 1.0, 0.0),
    float3(0.0, 0.0, 1.0)
    );
    float diff = ltc_evaluate_cc(n, v, pos, difv, points, true);
    return diff;
}
float3 transform_ts_normal( float3 t, float3 b, float3 n, float3 ts_normal )
{
    float3x3 tbn;
    tbn[0] = float3(t.x, b.x, n.x);
    tbn[1] = float3(t.y, b.y, n.y);
    tbn[2] = float3(t.z, b.z, n.z);
    return normalize( mul_tbn( tbn, ts_normal ) );
}
float3 hash_33( float3 p )
{
    p = float3(dot(p,float3(127.1,311.7, 74.7)),
    dot(p,float3(269.5,183.3,246.1)),
    dot(p,float3(113.5,271.9,124.6)));
    return fract(sin(p)*43758.5453123) * 2.0 - 1.0;
}
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.world_pos = world_pos_vs_output;
    _input.normal = normal_vs_output;
    _input.tangent = tangent_vs_output;
    _input.bitangent = bitangent_vs_output;
    _input.texcoord = texcoord_vs_output;
    _input.colour = colour_vs_output;
    ps_output _output;
    float4 albedo = sample_texture( diffuse_texture, _input.texcoord.xy );
    float3 normal_sample = sample_texture( normal_texture, _input.texcoord.xy ).rgb;
    float4 ro_sample = sample_texture( specular_texture, _input.texcoord.xy );
    float4 specular_sample = float4(1.0, 1.0, 1.0, 1.0);
    normal_sample = normal_sample * 2.0 - 1.0;
    float3 n = transform_ts_normal(
    _input.tangent,
    _input.bitangent,
    _input.normal,
    normal_sample );
    albedo *= _input.colour;
    float4 metalness = float4(1.0, 1.0, 1.0, 1.0);
    float3 lit_colour = float3( 0.0, 0.0, 0.0 );
    float reflectivity = saturate(user_data.z);
    float roughness = saturate(user_data.y);
    reflectivity = m_reflectivity;
    roughness = ro_sample.r;
    roughness = _input.colour.a;
    albedo.a = 1.0;
    n = _input.normal.rgb;
    roughness = m_roughness;
    float max_samples = 128.0;
    float3x3 inv_rot = to_3x3(sdf_shadow.world_matrix_inv);
    float3 r1 = _input.world_pos.xyz + _input.normal.xyz * m_surface_offset;
    float3 tr1 = mul( float4(r1, 1.0), sdf_shadow.world_matrix_inv ).xyz;
    float3 scale = float3(length(sdf_shadow.world_matrix[0].xyz), length(sdf_shadow.world_matrix[1].xyz), length(sdf_shadow.world_matrix[2].xyz)) * 2.0;
    float3 vddx = ddx( r1 );
    float3 vddy = ddy( r1 );
    float t = 1.0;
    float3 lll = float3(0.0, 0.0, 0.0);
    int shadow_map_index = 0;
    _pmfx_loop
    for( int i = 0; i < int(light_info.x); ++i )
    {
        float3 light_col = float3( 0.0, 0.0, 0.0 );
        light_col += cook_torrence(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        albedo.rgb,
        metalness.rgb,
        roughness,
        reflectivity
        );
        light_col += oren_nayar(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        1.0 - roughness,
        albedo.rgb
        );
        float s = sdf_shadow_trace(max_samples, lights[i].pos_radius.xyz, _input.world_pos.xyz, scale, tr1, sdf_shadow.world_matrix_inv, inv_rot);
        light_col *= smoothstep( 0.0, 0.1, s);
        if( lights[i].colour.a == 0.0 )
        {
            lit_colour += light_col;
            continue;
        }
        else
        {
            float shadow = 1.0;
            float d = 1.0;
            float4 offset_pos = float4(_input.world_pos.xyz + n.xyz * 0.01, 1.0);
            float4 sp = mul( offset_pos, shadow_matrix[i] );
            sp.xyz /= sp.w;
            sp.y *= -1.0;
            sp.xy = sp.xy * 0.5 + 0.5;
            sp.z = remap_depth(sp.z);
            shadow = sample_shadow_array_pcf_9(float(shadow_map_index), sp.xyz);
            lit_colour += light_col * shadow;
            ++shadow_map_index;
        }
    }
    int point_start = int(light_info.x);
    int point_end = int(light_info.x) + int(light_info.y);
    int omni_shadow_index = 0;
    _pmfx_loop
    for( int i = point_start; i < point_end; ++i )
    {
        float3 light_col = float3( 0.0, 0.0, 0.0 );
        light_col += cook_torrence(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        albedo.rgb,
        metalness.rgb,
        roughness,
        reflectivity
        );
        light_col += oren_nayar(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        roughness,
        albedo.rgb
        );
        float a = point_light_attenuation_cutoff( lights[i].pos_radius, _input.world_pos.xyz );
        light_col *= a;
        float s = sdf_shadow_trace(max_samples, lights[i].pos_radius.xyz, _input.world_pos.xyz, scale, tr1, sdf_shadow.world_matrix_inv, inv_rot);
        light_col *= smoothstep( 0.0, 0.1, s);
        if( lights[i].colour.a == 0.0)
        {
            lit_colour += light_col;
            continue;
        }
        else
        {
            lit_colour += light_col;
            continue;
        }
    }
    int spot_start = point_end;
    int spot_end = spot_start + int(light_info.z);
    _pmfx_loop
    for(int i = spot_start; i < spot_end; ++i )
    {
        float3 light_col = float3( 0.0, 0.0, 0.0 );
        light_col += cook_torrence(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        albedo.rgb,
        metalness.rgb,
        roughness,
        reflectivity
        );
        light_col += oren_nayar(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        roughness,
        albedo.rgb
        );
        float a = spot_light_attenuation(lights[i].pos_radius,
        lights[i].dir_cutoff,
        lights[i].data.x,
        _input.world_pos.xyz );
        light_col *= a;
        float s = sdf_shadow_trace(max_samples, lights[i].pos_radius.xyz, _input.world_pos.xyz, scale, tr1, sdf_shadow.world_matrix_inv, inv_rot);
        light_col *= smoothstep( 0.0, 0.1, s);
        if( lights[i].colour.a == 0.0 )
        {
            lit_colour += light_col;
            continue;
        }
        else
        {
            float shadow = 1.0;
            float d = 1.0;
            float4 offset_pos = float4(_input.world_pos.xyz + n.xyz * 0.01, 1.0);
            float4 sp = mul( offset_pos, shadow_matrix[shadow_map_index] );
            sp.xyz /= sp.w;
            sp.y *= -1.0;
            sp.xy = sp.xy * 0.5 + 0.5;
            sp.z = remap_depth(sp.z);
            shadow = sample_shadow_array_pcf_9(float(shadow_map_index), sp.xyz);
            lit_colour += light_col * shadow;
            ++shadow_map_index;
        }
    }
    {
        float pi = 3.14159265359;
        int num_area_lights = int(area_light_info.x);
        for(int i = 0; i < num_area_lights; ++i)
        {
            float3 v = -normalize(_input.world_pos.xyz - camera_view_pos.xyz);
            float3 pos = _input.world_pos.xyz;
            float3 points[4];
            for(int j = 0; j < 4; ++j)
            points[j] = area_lights[i].corners[j].xyz;
            float diff_sum = area_light_diffuse(points, pos, n, v);
            float3 diff = area_lights[i].colour.rgb * diff_sum;
            float spec_sum = area_light_specular(points, pos, ro_sample.x, n, v);
            float3 spec = area_lights[i].colour.rgb * spec_sum;
            float3 light_col = (spec.rgb + diff.rgb) / (2.0 * pi);
            lit_colour += light_col;
        }
        int ts = num_area_lights;
        int num_area_lights_textured = int(area_light_info.y);
        for(int i = ts; i < ts + num_area_lights_textured; ++i)
        {
            float slice = area_lights[i].colour.w;
            float levels = 8.0;
            float2 inv_texel = float2(1.0/640.0, 1.0/480.0);
            float2 inv_texel_x = float2(1.0, 1.0) - inv_texel;
            float3 points[4];
            for(int j = 0; j < 4; ++j)
            points[j] = area_lights[i].corners[j].xyz;
            float3 v = -normalize(_input.world_pos.xyz - camera_view_pos.xyz);
            float3 pos = _input.world_pos.xyz;
            float4 diff_uv = area_light_diffuse_uv(points, pos, n, v);
            float2 duv = clamp(diff_uv.xy, inv_texel, inv_texel_x);
            float3 diff = sample_texture_array_level( area_light_textures, duv, slice, diff_uv.z * levels).rgb * diff_uv.w;
            float4 spec_uv = area_light_specular_uv(points, pos, ro_sample.x, n, v);
            float2 suv = clamp(spec_uv.xy, inv_texel, inv_texel_x);
            float3 spec = sample_texture_array_level(area_light_textures, suv, slice, spec_uv.z * levels).rgb * spec_uv.w;
            float3 light_col = (spec.rgb + diff.rgb) / (2.0 * pi);
            lit_colour += light_col;
        }
    }
    _output.colour.rgb = lit_colour.rgb * albedo.a;
    _output.colour.a = albedo.a;
    float3 gn = _input.normal.xyz;
    float3 gt = _input.tangent.xyz;
    float3 gb = _input.bitangent.xyz;
    float3 dim = gi_scene_size.xyz;
    float3 to_uvx = dim * 0.5;
    int num_rays = 16;
    float3 rays[16];
    rays[0] = float3(0.57735, 0.57735, 0.57735);
    rays[1] = float3(0.57735, -0.57735, -0.57735);
    rays[2] = float3(-0.57735, 0.57735, -0.57735);
    rays[3] = float3(-0.57735, -0.57735, 0.57735);
    rays[4] = float3(-0.903007, -0.182696, -0.388844);
    rays[5] = float3(-0.903007, 0.182696, 0.388844);
    rays[6] = float3(0.903007, -0.182696, 0.388844);
    rays[7] = float3(0.903007, 0.182696, -0.388844);
    rays[8] = float3(-0.388844, -0.903007, -0.182696);
    rays[9] = float3(0.388844, -0.903007, 0.182696);
    rays[10] = float3(0.388844, 0.903007, -0.182696);
    rays[11] = float3(-0.388844, 0.903007, 0.182696);
    rays[12] = float3(-0.182696, -0.388844, -0.903007);
    rays[13] = float3(0.182696, 0.388844, -0.903007);
    rays[14] = float3(-0.182696, 0.388844, 0.903007);
    rays[15] = float3(0.182696, -0.388844, 0.903007);
    float4 gi = float4(0.0, 0.0, 0.0, 0.0);
    float4 sp = mul(_input.world_pos, vp_matrix);
    sp /= sp.w;
    sp.x *= (1280.0/512.0);
    sp.y *= (720.0/512.0);
    for(int i = 0; i < num_rays; ++i)
    {
        float3 noise = (hash_33(_input.world_pos.xyz + user_data.yyy));
        float3 noise2 = (sample_texture_level(blue_noise, sp.xy + noise.xy, 0.0).rgb * 2.0 - 1.0);
        float3 tex_size = gi_volume_size.xyz;
        float3 ray = chebyshev_normalize(noise2 + rays[i]);
        float3 cn = chebyshev_normalize(n);
        float3 step = (dim*2.0) / tex_size;
        float3 sp = _input.world_pos.xyz + (cn * step);
        ray *= dot(ray, gn) < 0.0 ? -1.0 : 1.0;
        float4 ray_gi = float4(0.0, 0.0, 0.0, 0.0);
        for(int j = 0; j < 4; ++j)
        {
            for(int k = 0; k < 2; ++k)
            {
                step = (dim*2.0) / tex_size;
                float3 uvw = saturate((sp / to_uvx) * 0.5 + 0.5);
                float4 g = sample_texture_level( volume_gi, uvw, float(j));
                float d = length(_input.world_pos.xyz - sp);
                d = smoothstep(0.0, 8.0, d);
                ray_gi.rgb = ray_gi.rgb + g.rgb * d;
                ray_gi.a += g.a;
                sp += ray * step.x;
            }
            tex_size /= 2.0;
            if(ray_gi.a >= 1.0 && j > 1)
            break;
        }
        gi += ray_gi;
    }
    gi /= float(num_rays);
    _output.colour.rgb = gi.rgb * 2.0 * m_albedo.rgb + lit_colour.rgb;
    if(albedo.a <= 0.0)
    discard;
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//forward_render simple_lighting__4__ vs 4
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
layout(location = 0) in float4 position_vs_input;
layout(location = 1) in float4 normal_vs_input;
layout(location = 2) in float4 texcoord_vs_input;
layout(location = 3) in float4 tangent_vs_input;
layout(location = 4) in float4 bitangent_vs_input;
out float4 world_pos_vs_output;
out float3 normal_vs_output;
out float3 tangent_vs_output;
out float3 bitangent_vs_output;
out float4 texcoord_vs_output;
out float4 colour_vs_output;
uniform float v_flip;
struct vs_input_multi
{
    float4 position;
    float4 normal;
    float4 texcoord;
    float4 tangent;
    float4 bitangent;
};
struct vs_output
{
    float4 position;
    float4 world_pos;
    float3 normal;
    float3 tangent;
    float3 bitangent;
    float4 texcoord;
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
layout (std140) uniform per_draw_call
{
    float4x4 world_matrix;
    float4 user_data;
    float4 user_data2;
    float4x4 world_matrix_inv_transpose;
};
layout (std140) uniform material_data
{
    float4 m_albedo;
    float m_roughness;
    float m_reflectivity;
    float m_sss_scale;
    float m_padding;
};
void main()
{
    //assign vs_input_multi struct from glsl inputs
    vs_input_multi _input;
    _input.position = position_vs_input;
    _input.normal = normal_vs_input;
    _input.texcoord = texcoord_vs_input;
    _input.tangent = tangent_vs_input;
    _input.bitangent = bitangent_vs_input;
    vs_output _output;
    float4x4 wvp = mul( world_matrix, vp_matrix );
    float4x4 wm = world_matrix;
    _output.texcoord = float4(_input.texcoord.x, 1.0 - _input.texcoord.y,
    _input.texcoord.z, 1.0 - _input.texcoord.w );
    _output.colour = m_albedo;
    _output.position = mul( _input.position, wvp );
    _output.world_pos = mul( _input.position, wm );
    float3x3 wrm = to_3x3(wm);
    wrm[0] = normalize(wrm[0]);
    wrm[1] = normalize(wrm[1]);
    wrm[2] = normalize(wrm[2]);
    _output.normal = mul( _input.normal.xyz, wrm );
    _output.tangent = mul( _input.tangent.xyz, wrm );
    _output.bitangent = mul( _input.bitangent.xyz, wrm );
    //assign glsl global outputs from structs
    gl_Position = _output.position;
    gl_Position.y *= v_flip;
    world_pos_vs_output = _output.world_pos;
    normal_vs_output = _output.normal;
    tangent_vs_output = _output.tangent;
    bitangent_vs_output = _output.bitangent;
    texcoord_vs_output = _output.texcoord;
    colour_vs_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//forward_render forward_lit__8__ vs 8
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
layout(location = 0) in float4 position_vs_input;
layout(location = 1) in float4 normal_vs_input;
layout(location = 2) in float4 texcoord_vs_input;
layout(location = 3) in float4 tangent_vs_input;
layout(location = 4) in float4 bitangent_vs_input;
out float4 world_pos_vs_output;
out float3 normal_vs_output;
out float3 tangent_vs_output;
out float3 bitangent_vs_output;
out float4 texcoord_vs_output;
out float4 colour_vs_output;
uniform float v_flip;
struct vs_input_multi
{
    float4 position;
    float4 normal;
    float4 texcoord;
    float4 tangent;
    float4 bitangent;
};
struct vs_output
{
    float4 position;
    float4 world_pos;
    float3 normal;
    float3 tangent;
    float3 bitangent;
    float4 texcoord;
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
layout (std140) uniform per_draw_call
{
    float4x4 world_matrix;
    float4 user_data;
    float4 user_data2;
    float4x4 world_matrix_inv_transpose;
};
layout (std140) uniform material_data
{
    float4 m_albedo;
    float m_roughness;
    float m_reflectivity;
    float m_surface_offset;
    float m_padding;
};
void main()
{
    //assign vs_input_multi struct from glsl inputs
    vs_input_multi _input;
    _input.position = position_vs_input;
    _input.normal = normal_vs_input;
    _input.texcoord = texcoord_vs_input;
    _input.tangent = tangent_vs_input;
    _input.bitangent = bitangent_vs_input;
    vs_output _output;
    float4x4 wvp = mul( world_matrix, vp_matrix );
    float4x4 wm = world_matrix;
    _output.texcoord = float4(_input.texcoord.x, 1.0 - _input.texcoord.y,
    _input.texcoord.z, 1.0 - _input.texcoord.w );
    _output.colour = m_albedo;
    _output.position = mul( _input.position, wvp );
    _output.world_pos = mul( _input.position, wm );
    float3x3 wrm = to_3x3(wm);
    wrm[0] = normalize(wrm[0]);
    wrm[1] = normalize(wrm[1]);
    wrm[2] = normalize(wrm[2]);
    _output.normal = mul( _input.normal.xyz, wrm );
    _output.tangent = mul( _input.tangent.xyz, wrm );
    _output.bitangent = mul( _input.bitangent.xyz, wrm );
    //assign glsl global outputs from structs
    gl_Position = _output.position;
    gl_Position.y *= v_flip;
    world_pos_vs_output = _output.world_pos;
    normal_vs_output = _output.normal;
    tangent_vs_output = _output.tangent;
    bitangent_vs_output = _output.bitangent;
    texcoord_vs_output = _output.texcoord;
    colour_vs_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//forward_render forward_lit__16__ ps 16
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 world_pos_vs_output;
in float3 normal_vs_output;
in float3 tangent_vs_output;
in float3 bitangent_vs_output;
in float4 texcoord_vs_output;
in float4 colour_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 world_pos;
    float3 normal;
    float3 tangent;
    float3 bitangent;
    float4 texcoord;
    float4 colour;
};
struct ps_output
{
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
layout (std140) uniform per_draw_call
{
    float4x4 world_matrix;
    float4 user_data;
    float4 user_data2;
    float4x4 world_matrix_inv_transpose;
};
layout (std140) uniform per_pass_lights
{
    float4 light_info;
    light_data lights[100];
};
layout (std140) uniform per_pass_shadow
{
    float4x4 shadow_matrix[100];
};
layout (std140) uniform per_pass_area_lights
{
    float4 area_light_info;
    area_light_data area_lights[10];
};
layout (std140) uniform cbuffer_gi_volume
{
    float4 gi_scene_size;
    float4 gi_volume_size;
};
layout (std140) uniform material_data
{
    float4 m_albedo;
    float m_roughness;
    float m_reflectivity;
    float2 m_padding;
};
texture_2d( diffuse_texture, 0 );
texture_2d( normal_texture, 1 );
texture_2d( specular_texture, 2 );
texture_2d( blue_noise, 5 );
texture_2d( ltc_mat, 13 );
texture_2d( ltc_mag, 12 );
texture_2d_array( area_light_textures, 11 );
texture_3d( volume_gi, 9 );
depth_2d_array( shadowmap_texture, 15 );
float3 cook_torrence(
float4 light_pos_radius,
float3 light_colour,
float3 n,
float3 world_pos,
float3 view_pos,
float3 albedo,
float3 metalness,
float roughness,
float reflectivity
)
{
    float3 l = normalize( light_pos_radius.xyz - world_pos.xyz );
    float n_dot_l = dot( n, l );
    if( n_dot_l > 0.0f )
    {
        float roughness_sq = roughness * roughness;
        float k = reflectivity;
        float3 v_view = normalize( (view_pos.xyz - world_pos.xyz) );
        float3 hv = normalize( v_view + l );
        float n_dot_v = dot( n, v_view );
        float n_dot_h = dot( n, hv );
        float v_dot_h = dot( v_view, hv );
        float n_dot_h_2 = 2.0f * n_dot_h;
        float g1 = (n_dot_h_2 * n_dot_v) / v_dot_h;
        float g2 = (n_dot_h_2 * n_dot_l) / v_dot_h;
        float geom_atten = min(1.0, min(g1, g2));
        float r1 = 1.0f / ( 4.0f * roughness_sq * pow(n_dot_h, 4.0f));
        float r2 = (n_dot_h * n_dot_h - 1.0) / (roughness_sq * n_dot_h * n_dot_h);
        float roughness_atten = r1 * exp(r2);
        float fresnel = pow(1.0 - v_dot_h, 5.0);
        fresnel *= roughness;
        fresnel += reflectivity;
        float specular = (fresnel * geom_atten * roughness_atten) / (n_dot_v * n_dot_l * 3.1419);
        float3 lit_colour = metalness * light_colour * n_dot_l * ( k + specular * ( 1.0 - k ) );
        return saturate(lit_colour);
    }
    return float3( 0.0, 0.0, 0.0 );
}
float3 oren_nayar(
float4 light_pos_radius,
float3 light_colour,
float3 n,
float3 world_pos,
float3 view_pos,
float roughness,
float3 albedo)
{
    float3 v = normalize(view_pos-world_pos);
    float3 l = normalize(light_pos_radius.xyz-world_pos);
    float l_dot_v = dot(l, v);
    float n_dot_l = dot(n, l);
    float n_dot_v = dot(n, v);
    float s = l_dot_v - n_dot_l * n_dot_v;
    float t = lerp(1.0, max(n_dot_l, n_dot_v), step(0.0, s));
    float lum = length( albedo );
    float sigma2 = roughness * roughness;
    float A = 1.0 + sigma2 * (lum / (sigma2 + 0.13) + 0.5 / (sigma2 + 0.33));
    float B = 0.45 * sigma2 / (sigma2 + 0.09);
    return ( albedo * light_colour * max(0.0, n_dot_l) * (A + B * s / t) / 3.14159265 );
}
float spot_light_attenuation(
float4 light_pos_radius,
float4 light_dir_cutoff,
float falloff,
float3 world_pos)
{
    float co = light_dir_cutoff.w;
    float3 vl = normalize(world_pos.xyz - light_pos_radius.xyz);
    float3 sd = normalize(light_dir_cutoff.xyz);
    float dp = (1.0 - dot(vl, sd));
    return smoothstep(co, co - falloff, dp);
}
float point_light_attenuation_cutoff(
float4 light_pos_radius,
float3 world_pos)
{
    float r = light_pos_radius.w;
    float d = length(world_pos.xyz - light_pos_radius.xyz);
    d = max(d - r, 0.0);
    float denom = d/r + 1.0;
    float attenuation = 1.0 / (denom*denom);
    float cutoff = 0.2;
    attenuation = (attenuation - cutoff) / (1.0 - cutoff);
    attenuation = max(attenuation, 0.0);
    return attenuation;
}
float sample_shadow_array_pcf_9(float array_slice, float3 sp)
{
    float2 samples[9];
    float2 inv_sm_size = float2(1.0/2048.0, 1.0/2048.0);
    samples[0] = float2(-1.0, -1.0) * inv_sm_size;
    samples[1] = float2(-1.0, 0.0) * inv_sm_size;
    samples[2] = float2(-1.0, 1.0) * inv_sm_size;
    samples[3] = float2(0.0, -1.0) * inv_sm_size;
    samples[4] = float2(0.0, 0.0) * inv_sm_size;
    samples[5] = float2(0.0, 1.0) * inv_sm_size;
    samples[6] = float2(1.0, -1.0) * inv_sm_size;
    samples[7] = float2(1.0, 0.0) * inv_sm_size;
    samples[8] = float2(1.0, 1.0) * inv_sm_size;
    float shadow = 0.0;
    for(int j = 0; j < 9; ++j)
    {
        shadow += sample_depth_compare_array(shadowmap_texture, sp.xy + samples[j], array_slice, sp.z);
    }
    shadow /= 9.0;
    return shadow;
}
float integrate_edge(float3 v1, float3 v2)
{
    float cos_theta = dot(v1, v2);
    float theta = acos(cos_theta);
    float res = cross(v1, v2).z * ((theta > 0.001) ? theta/sin(theta) : 1.0);
    return res;
}
void clip_quad_to_horizon(inout float3 L[5], out int n)
{
    int config = 0;
    if (L[0].z > 0.0) config += 1;
    if (L[1].z > 0.0) config += 2;
    if (L[2].z > 0.0) config += 4;
    if (L[3].z > 0.0) config += 8;
    n = 0;
    if (config == 0)
    {
    }
    else if (config == 1)
    {
        n = 3;
        L[1] = -L[1].z * L[0] + L[0].z * L[1];
        L[2] = -L[3].z * L[0] + L[0].z * L[3];
    }
    else if (config == 2)
    {
        n = 3;
        L[0] = -L[0].z * L[1] + L[1].z * L[0];
        L[2] = -L[2].z * L[1] + L[1].z * L[2];
    }
    else if (config == 3)
    {
        n = 4;
        L[2] = -L[2].z * L[1] + L[1].z * L[2];
        L[3] = -L[3].z * L[0] + L[0].z * L[3];
    }
    else if (config == 4)
    {
        n = 3;
        L[0] = -L[3].z * L[2] + L[2].z * L[3];
        L[1] = -L[1].z * L[2] + L[2].z * L[1];
    }
    else if (config == 5)
    {
        n = 0;
    }
    else if (config == 6)
    {
        n = 4;
        L[0] = -L[0].z * L[1] + L[1].z * L[0];
        L[3] = -L[3].z * L[2] + L[2].z * L[3];
    }
    else if (config == 7)
    {
        n = 5;
        L[4] = -L[3].z * L[0] + L[0].z * L[3];
        L[3] = -L[3].z * L[2] + L[2].z * L[3];
    }
    else if (config == 8)
    {
        n = 3;
        L[0] = -L[0].z * L[3] + L[3].z * L[0];
        L[1] = -L[2].z * L[3] + L[3].z * L[2];
        L[2] = L[3];
    }
    else if (config == 9)
    {
        n = 4;
        L[1] = -L[1].z * L[0] + L[0].z * L[1];
        L[2] = -L[2].z * L[3] + L[3].z * L[2];
    }
    else if (config == 10)
    {
        n = 0;
    }
    else if (config == 11)
    {
        n = 5;
        L[4] = L[3];
        L[3] = -L[2].z * L[3] + L[3].z * L[2];
        L[2] = -L[2].z * L[1] + L[1].z * L[2];
    }
    else if (config == 12)
    {
        n = 4;
        L[1] = -L[1].z * L[2] + L[2].z * L[1];
        L[0] = -L[0].z * L[3] + L[3].z * L[0];
    }
    else if (config == 13)
    {
        n = 5;
        L[4] = L[3];
        L[3] = L[2];
        L[2] = -L[1].z * L[2] + L[2].z * L[1];
        L[1] = -L[1].z * L[0] + L[0].z * L[1];
    }
    else if (config == 14)
    {
        n = 5;
        L[4] = -L[0].z * L[3] + L[3].z * L[0];
        L[0] = -L[0].z * L[1] + L[1].z * L[0];
    }
    else if (config == 15)
    {
        n = 4;
    }
    if (n == 3)
    L[3] = L[0];
    if (n == 4)
    L[4] = L[0];
}
float3 ltc_uv_coord(float3 p[4])
{
    float3 v1 = p[1] - p[0];
    float3 v2 = p[3] - p[0];
    float3 plane_ortho = (cross(v1, v2));
    float plane_area_squared = dot(plane_ortho, plane_ortho);
    float plane_distx_plane_area = dot(plane_ortho, p[0]);
    float3 pp = plane_distx_plane_area * plane_ortho / plane_area_squared - p[0];
    float v1_dot_v2 = dot(v1, v2);
    float inv_v1_dot_v1 = 1.0 / dot(v1, v1);
    float3 vv2 = v2 - v1 * v1_dot_v2 * inv_v1_dot_v1;
    float2 puv;
    puv.y = dot(vv2, pp) / dot(vv2, vv2);
    puv.x = dot(v1, pp) * inv_v1_dot_v1 - v1_dot_v2 * inv_v1_dot_v1 * puv.y;
    float d = abs(plane_distx_plane_area) / pow(plane_area_squared, 0.75);
    return float3(puv, d);
}
float4 ltc_evaluate(
float3 n,
float3 v,
float3 p,
float3x3 minv,
float3 points[4],
bool two_sided)
{
    float3 t1, t2;
    t1 = normalize(v - n * dot(v, n));
    t2 = cross(n, t1);
    float3x3 ttn = from_columns_3x3(t1, t2, n);
    minv = mul(minv, ttn);
    float3 l[5];
    l[0] = mul(minv, points[0] - p);
    l[1] = mul(minv, points[1] - p);
    l[2] = mul(minv, points[2] - p);
    l[3] = mul(minv, points[3] - p);
    l[4] = l[3];
    float3 ll[4];
    ll[0] = l[0];
    ll[1] = l[1];
    ll[2] = l[2];
    ll[3] = l[3];
    float3 uvl = ltc_uv_coord(ll);
    int nc;
    clip_quad_to_horizon(l, nc);
    if (nc == 0)
    return float4(0, 0, 0, 0.0);
    l[0] = normalize(l[0]);
    l[1] = normalize(l[1]);
    l[2] = normalize(l[2]);
    l[3] = normalize(l[3]);
    l[4] = normalize(l[4]);
    float sum = 0.0;
    sum += integrate_edge(l[0], l[1]);
    sum += integrate_edge(l[1], l[2]);
    sum += integrate_edge(l[2], l[3]);
    if (nc >= 4)
    sum += integrate_edge(l[3], l[4]);
    if (nc == 5)
    sum += integrate_edge(l[4], l[0]);
    sum = two_sided ? abs(sum) : max(0.0, sum);
    float3 lo_i = float3(sum, sum, sum);
    return float4(uvl.x, uvl.y, uvl.z, sum);
}
float ltc_evaluate_cc(
float3 n,
float3 v,
float3 p,
float3x3 minv,
float3 points[4],
bool two_sided)
{
    float3 t1, t2;
    t1 = normalize(v - n * dot(v, n));
    t2 = cross(n, t1);
    float3x3 ttn = from_columns_3x3(t1, t2, n);
    minv = mul(minv, ttn);
    float3 l[5];
    for(int i = 0; i < 4; ++i)
    l[i] = mul(minv, points[i] - p);
    l[4] = l[3];
    int nc;
    clip_quad_to_horizon(l, nc);
    if (nc == 0)
    return 0.0;
    for(int i = 0; i < 5; ++i)
    l[i] = normalize(l[i]);
    float sum = 0.0;
    sum += integrate_edge(l[0], l[1]);
    sum += integrate_edge(l[1], l[2]);
    sum += integrate_edge(l[2], l[3]);
    if (nc >= 4)
    sum += integrate_edge(l[3], l[4]);
    if (nc == 5)
    sum += integrate_edge(l[4], l[0]);
    sum = two_sided ? abs(sum) : max(0.0, sum);
    return sum;
}
float4 area_light_specular_uv(
float3 points[4],
float3 pos,
float roughness,
float3 n,
float3 v)
{
    float pi = 3.14159265359;
    float lut_size = 64.0;
    float lut_scale = (lut_size - 1.0)/lut_size;
    float lut_bias = 0.5/lut_size;
    float theta = acos(dot(n, v));
    float2 uv = float2(roughness, theta / (0.5 * pi));
    uv = uv * lut_scale + lut_bias;
    float4 mat = sample_texture(ltc_mat, uv);
    float mag = sample_texture(ltc_mag, uv).w;
    float3x3 minv = from_rows_3x3(
    float3(1.0, 0.0, mat.y),
    float3(0.0, mat.z, 0.0),
    float3(mat.w, 0.0, mat.x)
    );
    float4 spec = ltc_evaluate(n, v, pos, minv, points, true);
    return spec;
}
float area_light_specular(
float3 points[4],
float3 pos,
float roughness,
float3 n,
float3 v)
{
    float pi = 3.14159265359;
    float lut_size = 64.0;
    float lut_scale = (lut_size - 1.0)/lut_size;
    float lut_bias = 0.5/lut_size;
    float theta = acos(dot(n, v));
    float2 uv = float2(roughness, theta / (0.5 * pi));
    uv = uv * lut_scale + lut_bias;
    float4 mat = sample_texture(ltc_mat, uv);
    float mag = sample_texture(ltc_mag, uv).w;
    float3x3 minv = from_rows_3x3(
    float3(1.0, 0.0, mat.y),
    float3(0.0, mat.z, 0.0),
    float3(mat.w, 0.0, mat.x)
    );
    float spec = ltc_evaluate_cc(n, v, pos, minv, points, true);
    return spec;
}
float4 area_light_diffuse_uv(
float3 points[4],
float3 pos,
float3 n,
float3 v)
{
    float3x3 difv = float3x3(
    float3(1.0, 0.0, 0.0),
    float3(0.0, 1.0, 0.0),
    float3(0.0, 0.0, 1.0)
    );
    float4 diff = ltc_evaluate(n, v, pos, difv, points, true);
    return diff;
}
float area_light_diffuse(
float3 points[4],
float3 pos,
float3 n,
float3 v)
{
    float3x3 difv = float3x3(
    float3(1.0, 0.0, 0.0),
    float3(0.0, 1.0, 0.0),
    float3(0.0, 0.0, 1.0)
    );
    float diff = ltc_evaluate_cc(n, v, pos, difv, points, true);
    return diff;
}
float3 transform_ts_normal( float3 t, float3 b, float3 n, float3 ts_normal )
{
    float3x3 tbn;
    tbn[0] = float3(t.x, b.x, n.x);
    tbn[1] = float3(t.y, b.y, n.y);
    tbn[2] = float3(t.z, b.z, n.z);
    return normalize( mul_tbn( tbn, ts_normal ) );
}
float3 hash_33( float3 p )
{
    p = float3(dot(p,float3(127.1,311.7, 74.7)),
    dot(p,float3(269.5,183.3,246.1)),
    dot(p,float3(113.5,271.9,124.6)));
    return fract(sin(p)*43758.5453123) * 2.0 - 1.0;
}
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.world_pos = world_pos_vs_output;
    _input.normal = normal_vs_output;
    _input.tangent = tangent_vs_output;
    _input.bitangent = bitangent_vs_output;
    _input.texcoord = texcoord_vs_output;
    _input.colour = colour_vs_output;
    ps_output _output;
    float4 albedo = sample_texture( diffuse_texture, _input.texcoord.xy );
    float3 normal_sample = sample_texture( normal_texture, _input.texcoord.xy ).rgb;
    float4 ro_sample = sample_texture( specular_texture, _input.texcoord.xy );
    float4 specular_sample = float4(1.0, 1.0, 1.0, 1.0);
    normal_sample = normal_sample * 2.0 - 1.0;
    float3 n = transform_ts_normal(
    _input.tangent,
    _input.bitangent,
    _input.normal,
    normal_sample );
    albedo *= _input.colour;
    float4 metalness = float4(1.0, 1.0, 1.0, 1.0);
    float3 lit_colour = float3( 0.0, 0.0, 0.0 );
    float reflectivity = saturate(user_data.z);
    float roughness = saturate(user_data.y);
    reflectivity = m_reflectivity;
    roughness = ro_sample.r;
    float t = 1.0;
    float3 lll = float3(0.0, 0.0, 0.0);
    int shadow_map_index = 0;
    _pmfx_loop
    for( int i = 0; i < int(light_info.x); ++i )
    {
        float3 light_col = float3( 0.0, 0.0, 0.0 );
        light_col += cook_torrence(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        albedo.rgb,
        metalness.rgb,
        roughness,
        reflectivity
        );
        light_col += oren_nayar(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        1.0 - roughness,
        albedo.rgb
        );
        if( lights[i].colour.a == 0.0 )
        {
            lit_colour += light_col;
            continue;
        }
        else
        {
            float shadow = 1.0;
            float d = 1.0;
            float4 offset_pos = float4(_input.world_pos.xyz + n.xyz * 0.01, 1.0);
            float4 sp = mul( offset_pos, shadow_matrix[i] );
            sp.xyz /= sp.w;
            sp.y *= -1.0;
            sp.xy = sp.xy * 0.5 + 0.5;
            sp.z = remap_depth(sp.z);
            shadow = sample_shadow_array_pcf_9(float(shadow_map_index), sp.xyz);
            lit_colour += light_col * shadow;
            ++shadow_map_index;
        }
    }
    int point_start = int(light_info.x);
    int point_end = int(light_info.x) + int(light_info.y);
    int omni_shadow_index = 0;
    _pmfx_loop
    for( int i = point_start; i < point_end; ++i )
    {
        float3 light_col = float3( 0.0, 0.0, 0.0 );
        light_col += cook_torrence(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        albedo.rgb,
        metalness.rgb,
        roughness,
        reflectivity
        );
        light_col += oren_nayar(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        roughness,
        albedo.rgb
        );
        float a = point_light_attenuation_cutoff( lights[i].pos_radius, _input.world_pos.xyz );
        light_col *= a;
        if( lights[i].colour.a == 0.0)
        {
            lit_colour += light_col;
            continue;
        }
        else
        {
            lit_colour += light_col;
            continue;
        }
    }
    int spot_start = point_end;
    int spot_end = spot_start + int(light_info.z);
    _pmfx_loop
    for(int i = spot_start; i < spot_end; ++i )
    {
        float3 light_col = float3( 0.0, 0.0, 0.0 );
        light_col += cook_torrence(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        albedo.rgb,
        metalness.rgb,
        roughness,
        reflectivity
        );
        light_col += oren_nayar(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        roughness,
        albedo.rgb
        );
        float a = spot_light_attenuation(lights[i].pos_radius,
        lights[i].dir_cutoff,
        lights[i].data.x,
        _input.world_pos.xyz );
        light_col *= a;
        if( lights[i].colour.a == 0.0 )
        {
            lit_colour += light_col;
            continue;
        }
        else
        {
            float shadow = 1.0;
            float d = 1.0;
            float4 offset_pos = float4(_input.world_pos.xyz + n.xyz * 0.01, 1.0);
            float4 sp = mul( offset_pos, shadow_matrix[shadow_map_index] );
            sp.xyz /= sp.w;
            sp.y *= -1.0;
            sp.xy = sp.xy * 0.5 + 0.5;
            sp.z = remap_depth(sp.z);
            shadow = sample_shadow_array_pcf_9(float(shadow_map_index), sp.xyz);
            lit_colour += light_col * shadow;
            ++shadow_map_index;
        }
    }
    {
        float pi = 3.14159265359;
        int num_area_lights = int(area_light_info.x);
        for(int i = 0; i < num_area_lights; ++i)
        {
            float3 v = -normalize(_input.world_pos.xyz - camera_view_pos.xyz);
            float3 pos = _input.world_pos.xyz;
            float3 points[4];
            for(int j = 0; j < 4; ++j)
            points[j] = area_lights[i].corners[j].xyz;
            float diff_sum = area_light_diffuse(points, pos, n, v);
            float3 diff = area_lights[i].colour.rgb * diff_sum;
            float spec_sum = area_light_specular(points, pos, ro_sample.x, n, v);
            float3 spec = area_lights[i].colour.rgb * spec_sum;
            float3 light_col = (spec.rgb + diff.rgb) / (2.0 * pi);
            lit_colour += light_col;
        }
        int ts = num_area_lights;
        int num_area_lights_textured = int(area_light_info.y);
        for(int i = ts; i < ts + num_area_lights_textured; ++i)
        {
            float slice = area_lights[i].colour.w;
            float levels = 8.0;
            float2 inv_texel = float2(1.0/640.0, 1.0/480.0);
            float2 inv_texel_x = float2(1.0, 1.0) - inv_texel;
            float3 points[4];
            for(int j = 0; j < 4; ++j)
            points[j] = area_lights[i].corners[j].xyz;
            float3 v = -normalize(_input.world_pos.xyz - camera_view_pos.xyz);
            float3 pos = _input.world_pos.xyz;
            float4 diff_uv = area_light_diffuse_uv(points, pos, n, v);
            float2 duv = clamp(diff_uv.xy, inv_texel, inv_texel_x);
            float3 diff = sample_texture_array_level( area_light_textures, duv, slice, diff_uv.z * levels).rgb * diff_uv.w;
            float4 spec_uv = area_light_specular_uv(points, pos, ro_sample.x, n, v);
            float2 suv = clamp(spec_uv.xy, inv_texel, inv_texel_x);
            float3 spec = sample_texture_array_level(area_light_textures, suv, slice, spec_uv.z * levels).rgb * spec_uv.w;
            float3 light_col = (spec.rgb + diff.rgb) / (2.0 * pi);
            lit_colour += light_col;
        }
    }
    _output.colour.rgb = lit_colour.rgb * albedo.a;
    _output.colour.a = albedo.a;
    float3 gn = _input.normal.xyz;
    float3 gt = _input.tangent.xyz;
    float3 gb = _input.bitangent.xyz;
    float3 dim = gi_scene_size.xyz;
    float3 to_uvx = dim * 0.5;
    int num_rays = 16;
    float3 rays[16];
    rays[0] = float3(0.57735, 0.57735, 0.57735);
    rays[1] = float3(0.57735, -0.57735, -0.57735);
    rays[2] = float3(-0.57735, 0.57735, -0.57735);
    rays[3] = float3(-0.57735, -0.57735, 0.57735);
    rays[4] = float3(-0.903007, -0.182696, -0.388844);
    rays[5] = float3(-0.903007, 0.182696, 0.388844);
    rays[6] = float3(0.903007, -0.182696, 0.388844);
    rays[7] = float3(0.903007, 0.182696, -0.388844);
    rays[8] = float3(-0.388844, -0.903007, -0.182696);
    rays[9] = float3(0.388844, -0.903007, 0.182696);
    rays[10] = float3(0.388844, 0.903007, -0.182696);
    rays[11] = float3(-0.388844, 0.903007, 0.182696);
    rays[12] = float3(-0.182696, -0.388844, -0.903007);
    rays[13] = float3(0.182696, 0.388844, -0.903007);
    rays[14] = float3(-0.182696, 0.388844, 0.903007);
    rays[15] = float3(0.182696, -0.388844, 0.903007);
    float4 gi = float4(0.0, 0.0, 0.0, 0.0);
    float4 sp = mul(_input.world_pos, vp_matrix);
    sp /= sp.w;
    sp.x *= (1280.0/512.0);
    sp.y *= (720.0/512.0);
    for(int i = 0; i < num_rays; ++i)
    {
        float3 noise = (hash_33(_input.world_pos.xyz + user_data.yyy));
        float3 noise2 = (sample_texture_level(blue_noise, sp.xy + noise.xy, 0.0).rgb * 2.0 - 1.0);
        float3 tex_size = gi_volume_size.xyz;
        float3 ray = chebyshev_normalize(noise2 + rays[i]);
        float3 cn = chebyshev_normalize(n);
        float3 step = (dim*2.0) / tex_size;
        float3 sp = _input.world_pos.xyz + (cn * step);
        ray *= dot(ray, gn) < 0.0 ? -1.0 : 1.0;
        float4 ray_gi = float4(0.0, 0.0, 0.0, 0.0);
        for(int j = 0; j < 4; ++j)
        {
            for(int k = 0; k < 2; ++k)
            {
                step = (dim*2.0) / tex_size;
                float3 uvw = saturate((sp / to_uvx) * 0.5 + 0.5);
                float4 g = sample_texture_level( volume_gi, uvw, float(j));
                float d = length(_input.world_pos.xyz - sp);
                d = smoothstep(0.0, 8.0, d);
                ray_gi.rgb = ray_gi.rgb + g.rgb * d;
                ray_gi.a += g.a;
                sp += ray * step.x;
            }
            tex_size /= 2.0;
            if(ray_gi.a >= 1.0 && j > 1)
            break;
        }
        gi += ray_gi;
    }
    gi /= float(num_rays);
    _output.colour.rgb = gi.rgb * 2.0 * m_albedo.rgb + lit_colour.rgb;
    if(albedo.a <= 0.0)
    discard;
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//forward_render forward_lit__3221225472__ vs 3221225472
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
layout(location = 0) in float4 position_vs_input;
layout(location = 1) in float4 normal_vs_input;
layout(location = 2) in float4 texcoord_vs_input;
layout(location = 3) in float4 tangent_vs_input;
layout(location = 4) in float4 bitangent_vs_input;
layout(location = 5) in float4 blend_indices_vs_input;
layout(location = 6) in float4 blend_weights_vs_input;
layout(location = 7) in float4 world_matrix_0_instance_input;
layout(location = 8) in float4 world_matrix_1_instance_input;
layout(location = 9) in float4 world_matrix_2_instance_input;
layout(location = 10) in float4 world_matrix_3_instance_input;
layout(location = 11) in float4 user_data_instance_input;
layout(location = 12) in float4 user_data2_instance_input;
out float4 world_pos_vs_output;
out float3 normal_vs_output;
out float3 tangent_vs_output;
out float3 bitangent_vs_output;
out float4 texcoord_vs_output;
out float4 colour_vs_output;
uniform float v_flip;
struct vs_input_multi
{
    float4 position;
    float4 normal;
    float4 texcoord;
    float4 tangent;
    float4 bitangent;
    float4 blend_indices;
    float4 blend_weights;
};
struct vs_instance_input
{
    float4 world_matrix_0;
    float4 world_matrix_1;
    float4 world_matrix_2;
    float4 world_matrix_3;
    float4 user_data;
    float4 user_data2;
};
struct vs_output
{
    float4 position;
    float4 world_pos;
    float3 normal;
    float3 tangent;
    float3 bitangent;
    float4 texcoord;
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform skinning_info
{
    float4x4 bones[85];
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
layout (std140) uniform per_draw_call
{
    float4x4 world_matrix;
    float4 user_data;
    float4 user_data2;
    float4x4 world_matrix_inv_transpose;
};
float4 skin_pos(float4 pos, float4 weights, float4 indices)
{
    int bone_indices[4];
    bone_indices[0] = int(indices.x);
    bone_indices[1] = int(indices.y);
    bone_indices[2] = int(indices.z);
    bone_indices[3] = int(indices.w);
    float4 sp = float4( 0.0, 0.0, 0.0, 0.0 );
    float final_weight = 1.0;
    for(int i = 3; i >= 0; --i)
    {
        sp += mul( pos, bones[bone_indices[i]] ) * weights[i];
        final_weight -= weights[i];
    }
    sp += mul( pos, bones[bone_indices[0]] ) * final_weight;
    sp.w = 1.0;
    return sp;
}
void skin_tbn(inout float3 t, inout float3 b, inout float3 n, float4 weights, float4 indices)
{
    int bone_indices[4];
    bone_indices[0] = int(indices.x);
    bone_indices[1] = int(indices.y);
    bone_indices[2] = int(indices.z);
    bone_indices[3] = int(indices.w);
    float3 rt = float3( 0.0, 0.0, 0.0);
    float3 rb = float3( 0.0, 0.0, 0.0);
    float3 rn = float3( 0.0, 0.0, 0.0);
    float final_weight = 1.0;
    for( int i = 0; i < 3; ++i)
    {
        float3x3 rot_mat = to_3x3(bones[bone_indices[i]]);
        rt += mul(t, rot_mat) * weights[i];
        rb += mul(b, rot_mat) * weights[i];
        rn += mul(n, rot_mat) * weights[i];
        final_weight -= weights[i];
    }
    float3x3 rot_mat = to_3x3(bones[bone_indices[3]]);
    rt += mul(t, rot_mat) * final_weight;
    rb += mul(b, rot_mat) * final_weight;
    rn += mul(n, rot_mat) * final_weight;
    t = rt;
    b = rb;
    n = rn;
}
void main()
{
    //assign vs_input_multi struct from glsl inputs
    vs_input_multi _input;
    _input.position = position_vs_input;
    _input.normal = normal_vs_input;
    _input.texcoord = texcoord_vs_input;
    _input.tangent = tangent_vs_input;
    _input.bitangent = bitangent_vs_input;
    _input.blend_indices = blend_indices_vs_input;
    _input.blend_weights = blend_weights_vs_input;
    //assign vs_instance_input struct from glsl inputs
    vs_instance_input instance_input;
    instance_input.world_matrix_0 = world_matrix_0_instance_input;
    instance_input.world_matrix_1 = world_matrix_1_instance_input;
    instance_input.world_matrix_2 = world_matrix_2_instance_input;
    instance_input.world_matrix_3 = world_matrix_3_instance_input;
    instance_input.user_data = user_data_instance_input;
    instance_input.user_data2 = user_data2_instance_input;
    vs_output _output;
    float4x4 wvp = mul( world_matrix, vp_matrix );
    float4x4 wm = world_matrix;
    _output.texcoord = float4(_input.texcoord.x, 1.0 - _input.texcoord.y,
    _input.texcoord.z, 1.0 - _input.texcoord.w );
    float4x4 instance_world_mat;
    unpack_vb_instance_mat(
    instance_world_mat,
    instance_input.world_matrix_0,
    instance_input.world_matrix_1,
    instance_input.world_matrix_2,
    instance_input.world_matrix_3
    );
    wvp = mul( instance_world_mat, vp_matrix );
    wm = instance_world_mat;
    _output.colour = instance_input.user_data2;
    float4 sp = skin_pos(_input.position, _input.blend_weights, _input.blend_indices);
    _output.tangent = _input.tangent.xyz;
    _output.bitangent = _input.bitangent.xyz;
    _output.normal = _input.normal.xyz;
    skin_tbn(_output.tangent, _output.bitangent, _output.normal, _input.blend_weights, _input.blend_indices);
    _output.position = mul( sp, vp_matrix );
    _output.world_pos = sp;
    //assign glsl global outputs from structs
    gl_Position = _output.position;
    gl_Position.y *= v_flip;
    world_pos_vs_output = _output.world_pos;
    normal_vs_output = _output.normal;
    tangent_vs_output = _output.tangent;
    bitangent_vs_output = _output.bitangent;
    texcoord_vs_output = _output.texcoord;
    colour_vs_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//forward_render omni_shadow__2147483648__ vs 2147483648
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
layout(location = 0) in float4 position_vs_input;
layout(location = 1) in float4 normal_vs_input;
layout(location = 2) in float4 texcoord_vs_input;
layout(location = 3) in float4 tangent_vs_input;
layout(location = 4) in float4 bitangent_vs_input;
layout(location = 5) in float4 blend_indices_vs_input;
layout(location = 6) in float4 blend_weights_vs_input;
out float4 world_pos_vs_output;
uniform float v_flip;
struct vs_input_position_only
{
    float4 position;
    float4 normal;
    float4 texcoord;
    float4 tangent;
    float4 bitangent;
    float4 blend_indices;
    float4 blend_weights;
};
struct vs_output_zonly_wp
{
    float4 position;
    float4 world_pos;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform skinning_info
{
    float4x4 bones[85];
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
layout (std140) uniform per_draw_call
{
    float4x4 world_matrix;
    float4 user_data;
    float4 user_data2;
    float4x4 world_matrix_inv_transpose;
};
float4 skin_pos(float4 pos, float4 weights, float4 indices)
{
    int bone_indices[4];
    bone_indices[0] = int(indices.x);
    bone_indices[1] = int(indices.y);
    bone_indices[2] = int(indices.z);
    bone_indices[3] = int(indices.w);
    float4 sp = float4( 0.0, 0.0, 0.0, 0.0 );
    float final_weight = 1.0;
    for(int i = 3; i >= 0; --i)
    {
        sp += mul( pos, bones[bone_indices[i]] ) * weights[i];
        final_weight -= weights[i];
    }
    sp += mul( pos, bones[bone_indices[0]] ) * final_weight;
    sp.w = 1.0;
    return sp;
}
void main()
{
    //assign vs_input_position_only struct from glsl inputs
    vs_input_position_only _input;
    _input.position = position_vs_input;
    _input.normal = normal_vs_input;
    _input.texcoord = texcoord_vs_input;
    _input.tangent = tangent_vs_input;
    _input.bitangent = bitangent_vs_input;
    _input.blend_indices = blend_indices_vs_input;
    _input.blend_weights = blend_weights_vs_input;
    vs_output_zonly_wp _output;
    float4x4 wvp = mul( world_matrix, vp_matrix );
    float4x4 wm = world_matrix;
    float4 sp = skin_pos(_input.position, _input.blend_weights, _input.blend_indices);
    _output.position = mul( sp, vp_matrix );
    _output.world_pos = sp;
    //assign glsl global outputs from structs
    gl_Position = _output.position;
    gl_Position.y *= v_flip;
    world_pos_vs_output = _output.world_pos;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//forward_render zonly__2147483648__ vs 2147483648
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
layout(location = 0) in float4 position_vs_input;
layout(location = 1) in float4 normal_vs_input;
layout(location = 2) in float4 texcoord_vs_input;
layout(location = 3) in float4 tangent_vs_input;
layout(location = 4) in float4 bitangent_vs_input;
layout(location = 5) in float4 blend_indices_vs_input;
layout(location = 6) in float4 blend_weights_vs_input;
uniform float v_flip;
struct vs_input_position_only
{
    float4 position;
    float4 normal;
    float4 texcoord;
    float4 tangent;
    float4 bitangent;
    float4 blend_indices;
    float4 blend_weights;
};
struct vs_output_zonly
{
    float4 position;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform skinning_info
{
    float4x4 bones[85];
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
layout (std140) uniform per_draw_call
{
    float4x4 world_matrix;
    float4 user_data;
    float4 user_data2;
    float4x4 world_matrix_inv_transpose;
};
float4 skin_pos(float4 pos, float4 weights, float4 indices)
{
    int bone_indices[4];
    bone_indices[0] = int(indices.x);
    bone_indices[1] = int(indices.y);
    bone_indices[2] = int(indices.z);
    bone_indices[3] = int(indices.w);
    float4 sp = float4( 0.0, 0.0, 0.0, 0.0 );
    float final_weight = 1.0;
    for(int i = 3; i >= 0; --i)
    {
        sp += mul( pos, bones[bone_indices[i]] ) * weights[i];
        final_weight -= weights[i];
    }
    sp += mul( pos, bones[bone_indices[0]] ) * final_weight;
    sp.w = 1.0;
    return sp;
}
void main()
{
    //assign vs_input_position_only struct from glsl inputs
    vs_input_position_only _input;
    _input.position = position_vs_input;
    _input.normal = normal_vs_input;
    _input.texcoord = texcoord_vs_input;
    _input.tangent = tangent_vs_input;
    _input.bitangent = bitangent_vs_input;
    _input.blend_indices = blend_indices_vs_input;
    _input.blend_weights = blend_weights_vs_input;
    vs_output_zonly _output;
    float4x4 wvp;
    wvp = mul( world_matrix, vp_matrix );
    float4 sp = skin_pos(_input.position, _input.blend_weights, _input.blend_indices);
    _output.position = mul( sp, vp_matrix );
    //assign glsl global outputs from structs
    gl_Position = _output.position;
    gl_Position.y *= v_flip;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//forward_render single_light_directional ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 world_pos_vs_output;
in float3 normal_vs_output;
in float3 tangent_vs_output;
in float3 bitangent_vs_output;
in float4 texcoord_vs_output;
in float4 colour_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 world_pos;
    float3 normal;
    float3 tangent;
    float3 bitangent;
    float4 texcoord;
    float4 colour;
};
struct ps_output
{
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
layout (std140) uniform cbuffer_single_light
{
    light_data single_light;
};
layout (std140) uniform material_data
{
    float4 m_albedo;
    float m_roughness;
    float m_reflectivity;
    float2 m_padding;
};
texture_2d( diffuse_texture, 0 );
texture_2d( normal_texture, 1 );
texture_2d( specular_texture, 2 );
float3 cook_torrence(
float4 light_pos_radius,
float3 light_colour,
float3 n,
float3 world_pos,
float3 view_pos,
float3 albedo,
float3 metalness,
float roughness,
float reflectivity
)
{
    float3 l = normalize( light_pos_radius.xyz - world_pos.xyz );
    float n_dot_l = dot( n, l );
    if( n_dot_l > 0.0f )
    {
        float roughness_sq = roughness * roughness;
        float k = reflectivity;
        float3 v_view = normalize( (view_pos.xyz - world_pos.xyz) );
        float3 hv = normalize( v_view + l );
        float n_dot_v = dot( n, v_view );
        float n_dot_h = dot( n, hv );
        float v_dot_h = dot( v_view, hv );
        float n_dot_h_2 = 2.0f * n_dot_h;
        float g1 = (n_dot_h_2 * n_dot_v) / v_dot_h;
        float g2 = (n_dot_h_2 * n_dot_l) / v_dot_h;
        float geom_atten = min(1.0, min(g1, g2));
        float r1 = 1.0f / ( 4.0f * roughness_sq * pow(n_dot_h, 4.0f));
        float r2 = (n_dot_h * n_dot_h - 1.0) / (roughness_sq * n_dot_h * n_dot_h);
        float roughness_atten = r1 * exp(r2);
        float fresnel = pow(1.0 - v_dot_h, 5.0);
        fresnel *= roughness;
        fresnel += reflectivity;
        float specular = (fresnel * geom_atten * roughness_atten) / (n_dot_v * n_dot_l * 3.1419);
        float3 lit_colour = metalness * light_colour * n_dot_l * ( k + specular * ( 1.0 - k ) );
        return saturate(lit_colour);
    }
    return float3( 0.0, 0.0, 0.0 );
}
float3 oren_nayar(
float4 light_pos_radius,
float3 light_colour,
float3 n,
float3 world_pos,
float3 view_pos,
float roughness,
float3 albedo)
{
    float3 v = normalize(view_pos-world_pos);
    float3 l = normalize(light_pos_radius.xyz-world_pos);
    float l_dot_v = dot(l, v);
    float n_dot_l = dot(n, l);
    float n_dot_v = dot(n, v);
    float s = l_dot_v - n_dot_l * n_dot_v;
    float t = lerp(1.0, max(n_dot_l, n_dot_v), step(0.0, s));
    float lum = length( albedo );
    float sigma2 = roughness * roughness;
    float A = 1.0 + sigma2 * (lum / (sigma2 + 0.13) + 0.5 / (sigma2 + 0.33));
    float B = 0.45 * sigma2 / (sigma2 + 0.09);
    return ( albedo * light_colour * max(0.0, n_dot_l) * (A + B * s / t) / 3.14159265 );
}
float3 transform_ts_normal( float3 t, float3 b, float3 n, float3 ts_normal )
{
    float3x3 tbn;
    tbn[0] = float3(t.x, b.x, n.x);
    tbn[1] = float3(t.y, b.y, n.y);
    tbn[2] = float3(t.z, b.z, n.z);
    return normalize( mul_tbn( tbn, ts_normal ) );
}
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.world_pos = world_pos_vs_output;
    _input.normal = normal_vs_output;
    _input.tangent = tangent_vs_output;
    _input.bitangent = bitangent_vs_output;
    _input.texcoord = texcoord_vs_output;
    _input.colour = colour_vs_output;
    float4 albedo = sample_texture( diffuse_texture, _input.texcoord.xy );
    float3 normal_sample = sample_texture( normal_texture, _input.texcoord.xy ).rgb;
    float4 ro_sample = sample_texture( specular_texture, _input.texcoord.xy );
    float4 specular_sample = float4(1.0, 1.0, 1.0, 1.0);
    float reflectivity = m_reflectivity;
    float roughness = ro_sample.x;
    normal_sample = normal_sample * 2.0 - 1.0;
    float3 n = transform_ts_normal(
    _input.tangent,
    _input.bitangent,
    _input.normal,
    normal_sample );
    float3 lit_colour = float3( 0.0, 0.0, 0.0 );
    lit_colour += cook_torrence(
    single_light.pos_radius,
    single_light.colour.rgb,
    n,
    _input.world_pos.xyz,
    camera_view_pos.xyz,
    albedo.rgb,
    specular_sample.rgb,
    roughness,
    reflectivity);
    lit_colour += oren_nayar(
    single_light.pos_radius,
    single_light.colour.rgb,
    n,
    _input.world_pos.xyz,
    camera_view_pos.xyz,
    roughness,
    albedo.rgb);
    ps_output _output;
    _output.colour.rgb = lit_colour;
    _output.colour.a = albedo.a;
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//forward_render forward_lit__10__ ps 10
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 world_pos_vs_output;
in float3 normal_vs_output;
in float3 tangent_vs_output;
in float3 bitangent_vs_output;
in float4 texcoord_vs_output;
in float4 colour_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 world_pos;
    float3 normal;
    float3 tangent;
    float3 bitangent;
    float4 texcoord;
    float4 colour;
};
struct ps_output
{
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
layout (std140) uniform per_draw_call
{
    float4x4 world_matrix;
    float4 user_data;
    float4 user_data2;
    float4x4 world_matrix_inv_transpose;
};
layout (std140) uniform per_pass_lights
{
    float4 light_info;
    light_data lights[100];
};
layout (std140) uniform per_pass_shadow
{
    float4x4 shadow_matrix[100];
};
layout (std140) uniform per_pass_shadow_distance_fields
{
    distance_field_shadow sdf_shadow;
};
layout (std140) uniform per_pass_area_lights
{
    float4 area_light_info;
    area_light_data area_lights[10];
};
layout (std140) uniform material_data
{
    float4 m_albedo;
    float2 m_uv_scale;
    float m_roughness;
    float m_reflectivity;
    float m_surface_offset;
    float3 m_padding;
};
texture_2d( diffuse_texture, 0 );
texture_2d( normal_texture, 1 );
texture_2d( specular_texture, 2 );
texture_3d( sdf_volume, 14 );
texture_2d( ltc_mat, 13 );
texture_2d( ltc_mag, 12 );
texture_2d_array( area_light_textures, 11 );
depth_2d_array( shadowmap_texture, 15 );
float3 cook_torrence(
float4 light_pos_radius,
float3 light_colour,
float3 n,
float3 world_pos,
float3 view_pos,
float3 albedo,
float3 metalness,
float roughness,
float reflectivity
)
{
    float3 l = normalize( light_pos_radius.xyz - world_pos.xyz );
    float n_dot_l = dot( n, l );
    if( n_dot_l > 0.0f )
    {
        float roughness_sq = roughness * roughness;
        float k = reflectivity;
        float3 v_view = normalize( (view_pos.xyz - world_pos.xyz) );
        float3 hv = normalize( v_view + l );
        float n_dot_v = dot( n, v_view );
        float n_dot_h = dot( n, hv );
        float v_dot_h = dot( v_view, hv );
        float n_dot_h_2 = 2.0f * n_dot_h;
        float g1 = (n_dot_h_2 * n_dot_v) / v_dot_h;
        float g2 = (n_dot_h_2 * n_dot_l) / v_dot_h;
        float geom_atten = min(1.0, min(g1, g2));
        float r1 = 1.0f / ( 4.0f * roughness_sq * pow(n_dot_h, 4.0f));
        float r2 = (n_dot_h * n_dot_h - 1.0) / (roughness_sq * n_dot_h * n_dot_h);
        float roughness_atten = r1 * exp(r2);
        float fresnel = pow(1.0 - v_dot_h, 5.0);
        fresnel *= roughness;
        fresnel += reflectivity;
        float specular = (fresnel * geom_atten * roughness_atten) / (n_dot_v * n_dot_l * 3.1419);
        float3 lit_colour = metalness * light_colour * n_dot_l * ( k + specular * ( 1.0 - k ) );
        return saturate(lit_colour);
    }
    return float3( 0.0, 0.0, 0.0 );
}
float3 oren_nayar(
float4 light_pos_radius,
float3 light_colour,
float3 n,
float3 world_pos,
float3 view_pos,
float roughness,
float3 albedo)
{
    float3 v = normalize(view_pos-world_pos);
    float3 l = normalize(light_pos_radius.xyz-world_pos);
    float l_dot_v = dot(l, v);
    float n_dot_l = dot(n, l);
    float n_dot_v = dot(n, v);
    float s = l_dot_v - n_dot_l * n_dot_v;
    float t = lerp(1.0, max(n_dot_l, n_dot_v), step(0.0, s));
    float lum = length( albedo );
    float sigma2 = roughness * roughness;
    float A = 1.0 + sigma2 * (lum / (sigma2 + 0.13) + 0.5 / (sigma2 + 0.33));
    float B = 0.45 * sigma2 / (sigma2 + 0.09);
    return ( albedo * light_colour * max(0.0, n_dot_l) * (A + B * s / t) / 3.14159265 );
}
float spot_light_attenuation(
float4 light_pos_radius,
float4 light_dir_cutoff,
float falloff,
float3 world_pos)
{
    float co = light_dir_cutoff.w;
    float3 vl = normalize(world_pos.xyz - light_pos_radius.xyz);
    float3 sd = normalize(light_dir_cutoff.xyz);
    float dp = (1.0 - dot(vl, sd));
    return smoothstep(co, co - falloff, dp);
}
float point_light_attenuation_cutoff(
float4 light_pos_radius,
float3 world_pos)
{
    float r = light_pos_radius.w;
    float d = length(world_pos.xyz - light_pos_radius.xyz);
    d = max(d - r, 0.0);
    float denom = d/r + 1.0;
    float attenuation = 1.0 / (denom*denom);
    float cutoff = 0.2;
    attenuation = (attenuation - cutoff) / (1.0 - cutoff);
    attenuation = max(attenuation, 0.0);
    return attenuation;
}
float sample_shadow_array_pcf_9(float array_slice, float3 sp)
{
    float2 samples[9];
    float2 inv_sm_size = float2(1.0/2048.0, 1.0/2048.0);
    samples[0] = float2(-1.0, -1.0) * inv_sm_size;
    samples[1] = float2(-1.0, 0.0) * inv_sm_size;
    samples[2] = float2(-1.0, 1.0) * inv_sm_size;
    samples[3] = float2(0.0, -1.0) * inv_sm_size;
    samples[4] = float2(0.0, 0.0) * inv_sm_size;
    samples[5] = float2(0.0, 1.0) * inv_sm_size;
    samples[6] = float2(1.0, -1.0) * inv_sm_size;
    samples[7] = float2(1.0, 0.0) * inv_sm_size;
    samples[8] = float2(1.0, 1.0) * inv_sm_size;
    float shadow = 0.0;
    for(int j = 0; j < 9; ++j)
    {
        shadow += sample_depth_compare_array(shadowmap_texture, sp.xy + samples[j], array_slice, sp.z);
    }
    shadow /= 9.0;
    return shadow;
}
bool ray_vs_aabb(float3 emin, float3 emax, float3 r1, float3 rv, out float3 intersection)
{
    float3 dirfrac = float3(1.0, 1.0, 1.0) / rv;
    float t1 = (emin.x - r1.x)*dirfrac.x;
    float t2 = (emax.x - r1.x)*dirfrac.x;
    float t3 = (emin.y - r1.y)*dirfrac.y;
    float t4 = (emax.y - r1.y)*dirfrac.y;
    float t5 = (emin.z - r1.z)*dirfrac.z;
    float t6 = (emax.z - r1.z)*dirfrac.z;
    float tmin = max(max(min(t1, t2), min(t3, t4)), min(t5, t6));
    float tmax = min(min(max(t1, t2), max(t3, t4)), max(t5, t6));
    float t = 0.0;
    if (tmax < 0.0)
    {
        t = tmax;
        return false;
    }
    if (tmin > tmax)
    {
        t = tmax;
        return false;
    }
    t = tmin;
    intersection = r1 + rv * t;
    return true;
}
float sdf_shadow_trace(float max_samples, float3 light_pos, float3 world_pos, float3 scale, float3 ray_origin, float4x4 inv_mat, float3x3 inv_rot)
{
    float3 ray_dir = normalize(light_pos - world_pos);
    ray_dir = normalize( mul( ray_dir, inv_rot ) );
    float closest = 1.0;
    float3 uvw = ray_origin;
    if(abs(uvw.x) >= 1.0 || abs(uvw.y) >= 1.0 || abs(uvw.z) >= 1.0)
    {
        float3 emin = float3(-1.0, -1.0, -1.0);
        float3 emax = float3(1.0, 1.0, 1.0);
        float3 ip = float3(0.0, 0.0, 0.0);
        bool hit = ray_vs_aabb( emin, emax, uvw, ray_dir, ip);
        uvw = ip;
        if(!hit)
        {
            return closest;
        }
    }
    float3 light_uvw = mul( float4(light_pos, 1.0), inv_mat ).xyz * 0.5 + 0.5;
    uvw = uvw * 0.5 + 0.5;
    float3 v1 = normalize(light_uvw - uvw);
    for( int s = 0; s < int(max_samples); ++s )
    {
        float d = sample_texture_level( sdf_volume, uvw, 0.0 ).r;
        closest = min(d, closest);
        ray_dir = normalize(light_uvw - uvw);
        float3 step = ray_dir.xyz * float3(d, d, d) / scale * 0.7;
        uvw += step;
        if( d <= 0.0 )
        {
            closest = max( d, 0.0 );
            break;
        }
        if(uvw.x >= 1.0 || uvw.x < 0.0)
        break;
        if(uvw.y >= 1.0 || uvw.y < 0.0)
        break;
        if(uvw.z >= 1.0 || uvw.z < 0.0)
        break;
    }
    return closest;
}
float integrate_edge(float3 v1, float3 v2)
{
    float cos_theta = dot(v1, v2);
    float theta = acos(cos_theta);
    float res = cross(v1, v2).z * ((theta > 0.001) ? theta/sin(theta) : 1.0);
    return res;
}
void clip_quad_to_horizon(inout float3 L[5], out int n)
{
    int config = 0;
    if (L[0].z > 0.0) config += 1;
    if (L[1].z > 0.0) config += 2;
    if (L[2].z > 0.0) config += 4;
    if (L[3].z > 0.0) config += 8;
    n = 0;
    if (config == 0)
    {
    }
    else if (config == 1)
    {
        n = 3;
        L[1] = -L[1].z * L[0] + L[0].z * L[1];
        L[2] = -L[3].z * L[0] + L[0].z * L[3];
    }
    else if (config == 2)
    {
        n = 3;
        L[0] = -L[0].z * L[1] + L[1].z * L[0];
        L[2] = -L[2].z * L[1] + L[1].z * L[2];
    }
    else if (config == 3)
    {
        n = 4;
        L[2] = -L[2].z * L[1] + L[1].z * L[2];
        L[3] = -L[3].z * L[0] + L[0].z * L[3];
    }
    else if (config == 4)
    {
        n = 3;
        L[0] = -L[3].z * L[2] + L[2].z * L[3];
        L[1] = -L[1].z * L[2] + L[2].z * L[1];
    }
    else if (config == 5)
    {
        n = 0;
    }
    else if (config == 6)
    {
        n = 4;
        L[0] = -L[0].z * L[1] + L[1].z * L[0];
        L[3] = -L[3].z * L[2] + L[2].z * L[3];
    }
    else if (config == 7)
    {
        n = 5;
        L[4] = -L[3].z * L[0] + L[0].z * L[3];
        L[3] = -L[3].z * L[2] + L[2].z * L[3];
    }
    else if (config == 8)
    {
        n = 3;
        L[0] = -L[0].z * L[3] + L[3].z * L[0];
        L[1] = -L[2].z * L[3] + L[3].z * L[2];
        L[2] = L[3];
    }
    else if (config == 9)
    {
        n = 4;
        L[1] = -L[1].z * L[0] + L[0].z * L[1];
        L[2] = -L[2].z * L[3] + L[3].z * L[2];
    }
    else if (config == 10)
    {
        n = 0;
    }
    else if (config == 11)
    {
        n = 5;
        L[4] = L[3];
        L[3] = -L[2].z * L[3] + L[3].z * L[2];
        L[2] = -L[2].z * L[1] + L[1].z * L[2];
    }
    else if (config == 12)
    {
        n = 4;
        L[1] = -L[1].z * L[2] + L[2].z * L[1];
        L[0] = -L[0].z * L[3] + L[3].z * L[0];
    }
    else if (config == 13)
    {
        n = 5;
        L[4] = L[3];
        L[3] = L[2];
        L[2] = -L[1].z * L[2] + L[2].z * L[1];
        L[1] = -L[1].z * L[0] + L[0].z * L[1];
    }
    else if (config == 14)
    {
        n = 5;
        L[4] = -L[0].z * L[3] + L[3].z * L[0];
        L[0] = -L[0].z * L[1] + L[1].z * L[0];
    }
    else if (config == 15)
    {
        n = 4;
    }
    if (n == 3)
    L[3] = L[0];
    if (n == 4)
    L[4] = L[0];
}
float3 ltc_uv_coord(float3 p[4])
{
    float3 v1 = p[1] - p[0];
    float3 v2 = p[3] - p[0];
    float3 plane_ortho = (cross(v1, v2));
    float plane_area_squared = dot(plane_ortho, plane_ortho);
    float plane_distx_plane_area = dot(plane_ortho, p[0]);
    float3 pp = plane_distx_plane_area * plane_ortho / plane_area_squared - p[0];
    float v1_dot_v2 = dot(v1, v2);
    float inv_v1_dot_v1 = 1.0 / dot(v1, v1);
    float3 vv2 = v2 - v1 * v1_dot_v2 * inv_v1_dot_v1;
    float2 puv;
    puv.y = dot(vv2, pp) / dot(vv2, vv2);
    puv.x = dot(v1, pp) * inv_v1_dot_v1 - v1_dot_v2 * inv_v1_dot_v1 * puv.y;
    float d = abs(plane_distx_plane_area) / pow(plane_area_squared, 0.75);
    return float3(puv, d);
}
float4 ltc_evaluate(
float3 n,
float3 v,
float3 p,
float3x3 minv,
float3 points[4],
bool two_sided)
{
    float3 t1, t2;
    t1 = normalize(v - n * dot(v, n));
    t2 = cross(n, t1);
    float3x3 ttn = from_columns_3x3(t1, t2, n);
    minv = mul(minv, ttn);
    float3 l[5];
    l[0] = mul(minv, points[0] - p);
    l[1] = mul(minv, points[1] - p);
    l[2] = mul(minv, points[2] - p);
    l[3] = mul(minv, points[3] - p);
    l[4] = l[3];
    float3 ll[4];
    ll[0] = l[0];
    ll[1] = l[1];
    ll[2] = l[2];
    ll[3] = l[3];
    float3 uvl = ltc_uv_coord(ll);
    int nc;
    clip_quad_to_horizon(l, nc);
    if (nc == 0)
    return float4(0, 0, 0, 0.0);
    l[0] = normalize(l[0]);
    l[1] = normalize(l[1]);
    l[2] = normalize(l[2]);
    l[3] = normalize(l[3]);
    l[4] = normalize(l[4]);
    float sum = 0.0;
    sum += integrate_edge(l[0], l[1]);
    sum += integrate_edge(l[1], l[2]);
    sum += integrate_edge(l[2], l[3]);
    if (nc >= 4)
    sum += integrate_edge(l[3], l[4]);
    if (nc == 5)
    sum += integrate_edge(l[4], l[0]);
    sum = two_sided ? abs(sum) : max(0.0, sum);
    float3 lo_i = float3(sum, sum, sum);
    return float4(uvl.x, uvl.y, uvl.z, sum);
}
float ltc_evaluate_cc(
float3 n,
float3 v,
float3 p,
float3x3 minv,
float3 points[4],
bool two_sided)
{
    float3 t1, t2;
    t1 = normalize(v - n * dot(v, n));
    t2 = cross(n, t1);
    float3x3 ttn = from_columns_3x3(t1, t2, n);
    minv = mul(minv, ttn);
    float3 l[5];
    for(int i = 0; i < 4; ++i)
    l[i] = mul(minv, points[i] - p);
    l[4] = l[3];
    int nc;
    clip_quad_to_horizon(l, nc);
    if (nc == 0)
    return 0.0;
    for(int i = 0; i < 5; ++i)
    l[i] = normalize(l[i]);
    float sum = 0.0;
    sum += integrate_edge(l[0], l[1]);
    sum += integrate_edge(l[1], l[2]);
    sum += integrate_edge(l[2], l[3]);
    if (nc >= 4)
    sum += integrate_edge(l[3], l[4]);
    if (nc == 5)
    sum += integrate_edge(l[4], l[0]);
    sum = two_sided ? abs(sum) : max(0.0, sum);
    return sum;
}
float4 area_light_specular_uv(
float3 points[4],
float3 pos,
float roughness,
float3 n,
float3 v)
{
    float pi = 3.14159265359;
    float lut_size = 64.0;
    float lut_scale = (lut_size - 1.0)/lut_size;
    float lut_bias = 0.5/lut_size;
    float theta = acos(dot(n, v));
    float2 uv = float2(roughness, theta / (0.5 * pi));
    uv = uv * lut_scale + lut_bias;
    float4 mat = sample_texture(ltc_mat, uv);
    float mag = sample_texture(ltc_mag, uv).w;
    float3x3 minv = from_rows_3x3(
    float3(1.0, 0.0, mat.y),
    float3(0.0, mat.z, 0.0),
    float3(mat.w, 0.0, mat.x)
    );
    float4 spec = ltc_evaluate(n, v, pos, minv, points, true);
    return spec;
}
float area_light_specular(
float3 points[4],
float3 pos,
float roughness,
float3 n,
float3 v)
{
    float pi = 3.14159265359;
    float lut_size = 64.0;
    float lut_scale = (lut_size - 1.0)/lut_size;
    float lut_bias = 0.5/lut_size;
    float theta = acos(dot(n, v));
    float2 uv = float2(roughness, theta / (0.5 * pi));
    uv = uv * lut_scale + lut_bias;
    float4 mat = sample_texture(ltc_mat, uv);
    float mag = sample_texture(ltc_mag, uv).w;
    float3x3 minv = from_rows_3x3(
    float3(1.0, 0.0, mat.y),
    float3(0.0, mat.z, 0.0),
    float3(mat.w, 0.0, mat.x)
    );
    float spec = ltc_evaluate_cc(n, v, pos, minv, points, true);
    return spec;
}
float4 area_light_diffuse_uv(
float3 points[4],
float3 pos,
float3 n,
float3 v)
{
    float3x3 difv = float3x3(
    float3(1.0, 0.0, 0.0),
    float3(0.0, 1.0, 0.0),
    float3(0.0, 0.0, 1.0)
    );
    float4 diff = ltc_evaluate(n, v, pos, difv, points, true);
    return diff;
}
float area_light_diffuse(
float3 points[4],
float3 pos,
float3 n,
float3 v)
{
    float3x3 difv = float3x3(
    float3(1.0, 0.0, 0.0),
    float3(0.0, 1.0, 0.0),
    float3(0.0, 0.0, 1.0)
    );
    float diff = ltc_evaluate_cc(n, v, pos, difv, points, true);
    return diff;
}
float3 transform_ts_normal( float3 t, float3 b, float3 n, float3 ts_normal )
{
    float3x3 tbn;
    tbn[0] = float3(t.x, b.x, n.x);
    tbn[1] = float3(t.y, b.y, n.y);
    tbn[2] = float3(t.z, b.z, n.z);
    return normalize( mul_tbn( tbn, ts_normal ) );
}
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.world_pos = world_pos_vs_output;
    _input.normal = normal_vs_output;
    _input.tangent = tangent_vs_output;
    _input.bitangent = bitangent_vs_output;
    _input.texcoord = texcoord_vs_output;
    _input.colour = colour_vs_output;
    ps_output _output;
    float4 albedo = sample_texture( diffuse_texture, _input.texcoord.xy );
    float3 normal_sample = sample_texture( normal_texture, _input.texcoord.xy ).rgb;
    float4 ro_sample = sample_texture( specular_texture, _input.texcoord.xy );
    float4 specular_sample = float4(1.0, 1.0, 1.0, 1.0);
    normal_sample = normal_sample * 2.0 - 1.0;
    float3 n = transform_ts_normal(
    _input.tangent,
    _input.bitangent,
    _input.normal,
    normal_sample );
    albedo *= _input.colour;
    float4 metalness = float4(1.0, 1.0, 1.0, 1.0);
    float3 lit_colour = float3( 0.0, 0.0, 0.0 );
    float reflectivity = saturate(user_data.z);
    float roughness = saturate(user_data.y);
    reflectivity = m_reflectivity;
    roughness = ro_sample.r;
    n = _input.normal.rgb;
    roughness = m_roughness;
    float max_samples = 128.0;
    float3x3 inv_rot = to_3x3(sdf_shadow.world_matrix_inv);
    float3 r1 = _input.world_pos.xyz + _input.normal.xyz * m_surface_offset;
    float3 tr1 = mul( float4(r1, 1.0), sdf_shadow.world_matrix_inv ).xyz;
    float3 scale = float3(length(sdf_shadow.world_matrix[0].xyz), length(sdf_shadow.world_matrix[1].xyz), length(sdf_shadow.world_matrix[2].xyz)) * 2.0;
    float3 vddx = ddx( r1 );
    float3 vddy = ddy( r1 );
    float t = 1.0;
    float3 lll = float3(0.0, 0.0, 0.0);
    int shadow_map_index = 0;
    _pmfx_loop
    for( int i = 0; i < int(light_info.x); ++i )
    {
        float3 light_col = float3( 0.0, 0.0, 0.0 );
        light_col += cook_torrence(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        albedo.rgb,
        metalness.rgb,
        roughness,
        reflectivity
        );
        light_col += oren_nayar(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        1.0 - roughness,
        albedo.rgb
        );
        float s = sdf_shadow_trace(max_samples, lights[i].pos_radius.xyz, _input.world_pos.xyz, scale, tr1, sdf_shadow.world_matrix_inv, inv_rot);
        light_col *= smoothstep( 0.0, 0.1, s);
        if( lights[i].colour.a == 0.0 )
        {
            lit_colour += light_col;
            continue;
        }
        else
        {
            float shadow = 1.0;
            float d = 1.0;
            float4 offset_pos = float4(_input.world_pos.xyz + n.xyz * 0.01, 1.0);
            float4 sp = mul( offset_pos, shadow_matrix[i] );
            sp.xyz /= sp.w;
            sp.y *= -1.0;
            sp.xy = sp.xy * 0.5 + 0.5;
            sp.z = remap_depth(sp.z);
            shadow = sample_shadow_array_pcf_9(float(shadow_map_index), sp.xyz);
            lit_colour += light_col * shadow;
            ++shadow_map_index;
        }
    }
    int point_start = int(light_info.x);
    int point_end = int(light_info.x) + int(light_info.y);
    int omni_shadow_index = 0;
    _pmfx_loop
    for( int i = point_start; i < point_end; ++i )
    {
        float3 light_col = float3( 0.0, 0.0, 0.0 );
        light_col += cook_torrence(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        albedo.rgb,
        metalness.rgb,
        roughness,
        reflectivity
        );
        light_col += oren_nayar(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        roughness,
        albedo.rgb
        );
        float a = point_light_attenuation_cutoff( lights[i].pos_radius, _input.world_pos.xyz );
        light_col *= a;
        float s = sdf_shadow_trace(max_samples, lights[i].pos_radius.xyz, _input.world_pos.xyz, scale, tr1, sdf_shadow.world_matrix_inv, inv_rot);
        light_col *= smoothstep( 0.0, 0.1, s);
        if( lights[i].colour.a == 0.0)
        {
            lit_colour += light_col;
            continue;
        }
        else
        {
            lit_colour += light_col;
            continue;
        }
    }
    int spot_start = point_end;
    int spot_end = spot_start + int(light_info.z);
    _pmfx_loop
    for(int i = spot_start; i < spot_end; ++i )
    {
        float3 light_col = float3( 0.0, 0.0, 0.0 );
        light_col += cook_torrence(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        albedo.rgb,
        metalness.rgb,
        roughness,
        reflectivity
        );
        light_col += oren_nayar(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        roughness,
        albedo.rgb
        );
        float a = spot_light_attenuation(lights[i].pos_radius,
        lights[i].dir_cutoff,
        lights[i].data.x,
        _input.world_pos.xyz );
        light_col *= a;
        float s = sdf_shadow_trace(max_samples, lights[i].pos_radius.xyz, _input.world_pos.xyz, scale, tr1, sdf_shadow.world_matrix_inv, inv_rot);
        light_col *= smoothstep( 0.0, 0.1, s);
        if( lights[i].colour.a == 0.0 )
        {
            lit_colour += light_col;
            continue;
        }
        else
        {
            float shadow = 1.0;
            float d = 1.0;
            float4 offset_pos = float4(_input.world_pos.xyz + n.xyz * 0.01, 1.0);
            float4 sp = mul( offset_pos, shadow_matrix[shadow_map_index] );
            sp.xyz /= sp.w;
            sp.y *= -1.0;
            sp.xy = sp.xy * 0.5 + 0.5;
            sp.z = remap_depth(sp.z);
            shadow = sample_shadow_array_pcf_9(float(shadow_map_index), sp.xyz);
            lit_colour += light_col * shadow;
            ++shadow_map_index;
        }
    }
    {
        float pi = 3.14159265359;
        int num_area_lights = int(area_light_info.x);
        for(int i = 0; i < num_area_lights; ++i)
        {
            float3 v = -normalize(_input.world_pos.xyz - camera_view_pos.xyz);
            float3 pos = _input.world_pos.xyz;
            float3 points[4];
            for(int j = 0; j < 4; ++j)
            points[j] = area_lights[i].corners[j].xyz;
            float diff_sum = area_light_diffuse(points, pos, n, v);
            float3 diff = area_lights[i].colour.rgb * diff_sum;
            float spec_sum = area_light_specular(points, pos, ro_sample.x, n, v);
            float3 spec = area_lights[i].colour.rgb * spec_sum;
            float3 light_col = (spec.rgb + diff.rgb) / (2.0 * pi);
            lit_colour += light_col;
        }
        int ts = num_area_lights;
        int num_area_lights_textured = int(area_light_info.y);
        for(int i = ts; i < ts + num_area_lights_textured; ++i)
        {
            float slice = area_lights[i].colour.w;
            float levels = 8.0;
            float2 inv_texel = float2(1.0/640.0, 1.0/480.0);
            float2 inv_texel_x = float2(1.0, 1.0) - inv_texel;
            float3 points[4];
            for(int j = 0; j < 4; ++j)
            points[j] = area_lights[i].corners[j].xyz;
            float3 v = -normalize(_input.world_pos.xyz - camera_view_pos.xyz);
            float3 pos = _input.world_pos.xyz;
            float4 diff_uv = area_light_diffuse_uv(points, pos, n, v);
            float2 duv = clamp(diff_uv.xy, inv_texel, inv_texel_x);
            float3 diff = sample_texture_array_level( area_light_textures, duv, slice, diff_uv.z * levels).rgb * diff_uv.w;
            float4 spec_uv = area_light_specular_uv(points, pos, ro_sample.x, n, v);
            float2 suv = clamp(spec_uv.xy, inv_texel, inv_texel_x);
            float3 spec = sample_texture_array_level(area_light_textures, suv, slice, spec_uv.z * levels).rgb * spec_uv.w;
            float3 light_col = (spec.rgb + diff.rgb) / (2.0 * pi);
            lit_colour += light_col;
        }
    }
    _output.colour.rgb = lit_colour.rgb * albedo.a;
    _output.colour.a = albedo.a;
    if(albedo.a <= 0.0)
    discard;
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
{
    "cmdline": "../third_party/pmbuild/scripts/pmfx-shader/build_pmfx.py -shader_platform gles -shader_version 300 -i assets/shaders ../assets/shaders -o build/web/data/pmfx/glsl -h shader_structs -t temp/shaders -v_flip -source ",
    "files": [
        {
            "name": "/Users/alex.dixon/dev/pmtech/third_party/pmbuild/scripts/pmfx-shader/build_pmfx.py",
            "timestamp": 1608637107.3205462
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/third_party/pmbuild/scripts/pmfx-shader/platform/pmfx.h",
            "timestamp": 1605953217.8167121
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/third_party/pmbuild/scripts/pmfx-shader/platform/glsl.h",
            "timestamp": 1608635330.6987193
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/examples/../assets/shaders/forward_render.pmfx",
            "timestamp": 1608721556.2862499
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/examples/../assets/shaders/libs/lighting.pmfx",
            "timestamp": 1608572067.1994717
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/examples/../assets/shaders/libs/skinning.pmfx",
            "timestamp": 1608572067.2003047
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/examples/../assets/shaders/libs/globals.pmfx",
            "timestamp": 1608572067.200933
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/examples/../assets/shaders/libs/sdf.pmfx",
            "timestamp": 1608572067.2005048
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/examples/../assets/shaders/libs/area_lights.pmfx",
            "timestamp": 1608572067.201319
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/examples/../assets/shaders/libs/maths.pmfx",
            "timestamp": 1608572067.2011206
        }
    ],
    "techniques": [
        {
            "vs": "vs_main_zonly_wp",
            "ps": "ps_omni_shadow",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                }
            },
            "name": "omni_shadow",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "ltc_mat",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 13
                },
                {
                    "name": "ltc_mag",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 12
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                },
                {
                    "name": "volume_gi",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 9
                },
                {
                    "name": "single_shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d",
                    "unit": 7
                },
                {
                    "name": "shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d_array",
                    "unit": 15
                },
                {
                    "name": "shadowmap_texture_sss",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "vs_file": "omni_shadow.vsc",
            "ps_file": "omni_shadow.psc",
            "permutation_id": 0,
            "permutation_option_mask": 3221225472
        },
        {
            "vs": "vs_main_zonly_wp",
            "ps": "ps_omni_shadow",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                }
            },
            "name": "omni_shadow",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "ltc_mat",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 13
                },
                {
                    "name": "ltc_mag",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 12
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                },
                {
                    "name": "volume_gi",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 9
                },
                {
                    "name": "single_shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d",
                    "unit": 7
                },
                {
                    "name": "shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d_array",
                    "unit": 15
                },
                {
                    "name": "shadowmap_texture_sss",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "blend_indices",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                },
                {
                    "name": "blend_weights",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 96
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "vs_file": "omni_shadow__2147483648__.vsc",
            "ps_file": "omni_shadow.psc",
            "permutation_id": 2147483648,
            "permutation_option_mask": 3221225472
        },
        {
            "vs": "vs_main_zonly_wp",
            "ps": "ps_omni_shadow",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                }
            },
            "name": "omni_shadow",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "ltc_mat",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 13
                },
                {
                    "name": "ltc_mag",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 12
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                },
                {
                    "name": "volume_gi",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 9
                },
                {
                    "name": "single_shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d",
                    "unit": 7
                },
                {
                    "name": "shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d_array",
                    "unit": 15
                },
                {
                    "name": "shadowmap_texture_sss",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                }
            ],
            "instance_inputs": [
                {
                    "name": "world_matrix_0",
                    "semantic_index": 6,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_matrix_1",
                    "semantic_index": 7,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "world_matrix_2",
                    "semantic_index": 8,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "world_matrix_3",
                    "semantic_index": 9,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "user_data",
                    "semantic_index": 10,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "user_data2",
                    "semantic_index": 11,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                }
            ],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "vs_file": "omni_shadow__1073741824__.vsc",
            "ps_file": "omni_shadow.psc",
            "permutation_id": 1073741824,
            "permutation_option_mask": 3221225472
        },
        {
            "vs": "vs_main_zonly_wp",
            "ps": "ps_omni_shadow",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                }
            },
            "name": "omni_shadow",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "ltc_mat",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 13
                },
                {
                    "name": "ltc_mag",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 12
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                },
                {
                    "name": "volume_gi",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 9
                },
                {
                    "name": "single_shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d",
                    "unit": 7
                },
                {
                    "name": "shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d_array",
                    "unit": 15
                },
                {
                    "name": "shadowmap_texture_sss",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "blend_indices",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                },
                {
                    "name": "blend_weights",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 96
                }
            ],
            "instance_inputs": [
                {
                    "name": "world_matrix_0",
                    "semantic_index": 6,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_matrix_1",
                    "semantic_index": 7,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "world_matrix_2",
                    "semantic_index": 8,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "world_matrix_3",
                    "semantic_index": 9,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "user_data",
                    "semantic_index": 10,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "user_data2",
                    "semantic_index": 11,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                }
            ],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "vs_file": "omni_shadow__3221225472__.vsc",
            "ps_file": "omni_shadow.psc",
            "permutation_id": 3221225472,
            "permutation_option_mask": 3221225472
        },
        {
            "vs": "vs_main",
            "ps": "ps_forward_lit",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                },
                "UV_SCALE": {
                    "val": 2,
                    "type": "checkbox"
                },
                "SDF_SHADOW": {
                    "val": 8,
                    "type": "checkbox"
                },
                "GI": {
                    "val": 16,
                    "type": "checkbox"
                }
            },
            "constants": {
                "albedo": {
                    "type": "float4",
                    "widget": "colour",
                    "default": [
                        1.0,
                        1.0,
                        1.0,
                        1.0
                    ],
                    "offset": 0,
                    "num_elements": 4
                },
                "roughness": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.5,
                    "offset": 4,
                    "num_elements": 1
                },
                "reflectivity": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.3,
                    "offset": 5,
                    "num_elements": 1
                }
            },
            "texture_samplers": {
                "albedo": {
                    "type": "texture_2d",
                    "unit": 0,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/albedo.dds"
                },
                "normals": {
                    "type": "texture_2d",
                    "unit": 1,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/normal.dds"
                },
                "roughness": {
                    "type": "texture_2d",
                    "unit": 2,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/spec.dds"
                },
                "metalness": {
                    "type": "texture_2d",
                    "unit": 3,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/black.dds"
                }
            },
            "constants_used_bytes": 24,
            "constants_size_bytes": 32,
            "name": "forward_lit",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "ltc_mat",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 13
                },
                {
                    "name": "ltc_mag",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 12
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                },
                {
                    "name": "volume_gi",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 9
                },
                {
                    "name": "single_shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d",
                    "unit": 7
                },
                {
                    "name": "shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d_array",
                    "unit": 15
                },
                {
                    "name": "shadowmap_texture_sss",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                },
                {
                    "name": "albedo",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normals",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "roughness",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "metalness",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 3
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "material_data",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                },
                {
                    "name": "colour",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 84
                }
            ],
            "vs_file": "forward_lit.vsc",
            "ps_file": "forward_lit.psc",
            "permutation_id": 0,
            "permutation_option_mask": 3221225498
        },
        {
            "vs": "vs_main",
            "ps": "ps_forward_lit",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                },
                "UV_SCALE": {
                    "val": 2,
                    "type": "checkbox"
                },
                "SDF_SHADOW": {
                    "val": 8,
                    "type": "checkbox"
                },
                "GI": {
                    "val": 16,
                    "type": "checkbox"
                }
            },
            "constants": {
                "albedo": {
                    "type": "float4",
                    "widget": "colour",
                    "default": [
                        1.0,
                        1.0,
                        1.0,
                        1.0
                    ],
                    "offset": 0,
                    "num_elements": 4
                },
                "roughness": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.5,
                    "offset": 4,
                    "num_elements": 1
                },
                "reflectivity": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.3,
                    "offset": 5,
                    "num_elements": 1
                }
            },
            "texture_samplers": {
                "albedo": {
                    "type": "texture_2d",
                    "unit": 0,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/albedo.dds"
                },
                "normals": {
                    "type": "texture_2d",
                    "unit": 1,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/normal.dds"
                },
                "roughness": {
                    "type": "texture_2d",
                    "unit": 2,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/spec.dds"
                },
                "metalness": {
                    "type": "texture_2d",
                    "unit": 3,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/black.dds"
                }
            },
            "constants_used_bytes": 24,
            "constants_size_bytes": 32,
            "name": "forward_lit",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "ltc_mat",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 13
                },
                {
                    "name": "ltc_mag",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 12
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                },
                {
                    "name": "volume_gi",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 9
                },
                {
                    "name": "single_shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d",
                    "unit": 7
                },
                {
                    "name": "shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d_array",
                    "unit": 15
                },
                {
                    "name": "shadowmap_texture_sss",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                },
                {
                    "name": "albedo",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normals",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "roughness",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "metalness",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 3
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "material_data",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "blend_indices",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                },
                {
                    "name": "blend_weights",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 96
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                },
                {
                    "name": "colour",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 84
                }
            ],
            "vs_file": "forward_lit__2147483648__.vsc",
            "ps_file": "forward_lit.psc",
            "permutation_id": 2147483648,
            "permutation_option_mask": 3221225498
        },
        {
            "vs": "vs_main",
            "ps": "ps_forward_lit",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                },
                "UV_SCALE": {
                    "val": 2,
                    "type": "checkbox"
                },
                "SDF_SHADOW": {
                    "val": 8,
                    "type": "checkbox"
                },
                "GI": {
                    "val": 16,
                    "type": "checkbox"
                }
            },
            "constants": {
                "albedo": {
                    "type": "float4",
                    "widget": "colour",
                    "default": [
                        1.0,
                        1.0,
                        1.0,
                        1.0
                    ],
                    "offset": 0,
                    "num_elements": 4
                },
                "roughness": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.5,
                    "offset": 4,
                    "num_elements": 1
                },
                "reflectivity": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.3,
                    "offset": 5,
                    "num_elements": 1
                }
            },
            "texture_samplers": {
                "albedo": {
                    "type": "texture_2d",
                    "unit": 0,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/albedo.dds"
                },
                "normals": {
                    "type": "texture_2d",
                    "unit": 1,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/normal.dds"
                },
                "roughness": {
                    "type": "texture_2d",
                    "unit": 2,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/spec.dds"
                },
                "metalness": {
                    "type": "texture_2d",
                    "unit": 3,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/black.dds"
                }
            },
            "constants_used_bytes": 24,
            "constants_size_bytes": 32,
            "name": "forward_lit",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "ltc_mat",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 13
                },
                {
                    "name": "ltc_mag",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 12
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                },
                {
                    "name": "volume_gi",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 9
                },
                {
                    "name": "single_shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d",
                    "unit": 7
                },
                {
                    "name": "shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d_array",
                    "unit": 15
                },
                {
                    "name": "shadowmap_texture_sss",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                },
                {
                    "name": "albedo",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normals",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "roughness",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "metalness",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 3
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "material_data",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                }
            ],
            "instance_inputs": [
                {
                    "name": "world_matrix_0",
                    "semantic_index": 6,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_matrix_1",
                    "semantic_index": 7,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "world_matrix_2",
                    "semantic_index": 8,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "world_matrix_3",
                    "semantic_index": 9,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "user_data",
                    "semantic_index": 10,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "user_data2",
                    "semantic_index": 11,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                }
            ],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                },
                {
                    "name": "colour",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 84
                }
            ],
            "vs_file": "forward_lit__1073741824__.vsc",
            "ps_file": "forward_lit__1073741824__.psc",
            "permutation_id": 1073741824,
            "permutation_option_mask": 3221225498
        },
        {
            "vs": "vs_main",
            "ps": "ps_forward_lit",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                },
                "UV_SCALE": {
                    "val": 2,
                    "type": "checkbox"
                },
                "SDF_SHADOW": {
                    "val": 8,
                    "type": "checkbox"
                },
                "GI": {
                    "val": 16,
                    "type": "checkbox"
                }
            },
            "constants": {
                "albedo": {
                    "type": "float4",
                    "widget": "colour",
                    "default": [
                        1.0,
                        1.0,
                        1.0,
                        1.0
                    ],
                    "offset": 0,
                    "num_elements": 4
                },
                "roughness": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.5,
                    "offset": 4,
                    "num_elements": 1
                },
                "reflectivity": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.3,
                    "offset": 5,
                    "num_elements": 1
                }
            },
            "texture_samplers": {
                "albedo": {
                    "type": "texture_2d",
                    "unit": 0,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/albedo.dds"
                },
                "normals": {
                    "type": "texture_2d",
                    "unit": 1,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/normal.dds"
                },
                "roughness": {
                    "type": "texture_2d",
                    "unit": 2,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/spec.dds"
                },
                "metalness": {
                    "type": "texture_2d",
                    "unit": 3,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/black.dds"
                }
            },
            "constants_used_bytes": 24,
            "constants_size_bytes": 32,
            "name": "forward_lit",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "ltc_mat",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 13
                },
                {
                    "name": "ltc_mag",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 12
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                },
                {
                    "name": "volume_gi",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 9
                },
                {
                    "name": "single_shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d",
                    "unit": 7
                },
                {
                    "name": "shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d_array",
                    "unit": 15
                },
                {
                    "name": "shadowmap_texture_sss",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                },
                {
                    "name": "albedo",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normals",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "roughness",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "metalness",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 3
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "material_data",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "blend_indices",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                },
                {
                    "name": "blend_weights",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 96
                }
            ],
            "instance_inputs": [
                {
                    "name": "world_matrix_0",
                    "semantic_index": 6,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_matrix_1",
                    "semantic_index": 7,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "world_matrix_2",
                    "semantic_index": 8,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "world_matrix_3",
                    "semantic_index": 9,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "user_data",
                    "semantic_index": 10,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "user_data2",
                    "semantic_index": 11,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                }
            ],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                },
                {
                    "name": "colour",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 84
                }
            ],
            "vs_file": "forward_lit__3221225472__.vsc",
            "ps_file": "forward_lit__1073741824__.psc",
            "permutation_id": 3221225472,
            "permutation_option_mask": 3221225498
        },
        {
            "vs": "vs_main",
            "ps": "ps_forward_lit",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                },
                "UV_SCALE": {
                    "val": 2,
                    "type": "checkbox"
                },
                "SDF_SHADOW": {
                    "val": 8,
                    "type": "checkbox"
                },
                "GI": {
                    "val": 16,
                    "type": "checkbox"
                }
            },
            "constants": {
                "albedo": {
                    "type": "float4",
                    "widget": "colour",
                    "default": [
                        1.0,
                        1.0,
                        1.0,
                        1.0
                    ],
                    "offset": 0,
                    "num_elements": 4
                },
                "uv_scale": {
                    "type": "float2",
                    "widget": "slider",
                    "min": 0,
                    "max": 100,
                    "default": 1.0,
                    "offset": 4,
                    "num_elements": 2
                },
                "roughness": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.5,
                    "offset": 6,
                    "num_elements": 1
                },
                "reflectivity": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.3,
                    "offset": 7,
                    "num_elements": 1
                }
            },
            "texture_samplers": {
                "albedo": {
                    "type": "texture_2d",
                    "unit": 0,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/albedo.dds"
                },
                "normals": {
                    "type": "texture_2d",
                    "unit": 1,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/normal.dds"
                },
                "roughness": {
                    "type": "texture_2d",
                    "unit": 2,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/spec.dds"
                },
                "metalness": {
                    "type": "texture_2d",
                    "unit": 3,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/black.dds"
                }
            },
            "constants_used_bytes": 32,
            "constants_size_bytes": 32,
            "name": "forward_lit",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "ltc_mat",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 13
                },
                {
                    "name": "ltc_mag",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 12
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                },
                {
                    "name": "volume_gi",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 9
                },
                {
                    "name": "single_shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d",
                    "unit": 7
                },
                {
                    "name": "shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d_array",
                    "unit": 15
                },
                {
                    "name": "shadowmap_texture_sss",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                },
                {
                    "name": "albedo",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normals",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "roughness",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "metalness",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 3
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "material_data",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                },
                {
                    "name": "colour",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 84
                }
            ],
            "vs_file": "forward_lit__2__.vsc",
            "ps_file": "forward_lit__2__.psc",
            "permutation_id": 2,
            "permutation_option_mask": 3221225498
        },
        {
            "vs": "vs_main",
            "ps": "ps_forward_lit",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                },
                "UV_SCALE": {
                    "val": 2,
                    "type": "checkbox"
                },
                "SDF_SHADOW": {
                    "val": 8,
                    "type": "checkbox"
                },
                "GI": {
                    "val": 16,
                    "type": "checkbox"
                }
            },
            "constants": {
                "albedo": {
                    "type": "float4",
                    "widget": "colour",
                    "default": [
                        1.0,
                        1.0,
                        1.0,
                        1.0
                    ],
                    "offset": 0,
                    "num_elements": 4
                },
                "uv_scale": {
                    "type": "float2",
                    "widget": "slider",
                    "min": 0,
                    "max": 100,
                    "default": 1.0,
                    "offset": 4,
                    "num_elements": 2
                },
                "roughness": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.5,
                    "offset": 6,
                    "num_elements": 1
                },
                "reflectivity": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.3,
                    "offset": 7,
                    "num_elements": 1
                }
            },
            "texture_samplers": {
                "albedo": {
                    "type": "texture_2d",
                    "unit": 0,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/albedo.dds"
                },
                "normals": {
                    "type": "texture_2d",
                    "unit": 1,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/normal.dds"
                },
                "roughness": {
                    "type": "texture_2d",
                    "unit": 2,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/spec.dds"
                },
                "metalness": {
                    "type": "texture_2d",
                    "unit": 3,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/black.dds"
                }
            },
            "constants_used_bytes": 32,
            "constants_size_bytes": 32,
            "name": "forward_lit",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "ltc_mat",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 13
                },
                {
                    "name": "ltc_mag",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 12
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                },
                {
                    "name": "volume_gi",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 9
                },
                {
                    "name": "single_shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d",
                    "unit": 7
                },
                {
                    "name": "shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d_array",
                    "unit": 15
                },
                {
                    "name": "shadowmap_texture_sss",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                },
                {
                    "name": "albedo",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normals",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "roughness",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "metalness",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 3
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "material_data",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "blend_indices",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                },
                {
                    "name": "blend_weights",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 96
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                },
                {
                    "name": "colour",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 84
                }
            ],
            "vs_file": "forward_lit__2147483650__.vsc",
            "ps_file": "forward_lit__2__.psc",
            "permutation_id": 2147483650,
            "permutation_option_mask": 3221225498
        },
        {
            "vs": "vs_main",
            "ps": "ps_forward_lit",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                },
                "UV_SCALE": {
                    "val": 2,
                    "type": "checkbox"
                },
                "SDF_SHADOW": {
                    "val": 8,
                    "type": "checkbox"
                },
                "GI": {
                    "val": 16,
                    "type": "checkbox"
                }
            },
            "constants": {
                "albedo": {
                    "type": "float4",
                    "widget": "colour",
                    "default": [
                        1.0,
                        1.0,
                        1.0,
                        1.0
                    ],
                    "offset": 0,
                    "num_elements": 4
                },
                "uv_scale": {
                    "type": "float2",
                    "widget": "slider",
                    "min": 0,
                    "max": 100,
                    "default": 1.0,
                    "offset": 4,
                    "num_elements": 2
                },
                "roughness": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.5,
                    "offset": 6,
                    "num_elements": 1
                },
                "reflectivity": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.3,
                    "offset": 7,
                    "num_elements": 1
                }
            },
            "texture_samplers": {
                "albedo": {
                    "type": "texture_2d",
                    "unit": 0,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/albedo.dds"
                },
                "normals": {
                    "type": "texture_2d",
                    "unit": 1,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/normal.dds"
                },
                "roughness": {
                    "type": "texture_2d",
                    "unit": 2,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/spec.dds"
                },
                "metalness": {
                    "type": "texture_2d",
                    "unit": 3,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/black.dds"
                }
            },
            "constants_used_bytes": 32,
            "constants_size_bytes": 32,
            "name": "forward_lit",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "ltc_mat",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 13
                },
                {
                    "name": "ltc_mag",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 12
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                },
                {
                    "name": "volume_gi",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 9
                },
                {
                    "name": "single_shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d",
                    "unit": 7
                },
                {
                    "name": "shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d_array",
                    "unit": 15
                },
                {
                    "name": "shadowmap_texture_sss",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                },
                {
                    "name": "albedo",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normals",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "roughness",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "metalness",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 3
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "material_data",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                }
            ],
            "instance_inputs": [
                {
                    "name": "world_matrix_0",
                    "semantic_index": 6,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_matrix_1",
                    "semantic_index": 7,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "world_matrix_2",
                    "semantic_index": 8,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "world_matrix_3",
                    "semantic_index": 9,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "user_data",
                    "semantic_index": 10,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "user_data2",
                    "semantic_index": 11,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                }
            ],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                },
                {
                    "name": "colour",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 84
                }
            ],
            "vs_file": "forward_lit__1073741826__.vsc",
            "ps_file": "forward_lit__1073741826__.psc",
            "permutation_id": 1073741826,
            "permutation_option_mask": 3221225498
        },
        {
            "vs": "vs_main",
            "ps": "ps_forward_lit",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                },
                "UV_SCALE": {
                    "val": 2,
                    "type": "checkbox"
                },
                "SDF_SHADOW": {
                    "val": 8,
                    "type": "checkbox"
                },
                "GI": {
                    "val": 16,
                    "type": "checkbox"
                }
            },
            "constants": {
                "albedo": {
                    "type": "float4",
                    "widget": "colour",
                    "default": [
                        1.0,
                        1.0,
                        1.0,
                        1.0
                    ],
                    "offset": 0,
                    "num_elements": 4
                },
                "uv_scale": {
                    "type": "float2",
                    "widget": "slider",
                    "min": 0,
                    "max": 100,
                    "default": 1.0,
                    "offset": 4,
                    "num_elements": 2
                },
                "roughness": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.5,
                    "offset": 6,
                    "num_elements": 1
                },
                "reflectivity": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.3,
                    "offset": 7,
                    "num_elements": 1
                }
            },
            "texture_samplers": {
                "albedo": {
                    "type": "texture_2d",
                    "unit": 0,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/albedo.dds"
                },
                "normals": {
                    "type": "texture_2d",
                    "unit": 1,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/normal.dds"
                },
                "roughness": {
                    "type": "texture_2d",
                    "unit": 2,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/spec.dds"
                },
                "metalness": {
                    "type": "texture_2d",
                    "unit": 3,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/black.dds"
                }
            },
            "constants_used_bytes": 32,
            "constants_size_bytes": 32,
            "name": "forward_lit",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "ltc_mat",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 13
                },
                {
                    "name": "ltc_mag",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 12
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                },
                {
                    "name": "volume_gi",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 9
                },
                {
                    "name": "single_shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d",
                    "unit": 7
                },
                {
                    "name": "shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d_array",
                    "unit": 15
                },
                {
                    "name": "shadowmap_texture_sss",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                },
                {
                    "name": "albedo",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normals",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "roughness",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "metalness",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 3
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "material_data",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "blend_indices",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                },
                {
                    "name": "blend_weights",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 96
                }
            ],
            "instance_inputs": [
                {
                    "name": "world_matrix_0",
                    "semantic_index": 6,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_matrix_1",
                    "semantic_index": 7,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "world_matrix_2",
                    "semantic_index": 8,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "world_matrix_3",
                    "semantic_index": 9,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "user_data",
                    "semantic_index": 10,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "user_data2",
                    "semantic_index": 11,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                }
            ],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                },
                {
                    "name": "colour",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 84
                }
            ],
            "vs_file": "forward_lit__3221225474__.vsc",
            "ps_file": "forward_lit__1073741826__.psc",
            "permutation_id": 3221225474,
            "permutation_option_mask": 3221225498
        },
        {
            "vs": "vs_main",
            "ps": "ps_forward_lit",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                },
                "UV_SCALE": {
                    "val": 2,
                    "type": "checkbox"
                },
                "SDF_SHADOW": {
                    "val": 8,
                    "type": "checkbox"
                },
                "GI": {
                    "val": 16,
                    "type": "checkbox"
                }
            },
            "constants": {
                "albedo": {
                    "type": "float4",
                    "widget": "colour",
                    "default": [
                        1.0,
                        1.0,
                        1.0,
                        1.0
                    ],
                    "offset": 0,
                    "num_elements": 4
                },
                "roughness": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.5,
                    "offset": 4,
                    "num_elements": 1
                },
                "reflectivity": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.3,
                    "offset": 5,
                    "num_elements": 1
                },
                "surface_offset": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 1.0,
                    "offset": 6,
                    "num_elements": 1
                }
            },
            "texture_samplers": {
                "albedo": {
                    "type": "texture_2d",
                    "unit": 0,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/albedo.dds"
                },
                "normals": {
                    "type": "texture_2d",
                    "unit": 1,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/normal.dds"
                },
                "roughness": {
                    "type": "texture_2d",
                    "unit": 2,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/spec.dds"
                },
                "metalness": {
                    "type": "texture_2d",
                    "unit": 3,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/black.dds"
                }
            },
            "constants_used_bytes": 28,
            "constants_size_bytes": 32,
            "name": "forward_lit",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "ltc_mat",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 13
                },
                {
                    "name": "ltc_mag",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 12
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                },
                {
                    "name": "volume_gi",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 9
                },
                {
                    "name": "single_shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d",
                    "unit": 7
                },
                {
                    "name": "shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d_array",
                    "unit": 15
                },
                {
                    "name": "shadowmap_texture_sss",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                },
                {
                    "name": "albedo",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normals",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "roughness",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "metalness",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 3
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "material_data",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                },
                {
                    "name": "colour",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 84
                }
            ],
            "vs_file": "forward_lit__8__.vsc",
            "ps_file": "forward_lit__8__.psc",
            "permutation_id": 8,
            "permutation_option_mask": 3221225498
        },
        {
            "vs": "vs_main",
            "ps": "ps_forward_lit",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                },
                "UV_SCALE": {
                    "val": 2,
                    "type": "checkbox"
                },
                "SDF_SHADOW": {
                    "val": 8,
                    "type": "checkbox"
                },
                "GI": {
                    "val": 16,
                    "type": "checkbox"
                }
            },
            "constants": {
                "albedo": {
                    "type": "float4",
                    "widget": "colour",
                    "default": [
                        1.0,
                        1.0,
                        1.0,
                        1.0
                    ],
                    "offset": 0,
                    "num_elements": 4
                },
                "roughness": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.5,
                    "offset": 4,
                    "num_elements": 1
                },
                "reflectivity": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.3,
                    "offset": 5,
                    "num_elements": 1
                },
                "surface_offset": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 1.0,
                    "offset": 6,
                    "num_elements": 1
                }
            },
            "texture_samplers": {
                "albedo": {
                    "type": "texture_2d",
                    "unit": 0,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/albedo.dds"
                },
                "normals": {
                    "type": "texture_2d",
                    "unit": 1,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/normal.dds"
                },
                "roughness": {
                    "type": "texture_2d",
                    "unit": 2,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/spec.dds"
                },
                "metalness": {
                    "type": "texture_2d",
                    "unit": 3,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/black.dds"
                }
            },
            "constants_used_bytes": 28,
            "constants_size_bytes": 32,
            "name": "forward_lit",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "ltc_mat",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 13
                },
                {
                    "name": "ltc_mag",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 12
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                },
                {
                    "name": "volume_gi",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 9
                },
                {
                    "name": "single_shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d",
                    "unit": 7
                },
                {
                    "name": "shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d_array",
                    "unit": 15
                },
                {
                    "name": "shadowmap_texture_sss",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                },
                {
                    "name": "albedo",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normals",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "roughness",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "metalness",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 3
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "material_data",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "blend_indices",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                },
                {
                    "name": "blend_weights",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 96
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                },
                {
                    "name": "colour",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 84
                }
            ],
            "vs_file": "forward_lit__2147483656__.vsc",
            "ps_file": "forward_lit__8__.psc",
            "permutation_id": 2147483656,
            "permutation_option_mask": 3221225498
        },
        {
            "vs": "vs_main",
            "ps": "ps_forward_lit",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                },
                "UV_SCALE": {
                    "val": 2,
                    "type": "checkbox"
                },
                "SDF_SHADOW": {
                    "val": 8,
                    "type": "checkbox"
                },
                "GI": {
                    "val": 16,
                    "type": "checkbox"
                }
            },
            "constants": {
                "albedo": {
                    "type": "float4",
                    "widget": "colour",
                    "default": [
                        1.0,
                        1.0,
                        1.0,
                        1.0
                    ],
                    "offset": 0,
                    "num_elements": 4
                },
                "roughness": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.5,
                    "offset": 4,
                    "num_elements": 1
                },
                "reflectivity": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.3,
                    "offset": 5,
                    "num_elements": 1
                },
                "surface_offset": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 1.0,
                    "offset": 6,
                    "num_elements": 1
                }
            },
            "texture_samplers": {
                "albedo": {
                    "type": "texture_2d",
                    "unit": 0,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/albedo.dds"
                },
                "normals": {
                    "type": "texture_2d",
                    "unit": 1,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/normal.dds"
                },
                "roughness": {
                    "type": "texture_2d",
                    "unit": 2,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/spec.dds"
                },
                "metalness": {
                    "type": "texture_2d",
                    "unit": 3,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/black.dds"
                }
            },
            "constants_used_bytes": 28,
            "constants_size_bytes": 32,
            "name": "forward_lit",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "ltc_mat",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 13
                },
                {
                    "name": "ltc_mag",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 12
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                },
                {
                    "name": "volume_gi",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 9
                },
                {
                    "name": "single_shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d",
                    "unit": 7
                },
                {
                    "name": "shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d_array",
                    "unit": 15
                },
                {
                    "name": "shadowmap_texture_sss",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                },
                {
                    "name": "albedo",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normals",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "roughness",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "metalness",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 3
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "material_data",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                }
            ],
            "instance_inputs": [
                {
                    "name": "world_matrix_0",
                    "semantic_index": 6,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_matrix_1",
                    "semantic_index": 7,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "world_matrix_2",
                    "semantic_index": 8,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "world_matrix_3",
                    "semantic_index": 9,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "user_data",
                    "semantic_index": 10,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "user_data2",
                    "semantic_index": 11,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                }
            ],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                },
                {
                    "name": "colour",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 84
                }
            ],
            "vs_file": "forward_lit__1073741824__.vsc",
            "ps_file": "forward_lit__1073741832__.psc",
            "permutation_id": 1073741832,
            "permutation_option_mask": 3221225498
        },
        {
            "vs": "vs_main",
            "ps": "ps_forward_lit",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                },
                "UV_SCALE": {
                    "val": 2,
                    "type": "checkbox"
                },
                "SDF_SHADOW": {
                    "val": 8,
                    "type": "checkbox"
                },
                "GI": {
                    "val": 16,
                    "type": "checkbox"
                }
            },
            "constants": {
                "albedo": {
                    "type": "float4",
                    "widget": "colour",
                    "default": [
                        1.0,
                        1.0,
                        1.0,
                        1.0
                    ],
                    "offset": 0,
                    "num_elements": 4
                },
                "roughness": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.5,
                    "offset": 4,
                    "num_elements": 1
                },
                "reflectivity": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.3,
                    "offset": 5,
                    "num_elements": 1
                },
                "surface_offset": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 1.0,
                    "offset": 6,
                    "num_elements": 1
                }
            },
            "texture_samplers": {
                "albedo": {
                    "type": "texture_2d",
                    "unit": 0,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/albedo.dds"
                },
                "normals": {
                    "type": "texture_2d",
                    "unit": 1,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/normal.dds"
                },
                "roughness": {
                    "type": "texture_2d",
                    "unit": 2,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/spec.dds"
                },
                "metalness": {
                    "type": "texture_2d",
                    "unit": 3,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/black.dds"
                }
            },
            "constants_used_bytes": 28,
            "constants_size_bytes": 32,
            "name": "forward_lit",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "ltc_mat",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 13
                },
                {
                    "name": "ltc_mag",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 12
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                },
                {
                    "name": "volume_gi",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 9
                },
                {
                    "name": "single_shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d",
                    "unit": 7
                },
                {
                    "name": "shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d_array",
                    "unit": 15
                },
                {
                    "name": "shadowmap_texture_sss",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                },
                {
                    "name": "albedo",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normals",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "roughness",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "metalness",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 3
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "material_data",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "blend_indices",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                },
                {
                    "name": "blend_weights",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 96
                }
            ],
            "instance_inputs": [
                {
                    "name": "world_matrix_0",
                    "semantic_index": 6,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_matrix_1",
                    "semantic_index": 7,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "world_matrix_2",
                    "semantic_index": 8,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "world_matrix_3",
                    "semantic_index": 9,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "user_data",
                    "semantic_index": 10,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "user_data2",
                    "semantic_index": 11,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                }
            ],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                },
                {
                    "name": "colour",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 84
                }
            ],
            "vs_file": "forward_lit__3221225472__.vsc",
            "ps_file": "forward_lit__1073741832__.psc",
            "permutation_id": 3221225480,
            "permutation_option_mask": 3221225498
        },
        {
            "vs": "vs_main",
            "ps": "ps_forward_lit",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                },
                "UV_SCALE": {
                    "val": 2,
                    "type": "checkbox"
                },
                "SDF_SHADOW": {
                    "val": 8,
                    "type": "checkbox"
                },
                "GI": {
                    "val": 16,
                    "type": "checkbox"
                }
            },
            "constants": {
                "albedo": {
                    "type": "float4",
                    "widget": "colour",
                    "default": [
                        1.0,
                        1.0,
                        1.0,
                        1.0
                    ],
                    "offset": 0,
                    "num_elements": 4
                },
                "uv_scale": {
                    "type": "float2",
                    "widget": "slider",
                    "min": 0,
                    "max": 100,
                    "default": 1.0,
                    "offset": 4,
                    "num_elements": 2
                },
                "roughness": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.5,
                    "offset": 6,
                    "num_elements": 1
                },
                "reflectivity": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.3,
                    "offset": 7,
                    "num_elements": 1
                },
                "surface_offset": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 1.0,
                    "offset": 8,
                    "num_elements": 1
                }
            },
            "texture_samplers": {
                "albedo": {
                    "type": "texture_2d",
                    "unit": 0,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/albedo.dds"
                },
                "normals": {
                    "type": "texture_2d",
                    "unit": 1,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/normal.dds"
                },
                "roughness": {
                    "type": "texture_2d",
                    "unit": 2,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/spec.dds"
                },
                "metalness": {
                    "type": "texture_2d",
                    "unit": 3,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/black.dds"
                }
            },
            "constants_used_bytes": 36,
            "constants_size_bytes": 48,
            "name": "forward_lit",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "ltc_mat",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 13
                },
                {
                    "name": "ltc_mag",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 12
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                },
                {
                    "name": "volume_gi",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 9
                },
                {
                    "name": "single_shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d",
                    "unit": 7
                },
                {
                    "name": "shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d_array",
                    "unit": 15
                },
                {
                    "name": "shadowmap_texture_sss",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                },
                {
                    "name": "albedo",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normals",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "roughness",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "metalness",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 3
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "material_data",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                },
                {
                    "name": "colour",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 84
                }
            ],
            "vs_file": "forward_lit__10__.vsc",
            "ps_file": "forward_lit__10__.psc",
            "permutation_id": 10,
            "permutation_option_mask": 3221225498
        },
        {
            "vs": "vs_main",
            "ps": "ps_forward_lit",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                },
                "UV_SCALE": {
                    "val": 2,
                    "type": "checkbox"
                },
                "SDF_SHADOW": {
                    "val": 8,
                    "type": "checkbox"
                },
                "GI": {
                    "val": 16,
                    "type": "checkbox"
                }
            },
            "constants": {
                "albedo": {
                    "type": "float4",
                    "widget": "colour",
                    "default": [
                        1.0,
                        1.0,
                        1.0,
                        1.0
                    ],
                    "offset": 0,
                    "num_elements": 4
                },
                "uv_scale": {
                    "type": "float2",
                    "widget": "slider",
                    "min": 0,
                    "max": 100,
                    "default": 1.0,
                    "offset": 4,
                    "num_elements": 2
                },
                "roughness": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.5,
                    "offset": 6,
                    "num_elements": 1
                },
                "reflectivity": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.3,
                    "offset": 7,
                    "num_elements": 1
                },
                "surface_offset": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 1.0,
                    "offset": 8,
                    "num_elements": 1
                }
            },
            "texture_samplers": {
                "albedo": {
                    "type": "texture_2d",
                    "unit": 0,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/albedo.dds"
                },
                "normals": {
                    "type": "texture_2d",
                    "unit": 1,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/normal.dds"
                },
                "roughness": {
                    "type": "texture_2d",
                    "unit": 2,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/spec.dds"
                },
                "metalness": {
                    "type": "texture_2d",
                    "unit": 3,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/black.dds"
                }
            },
            "constants_used_bytes": 36,
            "constants_size_bytes": 48,
            "name": "forward_lit",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "ltc_mat",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 13
                },
                {
                    "name": "ltc_mag",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 12
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                },
                {
                    "name": "volume_gi",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 9
                },
                {
                    "name": "single_shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d",
                    "unit": 7
                },
                {
                    "name": "shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d_array",
                    "unit": 15
                },
                {
                    "name": "shadowmap_texture_sss",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                },
                {
                    "name": "albedo",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normals",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "roughness",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "metalness",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 3
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "material_data",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "blend_indices",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                },
                {
                    "name": "blend_weights",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 96
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                },
                {
                    "name": "colour",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 84
                }
            ],
            "vs_file": "forward_lit__2147483658__.vsc",
            "ps_file": "forward_lit__10__.psc",
            "permutation_id": 2147483658,
            "permutation_option_mask": 3221225498
        },
        {
            "vs": "vs_main",
            "ps": "ps_forward_lit",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                },
                "UV_SCALE": {
                    "val": 2,
                    "type": "checkbox"
                },
                "SDF_SHADOW": {
                    "val": 8,
                    "type": "checkbox"
                },
                "GI": {
                    "val": 16,
                    "type": "checkbox"
                }
            },
            "constants": {
                "albedo": {
                    "type": "float4",
                    "widget": "colour",
                    "default": [
                        1.0,
                        1.0,
                        1.0,
                        1.0
                    ],
                    "offset": 0,
                    "num_elements": 4
                },
                "uv_scale": {
                    "type": "float2",
                    "widget": "slider",
                    "min": 0,
                    "max": 100,
                    "default": 1.0,
                    "offset": 4,
                    "num_elements": 2
                },
                "roughness": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.5,
                    "offset": 6,
                    "num_elements": 1
                },
                "reflectivity": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.3,
                    "offset": 7,
                    "num_elements": 1
                },
                "surface_offset": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 1.0,
                    "offset": 8,
                    "num_elements": 1
                }
            },
            "texture_samplers": {
                "albedo": {
                    "type": "texture_2d",
                    "unit": 0,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/albedo.dds"
                },
                "normals": {
                    "type": "texture_2d",
                    "unit": 1,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/normal.dds"
                },
                "roughness": {
                    "type": "texture_2d",
                    "unit": 2,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/spec.dds"
                },
                "metalness": {
                    "type": "texture_2d",
                    "unit": 3,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/black.dds"
                }
            },
            "constants_used_bytes": 36,
            "constants_size_bytes": 48,
            "name": "forward_lit",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "ltc_mat",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 13
                },
                {
                    "name": "ltc_mag",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 12
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                },
                {
                    "name": "volume_gi",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 9
                },
                {
                    "name": "single_shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d",
                    "unit": 7
                },
                {
                    "name": "shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d_array",
                    "unit": 15
                },
                {
                    "name": "shadowmap_texture_sss",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                },
                {
                    "name": "albedo",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normals",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "roughness",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "metalness",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 3
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "material_data",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                }
            ],
            "instance_inputs": [
                {
                    "name": "world_matrix_0",
                    "semantic_index": 6,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_matrix_1",
                    "semantic_index": 7,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "world_matrix_2",
                    "semantic_index": 8,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "world_matrix_3",
                    "semantic_index": 9,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "user_data",
                    "semantic_index": 10,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "user_data2",
                    "semantic_index": 11,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                }
            ],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                },
                {
                    "name": "colour",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 84
                }
            ],
            "vs_file": "forward_lit__1073741834__.vsc",
            "ps_file": "forward_lit__1073741834__.psc",
            "permutation_id": 1073741834,
            "permutation_option_mask": 3221225498
        },
        {
            "vs": "vs_main",
            "ps": "ps_forward_lit",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                },
                "UV_SCALE": {
                    "val": 2,
                    "type": "checkbox"
                },
                "SDF_SHADOW": {
                    "val": 8,
                    "type": "checkbox"
                },
                "GI": {
                    "val": 16,
                    "type": "checkbox"
                }
            },
            "constants": {
                "albedo": {
                    "type": "float4",
                    "widget": "colour",
                    "default": [
                        1.0,
                        1.0,
                        1.0,
                        1.0
                    ],
                    "offset": 0,
                    "num_elements": 4
                },
                "uv_scale": {
                    "type": "float2",
                    "widget": "slider",
                    "min": 0,
                    "max": 100,
                    "default": 1.0,
                    "offset": 4,
                    "num_elements": 2
                },
                "roughness": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.5,
                    "offset": 6,
                    "num_elements": 1
                },
                "reflectivity": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.3,
                    "offset": 7,
                    "num_elements": 1
                },
                "surface_offset": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 1.0,
                    "offset": 8,
                    "num_elements": 1
                }
            },
            "texture_samplers": {
                "albedo": {
                    "type": "texture_2d",
                    "unit": 0,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/albedo.dds"
                },
                "normals": {
                    "type": "texture_2d",
                    "unit": 1,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/normal.dds"
                },
                "roughness": {
                    "type": "texture_2d",
                    "unit": 2,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/spec.dds"
                },
                "metalness": {
                    "type": "texture_2d",
                    "unit": 3,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/black.dds"
                }
            },
            "constants_used_bytes": 36,
            "constants_size_bytes": 48,
            "name": "forward_lit",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "ltc_mat",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 13
                },
                {
                    "name": "ltc_mag",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 12
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                },
                {
                    "name": "volume_gi",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 9
                },
                {
                    "name": "single_shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d",
                    "unit": 7
                },
                {
                    "name": "shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d_array",
                    "unit": 15
                },
                {
                    "name": "shadowmap_texture_sss",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                },
                {
                    "name": "albedo",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normals",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "roughness",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "metalness",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 3
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "material_data",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "blend_indices",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                },
                {
                    "name": "blend_weights",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 96
                }
            ],
            "instance_inputs": [
                {
                    "name": "world_matrix_0",
                    "semantic_index": 6,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_matrix_1",
                    "semantic_index": 7,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "world_matrix_2",
                    "semantic_index": 8,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "world_matrix_3",
                    "semantic_index": 9,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "user_data",
                    "semantic_index": 10,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "user_data2",
                    "semantic_index": 11,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                }
            ],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                },
                {
                    "name": "colour",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 84
                }
            ],
            "vs_file": "forward_lit__3221225482__.vsc",
            "ps_file": "forward_lit__1073741834__.psc",
            "permutation_id": 3221225482,
            "permutation_option_mask": 3221225498
        },
        {
            "vs": "vs_main",
            "ps": "ps_forward_lit",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                },
                "UV_SCALE": {
                    "val": 2,
                    "type": "checkbox"
                },
                "SDF_SHADOW": {
                    "val": 8,
                    "type": "checkbox"
                },
                "GI": {
                    "val": 16,
                    "type": "checkbox"
                }
            },
            "constants": {
                "albedo": {
                    "type": "float4",
                    "widget": "colour",
                    "default": [
                        1.0,
                        1.0,
                        1.0,
                        1.0
                    ],
                    "offset": 0,
                    "num_elements": 4
                },
                "roughness": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.5,
                    "offset": 4,
                    "num_elements": 1
                },
                "reflectivity": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.3,
                    "offset": 5,
                    "num_elements": 1
                }
            },
            "texture_samplers": {
                "albedo": {
                    "type": "texture_2d",
                    "unit": 0,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/albedo.dds"
                },
                "normals": {
                    "type": "texture_2d",
                    "unit": 1,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/normal.dds"
                },
                "roughness": {
                    "type": "texture_2d",
                    "unit": 2,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/spec.dds"
                },
                "metalness": {
                    "type": "texture_2d",
                    "unit": 3,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/black.dds"
                }
            },
            "constants_used_bytes": 24,
            "constants_size_bytes": 32,
            "name": "forward_lit",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "blue_noise",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 5
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "ltc_mat",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 13
                },
                {
                    "name": "ltc_mag",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 12
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                },
                {
                    "name": "volume_gi",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 9
                },
                {
                    "name": "single_shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d",
                    "unit": 7
                },
                {
                    "name": "shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d_array",
                    "unit": 15
                },
                {
                    "name": "shadowmap_texture_sss",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                },
                {
                    "name": "albedo",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normals",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "roughness",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "metalness",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 3
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "material_data",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                },
                {
                    "name": "colour",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 84
                }
            ],
            "vs_file": "forward_lit.vsc",
            "ps_file": "forward_lit__16__.psc",
            "permutation_id": 16,
            "permutation_option_mask": 3221225498
        },
        {
            "vs": "vs_main",
            "ps": "ps_forward_lit",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                },
                "UV_SCALE": {
                    "val": 2,
                    "type": "checkbox"
                },
                "SDF_SHADOW": {
                    "val": 8,
                    "type": "checkbox"
                },
                "GI": {
                    "val": 16,
                    "type": "checkbox"
                }
            },
            "constants": {
                "albedo": {
                    "type": "float4",
                    "widget": "colour",
                    "default": [
                        1.0,
                        1.0,
                        1.0,
                        1.0
                    ],
                    "offset": 0,
                    "num_elements": 4
                },
                "roughness": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.5,
                    "offset": 4,
                    "num_elements": 1
                },
                "reflectivity": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.3,
                    "offset": 5,
                    "num_elements": 1
                }
            },
            "texture_samplers": {
                "albedo": {
                    "type": "texture_2d",
                    "unit": 0,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/albedo.dds"
                },
                "normals": {
                    "type": "texture_2d",
                    "unit": 1,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/normal.dds"
                },
                "roughness": {
                    "type": "texture_2d",
                    "unit": 2,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/spec.dds"
                },
                "metalness": {
                    "type": "texture_2d",
                    "unit": 3,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/black.dds"
                }
            },
            "constants_used_bytes": 24,
            "constants_size_bytes": 32,
            "name": "forward_lit",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "blue_noise",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 5
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "ltc_mat",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 13
                },
                {
                    "name": "ltc_mag",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 12
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                },
                {
                    "name": "volume_gi",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 9
                },
                {
                    "name": "single_shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d",
                    "unit": 7
                },
                {
                    "name": "shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d_array",
                    "unit": 15
                },
                {
                    "name": "shadowmap_texture_sss",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                },
                {
                    "name": "albedo",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normals",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "roughness",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "metalness",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 3
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "material_data",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "blend_indices",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                },
                {
                    "name": "blend_weights",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 96
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                },
                {
                    "name": "colour",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 84
                }
            ],
            "vs_file": "forward_lit__2147483648__.vsc",
            "ps_file": "forward_lit__16__.psc",
            "permutation_id": 2147483664,
            "permutation_option_mask": 3221225498
        },
        {
            "vs": "vs_main",
            "ps": "ps_forward_lit",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                },
                "UV_SCALE": {
                    "val": 2,
                    "type": "checkbox"
                },
                "SDF_SHADOW": {
                    "val": 8,
                    "type": "checkbox"
                },
                "GI": {
                    "val": 16,
                    "type": "checkbox"
                }
            },
            "constants": {
                "albedo": {
                    "type": "float4",
                    "widget": "colour",
                    "default": [
                        1.0,
                        1.0,
                        1.0,
                        1.0
                    ],
                    "offset": 0,
                    "num_elements": 4
                },
                "roughness": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.5,
                    "offset": 4,
                    "num_elements": 1
                },
                "reflectivity": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.3,
                    "offset": 5,
                    "num_elements": 1
                }
            },
            "texture_samplers": {
                "albedo": {
                    "type": "texture_2d",
                    "unit": 0,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/albedo.dds"
                },
                "normals": {
                    "type": "texture_2d",
                    "unit": 1,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/normal.dds"
                },
                "roughness": {
                    "type": "texture_2d",
                    "unit": 2,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/spec.dds"
                },
                "metalness": {
                    "type": "texture_2d",
                    "unit": 3,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/black.dds"
                }
            },
            "constants_used_bytes": 24,
            "constants_size_bytes": 32,
            "name": "forward_lit",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "blue_noise",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 5
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "ltc_mat",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 13
                },
                {
                    "name": "ltc_mag",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 12
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                },
                {
                    "name": "volume_gi",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 9
                },
                {
                    "name": "single_shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d",
                    "unit": 7
                },
                {
                    "name": "shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d_array",
                    "unit": 15
                },
                {
                    "name": "shadowmap_texture_sss",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                },
                {
                    "name": "albedo",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normals",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "roughness",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "metalness",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 3
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "material_data",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                }
            ],
            "instance_inputs": [
                {
                    "name": "world_matrix_0",
                    "semantic_index": 6,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_matrix_1",
                    "semantic_index": 7,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "world_matrix_2",
                    "semantic_index": 8,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "world_matrix_3",
                    "semantic_index": 9,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "user_data",
                    "semantic_index": 10,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "user_data2",
                    "semantic_index": 11,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                }
            ],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                },
                {
                    "name": "colour",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 84
                }
            ],
            "vs_file": "forward_lit__1073741824__.vsc",
            "ps_file": "forward_lit__1073741840__.psc",
            "permutation_id": 1073741840,
            "permutation_option_mask": 3221225498
        },
        {
            "vs": "vs_main",
            "ps": "ps_forward_lit",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                },
                "UV_SCALE": {
                    "val": 2,
                    "type": "checkbox"
                },
                "SDF_SHADOW": {
                    "val": 8,
                    "type": "checkbox"
                },
                "GI": {
                    "val": 16,
                    "type": "checkbox"
                }
            },
            "constants": {
                "albedo": {
                    "type": "float4",
                    "widget": "colour",
                    "default": [
                        1.0,
                        1.0,
                        1.0,
                        1.0
                    ],
                    "offset": 0,
                    "num_elements": 4
                },
                "roughness": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.5,
                    "offset": 4,
                    "num_elements": 1
                },
                "reflectivity": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.3,
                    "offset": 5,
                    "num_elements": 1
                }
            },
            "texture_samplers": {
                "albedo": {
                    "type": "texture_2d",
                    "unit": 0,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/albedo.dds"
                },
                "normals": {
                    "type": "texture_2d",
                    "unit": 1,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/normal.dds"
                },
                "roughness": {
                    "type": "texture_2d",
                    "unit": 2,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/spec.dds"
                },
                "metalness": {
                    "type": "texture_2d",
                    "unit": 3,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/black.dds"
                }
            },
            "constants_used_bytes": 24,
            "constants_size_bytes": 32,
            "name": "forward_lit",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "blue_noise",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 5
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "ltc_mat",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 13
                },
                {
                    "name": "ltc_mag",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 12
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                },
                {
                    "name": "volume_gi",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 9
                },
                {
                    "name": "single_shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d",
                    "unit": 7
                },
                {
                    "name": "shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d_array",
                    "unit": 15
                },
                {
                    "name": "shadowmap_texture_sss",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                },
                {
                    "name": "albedo",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normals",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "roughness",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "metalness",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 3
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "material_data",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "blend_indices",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                },
                {
                    "name": "blend_weights",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 96
                }
            ],
            "instance_inputs": [
                {
                    "name": "world_matrix_0",
                    "semantic_index": 6,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_matrix_1",
                    "semantic_index": 7,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "world_matrix_2",
                    "semantic_index": 8,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "world_matrix_3",
                    "semantic_index": 9,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "user_data",
                    "semantic_index": 10,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "user_data2",
                    "semantic_index": 11,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                }
            ],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                },
                {
                    "name": "colour",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 84
                }
            ],
            "vs_file": "forward_lit__3221225472__.vsc",
            "ps_file": "forward_lit__1073741840__.psc",
            "permutation_id": 3221225488,
            "permutation_option_mask": 3221225498
        },
        {
            "vs": "vs_main",
            "ps": "ps_forward_lit",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                },
                "UV_SCALE": {
                    "val": 2,
                    "type": "checkbox"
                },
                "SDF_SHADOW": {
                    "val": 8,
                    "type": "checkbox"
                },
                "GI": {
                    "val": 16,
                    "type": "checkbox"
                }
            },
            "constants": {
                "albedo": {
                    "type": "float4",
                    "widget": "colour",
                    "default": [
                        1.0,
                        1.0,
                        1.0,
                        1.0
                    ],
                    "offset": 0,
                    "num_elements": 4
                },
                "uv_scale": {
                    "type": "float2",
                    "widget": "slider",
                    "min": 0,
                    "max": 100,
                    "default": 1.0,
                    "offset": 4,
                    "num_elements": 2
                },
                "roughness": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.5,
                    "offset": 6,
                    "num_elements": 1
                },
                "reflectivity": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.3,
                    "offset": 7,
                    "num_elements": 1
                }
            },
            "texture_samplers": {
                "albedo": {
                    "type": "texture_2d",
                    "unit": 0,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/albedo.dds"
                },
                "normals": {
                    "type": "texture_2d",
                    "unit": 1,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/normal.dds"
                },
                "roughness": {
                    "type": "texture_2d",
                    "unit": 2,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/spec.dds"
                },
                "metalness": {
                    "type": "texture_2d",
                    "unit": 3,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/black.dds"
                }
            },
            "constants_used_bytes": 32,
            "constants_size_bytes": 32,
            "name": "forward_lit",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "blue_noise",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 5
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "ltc_mat",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 13
                },
                {
                    "name": "ltc_mag",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 12
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                },
                {
                    "name": "volume_gi",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 9
                },
                {
                    "name": "single_shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d",
                    "unit": 7
                },
                {
                    "name": "shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d_array",
                    "unit": 15
                },
                {
                    "name": "shadowmap_texture_sss",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                },
                {
                    "name": "albedo",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normals",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "roughness",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "metalness",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 3
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "material_data",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                },
                {
                    "name": "colour",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 84
                }
            ],
            "vs_file": "forward_lit__2__.vsc",
            "ps_file": "forward_lit__18__.psc",
            "permutation_id": 18,
            "permutation_option_mask": 3221225498
        },
        {
            "vs": "vs_main",
            "ps": "ps_forward_lit",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                },
                "UV_SCALE": {
                    "val": 2,
                    "type": "checkbox"
                },
                "SDF_SHADOW": {
                    "val": 8,
                    "type": "checkbox"
                },
                "GI": {
                    "val": 16,
                    "type": "checkbox"
                }
            },
            "constants": {
                "albedo": {
                    "type": "float4",
                    "widget": "colour",
                    "default": [
                        1.0,
                        1.0,
                        1.0,
                        1.0
                    ],
                    "offset": 0,
                    "num_elements": 4
                },
                "uv_scale": {
                    "type": "float2",
                    "widget": "slider",
                    "min": 0,
                    "max": 100,
                    "default": 1.0,
                    "offset": 4,
                    "num_elements": 2
                },
                "roughness": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.5,
                    "offset": 6,
                    "num_elements": 1
                },
                "reflectivity": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.3,
                    "offset": 7,
                    "num_elements": 1
                }
            },
            "texture_samplers": {
                "albedo": {
                    "type": "texture_2d",
                    "unit": 0,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/albedo.dds"
                },
                "normals": {
                    "type": "texture_2d",
                    "unit": 1,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/normal.dds"
                },
                "roughness": {
                    "type": "texture_2d",
                    "unit": 2,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/spec.dds"
                },
                "metalness": {
                    "type": "texture_2d",
                    "unit": 3,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/black.dds"
                }
            },
            "constants_used_bytes": 32,
            "constants_size_bytes": 32,
            "name": "forward_lit",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "blue_noise",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 5
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "ltc_mat",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 13
                },
                {
                    "name": "ltc_mag",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 12
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                },
                {
                    "name": "volume_gi",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 9
                },
                {
                    "name": "single_shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d",
                    "unit": 7
                },
                {
                    "name": "shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d_array",
                    "unit": 15
                },
                {
                    "name": "shadowmap_texture_sss",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                },
                {
                    "name": "albedo",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normals",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "roughness",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "metalness",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 3
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "material_data",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "blend_indices",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                },
                {
                    "name": "blend_weights",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 96
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                },
                {
                    "name": "colour",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 84
                }
            ],
            "vs_file": "forward_lit__2147483650__.vsc",
            "ps_file": "forward_lit__18__.psc",
            "permutation_id": 2147483666,
            "permutation_option_mask": 3221225498
        },
        {
            "vs": "vs_main",
            "ps": "ps_forward_lit",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                },
                "UV_SCALE": {
                    "val": 2,
                    "type": "checkbox"
                },
                "SDF_SHADOW": {
                    "val": 8,
                    "type": "checkbox"
                },
                "GI": {
                    "val": 16,
                    "type": "checkbox"
                }
            },
            "constants": {
                "albedo": {
                    "type": "float4",
                    "widget": "colour",
                    "default": [
                        1.0,
                        1.0,
                        1.0,
                        1.0
                    ],
                    "offset": 0,
                    "num_elements": 4
                },
                "uv_scale": {
                    "type": "float2",
                    "widget": "slider",
                    "min": 0,
                    "max": 100,
                    "default": 1.0,
                    "offset": 4,
                    "num_elements": 2
                },
                "roughness": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.5,
                    "offset": 6,
                    "num_elements": 1
                },
                "reflectivity": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.3,
                    "offset": 7,
                    "num_elements": 1
                }
            },
            "texture_samplers": {
                "albedo": {
                    "type": "texture_2d",
                    "unit": 0,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/albedo.dds"
                },
                "normals": {
                    "type": "texture_2d",
                    "unit": 1,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/normal.dds"
                },
                "roughness": {
                    "type": "texture_2d",
                    "unit": 2,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/spec.dds"
                },
                "metalness": {
                    "type": "texture_2d",
                    "unit": 3,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/black.dds"
                }
            },
            "constants_used_bytes": 32,
            "constants_size_bytes": 32,
            "name": "forward_lit",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "blue_noise",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 5
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "ltc_mat",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 13
                },
                {
                    "name": "ltc_mag",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 12
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                },
                {
                    "name": "volume_gi",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 9
                },
                {
                    "name": "single_shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d",
                    "unit": 7
                },
                {
                    "name": "shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d_array",
                    "unit": 15
                },
                {
                    "name": "shadowmap_texture_sss",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                },
                {
                    "name": "albedo",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normals",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "roughness",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "metalness",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 3
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "material_data",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                }
            ],
            "instance_inputs": [
                {
                    "name": "world_matrix_0",
                    "semantic_index": 6,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_matrix_1",
                    "semantic_index": 7,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "world_matrix_2",
                    "semantic_index": 8,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "world_matrix_3",
                    "semantic_index": 9,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "user_data",
                    "semantic_index": 10,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "user_data2",
                    "semantic_index": 11,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                }
            ],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                },
                {
                    "name": "colour",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 84
                }
            ],
            "vs_file": "forward_lit__1073741826__.vsc",
            "ps_file": "forward_lit__1073741842__.psc",
            "permutation_id": 1073741842,
            "permutation_option_mask": 3221225498
        },
        {
            "vs": "vs_main",
            "ps": "ps_forward_lit",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                },
                "UV_SCALE": {
                    "val": 2,
                    "type": "checkbox"
                },
                "SDF_SHADOW": {
                    "val": 8,
                    "type": "checkbox"
                },
                "GI": {
                    "val": 16,
                    "type": "checkbox"
                }
            },
            "constants": {
                "albedo": {
                    "type": "float4",
                    "widget": "colour",
                    "default": [
                        1.0,
                        1.0,
                        1.0,
                        1.0
                    ],
                    "offset": 0,
                    "num_elements": 4
                },
                "uv_scale": {
                    "type": "float2",
                    "widget": "slider",
                    "min": 0,
                    "max": 100,
                    "default": 1.0,
                    "offset": 4,
                    "num_elements": 2
                },
                "roughness": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.5,
                    "offset": 6,
                    "num_elements": 1
                },
                "reflectivity": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.3,
                    "offset": 7,
                    "num_elements": 1
                }
            },
            "texture_samplers": {
                "albedo": {
                    "type": "texture_2d",
                    "unit": 0,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/albedo.dds"
                },
                "normals": {
                    "type": "texture_2d",
                    "unit": 1,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/normal.dds"
                },
                "roughness": {
                    "type": "texture_2d",
                    "unit": 2,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/spec.dds"
                },
                "metalness": {
                    "type": "texture_2d",
                    "unit": 3,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/black.dds"
                }
            },
            "constants_used_bytes": 32,
            "constants_size_bytes": 32,
            "name": "forward_lit",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "blue_noise",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 5
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "ltc_mat",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 13
                },
                {
                    "name": "ltc_mag",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 12
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                },
                {
                    "name": "volume_gi",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 9
                },
                {
                    "name": "single_shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d",
                    "unit": 7
                },
                {
                    "name": "shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d_array",
                    "unit": 15
                },
                {
                    "name": "shadowmap_texture_sss",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                },
                {
                    "name": "albedo",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normals",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "roughness",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "metalness",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 3
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "material_data",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "blend_indices",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                },
                {
                    "name": "blend_weights",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 96
                }
            ],
            "instance_inputs": [
                {
                    "name": "world_matrix_0",
                    "semantic_index": 6,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_matrix_1",
                    "semantic_index": 7,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "world_matrix_2",
                    "semantic_index": 8,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "world_matrix_3",
                    "semantic_index": 9,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "user_data",
                    "semantic_index": 10,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "user_data2",
                    "semantic_index": 11,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                }
            ],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                },
                {
                    "name": "colour",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 84
                }
            ],
            "vs_file": "forward_lit__3221225474__.vsc",
            "ps_file": "forward_lit__1073741842__.psc",
            "permutation_id": 3221225490,
            "permutation_option_mask": 3221225498
        },
        {
            "vs": "vs_main",
            "ps": "ps_forward_lit",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                },
                "UV_SCALE": {
                    "val": 2,
                    "type": "checkbox"
                },
                "SDF_SHADOW": {
                    "val": 8,
                    "type": "checkbox"
                },
                "GI": {
                    "val": 16,
                    "type": "checkbox"
                }
            },
            "constants": {
                "albedo": {
                    "type": "float4",
                    "widget": "colour",
                    "default": [
                        1.0,
                        1.0,
                        1.0,
                        1.0
                    ],
                    "offset": 0,
                    "num_elements": 4
                },
                "roughness": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.5,
                    "offset": 4,
                    "num_elements": 1
                },
                "reflectivity": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.3,
                    "offset": 5,
                    "num_elements": 1
                },
                "surface_offset": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 1.0,
                    "offset": 6,
                    "num_elements": 1
                }
            },
            "texture_samplers": {
                "albedo": {
                    "type": "texture_2d",
                    "unit": 0,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/albedo.dds"
                },
                "normals": {
                    "type": "texture_2d",
                    "unit": 1,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/normal.dds"
                },
                "roughness": {
                    "type": "texture_2d",
                    "unit": 2,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/spec.dds"
                },
                "metalness": {
                    "type": "texture_2d",
                    "unit": 3,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/black.dds"
                }
            },
            "constants_used_bytes": 28,
            "constants_size_bytes": 32,
            "name": "forward_lit",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "blue_noise",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 5
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "ltc_mat",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 13
                },
                {
                    "name": "ltc_mag",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 12
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                },
                {
                    "name": "volume_gi",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 9
                },
                {
                    "name": "single_shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d",
                    "unit": 7
                },
                {
                    "name": "shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d_array",
                    "unit": 15
                },
                {
                    "name": "shadowmap_texture_sss",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                },
                {
                    "name": "albedo",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normals",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "roughness",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "metalness",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 3
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "material_data",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                },
                {
                    "name": "colour",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 84
                }
            ],
            "vs_file": "forward_lit__8__.vsc",
            "ps_file": "forward_lit__24__.psc",
            "permutation_id": 24,
            "permutation_option_mask": 3221225498
        },
        {
            "vs": "vs_main",
            "ps": "ps_forward_lit",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                },
                "UV_SCALE": {
                    "val": 2,
                    "type": "checkbox"
                },
                "SDF_SHADOW": {
                    "val": 8,
                    "type": "checkbox"
                },
                "GI": {
                    "val": 16,
                    "type": "checkbox"
                }
            },
            "constants": {
                "albedo": {
                    "type": "float4",
                    "widget": "colour",
                    "default": [
                        1.0,
                        1.0,
                        1.0,
                        1.0
                    ],
                    "offset": 0,
                    "num_elements": 4
                },
                "roughness": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.5,
                    "offset": 4,
                    "num_elements": 1
                },
                "reflectivity": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.3,
                    "offset": 5,
                    "num_elements": 1
                },
                "surface_offset": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 1.0,
                    "offset": 6,
                    "num_elements": 1
                }
            },
            "texture_samplers": {
                "albedo": {
                    "type": "texture_2d",
                    "unit": 0,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/albedo.dds"
                },
                "normals": {
                    "type": "texture_2d",
                    "unit": 1,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/normal.dds"
                },
                "roughness": {
                    "type": "texture_2d",
                    "unit": 2,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/spec.dds"
                },
                "metalness": {
                    "type": "texture_2d",
                    "unit": 3,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/black.dds"
                }
            },
            "constants_used_bytes": 28,
            "constants_size_bytes": 32,
            "name": "forward_lit",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "blue_noise",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 5
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "ltc_mat",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 13
                },
                {
                    "name": "ltc_mag",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 12
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                },
                {
                    "name": "volume_gi",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 9
                },
                {
                    "name": "single_shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d",
                    "unit": 7
                },
                {
                    "name": "shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d_array",
                    "unit": 15
                },
                {
                    "name": "shadowmap_texture_sss",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                },
                {
                    "name": "albedo",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normals",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "roughness",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "metalness",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 3
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "material_data",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "blend_indices",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                },
                {
                    "name": "blend_weights",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 96
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                },
                {
                    "name": "colour",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 84
                }
            ],
            "vs_file": "forward_lit__2147483656__.vsc",
            "ps_file": "forward_lit__24__.psc",
            "permutation_id": 2147483672,
            "permutation_option_mask": 3221225498
        },
        {
            "vs": "vs_main",
            "ps": "ps_forward_lit",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                },
                "UV_SCALE": {
                    "val": 2,
                    "type": "checkbox"
                },
                "SDF_SHADOW": {
                    "val": 8,
                    "type": "checkbox"
                },
                "GI": {
                    "val": 16,
                    "type": "checkbox"
                }
            },
            "constants": {
                "albedo": {
                    "type": "float4",
                    "widget": "colour",
                    "default": [
                        1.0,
                        1.0,
                        1.0,
                        1.0
                    ],
                    "offset": 0,
                    "num_elements": 4
                },
                "roughness": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.5,
                    "offset": 4,
                    "num_elements": 1
                },
                "reflectivity": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.3,
                    "offset": 5,
                    "num_elements": 1
                },
                "surface_offset": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 1.0,
                    "offset": 6,
                    "num_elements": 1
                }
            },
            "texture_samplers": {
                "albedo": {
                    "type": "texture_2d",
                    "unit": 0,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/albedo.dds"
                },
                "normals": {
                    "type": "texture_2d",
                    "unit": 1,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/normal.dds"
                },
                "roughness": {
                    "type": "texture_2d",
                    "unit": 2,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/spec.dds"
                },
                "metalness": {
                    "type": "texture_2d",
                    "unit": 3,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/black.dds"
                }
            },
            "constants_used_bytes": 28,
            "constants_size_bytes": 32,
            "name": "forward_lit",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "blue_noise",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 5
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "ltc_mat",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 13
                },
                {
                    "name": "ltc_mag",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 12
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                },
                {
                    "name": "volume_gi",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 9
                },
                {
                    "name": "single_shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d",
                    "unit": 7
                },
                {
                    "name": "shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d_array",
                    "unit": 15
                },
                {
                    "name": "shadowmap_texture_sss",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                },
                {
                    "name": "albedo",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normals",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "roughness",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "metalness",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 3
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "material_data",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                }
            ],
            "instance_inputs": [
                {
                    "name": "world_matrix_0",
                    "semantic_index": 6,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_matrix_1",
                    "semantic_index": 7,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "world_matrix_2",
                    "semantic_index": 8,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "world_matrix_3",
                    "semantic_index": 9,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "user_data",
                    "semantic_index": 10,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "user_data2",
                    "semantic_index": 11,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                }
            ],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                },
                {
                    "name": "colour",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 84
                }
            ],
            "vs_file": "forward_lit__1073741824__.vsc",
            "ps_file": "forward_lit__1073741848__.psc",
            "permutation_id": 1073741848,
            "permutation_option_mask": 3221225498
        },
        {
            "vs": "vs_main",
            "ps": "ps_forward_lit",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                },
                "UV_SCALE": {
                    "val": 2,
                    "type": "checkbox"
                },
                "SDF_SHADOW": {
                    "val": 8,
                    "type": "checkbox"
                },
                "GI": {
                    "val": 16,
                    "type": "checkbox"
                }
            },
            "constants": {
                "albedo": {
                    "type": "float4",
                    "widget": "colour",
                    "default": [
                        1.0,
                        1.0,
                        1.0,
                        1.0
                    ],
                    "offset": 0,
                    "num_elements": 4
                },
                "roughness": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.5,
                    "offset": 4,
                    "num_elements": 1
                },
                "reflectivity": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.3,
                    "offset": 5,
                    "num_elements": 1
                },
                "surface_offset": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 1.0,
                    "offset": 6,
                    "num_elements": 1
                }
            },
            "texture_samplers": {
                "albedo": {
                    "type": "texture_2d",
                    "unit": 0,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/albedo.dds"
                },
                "normals": {
                    "type": "texture_2d",
                    "unit": 1,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/normal.dds"
                },
                "roughness": {
                    "type": "texture_2d",
                    "unit": 2,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/spec.dds"
                },
                "metalness": {
                    "type": "texture_2d",
                    "unit": 3,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/black.dds"
                }
            },
            "constants_used_bytes": 28,
            "constants_size_bytes": 32,
            "name": "forward_lit",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "blue_noise",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 5
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "ltc_mat",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 13
                },
                {
                    "name": "ltc_mag",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 12
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                },
                {
                    "name": "volume_gi",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 9
                },
                {
                    "name": "single_shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d",
                    "unit": 7
                },
                {
                    "name": "shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d_array",
                    "unit": 15
                },
                {
                    "name": "shadowmap_texture_sss",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                },
                {
                    "name": "albedo",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normals",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "roughness",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "metalness",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 3
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "material_data",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "blend_indices",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                },
                {
                    "name": "blend_weights",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 96
                }
            ],
            "instance_inputs": [
                {
                    "name": "world_matrix_0",
                    "semantic_index": 6,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_matrix_1",
                    "semantic_index": 7,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "world_matrix_2",
                    "semantic_index": 8,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "world_matrix_3",
                    "semantic_index": 9,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "user_data",
                    "semantic_index": 10,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "user_data2",
                    "semantic_index": 11,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                }
            ],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                },
                {
                    "name": "colour",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 84
                }
            ],
            "vs_file": "forward_lit__3221225472__.vsc",
            "ps_file": "forward_lit__1073741848__.psc",
            "permutation_id": 3221225496,
            "permutation_option_mask": 3221225498
        },
        {
            "vs": "vs_main",
            "ps": "ps_forward_lit",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                },
                "UV_SCALE": {
                    "val": 2,
                    "type": "checkbox"
                },
                "SDF_SHADOW": {
                    "val": 8,
                    "type": "checkbox"
                },
                "GI": {
                    "val": 16,
                    "type": "checkbox"
                }
            },
            "constants": {
                "albedo": {
                    "type": "float4",
                    "widget": "colour",
                    "default": [
                        1.0,
                        1.0,
                        1.0,
                        1.0
                    ],
                    "offset": 0,
                    "num_elements": 4
                },
                "uv_scale": {
                    "type": "float2",
                    "widget": "slider",
                    "min": 0,
                    "max": 100,
                    "default": 1.0,
                    "offset": 4,
                    "num_elements": 2
                },
                "roughness": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.5,
                    "offset": 6,
                    "num_elements": 1
                },
                "reflectivity": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.3,
                    "offset": 7,
                    "num_elements": 1
                },
                "surface_offset": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 1.0,
                    "offset": 8,
                    "num_elements": 1
                }
            },
            "texture_samplers": {
                "albedo": {
                    "type": "texture_2d",
                    "unit": 0,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/albedo.dds"
                },
                "normals": {
                    "type": "texture_2d",
                    "unit": 1,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/normal.dds"
                },
                "roughness": {
                    "type": "texture_2d",
                    "unit": 2,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/spec.dds"
                },
                "metalness": {
                    "type": "texture_2d",
                    "unit": 3,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/black.dds"
                }
            },
            "constants_used_bytes": 36,
            "constants_size_bytes": 48,
            "name": "forward_lit",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "blue_noise",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 5
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "ltc_mat",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 13
                },
                {
                    "name": "ltc_mag",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 12
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                },
                {
                    "name": "volume_gi",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 9
                },
                {
                    "name": "single_shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d",
                    "unit": 7
                },
                {
                    "name": "shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d_array",
                    "unit": 15
                },
                {
                    "name": "shadowmap_texture_sss",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                },
                {
                    "name": "albedo",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normals",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "roughness",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "metalness",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 3
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "material_data",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                },
                {
                    "name": "colour",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 84
                }
            ],
            "vs_file": "forward_lit__10__.vsc",
            "ps_file": "forward_lit__26__.psc",
            "permutation_id": 26,
            "permutation_option_mask": 3221225498
        },
        {
            "vs": "vs_main",
            "ps": "ps_forward_lit",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                },
                "UV_SCALE": {
                    "val": 2,
                    "type": "checkbox"
                },
                "SDF_SHADOW": {
                    "val": 8,
                    "type": "checkbox"
                },
                "GI": {
                    "val": 16,
                    "type": "checkbox"
                }
            },
            "constants": {
                "albedo": {
                    "type": "float4",
                    "widget": "colour",
                    "default": [
                        1.0,
                        1.0,
                        1.0,
                        1.0
                    ],
                    "offset": 0,
                    "num_elements": 4
                },
                "uv_scale": {
                    "type": "float2",
                    "widget": "slider",
                    "min": 0,
                    "max": 100,
                    "default": 1.0,
                    "offset": 4,
                    "num_elements": 2
                },
                "roughness": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.5,
                    "offset": 6,
                    "num_elements": 1
                },
                "reflectivity": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.3,
                    "offset": 7,
                    "num_elements": 1
                },
                "surface_offset": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 1.0,
                    "offset": 8,
                    "num_elements": 1
                }
            },
            "texture_samplers": {
                "albedo": {
                    "type": "texture_2d",
                    "unit": 0,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/albedo.dds"
                },
                "normals": {
                    "type": "texture_2d",
                    "unit": 1,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/normal.dds"
                },
                "roughness": {
                    "type": "texture_2d",
                    "unit": 2,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/spec.dds"
                },
                "metalness": {
                    "type": "texture_2d",
                    "unit": 3,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/black.dds"
                }
            },
            "constants_used_bytes": 36,
            "constants_size_bytes": 48,
            "name": "forward_lit",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "blue_noise",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 5
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "ltc_mat",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 13
                },
                {
                    "name": "ltc_mag",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 12
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                },
                {
                    "name": "volume_gi",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 9
                },
                {
                    "name": "single_shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d",
                    "unit": 7
                },
                {
                    "name": "shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d_array",
                    "unit": 15
                },
                {
                    "name": "shadowmap_texture_sss",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                },
                {
                    "name": "albedo",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normals",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "roughness",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "metalness",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 3
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "material_data",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "blend_indices",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                },
                {
                    "name": "blend_weights",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 96
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                },
                {
                    "name": "colour",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 84
                }
            ],
            "vs_file": "forward_lit__2147483658__.vsc",
            "ps_file": "forward_lit__26__.psc",
            "permutation_id": 2147483674,
            "permutation_option_mask": 3221225498
        },
        {
            "vs": "vs_main",
            "ps": "ps_forward_lit",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                },
                "UV_SCALE": {
                    "val": 2,
                    "type": "checkbox"
                },
                "SDF_SHADOW": {
                    "val": 8,
                    "type": "checkbox"
                },
                "GI": {
                    "val": 16,
                    "type": "checkbox"
                }
            },
            "constants": {
                "albedo": {
                    "type": "float4",
                    "widget": "colour",
                    "default": [
                        1.0,
                        1.0,
                        1.0,
                        1.0
                    ],
                    "offset": 0,
                    "num_elements": 4
                },
                "uv_scale": {
                    "type": "float2",
                    "widget": "slider",
                    "min": 0,
                    "max": 100,
                    "default": 1.0,
                    "offset": 4,
                    "num_elements": 2
                },
                "roughness": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.5,
                    "offset": 6,
                    "num_elements": 1
                },
                "reflectivity": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.3,
                    "offset": 7,
                    "num_elements": 1
                },
                "surface_offset": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 1.0,
                    "offset": 8,
                    "num_elements": 1
                }
            },
            "texture_samplers": {
                "albedo": {
                    "type": "texture_2d",
                    "unit": 0,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/albedo.dds"
                },
                "normals": {
                    "type": "texture_2d",
                    "unit": 1,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/normal.dds"
                },
                "roughness": {
                    "type": "texture_2d",
                    "unit": 2,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/spec.dds"
                },
                "metalness": {
                    "type": "texture_2d",
                    "unit": 3,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/black.dds"
                }
            },
            "constants_used_bytes": 36,
            "constants_size_bytes": 48,
            "name": "forward_lit",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "blue_noise",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 5
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "ltc_mat",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 13
                },
                {
                    "name": "ltc_mag",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 12
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                },
                {
                    "name": "volume_gi",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 9
                },
                {
                    "name": "single_shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d",
                    "unit": 7
                },
                {
                    "name": "shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d_array",
                    "unit": 15
                },
                {
                    "name": "shadowmap_texture_sss",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                },
                {
                    "name": "albedo",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normals",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "roughness",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "metalness",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 3
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "material_data",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                }
            ],
            "instance_inputs": [
                {
                    "name": "world_matrix_0",
                    "semantic_index": 6,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_matrix_1",
                    "semantic_index": 7,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "world_matrix_2",
                    "semantic_index": 8,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "world_matrix_3",
                    "semantic_index": 9,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "user_data",
                    "semantic_index": 10,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "user_data2",
                    "semantic_index": 11,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                }
            ],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                },
                {
                    "name": "colour",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 84
                }
            ],
            "vs_file": "forward_lit__1073741834__.vsc",
            "ps_file": "forward_lit__1073741850__.psc",
            "permutation_id": 1073741850,
            "permutation_option_mask": 3221225498
        },
        {
            "vs": "vs_main",
            "ps": "ps_forward_lit",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                },
                "UV_SCALE": {
                    "val": 2,
                    "type": "checkbox"
                },
                "SDF_SHADOW": {
                    "val": 8,
                    "type": "checkbox"
                },
                "GI": {
                    "val": 16,
                    "type": "checkbox"
                }
            },
            "constants": {
                "albedo": {
                    "type": "float4",
                    "widget": "colour",
                    "default": [
                        1.0,
                        1.0,
                        1.0,
                        1.0
                    ],
                    "offset": 0,
                    "num_elements": 4
                },
                "uv_scale": {
                    "type": "float2",
                    "widget": "slider",
                    "min": 0,
                    "max": 100,
                    "default": 1.0,
                    "offset": 4,
                    "num_elements": 2
                },
                "roughness": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.5,
                    "offset": 6,
                    "num_elements": 1
                },
                "reflectivity": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.3,
                    "offset": 7,
                    "num_elements": 1
                },
                "surface_offset": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 1.0,
                    "offset": 8,
                    "num_elements": 1
                }
            },
            "texture_samplers": {
                "albedo": {
                    "type": "texture_2d",
                    "unit": 0,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/albedo.dds"
                },
                "normals": {
                    "type": "texture_2d",
                    "unit": 1,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/normal.dds"
                },
                "roughness": {
                    "type": "texture_2d",
                    "unit": 2,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/spec.dds"
                },
                "metalness": {
                    "type": "texture_2d",
                    "unit": 3,
                    "bind_flags": [
                        "ps"
                    ],
                    "sampler": "wrap_linear",
                    "default": "data/textures/defaults/black.dds"
                }
            },
            "constants_used_bytes": 36,
            "constants_size_bytes": 48,
            "name": "forward_lit",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "blue_noise",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 5
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "ltc_mat",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 13
                },
                {
                    "name": "ltc_mag",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 12
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                },
                {
                    "name": "volume_gi",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 9
                },
                {
                    "name": "single_shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d",
                    "unit": 7
                },
                {
                    "name": "shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d_array",
                    "unit": 15
                },
                {
                    "name": "shadowmap_texture_sss",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                },
                {
                    "name": "albedo",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normals",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "roughness",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "metalness",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 3
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "material_data",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "blend_indices",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                },
                {
                    "name": "blend_weights",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 96
                }
            ],
            "instance_inputs": [
                {
                    "name": "world_matrix_0",
                    "semantic_index": 6,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_matrix_1",
                    "semantic_index": 7,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "world_matrix_2",
                    "semantic_index": 8,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "world_matrix_3",
                    "semantic_index": 9,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "user_data",
                    "semantic_index": 10,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "user_data2",
                    "semantic_index": 11,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                }
            ],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                },
                {
                    "name": "colour",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 84
                }
            ],
            "vs_file": "forward_lit__3221225482__.vsc",
            "ps_file": "forward_lit__1073741850__.psc",
            "permutation_id": 3221225498,
            "permutation_option_mask": 3221225498
        },
        {
            "vs": "vs_main",
            "ps": "ps_simple_lighting",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                },
                "SSS": {
                    "val": 4,
                    "type": "checkbox"
                }
            },
            "constants": {
                "albedo": {
                    "type": "float4",
                    "widget": "colour",
                    "default": [
                        1.0,
                        1.0,
                        1.0,
                        1.0
                    ],
                    "offset": 0,
                    "num_elements": 4
                },
                "roughness": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.5,
                    "offset": 4,
                    "num_elements": 1
                },
                "reflectivity": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.3,
                    "offset": 5,
                    "num_elements": 1
                }
            },
            "constants_used_bytes": 24,
            "constants_size_bytes": 32,
            "name": "simple_lighting",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "ltc_mat",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 13
                },
                {
                    "name": "ltc_mag",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 12
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                },
                {
                    "name": "volume_gi",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 9
                },
                {
                    "name": "single_shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d",
                    "unit": 7
                },
                {
                    "name": "shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d_array",
                    "unit": 15
                },
                {
                    "name": "shadowmap_texture_sss",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "material_data",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                },
                {
                    "name": "colour",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 84
                }
            ],
            "vs_file": "forward_lit.vsc",
            "ps_file": "simple_lighting.psc",
            "permutation_id": 0,
            "permutation_option_mask": 3221225476
        },
        {
            "vs": "vs_main",
            "ps": "ps_simple_lighting",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                },
                "SSS": {
                    "val": 4,
                    "type": "checkbox"
                }
            },
            "constants": {
                "albedo": {
                    "type": "float4",
                    "widget": "colour",
                    "default": [
                        1.0,
                        1.0,
                        1.0,
                        1.0
                    ],
                    "offset": 0,
                    "num_elements": 4
                },
                "roughness": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.5,
                    "offset": 4,
                    "num_elements": 1
                },
                "reflectivity": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.3,
                    "offset": 5,
                    "num_elements": 1
                }
            },
            "constants_used_bytes": 24,
            "constants_size_bytes": 32,
            "name": "simple_lighting",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "ltc_mat",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 13
                },
                {
                    "name": "ltc_mag",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 12
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                },
                {
                    "name": "volume_gi",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 9
                },
                {
                    "name": "single_shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d",
                    "unit": 7
                },
                {
                    "name": "shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d_array",
                    "unit": 15
                },
                {
                    "name": "shadowmap_texture_sss",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "material_data",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "blend_indices",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                },
                {
                    "name": "blend_weights",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 96
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                },
                {
                    "name": "colour",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 84
                }
            ],
            "vs_file": "forward_lit__2147483648__.vsc",
            "ps_file": "simple_lighting.psc",
            "permutation_id": 2147483648,
            "permutation_option_mask": 3221225476
        },
        {
            "vs": "vs_main",
            "ps": "ps_simple_lighting",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                },
                "SSS": {
                    "val": 4,
                    "type": "checkbox"
                }
            },
            "constants": {
                "albedo": {
                    "type": "float4",
                    "widget": "colour",
                    "default": [
                        1.0,
                        1.0,
                        1.0,
                        1.0
                    ],
                    "offset": 0,
                    "num_elements": 4
                },
                "roughness": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.5,
                    "offset": 4,
                    "num_elements": 1
                },
                "reflectivity": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.3,
                    "offset": 5,
                    "num_elements": 1
                }
            },
            "constants_used_bytes": 24,
            "constants_size_bytes": 32,
            "name": "simple_lighting",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "ltc_mat",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 13
                },
                {
                    "name": "ltc_mag",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 12
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                },
                {
                    "name": "volume_gi",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 9
                },
                {
                    "name": "single_shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d",
                    "unit": 7
                },
                {
                    "name": "shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d_array",
                    "unit": 15
                },
                {
                    "name": "shadowmap_texture_sss",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "material_data",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                }
            ],
            "instance_inputs": [
                {
                    "name": "world_matrix_0",
                    "semantic_index": 6,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_matrix_1",
                    "semantic_index": 7,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "world_matrix_2",
                    "semantic_index": 8,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "world_matrix_3",
                    "semantic_index": 9,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "user_data",
                    "semantic_index": 10,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "user_data2",
                    "semantic_index": 11,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                }
            ],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                },
                {
                    "name": "colour",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 84
                }
            ],
            "vs_file": "forward_lit__1073741824__.vsc",
            "ps_file": "simple_lighting__1073741824__.psc",
            "permutation_id": 1073741824,
            "permutation_option_mask": 3221225476
        },
        {
            "vs": "vs_main",
            "ps": "ps_simple_lighting",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                },
                "SSS": {
                    "val": 4,
                    "type": "checkbox"
                }
            },
            "constants": {
                "albedo": {
                    "type": "float4",
                    "widget": "colour",
                    "default": [
                        1.0,
                        1.0,
                        1.0,
                        1.0
                    ],
                    "offset": 0,
                    "num_elements": 4
                },
                "roughness": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.5,
                    "offset": 4,
                    "num_elements": 1
                },
                "reflectivity": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.3,
                    "offset": 5,
                    "num_elements": 1
                }
            },
            "constants_used_bytes": 24,
            "constants_size_bytes": 32,
            "name": "simple_lighting",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "ltc_mat",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 13
                },
                {
                    "name": "ltc_mag",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 12
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                },
                {
                    "name": "volume_gi",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 9
                },
                {
                    "name": "single_shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d",
                    "unit": 7
                },
                {
                    "name": "shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d_array",
                    "unit": 15
                },
                {
                    "name": "shadowmap_texture_sss",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "material_data",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "blend_indices",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                },
                {
                    "name": "blend_weights",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 96
                }
            ],
            "instance_inputs": [
                {
                    "name": "world_matrix_0",
                    "semantic_index": 6,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_matrix_1",
                    "semantic_index": 7,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "world_matrix_2",
                    "semantic_index": 8,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "world_matrix_3",
                    "semantic_index": 9,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "user_data",
                    "semantic_index": 10,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "user_data2",
                    "semantic_index": 11,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                }
            ],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                },
                {
                    "name": "colour",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 84
                }
            ],
            "vs_file": "forward_lit__3221225472__.vsc",
            "ps_file": "simple_lighting__1073741824__.psc",
            "permutation_id": 3221225472,
            "permutation_option_mask": 3221225476
        },
        {
            "vs": "vs_main",
            "ps": "ps_simple_lighting",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                },
                "SSS": {
                    "val": 4,
                    "type": "checkbox"
                }
            },
            "constants": {
                "albedo": {
                    "type": "float4",
                    "widget": "colour",
                    "default": [
                        1.0,
                        1.0,
                        1.0,
                        1.0
                    ],
                    "offset": 0,
                    "num_elements": 4
                },
                "roughness": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.5,
                    "offset": 4,
                    "num_elements": 1
                },
                "reflectivity": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.3,
                    "offset": 5,
                    "num_elements": 1
                },
                "sss_scale": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 500,
                    "default": 1.0,
                    "offset": 6,
                    "num_elements": 1
                }
            },
            "constants_used_bytes": 28,
            "constants_size_bytes": 32,
            "name": "simple_lighting",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "ltc_mat",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 13
                },
                {
                    "name": "ltc_mag",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 12
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                },
                {
                    "name": "volume_gi",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 9
                },
                {
                    "name": "single_shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d",
                    "unit": 7
                },
                {
                    "name": "shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d_array",
                    "unit": 15
                },
                {
                    "name": "shadowmap_texture_sss",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "material_data",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                },
                {
                    "name": "colour",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 84
                }
            ],
            "vs_file": "simple_lighting__4__.vsc",
            "ps_file": "simple_lighting__4__.psc",
            "permutation_id": 4,
            "permutation_option_mask": 3221225476
        },
        {
            "vs": "vs_main",
            "ps": "ps_simple_lighting",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                },
                "SSS": {
                    "val": 4,
                    "type": "checkbox"
                }
            },
            "constants": {
                "albedo": {
                    "type": "float4",
                    "widget": "colour",
                    "default": [
                        1.0,
                        1.0,
                        1.0,
                        1.0
                    ],
                    "offset": 0,
                    "num_elements": 4
                },
                "roughness": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.5,
                    "offset": 4,
                    "num_elements": 1
                },
                "reflectivity": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.3,
                    "offset": 5,
                    "num_elements": 1
                },
                "sss_scale": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 500,
                    "default": 1.0,
                    "offset": 6,
                    "num_elements": 1
                }
            },
            "constants_used_bytes": 28,
            "constants_size_bytes": 32,
            "name": "simple_lighting",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "ltc_mat",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 13
                },
                {
                    "name": "ltc_mag",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 12
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                },
                {
                    "name": "volume_gi",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 9
                },
                {
                    "name": "single_shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d",
                    "unit": 7
                },
                {
                    "name": "shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d_array",
                    "unit": 15
                },
                {
                    "name": "shadowmap_texture_sss",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "material_data",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "blend_indices",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                },
                {
                    "name": "blend_weights",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 96
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                },
                {
                    "name": "colour",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 84
                }
            ],
            "vs_file": "simple_lighting__2147483652__.vsc",
            "ps_file": "simple_lighting__4__.psc",
            "permutation_id": 2147483652,
            "permutation_option_mask": 3221225476
        },
        {
            "vs": "vs_main",
            "ps": "ps_simple_lighting",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                },
                "SSS": {
                    "val": 4,
                    "type": "checkbox"
                }
            },
            "constants": {
                "albedo": {
                    "type": "float4",
                    "widget": "colour",
                    "default": [
                        1.0,
                        1.0,
                        1.0,
                        1.0
                    ],
                    "offset": 0,
                    "num_elements": 4
                },
                "roughness": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.5,
                    "offset": 4,
                    "num_elements": 1
                },
                "reflectivity": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.3,
                    "offset": 5,
                    "num_elements": 1
                },
                "sss_scale": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 500,
                    "default": 1.0,
                    "offset": 6,
                    "num_elements": 1
                }
            },
            "constants_used_bytes": 28,
            "constants_size_bytes": 32,
            "name": "simple_lighting",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "ltc_mat",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 13
                },
                {
                    "name": "ltc_mag",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 12
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                },
                {
                    "name": "volume_gi",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 9
                },
                {
                    "name": "single_shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d",
                    "unit": 7
                },
                {
                    "name": "shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d_array",
                    "unit": 15
                },
                {
                    "name": "shadowmap_texture_sss",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "material_data",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                }
            ],
            "instance_inputs": [
                {
                    "name": "world_matrix_0",
                    "semantic_index": 6,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_matrix_1",
                    "semantic_index": 7,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "world_matrix_2",
                    "semantic_index": 8,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "world_matrix_3",
                    "semantic_index": 9,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "user_data",
                    "semantic_index": 10,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "user_data2",
                    "semantic_index": 11,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                }
            ],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                },
                {
                    "name": "colour",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 84
                }
            ],
            "vs_file": "forward_lit__1073741824__.vsc",
            "ps_file": "simple_lighting__1073741828__.psc",
            "permutation_id": 1073741828,
            "permutation_option_mask": 3221225476
        },
        {
            "vs": "vs_main",
            "ps": "ps_simple_lighting",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                },
                "SSS": {
                    "val": 4,
                    "type": "checkbox"
                }
            },
            "constants": {
                "albedo": {
                    "type": "float4",
                    "widget": "colour",
                    "default": [
                        1.0,
                        1.0,
                        1.0,
                        1.0
                    ],
                    "offset": 0,
                    "num_elements": 4
                },
                "roughness": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.5,
                    "offset": 4,
                    "num_elements": 1
                },
                "reflectivity": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.3,
                    "offset": 5,
                    "num_elements": 1
                },
                "sss_scale": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 500,
                    "default": 1.0,
                    "offset": 6,
                    "num_elements": 1
                }
            },
            "constants_used_bytes": 28,
            "constants_size_bytes": 32,
            "name": "simple_lighting",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "ltc_mat",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 13
                },
                {
                    "name": "ltc_mag",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 12
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                },
                {
                    "name": "volume_gi",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 9
                },
                {
                    "name": "single_shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d",
                    "unit": 7
                },
                {
                    "name": "shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d_array",
                    "unit": 15
                },
                {
                    "name": "shadowmap_texture_sss",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "material_data",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "blend_indices",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                },
                {
                    "name": "blend_weights",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 96
                }
            ],
            "instance_inputs": [
                {
                    "name": "world_matrix_0",
                    "semantic_index": 6,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_matrix_1",
                    "semantic_index": 7,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "world_matrix_2",
                    "semantic_index": 8,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "world_matrix_3",
                    "semantic_index": 9,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "user_data",
                    "semantic_index": 10,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "user_data2",
                    "semantic_index": 11,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                }
            ],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                },
                {
                    "name": "colour",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 84
                }
            ],
            "vs_file": "forward_lit__3221225472__.vsc",
            "ps_file": "simple_lighting__1073741828__.psc",
            "permutation_id": 3221225476,
            "permutation_option_mask": 3221225476
        },
        {
            "vs": "vs_main",
            "ps": "ps_gbuffer",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                },
                "UV_SCALE": {
                    "val": 2,
                    "type": "checkbox"
                }
            },
            "inherit_constants": [
                "forward_lit"
            ],
            "constants": {
                "albedo": {
                    "type": "float4",
                    "widget": "colour",
                    "default": [
                        1.0,
                        1.0,
                        1.0,
                        1.0
                    ],
                    "offset": 0,
                    "num_elements": 4
                },
                "roughness": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.5,
                    "offset": 4,
                    "num_elements": 1
                },
                "reflectivity": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.3,
                    "offset": 5,
                    "num_elements": 1
                }
            },
            "constants_used_bytes": 24,
            "constants_size_bytes": 32,
            "name": "gbuffer",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "ltc_mat",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 13
                },
                {
                    "name": "ltc_mag",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 12
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                },
                {
                    "name": "volume_gi",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 9
                },
                {
                    "name": "single_shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d",
                    "unit": 7
                },
                {
                    "name": "shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d_array",
                    "unit": 15
                },
                {
                    "name": "shadowmap_texture_sss",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "material_data",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                },
                {
                    "name": "colour",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 84
                }
            ],
            "vs_file": "forward_lit.vsc",
            "ps_file": "gbuffer.psc",
            "permutation_id": 0,
            "permutation_option_mask": 3221225474
        },
        {
            "vs": "vs_main",
            "ps": "ps_gbuffer",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                },
                "UV_SCALE": {
                    "val": 2,
                    "type": "checkbox"
                }
            },
            "inherit_constants": [
                "forward_lit"
            ],
            "constants": {
                "albedo": {
                    "type": "float4",
                    "widget": "colour",
                    "default": [
                        1.0,
                        1.0,
                        1.0,
                        1.0
                    ],
                    "offset": 0,
                    "num_elements": 4
                },
                "roughness": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.5,
                    "offset": 4,
                    "num_elements": 1
                },
                "reflectivity": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.3,
                    "offset": 5,
                    "num_elements": 1
                }
            },
            "constants_used_bytes": 24,
            "constants_size_bytes": 32,
            "name": "gbuffer",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "ltc_mat",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 13
                },
                {
                    "name": "ltc_mag",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 12
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                },
                {
                    "name": "volume_gi",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 9
                },
                {
                    "name": "single_shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d",
                    "unit": 7
                },
                {
                    "name": "shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d_array",
                    "unit": 15
                },
                {
                    "name": "shadowmap_texture_sss",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "material_data",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "blend_indices",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                },
                {
                    "name": "blend_weights",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 96
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                },
                {
                    "name": "colour",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 84
                }
            ],
            "vs_file": "forward_lit__2147483648__.vsc",
            "ps_file": "gbuffer.psc",
            "permutation_id": 2147483648,
            "permutation_option_mask": 3221225474
        },
        {
            "vs": "vs_main",
            "ps": "ps_gbuffer",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                },
                "UV_SCALE": {
                    "val": 2,
                    "type": "checkbox"
                }
            },
            "inherit_constants": [
                "forward_lit"
            ],
            "constants": {
                "albedo": {
                    "type": "float4",
                    "widget": "colour",
                    "default": [
                        1.0,
                        1.0,
                        1.0,
                        1.0
                    ],
                    "offset": 0,
                    "num_elements": 4
                },
                "roughness": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.5,
                    "offset": 4,
                    "num_elements": 1
                },
                "reflectivity": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.3,
                    "offset": 5,
                    "num_elements": 1
                }
            },
            "constants_used_bytes": 24,
            "constants_size_bytes": 32,
            "name": "gbuffer",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "ltc_mat",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 13
                },
                {
                    "name": "ltc_mag",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 12
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                },
                {
                    "name": "volume_gi",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 9
                },
                {
                    "name": "single_shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d",
                    "unit": 7
                },
                {
                    "name": "shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d_array",
                    "unit": 15
                },
                {
                    "name": "shadowmap_texture_sss",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "material_data",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                }
            ],
            "instance_inputs": [
                {
                    "name": "world_matrix_0",
                    "semantic_index": 6,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_matrix_1",
                    "semantic_index": 7,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "world_matrix_2",
                    "semantic_index": 8,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "world_matrix_3",
                    "semantic_index": 9,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "user_data",
                    "semantic_index": 10,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "user_data2",
                    "semantic_index": 11,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                }
            ],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                },
                {
                    "name": "colour",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 84
                }
            ],
            "vs_file": "forward_lit__1073741824__.vsc",
            "ps_file": "gbuffer.psc",
            "permutation_id": 1073741824,
            "permutation_option_mask": 3221225474
        },
        {
            "vs": "vs_main",
            "ps": "ps_gbuffer",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                },
                "UV_SCALE": {
                    "val": 2,
                    "type": "checkbox"
                }
            },
            "inherit_constants": [
                "forward_lit"
            ],
            "constants": {
                "albedo": {
                    "type": "float4",
                    "widget": "colour",
                    "default": [
                        1.0,
                        1.0,
                        1.0,
                        1.0
                    ],
                    "offset": 0,
                    "num_elements": 4
                },
                "roughness": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.5,
                    "offset": 4,
                    "num_elements": 1
                },
                "reflectivity": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.3,
                    "offset": 5,
                    "num_elements": 1
                }
            },
            "constants_used_bytes": 24,
            "constants_size_bytes": 32,
            "name": "gbuffer",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "ltc_mat",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 13
                },
                {
                    "name": "ltc_mag",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 12
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                },
                {
                    "name": "volume_gi",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 9
                },
                {
                    "name": "single_shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d",
                    "unit": 7
                },
                {
                    "name": "shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d_array",
                    "unit": 15
                },
                {
                    "name": "shadowmap_texture_sss",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "material_data",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "blend_indices",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                },
                {
                    "name": "blend_weights",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 96
                }
            ],
            "instance_inputs": [
                {
                    "name": "world_matrix_0",
                    "semantic_index": 6,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_matrix_1",
                    "semantic_index": 7,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "world_matrix_2",
                    "semantic_index": 8,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "world_matrix_3",
                    "semantic_index": 9,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "user_data",
                    "semantic_index": 10,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "user_data2",
                    "semantic_index": 11,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                }
            ],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                },
                {
                    "name": "colour",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 84
                }
            ],
            "vs_file": "forward_lit__3221225472__.vsc",
            "ps_file": "gbuffer.psc",
            "permutation_id": 3221225472,
            "permutation_option_mask": 3221225474
        },
        {
            "vs": "vs_main",
            "ps": "ps_gbuffer",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                },
                "UV_SCALE": {
                    "val": 2,
                    "type": "checkbox"
                }
            },
            "inherit_constants": [
                "forward_lit"
            ],
            "constants": {
                "albedo": {
                    "type": "float4",
                    "widget": "colour",
                    "default": [
                        1.0,
                        1.0,
                        1.0,
                        1.0
                    ],
                    "offset": 0,
                    "num_elements": 4
                },
                "uv_scale": {
                    "type": "float2",
                    "widget": "slider",
                    "min": 0,
                    "max": 100,
                    "default": 1.0,
                    "offset": 4,
                    "num_elements": 2
                },
                "roughness": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.5,
                    "offset": 6,
                    "num_elements": 1
                },
                "reflectivity": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.3,
                    "offset": 7,
                    "num_elements": 1
                }
            },
            "constants_used_bytes": 32,
            "constants_size_bytes": 32,
            "name": "gbuffer",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "ltc_mat",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 13
                },
                {
                    "name": "ltc_mag",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 12
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                },
                {
                    "name": "volume_gi",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 9
                },
                {
                    "name": "single_shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d",
                    "unit": 7
                },
                {
                    "name": "shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d_array",
                    "unit": 15
                },
                {
                    "name": "shadowmap_texture_sss",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "material_data",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                },
                {
                    "name": "colour",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 84
                }
            ],
            "vs_file": "forward_lit__2__.vsc",
            "ps_file": "gbuffer__2__.psc",
            "permutation_id": 2,
            "permutation_option_mask": 3221225474
        },
        {
            "vs": "vs_main",
            "ps": "ps_gbuffer",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                },
                "UV_SCALE": {
                    "val": 2,
                    "type": "checkbox"
                }
            },
            "inherit_constants": [
                "forward_lit"
            ],
            "constants": {
                "albedo": {
                    "type": "float4",
                    "widget": "colour",
                    "default": [
                        1.0,
                        1.0,
                        1.0,
                        1.0
                    ],
                    "offset": 0,
                    "num_elements": 4
                },
                "uv_scale": {
                    "type": "float2",
                    "widget": "slider",
                    "min": 0,
                    "max": 100,
                    "default": 1.0,
                    "offset": 4,
                    "num_elements": 2
                },
                "roughness": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.5,
                    "offset": 6,
                    "num_elements": 1
                },
                "reflectivity": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.3,
                    "offset": 7,
                    "num_elements": 1
                }
            },
            "constants_used_bytes": 32,
            "constants_size_bytes": 32,
            "name": "gbuffer",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "ltc_mat",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 13
                },
                {
                    "name": "ltc_mag",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 12
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                },
                {
                    "name": "volume_gi",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 9
                },
                {
                    "name": "single_shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d",
                    "unit": 7
                },
                {
                    "name": "shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d_array",
                    "unit": 15
                },
                {
                    "name": "shadowmap_texture_sss",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "material_data",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "blend_indices",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                },
                {
                    "name": "blend_weights",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 96
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                },
                {
                    "name": "colour",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 84
                }
            ],
            "vs_file": "forward_lit__2147483650__.vsc",
            "ps_file": "gbuffer__2__.psc",
            "permutation_id": 2147483650,
            "permutation_option_mask": 3221225474
        },
        {
            "vs": "vs_main",
            "ps": "ps_gbuffer",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                },
                "UV_SCALE": {
                    "val": 2,
                    "type": "checkbox"
                }
            },
            "inherit_constants": [
                "forward_lit"
            ],
            "constants": {
                "albedo": {
                    "type": "float4",
                    "widget": "colour",
                    "default": [
                        1.0,
                        1.0,
                        1.0,
                        1.0
                    ],
                    "offset": 0,
                    "num_elements": 4
                },
                "uv_scale": {
                    "type": "float2",
                    "widget": "slider",
                    "min": 0,
                    "max": 100,
                    "default": 1.0,
                    "offset": 4,
                    "num_elements": 2
                },
                "roughness": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.5,
                    "offset": 6,
                    "num_elements": 1
                },
                "reflectivity": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.3,
                    "offset": 7,
                    "num_elements": 1
                }
            },
            "constants_used_bytes": 32,
            "constants_size_bytes": 32,
            "name": "gbuffer",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "ltc_mat",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 13
                },
                {
                    "name": "ltc_mag",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 12
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                },
                {
                    "name": "volume_gi",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 9
                },
                {
                    "name": "single_shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d",
                    "unit": 7
                },
                {
                    "name": "shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d_array",
                    "unit": 15
                },
                {
                    "name": "shadowmap_texture_sss",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "material_data",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                }
            ],
            "instance_inputs": [
                {
                    "name": "world_matrix_0",
                    "semantic_index": 6,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_matrix_1",
                    "semantic_index": 7,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "world_matrix_2",
                    "semantic_index": 8,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "world_matrix_3",
                    "semantic_index": 9,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "user_data",
                    "semantic_index": 10,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "user_data2",
                    "semantic_index": 11,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                }
            ],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                },
                {
                    "name": "colour",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 84
                }
            ],
            "vs_file": "forward_lit__1073741826__.vsc",
            "ps_file": "gbuffer__2__.psc",
            "permutation_id": 1073741826,
            "permutation_option_mask": 3221225474
        },
        {
            "vs": "vs_main",
            "ps": "ps_gbuffer",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                },
                "UV_SCALE": {
                    "val": 2,
                    "type": "checkbox"
                }
            },
            "inherit_constants": [
                "forward_lit"
            ],
            "constants": {
                "albedo": {
                    "type": "float4",
                    "widget": "colour",
                    "default": [
                        1.0,
                        1.0,
                        1.0,
                        1.0
                    ],
                    "offset": 0,
                    "num_elements": 4
                },
                "uv_scale": {
                    "type": "float2",
                    "widget": "slider",
                    "min": 0,
                    "max": 100,
                    "default": 1.0,
                    "offset": 4,
                    "num_elements": 2
                },
                "roughness": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.5,
                    "offset": 6,
                    "num_elements": 1
                },
                "reflectivity": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.3,
                    "offset": 7,
                    "num_elements": 1
                }
            },
            "constants_used_bytes": 32,
            "constants_size_bytes": 32,
            "name": "gbuffer",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "ltc_mat",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 13
                },
                {
                    "name": "ltc_mag",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 12
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                },
                {
                    "name": "volume_gi",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 9
                },
                {
                    "name": "single_shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d",
                    "unit": 7
                },
                {
                    "name": "shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d_array",
                    "unit": 15
                },
                {
                    "name": "shadowmap_texture_sss",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "material_data",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "blend_indices",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                },
                {
                    "name": "blend_weights",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 96
                }
            ],
            "instance_inputs": [
                {
                    "name": "world_matrix_0",
                    "semantic_index": 6,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_matrix_1",
                    "semantic_index": 7,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "world_matrix_2",
                    "semantic_index": 8,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "world_matrix_3",
                    "semantic_index": 9,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "user_data",
                    "semantic_index": 10,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "user_data2",
                    "semantic_index": 11,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                }
            ],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                },
                {
                    "name": "colour",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 84
                }
            ],
            "vs_file": "forward_lit__3221225474__.vsc",
            "ps_file": "gbuffer__2__.psc",
            "permutation_id": 3221225474,
            "permutation_option_mask": 3221225474
        },
        {
            "vs": "vs_main_zonly",
            "ps": "ps_null",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                }
            },
            "name": "zonly",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "ltc_mat",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 13
                },
                {
                    "name": "ltc_mag",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 12
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                },
                {
                    "name": "volume_gi",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 9
                },
                {
                    "name": "single_shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d",
                    "unit": 7
                },
                {
                    "name": "shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d_array",
                    "unit": 15
                },
                {
                    "name": "shadowmap_texture_sss",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                }
            ],
            "vs_file": "zonly.vsc",
            "ps_file": "zonly.psc",
            "permutation_id": 0,
            "permutation_option_mask": 3221225472
        },
        {
            "vs": "vs_main_zonly",
            "ps": "ps_null",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                }
            },
            "name": "zonly",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "ltc_mat",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 13
                },
                {
                    "name": "ltc_mag",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 12
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                },
                {
                    "name": "volume_gi",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 9
                },
                {
                    "name": "single_shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d",
                    "unit": 7
                },
                {
                    "name": "shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d_array",
                    "unit": 15
                },
                {
                    "name": "shadowmap_texture_sss",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "blend_indices",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                },
                {
                    "name": "blend_weights",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 96
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                }
            ],
            "vs_file": "zonly__2147483648__.vsc",
            "ps_file": "zonly.psc",
            "permutation_id": 2147483648,
            "permutation_option_mask": 3221225472
        },
        {
            "vs": "vs_main_zonly",
            "ps": "ps_null",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                }
            },
            "name": "zonly",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "ltc_mat",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 13
                },
                {
                    "name": "ltc_mag",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 12
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                },
                {
                    "name": "volume_gi",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 9
                },
                {
                    "name": "single_shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d",
                    "unit": 7
                },
                {
                    "name": "shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d_array",
                    "unit": 15
                },
                {
                    "name": "shadowmap_texture_sss",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                }
            ],
            "instance_inputs": [
                {
                    "name": "world_matrix_0",
                    "semantic_index": 6,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_matrix_1",
                    "semantic_index": 7,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "world_matrix_2",
                    "semantic_index": 8,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "world_matrix_3",
                    "semantic_index": 9,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "user_data",
                    "semantic_index": 10,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "user_data2",
                    "semantic_index": 11,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                }
            ],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                }
            ],
            "vs_file": "zonly__1073741824__.vsc",
            "ps_file": "zonly.psc",
            "permutation_id": 1073741824,
            "permutation_option_mask": 3221225472
        },
        {
            "vs": "vs_main_zonly",
            "ps": "ps_null",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                }
            },
            "name": "zonly",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "ltc_mat",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 13
                },
                {
                    "name": "ltc_mag",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 12
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                },
                {
                    "name": "volume_gi",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 9
                },
                {
                    "name": "single_shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d",
                    "unit": 7
                },
                {
                    "name": "shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d_array",
                    "unit": 15
                },
                {
                    "name": "shadowmap_texture_sss",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "blend_indices",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                },
                {
                    "name": "blend_weights",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 96
                }
            ],
            "instance_inputs": [
                {
                    "name": "world_matrix_0",
                    "semantic_index": 6,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_matrix_1",
                    "semantic_index": 7,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "world_matrix_2",
                    "semantic_index": 8,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "world_matrix_3",
                    "semantic_index": 9,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "user_data",
                    "semantic_index": 10,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "user_data2",
                    "semantic_index": 11,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                }
            ],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                }
            ],
            "vs_file": "zonly__3221225472__.vsc",
            "ps_file": "zonly.psc",
            "permutation_id": 3221225472,
            "permutation_option_mask": 3221225472
        },
        {
            "vs": "vs_main",
            "ps": "ps_single_light",
            "constants": {
                "albedo": {
                    "type": "float4",
                    "widget": "colour",
                    "default": [
                        1.0,
                        1.0,
                        1.0,
                        1.0
                    ],
                    "offset": 0,
                    "num_elements": 4
                },
                "roughness": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.5,
                    "offset": 4,
                    "num_elements": 1
                },
                "reflectivity": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.3,
                    "offset": 5,
                    "num_elements": 1
                }
            },
            "constants_used_bytes": 24,
            "constants_size_bytes": 32,
            "name": "single_light_directional",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "ltc_mat",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 13
                },
                {
                    "name": "ltc_mag",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 12
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                },
                {
                    "name": "volume_gi",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 9
                },
                {
                    "name": "single_shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d",
                    "unit": 7
                },
                {
                    "name": "shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d_array",
                    "unit": 15
                },
                {
                    "name": "shadowmap_texture_sss",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "material_data",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                },
                {
                    "name": "colour",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 84
                }
            ],
            "vs_file": "forward_lit.vsc",
            "ps_file": "single_light_directional.psc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        },
        {
            "vs": "vs_main",
            "ps": "ps_lambert",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                }
            },
            "constants": {
                "albedo": {
                    "type": "float4",
                    "widget": "colour",
                    "default": [
                        1.0,
                        1.0,
                        1.0,
                        1.0
                    ],
                    "offset": 0,
                    "num_elements": 4
                }
            },
            "constants_used_bytes": 16,
            "constants_size_bytes": 16,
            "name": "lambert",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "ltc_mat",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 13
                },
                {
                    "name": "ltc_mag",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 12
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                },
                {
                    "name": "volume_gi",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 9
                },
                {
                    "name": "single_shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d",
                    "unit": 7
                },
                {
                    "name": "shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d_array",
                    "unit": 15
                },
                {
                    "name": "shadowmap_texture_sss",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "material_data",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                },
                {
                    "name": "colour",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 84
                }
            ],
            "vs_file": "lambert.vsc",
            "ps_file": "lambert.psc",
            "permutation_id": 0,
            "permutation_option_mask": 3221225472
        },
        {
            "vs": "vs_main",
            "ps": "ps_lambert",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                }
            },
            "constants": {
                "albedo": {
                    "type": "float4",
                    "widget": "colour",
                    "default": [
                        1.0,
                        1.0,
                        1.0,
                        1.0
                    ],
                    "offset": 0,
                    "num_elements": 4
                }
            },
            "constants_used_bytes": 16,
            "constants_size_bytes": 16,
            "name": "lambert",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "ltc_mat",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 13
                },
                {
                    "name": "ltc_mag",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 12
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                },
                {
                    "name": "volume_gi",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 9
                },
                {
                    "name": "single_shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d",
                    "unit": 7
                },
                {
                    "name": "shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d_array",
                    "unit": 15
                },
                {
                    "name": "shadowmap_texture_sss",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "material_data",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "blend_indices",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                },
                {
                    "name": "blend_weights",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 96
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                },
                {
                    "name": "colour",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 84
                }
            ],
            "vs_file": "lambert__2147483648__.vsc",
            "ps_file": "lambert.psc",
            "permutation_id": 2147483648,
            "permutation_option_mask": 3221225472
        },
        {
            "vs": "vs_main",
            "ps": "ps_lambert",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                }
            },
            "constants": {
                "albedo": {
                    "type": "float4",
                    "widget": "colour",
                    "default": [
                        1.0,
                        1.0,
                        1.0,
                        1.0
                    ],
                    "offset": 0,
                    "num_elements": 4
                }
            },
            "constants_used_bytes": 16,
            "constants_size_bytes": 16,
            "name": "lambert",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "ltc_mat",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 13
                },
                {
                    "name": "ltc_mag",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 12
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                },
                {
                    "name": "volume_gi",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 9
                },
                {
                    "name": "single_shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d",
                    "unit": 7
                },
                {
                    "name": "shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d_array",
                    "unit": 15
                },
                {
                    "name": "shadowmap_texture_sss",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "material_data",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                }
            ],
            "instance_inputs": [
                {
                    "name": "world_matrix_0",
                    "semantic_index": 6,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_matrix_1",
                    "semantic_index": 7,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "world_matrix_2",
                    "semantic_index": 8,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "world_matrix_3",
                    "semantic_index": 9,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "user_data",
                    "semantic_index": 10,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "user_data2",
                    "semantic_index": 11,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                }
            ],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                },
                {
                    "name": "colour",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 84
                }
            ],
            "vs_file": "forward_lit__1073741824__.vsc",
            "ps_file": "lambert.psc",
            "permutation_id": 1073741824,
            "permutation_option_mask": 3221225472
        },
        {
            "vs": "vs_main",
            "ps": "ps_lambert",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                }
            },
            "constants": {
                "albedo": {
                    "type": "float4",
                    "widget": "colour",
                    "default": [
                        1.0,
                        1.0,
                        1.0,
                        1.0
                    ],
                    "offset": 0,
                    "num_elements": 4
                }
            },
            "constants_used_bytes": 16,
            "constants_size_bytes": 16,
            "name": "lambert",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "ltc_mat",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 13
                },
                {
                    "name": "ltc_mag",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 12
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                },
                {
                    "name": "volume_gi",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 9
                },
                {
                    "name": "single_shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d",
                    "unit": 7
                },
                {
                    "name": "shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d_array",
                    "unit": 15
                },
                {
                    "name": "shadowmap_texture_sss",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "material_data",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "blend_indices",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                },
                {
                    "name": "blend_weights",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 96
                }
            ],
            "instance_inputs": [
                {
                    "name": "world_matrix_0",
                    "semantic_index": 6,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_matrix_1",
                    "semantic_index": 7,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "world_matrix_2",
                    "semantic_index": 8,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "world_matrix_3",
                    "semantic_index": 9,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "user_data",
                    "semantic_index": 10,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "user_data2",
                    "semantic_index": 11,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                }
            ],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                },
                {
                    "name": "colour",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 84
                }
            ],
            "vs_file": "forward_lit__3221225472__.vsc",
            "ps_file": "lambert.psc",
            "permutation_id": 3221225472,
            "permutation_option_mask": 3221225472
        },
        {
            "vs": "vs_main",
            "ps": "ps_single_light_diffuse",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                }
            },
            "inherit_constants": [
                "forward_lit"
            ],
            "constants": {
                "albedo": {
                    "type": "float4",
                    "widget": "colour",
                    "default": [
                        1.0,
                        1.0,
                        1.0,
                        1.0
                    ],
                    "offset": 0,
                    "num_elements": 4
                },
                "roughness": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.5,
                    "offset": 4,
                    "num_elements": 1
                },
                "reflectivity": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.3,
                    "offset": 5,
                    "num_elements": 1
                }
            },
            "constants_used_bytes": 24,
            "constants_size_bytes": 32,
            "name": "gi",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "ltc_mat",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 13
                },
                {
                    "name": "ltc_mag",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 12
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                },
                {
                    "name": "volume_gi",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 9
                },
                {
                    "name": "single_shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d",
                    "unit": 7
                },
                {
                    "name": "shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d_array",
                    "unit": 15
                },
                {
                    "name": "shadowmap_texture_sss",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "material_data",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                },
                {
                    "name": "colour",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 84
                }
            ],
            "vs_file": "forward_lit.vsc",
            "ps_file": "gi.psc",
            "permutation_id": 0,
            "permutation_option_mask": 3221225472
        },
        {
            "vs": "vs_main",
            "ps": "ps_single_light_diffuse",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                }
            },
            "inherit_constants": [
                "forward_lit"
            ],
            "constants": {
                "albedo": {
                    "type": "float4",
                    "widget": "colour",
                    "default": [
                        1.0,
                        1.0,
                        1.0,
                        1.0
                    ],
                    "offset": 0,
                    "num_elements": 4
                },
                "roughness": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.5,
                    "offset": 4,
                    "num_elements": 1
                },
                "reflectivity": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.3,
                    "offset": 5,
                    "num_elements": 1
                }
            },
            "constants_used_bytes": 24,
            "constants_size_bytes": 32,
            "name": "gi",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "ltc_mat",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 13
                },
                {
                    "name": "ltc_mag",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 12
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                },
                {
                    "name": "volume_gi",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 9
                },
                {
                    "name": "single_shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d",
                    "unit": 7
                },
                {
                    "name": "shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d_array",
                    "unit": 15
                },
                {
                    "name": "shadowmap_texture_sss",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "material_data",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "blend_indices",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                },
                {
                    "name": "blend_weights",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 96
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                },
                {
                    "name": "colour",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 84
                }
            ],
            "vs_file": "forward_lit__2147483648__.vsc",
            "ps_file": "gi.psc",
            "permutation_id": 2147483648,
            "permutation_option_mask": 3221225472
        },
        {
            "vs": "vs_main",
            "ps": "ps_single_light_diffuse",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                }
            },
            "inherit_constants": [
                "forward_lit"
            ],
            "constants": {
                "albedo": {
                    "type": "float4",
                    "widget": "colour",
                    "default": [
                        1.0,
                        1.0,
                        1.0,
                        1.0
                    ],
                    "offset": 0,
                    "num_elements": 4
                },
                "roughness": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.5,
                    "offset": 4,
                    "num_elements": 1
                },
                "reflectivity": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.3,
                    "offset": 5,
                    "num_elements": 1
                }
            },
            "constants_used_bytes": 24,
            "constants_size_bytes": 32,
            "name": "gi",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "ltc_mat",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 13
                },
                {
                    "name": "ltc_mag",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 12
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                },
                {
                    "name": "volume_gi",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 9
                },
                {
                    "name": "single_shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d",
                    "unit": 7
                },
                {
                    "name": "shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d_array",
                    "unit": 15
                },
                {
                    "name": "shadowmap_texture_sss",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "material_data",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                }
            ],
            "instance_inputs": [
                {
                    "name": "world_matrix_0",
                    "semantic_index": 6,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_matrix_1",
                    "semantic_index": 7,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "world_matrix_2",
                    "semantic_index": 8,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "world_matrix_3",
                    "semantic_index": 9,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "user_data",
                    "semantic_index": 10,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "user_data2",
                    "semantic_index": 11,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                }
            ],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                },
                {
                    "name": "colour",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 84
                }
            ],
            "vs_file": "forward_lit__1073741824__.vsc",
            "ps_file": "gi.psc",
            "permutation_id": 1073741824,
            "permutation_option_mask": 3221225472
        },
        {
            "vs": "vs_main",
            "ps": "ps_single_light_diffuse",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                }
            },
            "inherit_constants": [
                "forward_lit"
            ],
            "constants": {
                "albedo": {
                    "type": "float4",
                    "widget": "colour",
                    "default": [
                        1.0,
                        1.0,
                        1.0,
                        1.0
                    ],
                    "offset": 0,
                    "num_elements": 4
                },
                "roughness": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.5,
                    "offset": 4,
                    "num_elements": 1
                },
                "reflectivity": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1,
                    "default": 0.3,
                    "offset": 5,
                    "num_elements": 1
                }
            },
            "constants_used_bytes": 24,
            "constants_size_bytes": 32,
            "name": "gi",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "ltc_mat",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 13
                },
                {
                    "name": "ltc_mag",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 12
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                },
                {
                    "name": "volume_gi",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 9
                },
                {
                    "name": "single_shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d",
                    "unit": 7
                },
                {
                    "name": "shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d_array",
                    "unit": 15
                },
                {
                    "name": "shadowmap_texture_sss",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "material_data",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "blend_indices",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                },
                {
                    "name": "blend_weights",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 96
                }
            ],
            "instance_inputs": [
                {
                    "name": "world_matrix_0",
                    "semantic_index": 6,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_matrix_1",
                    "semantic_index": 7,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "world_matrix_2",
                    "semantic_index": 8,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "world_matrix_3",
                    "semantic_index": 9,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "user_data",
                    "semantic_index": 10,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "user_data2",
                    "semantic_index": 11,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                }
            ],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                },
                {
                    "name": "colour",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 84
                }
            ],
            "vs_file": "forward_lit__3221225472__.vsc",
            "ps_file": "gi.psc",
            "permutation_id": 3221225472,
            "permutation_option_mask": 3221225472
        },
        {
            "vs": "vs_main_pre_skin",
            "stream_out": true,
            "name": "pre_skin",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "ltc_mat",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 13
                },
                {
                    "name": "ltc_mag",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 12
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                },
                {
                    "name": "volume_gi",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 9
                },
                {
                    "name": "single_shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d",
                    "unit": 7
                },
                {
                    "name": "shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d_array",
                    "unit": 15
                },
                {
                    "name": "shadowmap_texture_sss",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "blend_indices",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                },
                {
                    "name": "blend_weights",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 96
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "vb_position",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                }
            ],
            "vs_file": "pre_skin.vsc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        },
        {
            "vs": "vs_main_extrude",
            "ps": "ps_dbg",
            "name": "shadow_extrude",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "ltc_mat",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 13
                },
                {
                    "name": "ltc_mag",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 12
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                },
                {
                    "name": "volume_gi",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 9
                },
                {
                    "name": "single_shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d",
                    "unit": 7
                },
                {
                    "name": "shadowmap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "depth_2d_array",
                    "unit": 15
                },
                {
                    "name": "shadowmap_texture_sss",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 8
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "face_normal_0",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "face_normal_1",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                },
                {
                    "name": "colour",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 84
                }
            ],
            "vs_file": "shadow_extrude.vsc",
            "ps_file": "shadow_extrude.psc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        }
    ],
    "failures": {}
}#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//forward_render forward_lit__2147483658__ vs 2147483658
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
layout(location = 0) in float4 position_vs_input;
layout(location = 1) in float4 normal_vs_input;
layout(location = 2) in float4 texcoord_vs_input;
layout(location = 3) in float4 tangent_vs_input;
layout(location = 4) in float4 bitangent_vs_input;
layout(location = 5) in float4 blend_indices_vs_input;
layout(location = 6) in float4 blend_weights_vs_input;
out float4 world_pos_vs_output;
out float3 normal_vs_output;
out float3 tangent_vs_output;
out float3 bitangent_vs_output;
out float4 texcoord_vs_output;
out float4 colour_vs_output;
uniform float v_flip;
struct vs_input_multi
{
    float4 position;
    float4 normal;
    float4 texcoord;
    float4 tangent;
    float4 bitangent;
    float4 blend_indices;
    float4 blend_weights;
};
struct vs_output
{
    float4 position;
    float4 world_pos;
    float3 normal;
    float3 tangent;
    float3 bitangent;
    float4 texcoord;
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform skinning_info
{
    float4x4 bones[85];
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
layout (std140) uniform per_draw_call
{
    float4x4 world_matrix;
    float4 user_data;
    float4 user_data2;
    float4x4 world_matrix_inv_transpose;
};
layout (std140) uniform material_data
{
    float4 m_albedo;
    float2 m_uv_scale;
    float m_roughness;
    float m_reflectivity;
    float m_surface_offset;
    float3 m_padding;
};
float4 skin_pos(float4 pos, float4 weights, float4 indices)
{
    int bone_indices[4];
    bone_indices[0] = int(indices.x);
    bone_indices[1] = int(indices.y);
    bone_indices[2] = int(indices.z);
    bone_indices[3] = int(indices.w);
    float4 sp = float4( 0.0, 0.0, 0.0, 0.0 );
    float final_weight = 1.0;
    for(int i = 3; i >= 0; --i)
    {
        sp += mul( pos, bones[bone_indices[i]] ) * weights[i];
        final_weight -= weights[i];
    }
    sp += mul( pos, bones[bone_indices[0]] ) * final_weight;
    sp.w = 1.0;
    return sp;
}
void skin_tbn(inout float3 t, inout float3 b, inout float3 n, float4 weights, float4 indices)
{
    int bone_indices[4];
    bone_indices[0] = int(indices.x);
    bone_indices[1] = int(indices.y);
    bone_indices[2] = int(indices.z);
    bone_indices[3] = int(indices.w);
    float3 rt = float3( 0.0, 0.0, 0.0);
    float3 rb = float3( 0.0, 0.0, 0.0);
    float3 rn = float3( 0.0, 0.0, 0.0);
    float final_weight = 1.0;
    for( int i = 0; i < 3; ++i)
    {
        float3x3 rot_mat = to_3x3(bones[bone_indices[i]]);
        rt += mul(t, rot_mat) * weights[i];
        rb += mul(b, rot_mat) * weights[i];
        rn += mul(n, rot_mat) * weights[i];
        final_weight -= weights[i];
    }
    float3x3 rot_mat = to_3x3(bones[bone_indices[3]]);
    rt += mul(t, rot_mat) * final_weight;
    rb += mul(b, rot_mat) * final_weight;
    rn += mul(n, rot_mat) * final_weight;
    t = rt;
    b = rb;
    n = rn;
}
void main()
{
    //assign vs_input_multi struct from glsl inputs
    vs_input_multi _input;
    _input.position = position_vs_input;
    _input.normal = normal_vs_input;
    _input.texcoord = texcoord_vs_input;
    _input.tangent = tangent_vs_input;
    _input.bitangent = bitangent_vs_input;
    _input.blend_indices = blend_indices_vs_input;
    _input.blend_weights = blend_weights_vs_input;
    vs_output _output;
    float4x4 wvp = mul( world_matrix, vp_matrix );
    float4x4 wm = world_matrix;
    _output.texcoord = float4(_input.texcoord.x, 1.0 - _input.texcoord.y,
    _input.texcoord.z, 1.0 - _input.texcoord.w );
    _output.colour = m_albedo;
    float4 sp = skin_pos(_input.position, _input.blend_weights, _input.blend_indices);
    _output.tangent = _input.tangent.xyz;
    _output.bitangent = _input.bitangent.xyz;
    _output.normal = _input.normal.xyz;
    skin_tbn(_output.tangent, _output.bitangent, _output.normal, _input.blend_weights, _input.blend_indices);
    _output.position = mul( sp, vp_matrix );
    _output.world_pos = sp;
    float3 scale = float3(length(world_matrix[0].xyz),
    length(world_matrix[1].xyz),
    length(world_matrix[2].xyz));
    float xs = length(_input.tangent.xyz * scale);
    float ys = length(_input.bitangent.xyz * scale);
    _output.texcoord *= float4(m_uv_scale.x * xs, m_uv_scale.y * ys, m_uv_scale.x, m_uv_scale.y);
    //assign glsl global outputs from structs
    gl_Position = _output.position;
    gl_Position.y *= v_flip;
    world_pos_vs_output = _output.world_pos;
    normal_vs_output = _output.normal;
    tangent_vs_output = _output.tangent;
    bitangent_vs_output = _output.bitangent;
    texcoord_vs_output = _output.texcoord;
    colour_vs_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//forward_render forward_lit__3221225474__ vs 3221225474
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
layout(location = 0) in float4 position_vs_input;
layout(location = 1) in float4 normal_vs_input;
layout(location = 2) in float4 texcoord_vs_input;
layout(location = 3) in float4 tangent_vs_input;
layout(location = 4) in float4 bitangent_vs_input;
layout(location = 5) in float4 blend_indices_vs_input;
layout(location = 6) in float4 blend_weights_vs_input;
layout(location = 7) in float4 world_matrix_0_instance_input;
layout(location = 8) in float4 world_matrix_1_instance_input;
layout(location = 9) in float4 world_matrix_2_instance_input;
layout(location = 10) in float4 world_matrix_3_instance_input;
layout(location = 11) in float4 user_data_instance_input;
layout(location = 12) in float4 user_data2_instance_input;
out float4 world_pos_vs_output;
out float3 normal_vs_output;
out float3 tangent_vs_output;
out float3 bitangent_vs_output;
out float4 texcoord_vs_output;
out float4 colour_vs_output;
uniform float v_flip;
struct vs_input_multi
{
    float4 position;
    float4 normal;
    float4 texcoord;
    float4 tangent;
    float4 bitangent;
    float4 blend_indices;
    float4 blend_weights;
};
struct vs_instance_input
{
    float4 world_matrix_0;
    float4 world_matrix_1;
    float4 world_matrix_2;
    float4 world_matrix_3;
    float4 user_data;
    float4 user_data2;
};
struct vs_output
{
    float4 position;
    float4 world_pos;
    float3 normal;
    float3 tangent;
    float3 bitangent;
    float4 texcoord;
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform skinning_info
{
    float4x4 bones[85];
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
layout (std140) uniform per_draw_call
{
    float4x4 world_matrix;
    float4 user_data;
    float4 user_data2;
    float4x4 world_matrix_inv_transpose;
};
layout (std140) uniform material_data
{
    float4 m_albedo;
    float2 m_uv_scale;
    float m_roughness;
    float m_reflectivity;
};
float4 skin_pos(float4 pos, float4 weights, float4 indices)
{
    int bone_indices[4];
    bone_indices[0] = int(indices.x);
    bone_indices[1] = int(indices.y);
    bone_indices[2] = int(indices.z);
    bone_indices[3] = int(indices.w);
    float4 sp = float4( 0.0, 0.0, 0.0, 0.0 );
    float final_weight = 1.0;
    for(int i = 3; i >= 0; --i)
    {
        sp += mul( pos, bones[bone_indices[i]] ) * weights[i];
        final_weight -= weights[i];
    }
    sp += mul( pos, bones[bone_indices[0]] ) * final_weight;
    sp.w = 1.0;
    return sp;
}
void skin_tbn(inout float3 t, inout float3 b, inout float3 n, float4 weights, float4 indices)
{
    int bone_indices[4];
    bone_indices[0] = int(indices.x);
    bone_indices[1] = int(indices.y);
    bone_indices[2] = int(indices.z);
    bone_indices[3] = int(indices.w);
    float3 rt = float3( 0.0, 0.0, 0.0);
    float3 rb = float3( 0.0, 0.0, 0.0);
    float3 rn = float3( 0.0, 0.0, 0.0);
    float final_weight = 1.0;
    for( int i = 0; i < 3; ++i)
    {
        float3x3 rot_mat = to_3x3(bones[bone_indices[i]]);
        rt += mul(t, rot_mat) * weights[i];
        rb += mul(b, rot_mat) * weights[i];
        rn += mul(n, rot_mat) * weights[i];
        final_weight -= weights[i];
    }
    float3x3 rot_mat = to_3x3(bones[bone_indices[3]]);
    rt += mul(t, rot_mat) * final_weight;
    rb += mul(b, rot_mat) * final_weight;
    rn += mul(n, rot_mat) * final_weight;
    t = rt;
    b = rb;
    n = rn;
}
void main()
{
    //assign vs_input_multi struct from glsl inputs
    vs_input_multi _input;
    _input.position = position_vs_input;
    _input.normal = normal_vs_input;
    _input.texcoord = texcoord_vs_input;
    _input.tangent = tangent_vs_input;
    _input.bitangent = bitangent_vs_input;
    _input.blend_indices = blend_indices_vs_input;
    _input.blend_weights = blend_weights_vs_input;
    //assign vs_instance_input struct from glsl inputs
    vs_instance_input instance_input;
    instance_input.world_matrix_0 = world_matrix_0_instance_input;
    instance_input.world_matrix_1 = world_matrix_1_instance_input;
    instance_input.world_matrix_2 = world_matrix_2_instance_input;
    instance_input.world_matrix_3 = world_matrix_3_instance_input;
    instance_input.user_data = user_data_instance_input;
    instance_input.user_data2 = user_data2_instance_input;
    vs_output _output;
    float4x4 wvp = mul( world_matrix, vp_matrix );
    float4x4 wm = world_matrix;
    _output.texcoord = float4(_input.texcoord.x, 1.0 - _input.texcoord.y,
    _input.texcoord.z, 1.0 - _input.texcoord.w );
    float4x4 instance_world_mat;
    unpack_vb_instance_mat(
    instance_world_mat,
    instance_input.world_matrix_0,
    instance_input.world_matrix_1,
    instance_input.world_matrix_2,
    instance_input.world_matrix_3
    );
    wvp = mul( instance_world_mat, vp_matrix );
    wm = instance_world_mat;
    _output.colour = instance_input.user_data2;
    float4 sp = skin_pos(_input.position, _input.blend_weights, _input.blend_indices);
    _output.tangent = _input.tangent.xyz;
    _output.bitangent = _input.bitangent.xyz;
    _output.normal = _input.normal.xyz;
    skin_tbn(_output.tangent, _output.bitangent, _output.normal, _input.blend_weights, _input.blend_indices);
    _output.position = mul( sp, vp_matrix );
    _output.world_pos = sp;
    float3 scale = float3(length(world_matrix[0].xyz),
    length(world_matrix[1].xyz),
    length(world_matrix[2].xyz));
    float xs = length(_input.tangent.xyz * scale);
    float ys = length(_input.bitangent.xyz * scale);
    _output.texcoord *= float4(m_uv_scale.x * xs, m_uv_scale.y * ys, m_uv_scale.x, m_uv_scale.y);
    //assign glsl global outputs from structs
    gl_Position = _output.position;
    gl_Position.y *= v_flip;
    world_pos_vs_output = _output.world_pos;
    normal_vs_output = _output.normal;
    tangent_vs_output = _output.tangent;
    bitangent_vs_output = _output.bitangent;
    texcoord_vs_output = _output.texcoord;
    colour_vs_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//forward_render pre_skin vs 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
layout(location = 0) in float4 position_vs_input;
layout(location = 1) in float4 normal_vs_input;
layout(location = 2) in float4 texcoord_vs_input;
layout(location = 3) in float4 tangent_vs_input;
layout(location = 4) in float4 bitangent_vs_input;
layout(location = 5) in float4 blend_indices_vs_input;
layout(location = 6) in float4 blend_weights_vs_input;
out float4 vb_position_vs_output;
out float4 normal_vs_output;
out float4 tangent_vs_output;
out float4 bitangent_vs_output;
out float4 texcoord_vs_output;
uniform float v_flip;
struct vs_input_skinned
{
    float4 position;
    float4 normal;
    float4 texcoord;
    float4 tangent;
    float4 bitangent;
    float4 blend_indices;
    float4 blend_weights;
};
struct vs_output_pre_skin
{
    float4 vb_position;
    float4 normal;
    float4 tangent;
    float4 bitangent;
    float4 texcoord;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform skinning_info
{
    float4x4 bones[85];
};
float4 skin_pos(float4 pos, float4 weights, float4 indices)
{
    int bone_indices[4];
    bone_indices[0] = int(indices.x);
    bone_indices[1] = int(indices.y);
    bone_indices[2] = int(indices.z);
    bone_indices[3] = int(indices.w);
    float4 sp = float4( 0.0, 0.0, 0.0, 0.0 );
    float final_weight = 1.0;
    for(int i = 3; i >= 0; --i)
    {
        sp += mul( pos, bones[bone_indices[i]] ) * weights[i];
        final_weight -= weights[i];
    }
    sp += mul( pos, bones[bone_indices[0]] ) * final_weight;
    sp.w = 1.0;
    return sp;
}
void skin_tbn(inout float3 t, inout float3 b, inout float3 n, float4 weights, float4 indices)
{
    int bone_indices[4];
    bone_indices[0] = int(indices.x);
    bone_indices[1] = int(indices.y);
    bone_indices[2] = int(indices.z);
    bone_indices[3] = int(indices.w);
    float3 rt = float3( 0.0, 0.0, 0.0);
    float3 rb = float3( 0.0, 0.0, 0.0);
    float3 rn = float3( 0.0, 0.0, 0.0);
    float final_weight = 1.0;
    for( int i = 0; i < 3; ++i)
    {
        float3x3 rot_mat = to_3x3(bones[bone_indices[i]]);
        rt += mul(t, rot_mat) * weights[i];
        rb += mul(b, rot_mat) * weights[i];
        rn += mul(n, rot_mat) * weights[i];
        final_weight -= weights[i];
    }
    float3x3 rot_mat = to_3x3(bones[bone_indices[3]]);
    rt += mul(t, rot_mat) * final_weight;
    rb += mul(b, rot_mat) * final_weight;
    rn += mul(n, rot_mat) * final_weight;
    t = rt;
    b = rb;
    n = rn;
}
void main()
{
    //assign vs_input_skinned struct from glsl inputs
    vs_input_skinned _input;
    _input.position = position_vs_input;
    _input.normal = normal_vs_input;
    _input.texcoord = texcoord_vs_input;
    _input.tangent = tangent_vs_input;
    _input.bitangent = bitangent_vs_input;
    _input.blend_indices = blend_indices_vs_input;
    _input.blend_weights = blend_weights_vs_input;
    vs_output_pre_skin _output;
    float4 sp = skin_pos(_input.position, _input.blend_weights, _input.blend_indices);
    _output.vb_position = sp;
    _output.normal = _input.normal;
    _output.tangent = _input.tangent;
    _output.bitangent = _input.bitangent;
    _output.texcoord = _input.texcoord;
    float3 t = _input.tangent.xyz;
    float3 b = _input.bitangent.xyz;
    float3 n = _input.normal.xyz;
    skin_tbn(t, b, n, _input.blend_weights, _input.blend_indices);
    _output.normal.xyz = n;
    _output.tangent.xyz = t;
    _output.bitangent.xyz = b;
    //assign glsl global outputs from structs
    vb_position_vs_output = _output.vb_position;
    normal_vs_output = _output.normal;
    tangent_vs_output = _output.tangent;
    bitangent_vs_output = _output.bitangent;
    texcoord_vs_output = _output.texcoord;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//forward_render forward_lit__1073741832__ ps 1073741832
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 world_pos_vs_output;
in float3 normal_vs_output;
in float3 tangent_vs_output;
in float3 bitangent_vs_output;
in float4 texcoord_vs_output;
in float4 colour_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 world_pos;
    float3 normal;
    float3 tangent;
    float3 bitangent;
    float4 texcoord;
    float4 colour;
};
struct ps_output
{
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
layout (std140) uniform per_draw_call
{
    float4x4 world_matrix;
    float4 user_data;
    float4 user_data2;
    float4x4 world_matrix_inv_transpose;
};
layout (std140) uniform per_pass_lights
{
    float4 light_info;
    light_data lights[100];
};
layout (std140) uniform per_pass_shadow
{
    float4x4 shadow_matrix[100];
};
layout (std140) uniform per_pass_shadow_distance_fields
{
    distance_field_shadow sdf_shadow;
};
layout (std140) uniform per_pass_area_lights
{
    float4 area_light_info;
    area_light_data area_lights[10];
};
layout (std140) uniform material_data
{
    float4 m_albedo;
    float m_roughness;
    float m_reflectivity;
    float m_surface_offset;
    float m_padding;
};
texture_2d( diffuse_texture, 0 );
texture_2d( normal_texture, 1 );
texture_2d( specular_texture, 2 );
texture_3d( sdf_volume, 14 );
texture_2d( ltc_mat, 13 );
texture_2d( ltc_mag, 12 );
texture_2d_array( area_light_textures, 11 );
depth_2d_array( shadowmap_texture, 15 );
float3 cook_torrence(
float4 light_pos_radius,
float3 light_colour,
float3 n,
float3 world_pos,
float3 view_pos,
float3 albedo,
float3 metalness,
float roughness,
float reflectivity
)
{
    float3 l = normalize( light_pos_radius.xyz - world_pos.xyz );
    float n_dot_l = dot( n, l );
    if( n_dot_l > 0.0f )
    {
        float roughness_sq = roughness * roughness;
        float k = reflectivity;
        float3 v_view = normalize( (view_pos.xyz - world_pos.xyz) );
        float3 hv = normalize( v_view + l );
        float n_dot_v = dot( n, v_view );
        float n_dot_h = dot( n, hv );
        float v_dot_h = dot( v_view, hv );
        float n_dot_h_2 = 2.0f * n_dot_h;
        float g1 = (n_dot_h_2 * n_dot_v) / v_dot_h;
        float g2 = (n_dot_h_2 * n_dot_l) / v_dot_h;
        float geom_atten = min(1.0, min(g1, g2));
        float r1 = 1.0f / ( 4.0f * roughness_sq * pow(n_dot_h, 4.0f));
        float r2 = (n_dot_h * n_dot_h - 1.0) / (roughness_sq * n_dot_h * n_dot_h);
        float roughness_atten = r1 * exp(r2);
        float fresnel = pow(1.0 - v_dot_h, 5.0);
        fresnel *= roughness;
        fresnel += reflectivity;
        float specular = (fresnel * geom_atten * roughness_atten) / (n_dot_v * n_dot_l * 3.1419);
        float3 lit_colour = metalness * light_colour * n_dot_l * ( k + specular * ( 1.0 - k ) );
        return saturate(lit_colour);
    }
    return float3( 0.0, 0.0, 0.0 );
}
float3 oren_nayar(
float4 light_pos_radius,
float3 light_colour,
float3 n,
float3 world_pos,
float3 view_pos,
float roughness,
float3 albedo)
{
    float3 v = normalize(view_pos-world_pos);
    float3 l = normalize(light_pos_radius.xyz-world_pos);
    float l_dot_v = dot(l, v);
    float n_dot_l = dot(n, l);
    float n_dot_v = dot(n, v);
    float s = l_dot_v - n_dot_l * n_dot_v;
    float t = lerp(1.0, max(n_dot_l, n_dot_v), step(0.0, s));
    float lum = length( albedo );
    float sigma2 = roughness * roughness;
    float A = 1.0 + sigma2 * (lum / (sigma2 + 0.13) + 0.5 / (sigma2 + 0.33));
    float B = 0.45 * sigma2 / (sigma2 + 0.09);
    return ( albedo * light_colour * max(0.0, n_dot_l) * (A + B * s / t) / 3.14159265 );
}
float spot_light_attenuation(
float4 light_pos_radius,
float4 light_dir_cutoff,
float falloff,
float3 world_pos)
{
    float co = light_dir_cutoff.w;
    float3 vl = normalize(world_pos.xyz - light_pos_radius.xyz);
    float3 sd = normalize(light_dir_cutoff.xyz);
    float dp = (1.0 - dot(vl, sd));
    return smoothstep(co, co - falloff, dp);
}
float point_light_attenuation_cutoff(
float4 light_pos_radius,
float3 world_pos)
{
    float r = light_pos_radius.w;
    float d = length(world_pos.xyz - light_pos_radius.xyz);
    d = max(d - r, 0.0);
    float denom = d/r + 1.0;
    float attenuation = 1.0 / (denom*denom);
    float cutoff = 0.2;
    attenuation = (attenuation - cutoff) / (1.0 - cutoff);
    attenuation = max(attenuation, 0.0);
    return attenuation;
}
float sample_shadow_array_pcf_9(float array_slice, float3 sp)
{
    float2 samples[9];
    float2 inv_sm_size = float2(1.0/2048.0, 1.0/2048.0);
    samples[0] = float2(-1.0, -1.0) * inv_sm_size;
    samples[1] = float2(-1.0, 0.0) * inv_sm_size;
    samples[2] = float2(-1.0, 1.0) * inv_sm_size;
    samples[3] = float2(0.0, -1.0) * inv_sm_size;
    samples[4] = float2(0.0, 0.0) * inv_sm_size;
    samples[5] = float2(0.0, 1.0) * inv_sm_size;
    samples[6] = float2(1.0, -1.0) * inv_sm_size;
    samples[7] = float2(1.0, 0.0) * inv_sm_size;
    samples[8] = float2(1.0, 1.0) * inv_sm_size;
    float shadow = 0.0;
    for(int j = 0; j < 9; ++j)
    {
        shadow += sample_depth_compare_array(shadowmap_texture, sp.xy + samples[j], array_slice, sp.z);
    }
    shadow /= 9.0;
    return shadow;
}
bool ray_vs_aabb(float3 emin, float3 emax, float3 r1, float3 rv, out float3 intersection)
{
    float3 dirfrac = float3(1.0, 1.0, 1.0) / rv;
    float t1 = (emin.x - r1.x)*dirfrac.x;
    float t2 = (emax.x - r1.x)*dirfrac.x;
    float t3 = (emin.y - r1.y)*dirfrac.y;
    float t4 = (emax.y - r1.y)*dirfrac.y;
    float t5 = (emin.z - r1.z)*dirfrac.z;
    float t6 = (emax.z - r1.z)*dirfrac.z;
    float tmin = max(max(min(t1, t2), min(t3, t4)), min(t5, t6));
    float tmax = min(min(max(t1, t2), max(t3, t4)), max(t5, t6));
    float t = 0.0;
    if (tmax < 0.0)
    {
        t = tmax;
        return false;
    }
    if (tmin > tmax)
    {
        t = tmax;
        return false;
    }
    t = tmin;
    intersection = r1 + rv * t;
    return true;
}
float sdf_shadow_trace(float max_samples, float3 light_pos, float3 world_pos, float3 scale, float3 ray_origin, float4x4 inv_mat, float3x3 inv_rot)
{
    float3 ray_dir = normalize(light_pos - world_pos);
    ray_dir = normalize( mul( ray_dir, inv_rot ) );
    float closest = 1.0;
    float3 uvw = ray_origin;
    if(abs(uvw.x) >= 1.0 || abs(uvw.y) >= 1.0 || abs(uvw.z) >= 1.0)
    {
        float3 emin = float3(-1.0, -1.0, -1.0);
        float3 emax = float3(1.0, 1.0, 1.0);
        float3 ip = float3(0.0, 0.0, 0.0);
        bool hit = ray_vs_aabb( emin, emax, uvw, ray_dir, ip);
        uvw = ip;
        if(!hit)
        {
            return closest;
        }
    }
    float3 light_uvw = mul( float4(light_pos, 1.0), inv_mat ).xyz * 0.5 + 0.5;
    uvw = uvw * 0.5 + 0.5;
    float3 v1 = normalize(light_uvw - uvw);
    for( int s = 0; s < int(max_samples); ++s )
    {
        float d = sample_texture_level( sdf_volume, uvw, 0.0 ).r;
        closest = min(d, closest);
        ray_dir = normalize(light_uvw - uvw);
        float3 step = ray_dir.xyz * float3(d, d, d) / scale * 0.7;
        uvw += step;
        if( d <= 0.0 )
        {
            closest = max( d, 0.0 );
            break;
        }
        if(uvw.x >= 1.0 || uvw.x < 0.0)
        break;
        if(uvw.y >= 1.0 || uvw.y < 0.0)
        break;
        if(uvw.z >= 1.0 || uvw.z < 0.0)
        break;
    }
    return closest;
}
float integrate_edge(float3 v1, float3 v2)
{
    float cos_theta = dot(v1, v2);
    float theta = acos(cos_theta);
    float res = cross(v1, v2).z * ((theta > 0.001) ? theta/sin(theta) : 1.0);
    return res;
}
void clip_quad_to_horizon(inout float3 L[5], out int n)
{
    int config = 0;
    if (L[0].z > 0.0) config += 1;
    if (L[1].z > 0.0) config += 2;
    if (L[2].z > 0.0) config += 4;
    if (L[3].z > 0.0) config += 8;
    n = 0;
    if (config == 0)
    {
    }
    else if (config == 1)
    {
        n = 3;
        L[1] = -L[1].z * L[0] + L[0].z * L[1];
        L[2] = -L[3].z * L[0] + L[0].z * L[3];
    }
    else if (config == 2)
    {
        n = 3;
        L[0] = -L[0].z * L[1] + L[1].z * L[0];
        L[2] = -L[2].z * L[1] + L[1].z * L[2];
    }
    else if (config == 3)
    {
        n = 4;
        L[2] = -L[2].z * L[1] + L[1].z * L[2];
        L[3] = -L[3].z * L[0] + L[0].z * L[3];
    }
    else if (config == 4)
    {
        n = 3;
        L[0] = -L[3].z * L[2] + L[2].z * L[3];
        L[1] = -L[1].z * L[2] + L[2].z * L[1];
    }
    else if (config == 5)
    {
        n = 0;
    }
    else if (config == 6)
    {
        n = 4;
        L[0] = -L[0].z * L[1] + L[1].z * L[0];
        L[3] = -L[3].z * L[2] + L[2].z * L[3];
    }
    else if (config == 7)
    {
        n = 5;
        L[4] = -L[3].z * L[0] + L[0].z * L[3];
        L[3] = -L[3].z * L[2] + L[2].z * L[3];
    }
    else if (config == 8)
    {
        n = 3;
        L[0] = -L[0].z * L[3] + L[3].z * L[0];
        L[1] = -L[2].z * L[3] + L[3].z * L[2];
        L[2] = L[3];
    }
    else if (config == 9)
    {
        n = 4;
        L[1] = -L[1].z * L[0] + L[0].z * L[1];
        L[2] = -L[2].z * L[3] + L[3].z * L[2];
    }
    else if (config == 10)
    {
        n = 0;
    }
    else if (config == 11)
    {
        n = 5;
        L[4] = L[3];
        L[3] = -L[2].z * L[3] + L[3].z * L[2];
        L[2] = -L[2].z * L[1] + L[1].z * L[2];
    }
    else if (config == 12)
    {
        n = 4;
        L[1] = -L[1].z * L[2] + L[2].z * L[1];
        L[0] = -L[0].z * L[3] + L[3].z * L[0];
    }
    else if (config == 13)
    {
        n = 5;
        L[4] = L[3];
        L[3] = L[2];
        L[2] = -L[1].z * L[2] + L[2].z * L[1];
        L[1] = -L[1].z * L[0] + L[0].z * L[1];
    }
    else if (config == 14)
    {
        n = 5;
        L[4] = -L[0].z * L[3] + L[3].z * L[0];
        L[0] = -L[0].z * L[1] + L[1].z * L[0];
    }
    else if (config == 15)
    {
        n = 4;
    }
    if (n == 3)
    L[3] = L[0];
    if (n == 4)
    L[4] = L[0];
}
float3 ltc_uv_coord(float3 p[4])
{
    float3 v1 = p[1] - p[0];
    float3 v2 = p[3] - p[0];
    float3 plane_ortho = (cross(v1, v2));
    float plane_area_squared = dot(plane_ortho, plane_ortho);
    float plane_distx_plane_area = dot(plane_ortho, p[0]);
    float3 pp = plane_distx_plane_area * plane_ortho / plane_area_squared - p[0];
    float v1_dot_v2 = dot(v1, v2);
    float inv_v1_dot_v1 = 1.0 / dot(v1, v1);
    float3 vv2 = v2 - v1 * v1_dot_v2 * inv_v1_dot_v1;
    float2 puv;
    puv.y = dot(vv2, pp) / dot(vv2, vv2);
    puv.x = dot(v1, pp) * inv_v1_dot_v1 - v1_dot_v2 * inv_v1_dot_v1 * puv.y;
    float d = abs(plane_distx_plane_area) / pow(plane_area_squared, 0.75);
    return float3(puv, d);
}
float4 ltc_evaluate(
float3 n,
float3 v,
float3 p,
float3x3 minv,
float3 points[4],
bool two_sided)
{
    float3 t1, t2;
    t1 = normalize(v - n * dot(v, n));
    t2 = cross(n, t1);
    float3x3 ttn = from_columns_3x3(t1, t2, n);
    minv = mul(minv, ttn);
    float3 l[5];
    l[0] = mul(minv, points[0] - p);
    l[1] = mul(minv, points[1] - p);
    l[2] = mul(minv, points[2] - p);
    l[3] = mul(minv, points[3] - p);
    l[4] = l[3];
    float3 ll[4];
    ll[0] = l[0];
    ll[1] = l[1];
    ll[2] = l[2];
    ll[3] = l[3];
    float3 uvl = ltc_uv_coord(ll);
    int nc;
    clip_quad_to_horizon(l, nc);
    if (nc == 0)
    return float4(0, 0, 0, 0.0);
    l[0] = normalize(l[0]);
    l[1] = normalize(l[1]);
    l[2] = normalize(l[2]);
    l[3] = normalize(l[3]);
    l[4] = normalize(l[4]);
    float sum = 0.0;
    sum += integrate_edge(l[0], l[1]);
    sum += integrate_edge(l[1], l[2]);
    sum += integrate_edge(l[2], l[3]);
    if (nc >= 4)
    sum += integrate_edge(l[3], l[4]);
    if (nc == 5)
    sum += integrate_edge(l[4], l[0]);
    sum = two_sided ? abs(sum) : max(0.0, sum);
    float3 lo_i = float3(sum, sum, sum);
    return float4(uvl.x, uvl.y, uvl.z, sum);
}
float ltc_evaluate_cc(
float3 n,
float3 v,
float3 p,
float3x3 minv,
float3 points[4],
bool two_sided)
{
    float3 t1, t2;
    t1 = normalize(v - n * dot(v, n));
    t2 = cross(n, t1);
    float3x3 ttn = from_columns_3x3(t1, t2, n);
    minv = mul(minv, ttn);
    float3 l[5];
    for(int i = 0; i < 4; ++i)
    l[i] = mul(minv, points[i] - p);
    l[4] = l[3];
    int nc;
    clip_quad_to_horizon(l, nc);
    if (nc == 0)
    return 0.0;
    for(int i = 0; i < 5; ++i)
    l[i] = normalize(l[i]);
    float sum = 0.0;
    sum += integrate_edge(l[0], l[1]);
    sum += integrate_edge(l[1], l[2]);
    sum += integrate_edge(l[2], l[3]);
    if (nc >= 4)
    sum += integrate_edge(l[3], l[4]);
    if (nc == 5)
    sum += integrate_edge(l[4], l[0]);
    sum = two_sided ? abs(sum) : max(0.0, sum);
    return sum;
}
float4 area_light_specular_uv(
float3 points[4],
float3 pos,
float roughness,
float3 n,
float3 v)
{
    float pi = 3.14159265359;
    float lut_size = 64.0;
    float lut_scale = (lut_size - 1.0)/lut_size;
    float lut_bias = 0.5/lut_size;
    float theta = acos(dot(n, v));
    float2 uv = float2(roughness, theta / (0.5 * pi));
    uv = uv * lut_scale + lut_bias;
    float4 mat = sample_texture(ltc_mat, uv);
    float mag = sample_texture(ltc_mag, uv).w;
    float3x3 minv = from_rows_3x3(
    float3(1.0, 0.0, mat.y),
    float3(0.0, mat.z, 0.0),
    float3(mat.w, 0.0, mat.x)
    );
    float4 spec = ltc_evaluate(n, v, pos, minv, points, true);
    return spec;
}
float area_light_specular(
float3 points[4],
float3 pos,
float roughness,
float3 n,
float3 v)
{
    float pi = 3.14159265359;
    float lut_size = 64.0;
    float lut_scale = (lut_size - 1.0)/lut_size;
    float lut_bias = 0.5/lut_size;
    float theta = acos(dot(n, v));
    float2 uv = float2(roughness, theta / (0.5 * pi));
    uv = uv * lut_scale + lut_bias;
    float4 mat = sample_texture(ltc_mat, uv);
    float mag = sample_texture(ltc_mag, uv).w;
    float3x3 minv = from_rows_3x3(
    float3(1.0, 0.0, mat.y),
    float3(0.0, mat.z, 0.0),
    float3(mat.w, 0.0, mat.x)
    );
    float spec = ltc_evaluate_cc(n, v, pos, minv, points, true);
    return spec;
}
float4 area_light_diffuse_uv(
float3 points[4],
float3 pos,
float3 n,
float3 v)
{
    float3x3 difv = float3x3(
    float3(1.0, 0.0, 0.0),
    float3(0.0, 1.0, 0.0),
    float3(0.0, 0.0, 1.0)
    );
    float4 diff = ltc_evaluate(n, v, pos, difv, points, true);
    return diff;
}
float area_light_diffuse(
float3 points[4],
float3 pos,
float3 n,
float3 v)
{
    float3x3 difv = float3x3(
    float3(1.0, 0.0, 0.0),
    float3(0.0, 1.0, 0.0),
    float3(0.0, 0.0, 1.0)
    );
    float diff = ltc_evaluate_cc(n, v, pos, difv, points, true);
    return diff;
}
float3 transform_ts_normal( float3 t, float3 b, float3 n, float3 ts_normal )
{
    float3x3 tbn;
    tbn[0] = float3(t.x, b.x, n.x);
    tbn[1] = float3(t.y, b.y, n.y);
    tbn[2] = float3(t.z, b.z, n.z);
    return normalize( mul_tbn( tbn, ts_normal ) );
}
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.world_pos = world_pos_vs_output;
    _input.normal = normal_vs_output;
    _input.tangent = tangent_vs_output;
    _input.bitangent = bitangent_vs_output;
    _input.texcoord = texcoord_vs_output;
    _input.colour = colour_vs_output;
    ps_output _output;
    float4 albedo = sample_texture( diffuse_texture, _input.texcoord.xy );
    float3 normal_sample = sample_texture( normal_texture, _input.texcoord.xy ).rgb;
    float4 ro_sample = sample_texture( specular_texture, _input.texcoord.xy );
    float4 specular_sample = float4(1.0, 1.0, 1.0, 1.0);
    normal_sample = normal_sample * 2.0 - 1.0;
    float3 n = transform_ts_normal(
    _input.tangent,
    _input.bitangent,
    _input.normal,
    normal_sample );
    albedo *= _input.colour;
    float4 metalness = float4(1.0, 1.0, 1.0, 1.0);
    float3 lit_colour = float3( 0.0, 0.0, 0.0 );
    float reflectivity = saturate(user_data.z);
    float roughness = saturate(user_data.y);
    reflectivity = m_reflectivity;
    roughness = ro_sample.r;
    roughness = _input.colour.a;
    albedo.a = 1.0;
    n = _input.normal.rgb;
    roughness = m_roughness;
    float max_samples = 128.0;
    float3x3 inv_rot = to_3x3(sdf_shadow.world_matrix_inv);
    float3 r1 = _input.world_pos.xyz + _input.normal.xyz * m_surface_offset;
    float3 tr1 = mul( float4(r1, 1.0), sdf_shadow.world_matrix_inv ).xyz;
    float3 scale = float3(length(sdf_shadow.world_matrix[0].xyz), length(sdf_shadow.world_matrix[1].xyz), length(sdf_shadow.world_matrix[2].xyz)) * 2.0;
    float3 vddx = ddx( r1 );
    float3 vddy = ddy( r1 );
    float t = 1.0;
    float3 lll = float3(0.0, 0.0, 0.0);
    int shadow_map_index = 0;
    _pmfx_loop
    for( int i = 0; i < int(light_info.x); ++i )
    {
        float3 light_col = float3( 0.0, 0.0, 0.0 );
        light_col += cook_torrence(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        albedo.rgb,
        metalness.rgb,
        roughness,
        reflectivity
        );
        light_col += oren_nayar(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        1.0 - roughness,
        albedo.rgb
        );
        float s = sdf_shadow_trace(max_samples, lights[i].pos_radius.xyz, _input.world_pos.xyz, scale, tr1, sdf_shadow.world_matrix_inv, inv_rot);
        light_col *= smoothstep( 0.0, 0.1, s);
        if( lights[i].colour.a == 0.0 )
        {
            lit_colour += light_col;
            continue;
        }
        else
        {
            float shadow = 1.0;
            float d = 1.0;
            float4 offset_pos = float4(_input.world_pos.xyz + n.xyz * 0.01, 1.0);
            float4 sp = mul( offset_pos, shadow_matrix[i] );
            sp.xyz /= sp.w;
            sp.y *= -1.0;
            sp.xy = sp.xy * 0.5 + 0.5;
            sp.z = remap_depth(sp.z);
            shadow = sample_shadow_array_pcf_9(float(shadow_map_index), sp.xyz);
            lit_colour += light_col * shadow;
            ++shadow_map_index;
        }
    }
    int point_start = int(light_info.x);
    int point_end = int(light_info.x) + int(light_info.y);
    int omni_shadow_index = 0;
    _pmfx_loop
    for( int i = point_start; i < point_end; ++i )
    {
        float3 light_col = float3( 0.0, 0.0, 0.0 );
        light_col += cook_torrence(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        albedo.rgb,
        metalness.rgb,
        roughness,
        reflectivity
        );
        light_col += oren_nayar(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        roughness,
        albedo.rgb
        );
        float a = point_light_attenuation_cutoff( lights[i].pos_radius, _input.world_pos.xyz );
        light_col *= a;
        float s = sdf_shadow_trace(max_samples, lights[i].pos_radius.xyz, _input.world_pos.xyz, scale, tr1, sdf_shadow.world_matrix_inv, inv_rot);
        light_col *= smoothstep( 0.0, 0.1, s);
        if( lights[i].colour.a == 0.0)
        {
            lit_colour += light_col;
            continue;
        }
        else
        {
            lit_colour += light_col;
            continue;
        }
    }
    int spot_start = point_end;
    int spot_end = spot_start + int(light_info.z);
    _pmfx_loop
    for(int i = spot_start; i < spot_end; ++i )
    {
        float3 light_col = float3( 0.0, 0.0, 0.0 );
        light_col += cook_torrence(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        albedo.rgb,
        metalness.rgb,
        roughness,
        reflectivity
        );
        light_col += oren_nayar(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        roughness,
        albedo.rgb
        );
        float a = spot_light_attenuation(lights[i].pos_radius,
        lights[i].dir_cutoff,
        lights[i].data.x,
        _input.world_pos.xyz );
        light_col *= a;
        float s = sdf_shadow_trace(max_samples, lights[i].pos_radius.xyz, _input.world_pos.xyz, scale, tr1, sdf_shadow.world_matrix_inv, inv_rot);
        light_col *= smoothstep( 0.0, 0.1, s);
        if( lights[i].colour.a == 0.0 )
        {
            lit_colour += light_col;
            continue;
        }
        else
        {
            float shadow = 1.0;
            float d = 1.0;
            float4 offset_pos = float4(_input.world_pos.xyz + n.xyz * 0.01, 1.0);
            float4 sp = mul( offset_pos, shadow_matrix[shadow_map_index] );
            sp.xyz /= sp.w;
            sp.y *= -1.0;
            sp.xy = sp.xy * 0.5 + 0.5;
            sp.z = remap_depth(sp.z);
            shadow = sample_shadow_array_pcf_9(float(shadow_map_index), sp.xyz);
            lit_colour += light_col * shadow;
            ++shadow_map_index;
        }
    }
    {
        float pi = 3.14159265359;
        int num_area_lights = int(area_light_info.x);
        for(int i = 0; i < num_area_lights; ++i)
        {
            float3 v = -normalize(_input.world_pos.xyz - camera_view_pos.xyz);
            float3 pos = _input.world_pos.xyz;
            float3 points[4];
            for(int j = 0; j < 4; ++j)
            points[j] = area_lights[i].corners[j].xyz;
            float diff_sum = area_light_diffuse(points, pos, n, v);
            float3 diff = area_lights[i].colour.rgb * diff_sum;
            float spec_sum = area_light_specular(points, pos, ro_sample.x, n, v);
            float3 spec = area_lights[i].colour.rgb * spec_sum;
            float3 light_col = (spec.rgb + diff.rgb) / (2.0 * pi);
            lit_colour += light_col;
        }
        int ts = num_area_lights;
        int num_area_lights_textured = int(area_light_info.y);
        for(int i = ts; i < ts + num_area_lights_textured; ++i)
        {
            float slice = area_lights[i].colour.w;
            float levels = 8.0;
            float2 inv_texel = float2(1.0/640.0, 1.0/480.0);
            float2 inv_texel_x = float2(1.0, 1.0) - inv_texel;
            float3 points[4];
            for(int j = 0; j < 4; ++j)
            points[j] = area_lights[i].corners[j].xyz;
            float3 v = -normalize(_input.world_pos.xyz - camera_view_pos.xyz);
            float3 pos = _input.world_pos.xyz;
            float4 diff_uv = area_light_diffuse_uv(points, pos, n, v);
            float2 duv = clamp(diff_uv.xy, inv_texel, inv_texel_x);
            float3 diff = sample_texture_array_level( area_light_textures, duv, slice, diff_uv.z * levels).rgb * diff_uv.w;
            float4 spec_uv = area_light_specular_uv(points, pos, ro_sample.x, n, v);
            float2 suv = clamp(spec_uv.xy, inv_texel, inv_texel_x);
            float3 spec = sample_texture_array_level(area_light_textures, suv, slice, spec_uv.z * levels).rgb * spec_uv.w;
            float3 light_col = (spec.rgb + diff.rgb) / (2.0 * pi);
            lit_colour += light_col;
        }
    }
    _output.colour.rgb = lit_colour.rgb * albedo.a;
    _output.colour.a = albedo.a;
    if(albedo.a <= 0.0)
    discard;
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//forward_render zonly vs 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
layout(location = 0) in float4 position_vs_input;
uniform float v_flip;
struct vs_input_position_only
{
    float4 position;
};
struct vs_output_zonly
{
    float4 position;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
layout (std140) uniform per_draw_call
{
    float4x4 world_matrix;
    float4 user_data;
    float4 user_data2;
    float4x4 world_matrix_inv_transpose;
};
void main()
{
    //assign vs_input_position_only struct from glsl inputs
    vs_input_position_only _input;
    _input.position = position_vs_input;
    vs_output_zonly _output;
    float4x4 wvp;
    wvp = mul( world_matrix, vp_matrix );
    _output.position = mul( _input.position, wvp );
    //assign glsl global outputs from structs
    gl_Position = _output.position;
    gl_Position.y *= v_flip;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//forward_render forward_lit__1073741848__ ps 1073741848
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 world_pos_vs_output;
in float3 normal_vs_output;
in float3 tangent_vs_output;
in float3 bitangent_vs_output;
in float4 texcoord_vs_output;
in float4 colour_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 world_pos;
    float3 normal;
    float3 tangent;
    float3 bitangent;
    float4 texcoord;
    float4 colour;
};
struct ps_output
{
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
layout (std140) uniform per_draw_call
{
    float4x4 world_matrix;
    float4 user_data;
    float4 user_data2;
    float4x4 world_matrix_inv_transpose;
};
layout (std140) uniform per_pass_lights
{
    float4 light_info;
    light_data lights[100];
};
layout (std140) uniform per_pass_shadow
{
    float4x4 shadow_matrix[100];
};
layout (std140) uniform per_pass_shadow_distance_fields
{
    distance_field_shadow sdf_shadow;
};
layout (std140) uniform per_pass_area_lights
{
    float4 area_light_info;
    area_light_data area_lights[10];
};
layout (std140) uniform cbuffer_gi_volume
{
    float4 gi_scene_size;
    float4 gi_volume_size;
};
layout (std140) uniform material_data
{
    float4 m_albedo;
    float m_roughness;
    float m_reflectivity;
    float m_surface_offset;
    float m_padding;
};
texture_2d( diffuse_texture, 0 );
texture_2d( normal_texture, 1 );
texture_2d( specular_texture, 2 );
texture_2d( blue_noise, 5 );
texture_3d( sdf_volume, 14 );
texture_2d( ltc_mat, 13 );
texture_2d( ltc_mag, 12 );
texture_2d_array( area_light_textures, 11 );
texture_3d( volume_gi, 9 );
depth_2d_array( shadowmap_texture, 15 );
float3 cook_torrence(
float4 light_pos_radius,
float3 light_colour,
float3 n,
float3 world_pos,
float3 view_pos,
float3 albedo,
float3 metalness,
float roughness,
float reflectivity
)
{
    float3 l = normalize( light_pos_radius.xyz - world_pos.xyz );
    float n_dot_l = dot( n, l );
    if( n_dot_l > 0.0f )
    {
        float roughness_sq = roughness * roughness;
        float k = reflectivity;
        float3 v_view = normalize( (view_pos.xyz - world_pos.xyz) );
        float3 hv = normalize( v_view + l );
        float n_dot_v = dot( n, v_view );
        float n_dot_h = dot( n, hv );
        float v_dot_h = dot( v_view, hv );
        float n_dot_h_2 = 2.0f * n_dot_h;
        float g1 = (n_dot_h_2 * n_dot_v) / v_dot_h;
        float g2 = (n_dot_h_2 * n_dot_l) / v_dot_h;
        float geom_atten = min(1.0, min(g1, g2));
        float r1 = 1.0f / ( 4.0f * roughness_sq * pow(n_dot_h, 4.0f));
        float r2 = (n_dot_h * n_dot_h - 1.0) / (roughness_sq * n_dot_h * n_dot_h);
        float roughness_atten = r1 * exp(r2);
        float fresnel = pow(1.0 - v_dot_h, 5.0);
        fresnel *= roughness;
        fresnel += reflectivity;
        float specular = (fresnel * geom_atten * roughness_atten) / (n_dot_v * n_dot_l * 3.1419);
        float3 lit_colour = metalness * light_colour * n_dot_l * ( k + specular * ( 1.0 - k ) );
        return saturate(lit_colour);
    }
    return float3( 0.0, 0.0, 0.0 );
}
float3 oren_nayar(
float4 light_pos_radius,
float3 light_colour,
float3 n,
float3 world_pos,
float3 view_pos,
float roughness,
float3 albedo)
{
    float3 v = normalize(view_pos-world_pos);
    float3 l = normalize(light_pos_radius.xyz-world_pos);
    float l_dot_v = dot(l, v);
    float n_dot_l = dot(n, l);
    float n_dot_v = dot(n, v);
    float s = l_dot_v - n_dot_l * n_dot_v;
    float t = lerp(1.0, max(n_dot_l, n_dot_v), step(0.0, s));
    float lum = length( albedo );
    float sigma2 = roughness * roughness;
    float A = 1.0 + sigma2 * (lum / (sigma2 + 0.13) + 0.5 / (sigma2 + 0.33));
    float B = 0.45 * sigma2 / (sigma2 + 0.09);
    return ( albedo * light_colour * max(0.0, n_dot_l) * (A + B * s / t) / 3.14159265 );
}
float spot_light_attenuation(
float4 light_pos_radius,
float4 light_dir_cutoff,
float falloff,
float3 world_pos)
{
    float co = light_dir_cutoff.w;
    float3 vl = normalize(world_pos.xyz - light_pos_radius.xyz);
    float3 sd = normalize(light_dir_cutoff.xyz);
    float dp = (1.0 - dot(vl, sd));
    return smoothstep(co, co - falloff, dp);
}
float point_light_attenuation_cutoff(
float4 light_pos_radius,
float3 world_pos)
{
    float r = light_pos_radius.w;
    float d = length(world_pos.xyz - light_pos_radius.xyz);
    d = max(d - r, 0.0);
    float denom = d/r + 1.0;
    float attenuation = 1.0 / (denom*denom);
    float cutoff = 0.2;
    attenuation = (attenuation - cutoff) / (1.0 - cutoff);
    attenuation = max(attenuation, 0.0);
    return attenuation;
}
float sample_shadow_array_pcf_9(float array_slice, float3 sp)
{
    float2 samples[9];
    float2 inv_sm_size = float2(1.0/2048.0, 1.0/2048.0);
    samples[0] = float2(-1.0, -1.0) * inv_sm_size;
    samples[1] = float2(-1.0, 0.0) * inv_sm_size;
    samples[2] = float2(-1.0, 1.0) * inv_sm_size;
    samples[3] = float2(0.0, -1.0) * inv_sm_size;
    samples[4] = float2(0.0, 0.0) * inv_sm_size;
    samples[5] = float2(0.0, 1.0) * inv_sm_size;
    samples[6] = float2(1.0, -1.0) * inv_sm_size;
    samples[7] = float2(1.0, 0.0) * inv_sm_size;
    samples[8] = float2(1.0, 1.0) * inv_sm_size;
    float shadow = 0.0;
    for(int j = 0; j < 9; ++j)
    {
        shadow += sample_depth_compare_array(shadowmap_texture, sp.xy + samples[j], array_slice, sp.z);
    }
    shadow /= 9.0;
    return shadow;
}
bool ray_vs_aabb(float3 emin, float3 emax, float3 r1, float3 rv, out float3 intersection)
{
    float3 dirfrac = float3(1.0, 1.0, 1.0) / rv;
    float t1 = (emin.x - r1.x)*dirfrac.x;
    float t2 = (emax.x - r1.x)*dirfrac.x;
    float t3 = (emin.y - r1.y)*dirfrac.y;
    float t4 = (emax.y - r1.y)*dirfrac.y;
    float t5 = (emin.z - r1.z)*dirfrac.z;
    float t6 = (emax.z - r1.z)*dirfrac.z;
    float tmin = max(max(min(t1, t2), min(t3, t4)), min(t5, t6));
    float tmax = min(min(max(t1, t2), max(t3, t4)), max(t5, t6));
    float t = 0.0;
    if (tmax < 0.0)
    {
        t = tmax;
        return false;
    }
    if (tmin > tmax)
    {
        t = tmax;
        return false;
    }
    t = tmin;
    intersection = r1 + rv * t;
    return true;
}
float sdf_shadow_trace(float max_samples, float3 light_pos, float3 world_pos, float3 scale, float3 ray_origin, float4x4 inv_mat, float3x3 inv_rot)
{
    float3 ray_dir = normalize(light_pos - world_pos);
    ray_dir = normalize( mul( ray_dir, inv_rot ) );
    float closest = 1.0;
    float3 uvw = ray_origin;
    if(abs(uvw.x) >= 1.0 || abs(uvw.y) >= 1.0 || abs(uvw.z) >= 1.0)
    {
        float3 emin = float3(-1.0, -1.0, -1.0);
        float3 emax = float3(1.0, 1.0, 1.0);
        float3 ip = float3(0.0, 0.0, 0.0);
        bool hit = ray_vs_aabb( emin, emax, uvw, ray_dir, ip);
        uvw = ip;
        if(!hit)
        {
            return closest;
        }
    }
    float3 light_uvw = mul( float4(light_pos, 1.0), inv_mat ).xyz * 0.5 + 0.5;
    uvw = uvw * 0.5 + 0.5;
    float3 v1 = normalize(light_uvw - uvw);
    for( int s = 0; s < int(max_samples); ++s )
    {
        float d = sample_texture_level( sdf_volume, uvw, 0.0 ).r;
        closest = min(d, closest);
        ray_dir = normalize(light_uvw - uvw);
        float3 step = ray_dir.xyz * float3(d, d, d) / scale * 0.7;
        uvw += step;
        if( d <= 0.0 )
        {
            closest = max( d, 0.0 );
            break;
        }
        if(uvw.x >= 1.0 || uvw.x < 0.0)
        break;
        if(uvw.y >= 1.0 || uvw.y < 0.0)
        break;
        if(uvw.z >= 1.0 || uvw.z < 0.0)
        break;
    }
    return closest;
}
float integrate_edge(float3 v1, float3 v2)
{
    float cos_theta = dot(v1, v2);
    float theta = acos(cos_theta);
    float res = cross(v1, v2).z * ((theta > 0.001) ? theta/sin(theta) : 1.0);
    return res;
}
void clip_quad_to_horizon(inout float3 L[5], out int n)
{
    int config = 0;
    if (L[0].z > 0.0) config += 1;
    if (L[1].z > 0.0) config += 2;
    if (L[2].z > 0.0) config += 4;
    if (L[3].z > 0.0) config += 8;
    n = 0;
    if (config == 0)
    {
    }
    else if (config == 1)
    {
        n = 3;
        L[1] = -L[1].z * L[0] + L[0].z * L[1];
        L[2] = -L[3].z * L[0] + L[0].z * L[3];
    }
    else if (config == 2)
    {
        n = 3;
        L[0] = -L[0].z * L[1] + L[1].z * L[0];
        L[2] = -L[2].z * L[1] + L[1].z * L[2];
    }
    else if (config == 3)
    {
        n = 4;
        L[2] = -L[2].z * L[1] + L[1].z * L[2];
        L[3] = -L[3].z * L[0] + L[0].z * L[3];
    }
    else if (config == 4)
    {
        n = 3;
        L[0] = -L[3].z * L[2] + L[2].z * L[3];
        L[1] = -L[1].z * L[2] + L[2].z * L[1];
    }
    else if (config == 5)
    {
        n = 0;
    }
    else if (config == 6)
    {
        n = 4;
        L[0] = -L[0].z * L[1] + L[1].z * L[0];
        L[3] = -L[3].z * L[2] + L[2].z * L[3];
    }
    else if (config == 7)
    {
        n = 5;
        L[4] = -L[3].z * L[0] + L[0].z * L[3];
        L[3] = -L[3].z * L[2] + L[2].z * L[3];
    }
    else if (config == 8)
    {
        n = 3;
        L[0] = -L[0].z * L[3] + L[3].z * L[0];
        L[1] = -L[2].z * L[3] + L[3].z * L[2];
        L[2] = L[3];
    }
    else if (config == 9)
    {
        n = 4;
        L[1] = -L[1].z * L[0] + L[0].z * L[1];
        L[2] = -L[2].z * L[3] + L[3].z * L[2];
    }
    else if (config == 10)
    {
        n = 0;
    }
    else if (config == 11)
    {
        n = 5;
        L[4] = L[3];
        L[3] = -L[2].z * L[3] + L[3].z * L[2];
        L[2] = -L[2].z * L[1] + L[1].z * L[2];
    }
    else if (config == 12)
    {
        n = 4;
        L[1] = -L[1].z * L[2] + L[2].z * L[1];
        L[0] = -L[0].z * L[3] + L[3].z * L[0];
    }
    else if (config == 13)
    {
        n = 5;
        L[4] = L[3];
        L[3] = L[2];
        L[2] = -L[1].z * L[2] + L[2].z * L[1];
        L[1] = -L[1].z * L[0] + L[0].z * L[1];
    }
    else if (config == 14)
    {
        n = 5;
        L[4] = -L[0].z * L[3] + L[3].z * L[0];
        L[0] = -L[0].z * L[1] + L[1].z * L[0];
    }
    else if (config == 15)
    {
        n = 4;
    }
    if (n == 3)
    L[3] = L[0];
    if (n == 4)
    L[4] = L[0];
}
float3 ltc_uv_coord(float3 p[4])
{
    float3 v1 = p[1] - p[0];
    float3 v2 = p[3] - p[0];
    float3 plane_ortho = (cross(v1, v2));
    float plane_area_squared = dot(plane_ortho, plane_ortho);
    float plane_distx_plane_area = dot(plane_ortho, p[0]);
    float3 pp = plane_distx_plane_area * plane_ortho / plane_area_squared - p[0];
    float v1_dot_v2 = dot(v1, v2);
    float inv_v1_dot_v1 = 1.0 / dot(v1, v1);
    float3 vv2 = v2 - v1 * v1_dot_v2 * inv_v1_dot_v1;
    float2 puv;
    puv.y = dot(vv2, pp) / dot(vv2, vv2);
    puv.x = dot(v1, pp) * inv_v1_dot_v1 - v1_dot_v2 * inv_v1_dot_v1 * puv.y;
    float d = abs(plane_distx_plane_area) / pow(plane_area_squared, 0.75);
    return float3(puv, d);
}
float4 ltc_evaluate(
float3 n,
float3 v,
float3 p,
float3x3 minv,
float3 points[4],
bool two_sided)
{
    float3 t1, t2;
    t1 = normalize(v - n * dot(v, n));
    t2 = cross(n, t1);
    float3x3 ttn = from_columns_3x3(t1, t2, n);
    minv = mul(minv, ttn);
    float3 l[5];
    l[0] = mul(minv, points[0] - p);
    l[1] = mul(minv, points[1] - p);
    l[2] = mul(minv, points[2] - p);
    l[3] = mul(minv, points[3] - p);
    l[4] = l[3];
    float3 ll[4];
    ll[0] = l[0];
    ll[1] = l[1];
    ll[2] = l[2];
    ll[3] = l[3];
    float3 uvl = ltc_uv_coord(ll);
    int nc;
    clip_quad_to_horizon(l, nc);
    if (nc == 0)
    return float4(0, 0, 0, 0.0);
    l[0] = normalize(l[0]);
    l[1] = normalize(l[1]);
    l[2] = normalize(l[2]);
    l[3] = normalize(l[3]);
    l[4] = normalize(l[4]);
    float sum = 0.0;
    sum += integrate_edge(l[0], l[1]);
    sum += integrate_edge(l[1], l[2]);
    sum += integrate_edge(l[2], l[3]);
    if (nc >= 4)
    sum += integrate_edge(l[3], l[4]);
    if (nc == 5)
    sum += integrate_edge(l[4], l[0]);
    sum = two_sided ? abs(sum) : max(0.0, sum);
    float3 lo_i = float3(sum, sum, sum);
    return float4(uvl.x, uvl.y, uvl.z, sum);
}
float ltc_evaluate_cc(
float3 n,
float3 v,
float3 p,
float3x3 minv,
float3 points[4],
bool two_sided)
{
    float3 t1, t2;
    t1 = normalize(v - n * dot(v, n));
    t2 = cross(n, t1);
    float3x3 ttn = from_columns_3x3(t1, t2, n);
    minv = mul(minv, ttn);
    float3 l[5];
    for(int i = 0; i < 4; ++i)
    l[i] = mul(minv, points[i] - p);
    l[4] = l[3];
    int nc;
    clip_quad_to_horizon(l, nc);
    if (nc == 0)
    return 0.0;
    for(int i = 0; i < 5; ++i)
    l[i] = normalize(l[i]);
    float sum = 0.0;
    sum += integrate_edge(l[0], l[1]);
    sum += integrate_edge(l[1], l[2]);
    sum += integrate_edge(l[2], l[3]);
    if (nc >= 4)
    sum += integrate_edge(l[3], l[4]);
    if (nc == 5)
    sum += integrate_edge(l[4], l[0]);
    sum = two_sided ? abs(sum) : max(0.0, sum);
    return sum;
}
float4 area_light_specular_uv(
float3 points[4],
float3 pos,
float roughness,
float3 n,
float3 v)
{
    float pi = 3.14159265359;
    float lut_size = 64.0;
    float lut_scale = (lut_size - 1.0)/lut_size;
    float lut_bias = 0.5/lut_size;
    float theta = acos(dot(n, v));
    float2 uv = float2(roughness, theta / (0.5 * pi));
    uv = uv * lut_scale + lut_bias;
    float4 mat = sample_texture(ltc_mat, uv);
    float mag = sample_texture(ltc_mag, uv).w;
    float3x3 minv = from_rows_3x3(
    float3(1.0, 0.0, mat.y),
    float3(0.0, mat.z, 0.0),
    float3(mat.w, 0.0, mat.x)
    );
    float4 spec = ltc_evaluate(n, v, pos, minv, points, true);
    return spec;
}
float area_light_specular(
float3 points[4],
float3 pos,
float roughness,
float3 n,
float3 v)
{
    float pi = 3.14159265359;
    float lut_size = 64.0;
    float lut_scale = (lut_size - 1.0)/lut_size;
    float lut_bias = 0.5/lut_size;
    float theta = acos(dot(n, v));
    float2 uv = float2(roughness, theta / (0.5 * pi));
    uv = uv * lut_scale + lut_bias;
    float4 mat = sample_texture(ltc_mat, uv);
    float mag = sample_texture(ltc_mag, uv).w;
    float3x3 minv = from_rows_3x3(
    float3(1.0, 0.0, mat.y),
    float3(0.0, mat.z, 0.0),
    float3(mat.w, 0.0, mat.x)
    );
    float spec = ltc_evaluate_cc(n, v, pos, minv, points, true);
    return spec;
}
float4 area_light_diffuse_uv(
float3 points[4],
float3 pos,
float3 n,
float3 v)
{
    float3x3 difv = float3x3(
    float3(1.0, 0.0, 0.0),
    float3(0.0, 1.0, 0.0),
    float3(0.0, 0.0, 1.0)
    );
    float4 diff = ltc_evaluate(n, v, pos, difv, points, true);
    return diff;
}
float area_light_diffuse(
float3 points[4],
float3 pos,
float3 n,
float3 v)
{
    float3x3 difv = float3x3(
    float3(1.0, 0.0, 0.0),
    float3(0.0, 1.0, 0.0),
    float3(0.0, 0.0, 1.0)
    );
    float diff = ltc_evaluate_cc(n, v, pos, difv, points, true);
    return diff;
}
float3 transform_ts_normal( float3 t, float3 b, float3 n, float3 ts_normal )
{
    float3x3 tbn;
    tbn[0] = float3(t.x, b.x, n.x);
    tbn[1] = float3(t.y, b.y, n.y);
    tbn[2] = float3(t.z, b.z, n.z);
    return normalize( mul_tbn( tbn, ts_normal ) );
}
float3 hash_33( float3 p )
{
    p = float3(dot(p,float3(127.1,311.7, 74.7)),
    dot(p,float3(269.5,183.3,246.1)),
    dot(p,float3(113.5,271.9,124.6)));
    return fract(sin(p)*43758.5453123) * 2.0 - 1.0;
}
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.world_pos = world_pos_vs_output;
    _input.normal = normal_vs_output;
    _input.tangent = tangent_vs_output;
    _input.bitangent = bitangent_vs_output;
    _input.texcoord = texcoord_vs_output;
    _input.colour = colour_vs_output;
    ps_output _output;
    float4 albedo = sample_texture( diffuse_texture, _input.texcoord.xy );
    float3 normal_sample = sample_texture( normal_texture, _input.texcoord.xy ).rgb;
    float4 ro_sample = sample_texture( specular_texture, _input.texcoord.xy );
    float4 specular_sample = float4(1.0, 1.0, 1.0, 1.0);
    normal_sample = normal_sample * 2.0 - 1.0;
    float3 n = transform_ts_normal(
    _input.tangent,
    _input.bitangent,
    _input.normal,
    normal_sample );
    albedo *= _input.colour;
    float4 metalness = float4(1.0, 1.0, 1.0, 1.0);
    float3 lit_colour = float3( 0.0, 0.0, 0.0 );
    float reflectivity = saturate(user_data.z);
    float roughness = saturate(user_data.y);
    reflectivity = m_reflectivity;
    roughness = ro_sample.r;
    roughness = _input.colour.a;
    albedo.a = 1.0;
    n = _input.normal.rgb;
    roughness = m_roughness;
    float max_samples = 128.0;
    float3x3 inv_rot = to_3x3(sdf_shadow.world_matrix_inv);
    float3 r1 = _input.world_pos.xyz + _input.normal.xyz * m_surface_offset;
    float3 tr1 = mul( float4(r1, 1.0), sdf_shadow.world_matrix_inv ).xyz;
    float3 scale = float3(length(sdf_shadow.world_matrix[0].xyz), length(sdf_shadow.world_matrix[1].xyz), length(sdf_shadow.world_matrix[2].xyz)) * 2.0;
    float3 vddx = ddx( r1 );
    float3 vddy = ddy( r1 );
    float t = 1.0;
    float3 lll = float3(0.0, 0.0, 0.0);
    int shadow_map_index = 0;
    _pmfx_loop
    for( int i = 0; i < int(light_info.x); ++i )
    {
        float3 light_col = float3( 0.0, 0.0, 0.0 );
        light_col += cook_torrence(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        albedo.rgb,
        metalness.rgb,
        roughness,
        reflectivity
        );
        light_col += oren_nayar(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        1.0 - roughness,
        albedo.rgb
        );
        float s = sdf_shadow_trace(max_samples, lights[i].pos_radius.xyz, _input.world_pos.xyz, scale, tr1, sdf_shadow.world_matrix_inv, inv_rot);
        light_col *= smoothstep( 0.0, 0.1, s);
        if( lights[i].colour.a == 0.0 )
        {
            lit_colour += light_col;
            continue;
        }
        else
        {
            float shadow = 1.0;
            float d = 1.0;
            float4 offset_pos = float4(_input.world_pos.xyz + n.xyz * 0.01, 1.0);
            float4 sp = mul( offset_pos, shadow_matrix[i] );
            sp.xyz /= sp.w;
            sp.y *= -1.0;
            sp.xy = sp.xy * 0.5 + 0.5;
            sp.z = remap_depth(sp.z);
            shadow = sample_shadow_array_pcf_9(float(shadow_map_index), sp.xyz);
            lit_colour += light_col * shadow;
            ++shadow_map_index;
        }
    }
    int point_start = int(light_info.x);
    int point_end = int(light_info.x) + int(light_info.y);
    int omni_shadow_index = 0;
    _pmfx_loop
    for( int i = point_start; i < point_end; ++i )
    {
        float3 light_col = float3( 0.0, 0.0, 0.0 );
        light_col += cook_torrence(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        albedo.rgb,
        metalness.rgb,
        roughness,
        reflectivity
        );
        light_col += oren_nayar(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        roughness,
        albedo.rgb
        );
        float a = point_light_attenuation_cutoff( lights[i].pos_radius, _input.world_pos.xyz );
        light_col *= a;
        float s = sdf_shadow_trace(max_samples, lights[i].pos_radius.xyz, _input.world_pos.xyz, scale, tr1, sdf_shadow.world_matrix_inv, inv_rot);
        light_col *= smoothstep( 0.0, 0.1, s);
        if( lights[i].colour.a == 0.0)
        {
            lit_colour += light_col;
            continue;
        }
        else
        {
            lit_colour += light_col;
            continue;
        }
    }
    int spot_start = point_end;
    int spot_end = spot_start + int(light_info.z);
    _pmfx_loop
    for(int i = spot_start; i < spot_end; ++i )
    {
        float3 light_col = float3( 0.0, 0.0, 0.0 );
        light_col += cook_torrence(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        albedo.rgb,
        metalness.rgb,
        roughness,
        reflectivity
        );
        light_col += oren_nayar(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        roughness,
        albedo.rgb
        );
        float a = spot_light_attenuation(lights[i].pos_radius,
        lights[i].dir_cutoff,
        lights[i].data.x,
        _input.world_pos.xyz );
        light_col *= a;
        float s = sdf_shadow_trace(max_samples, lights[i].pos_radius.xyz, _input.world_pos.xyz, scale, tr1, sdf_shadow.world_matrix_inv, inv_rot);
        light_col *= smoothstep( 0.0, 0.1, s);
        if( lights[i].colour.a == 0.0 )
        {
            lit_colour += light_col;
            continue;
        }
        else
        {
            float shadow = 1.0;
            float d = 1.0;
            float4 offset_pos = float4(_input.world_pos.xyz + n.xyz * 0.01, 1.0);
            float4 sp = mul( offset_pos, shadow_matrix[shadow_map_index] );
            sp.xyz /= sp.w;
            sp.y *= -1.0;
            sp.xy = sp.xy * 0.5 + 0.5;
            sp.z = remap_depth(sp.z);
            shadow = sample_shadow_array_pcf_9(float(shadow_map_index), sp.xyz);
            lit_colour += light_col * shadow;
            ++shadow_map_index;
        }
    }
    {
        float pi = 3.14159265359;
        int num_area_lights = int(area_light_info.x);
        for(int i = 0; i < num_area_lights; ++i)
        {
            float3 v = -normalize(_input.world_pos.xyz - camera_view_pos.xyz);
            float3 pos = _input.world_pos.xyz;
            float3 points[4];
            for(int j = 0; j < 4; ++j)
            points[j] = area_lights[i].corners[j].xyz;
            float diff_sum = area_light_diffuse(points, pos, n, v);
            float3 diff = area_lights[i].colour.rgb * diff_sum;
            float spec_sum = area_light_specular(points, pos, ro_sample.x, n, v);
            float3 spec = area_lights[i].colour.rgb * spec_sum;
            float3 light_col = (spec.rgb + diff.rgb) / (2.0 * pi);
            lit_colour += light_col;
        }
        int ts = num_area_lights;
        int num_area_lights_textured = int(area_light_info.y);
        for(int i = ts; i < ts + num_area_lights_textured; ++i)
        {
            float slice = area_lights[i].colour.w;
            float levels = 8.0;
            float2 inv_texel = float2(1.0/640.0, 1.0/480.0);
            float2 inv_texel_x = float2(1.0, 1.0) - inv_texel;
            float3 points[4];
            for(int j = 0; j < 4; ++j)
            points[j] = area_lights[i].corners[j].xyz;
            float3 v = -normalize(_input.world_pos.xyz - camera_view_pos.xyz);
            float3 pos = _input.world_pos.xyz;
            float4 diff_uv = area_light_diffuse_uv(points, pos, n, v);
            float2 duv = clamp(diff_uv.xy, inv_texel, inv_texel_x);
            float3 diff = sample_texture_array_level( area_light_textures, duv, slice, diff_uv.z * levels).rgb * diff_uv.w;
            float4 spec_uv = area_light_specular_uv(points, pos, ro_sample.x, n, v);
            float2 suv = clamp(spec_uv.xy, inv_texel, inv_texel_x);
            float3 spec = sample_texture_array_level(area_light_textures, suv, slice, spec_uv.z * levels).rgb * spec_uv.w;
            float3 light_col = (spec.rgb + diff.rgb) / (2.0 * pi);
            lit_colour += light_col;
        }
    }
    _output.colour.rgb = lit_colour.rgb * albedo.a;
    _output.colour.a = albedo.a;
    float3 gn = _input.normal.xyz;
    float3 gt = _input.tangent.xyz;
    float3 gb = _input.bitangent.xyz;
    float3 dim = gi_scene_size.xyz;
    float3 to_uvx = dim * 0.5;
    int num_rays = 16;
    float3 rays[16];
    rays[0] = float3(0.57735, 0.57735, 0.57735);
    rays[1] = float3(0.57735, -0.57735, -0.57735);
    rays[2] = float3(-0.57735, 0.57735, -0.57735);
    rays[3] = float3(-0.57735, -0.57735, 0.57735);
    rays[4] = float3(-0.903007, -0.182696, -0.388844);
    rays[5] = float3(-0.903007, 0.182696, 0.388844);
    rays[6] = float3(0.903007, -0.182696, 0.388844);
    rays[7] = float3(0.903007, 0.182696, -0.388844);
    rays[8] = float3(-0.388844, -0.903007, -0.182696);
    rays[9] = float3(0.388844, -0.903007, 0.182696);
    rays[10] = float3(0.388844, 0.903007, -0.182696);
    rays[11] = float3(-0.388844, 0.903007, 0.182696);
    rays[12] = float3(-0.182696, -0.388844, -0.903007);
    rays[13] = float3(0.182696, 0.388844, -0.903007);
    rays[14] = float3(-0.182696, 0.388844, 0.903007);
    rays[15] = float3(0.182696, -0.388844, 0.903007);
    float4 gi = float4(0.0, 0.0, 0.0, 0.0);
    float4 sp = mul(_input.world_pos, vp_matrix);
    sp /= sp.w;
    sp.x *= (1280.0/512.0);
    sp.y *= (720.0/512.0);
    for(int i = 0; i < num_rays; ++i)
    {
        float3 noise = (hash_33(_input.world_pos.xyz + user_data.yyy));
        float3 noise2 = (sample_texture_level(blue_noise, sp.xy + noise.xy, 0.0).rgb * 2.0 - 1.0);
        float3 tex_size = gi_volume_size.xyz;
        float3 ray = chebyshev_normalize(noise2 + rays[i]);
        float3 cn = chebyshev_normalize(n);
        float3 step = (dim*2.0) / tex_size;
        float3 sp = _input.world_pos.xyz + (cn * step);
        ray *= dot(ray, gn) < 0.0 ? -1.0 : 1.0;
        float4 ray_gi = float4(0.0, 0.0, 0.0, 0.0);
        for(int j = 0; j < 4; ++j)
        {
            for(int k = 0; k < 2; ++k)
            {
                step = (dim*2.0) / tex_size;
                float3 uvw = saturate((sp / to_uvx) * 0.5 + 0.5);
                float4 g = sample_texture_level( volume_gi, uvw, float(j));
                float d = length(_input.world_pos.xyz - sp);
                d = smoothstep(0.0, 8.0, d);
                ray_gi.rgb = ray_gi.rgb + g.rgb * d;
                ray_gi.a += g.a;
                sp += ray * step.x;
            }
            tex_size /= 2.0;
            if(ray_gi.a >= 1.0 && j > 1)
            break;
        }
        gi += ray_gi;
    }
    gi /= float(num_rays);
    _output.colour.rgb = gi.rgb * 2.0 * m_albedo.rgb + lit_colour.rgb;
    if(albedo.a <= 0.0)
    discard;
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//forward_render lambert ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 world_pos_vs_output;
in float3 normal_vs_output;
in float3 tangent_vs_output;
in float3 bitangent_vs_output;
in float4 texcoord_vs_output;
in float4 colour_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 world_pos;
    float3 normal;
    float3 tangent;
    float3 bitangent;
    float4 texcoord;
    float4 colour;
};
struct ps_output
{
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform per_pass_lights
{
    float4 light_info;
    light_data lights[100];
};
texture_2d( diffuse_texture, 0 );
texture_2d( normal_texture, 1 );
texture_2d( specular_texture, 2 );
float3 lambert(
float4 light_pos_radius,
float3 light_colour,
float3 n,
float3 world_pos,
float3 albedo
)
{
    float3 l = normalize( light_pos_radius.xyz - world_pos.xyz );
    float n_dot_l = max( dot( n, l ), 0.0 );
    float3 lit_colour = light_colour * n_dot_l * albedo.rgb;
    return lit_colour;
}
float3 transform_ts_normal( float3 t, float3 b, float3 n, float3 ts_normal )
{
    float3x3 tbn;
    tbn[0] = float3(t.x, b.x, n.x);
    tbn[1] = float3(t.y, b.y, n.y);
    tbn[2] = float3(t.z, b.z, n.z);
    return normalize( mul_tbn( tbn, ts_normal ) );
}
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.world_pos = world_pos_vs_output;
    _input.normal = normal_vs_output;
    _input.tangent = tangent_vs_output;
    _input.bitangent = bitangent_vs_output;
    _input.texcoord = texcoord_vs_output;
    _input.colour = colour_vs_output;
    ps_output _output;
    float4 albedo = sample_texture( diffuse_texture, _input.texcoord.xy );
    float3 normal_sample = sample_texture( normal_texture, _input.texcoord.xy ).rgb;
    float4 ro_sample = sample_texture( specular_texture, _input.texcoord.xy );
    float4 specular_sample = float4(1.0, 1.0, 1.0, 1.0);
    normal_sample = normal_sample * 2.0 - 1.0;
    float3 n = transform_ts_normal(
    _input.tangent,
    _input.bitangent,
    _input.normal,
    normal_sample );
    albedo *= _input.colour;
    float3 lit_colour = float3( 0.0, 0.0, 0.0 );
    for(int i = 0; i < 1; ++i )
    {
        lit_colour += lambert(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        albedo.rgb
        );
        lit_colour += lambert(
        lights[i].pos_radius * -1.0,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        albedo.rgb
        ) * 0.2;
    }
    _output.colour.rgb = lit_colour;
    _output.colour.a = albedo.a;
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//forward_render forward_lit__2__ ps 2
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 world_pos_vs_output;
in float3 normal_vs_output;
in float3 tangent_vs_output;
in float3 bitangent_vs_output;
in float4 texcoord_vs_output;
in float4 colour_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 world_pos;
    float3 normal;
    float3 tangent;
    float3 bitangent;
    float4 texcoord;
    float4 colour;
};
struct ps_output
{
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
layout (std140) uniform per_draw_call
{
    float4x4 world_matrix;
    float4 user_data;
    float4 user_data2;
    float4x4 world_matrix_inv_transpose;
};
layout (std140) uniform per_pass_lights
{
    float4 light_info;
    light_data lights[100];
};
layout (std140) uniform per_pass_shadow
{
    float4x4 shadow_matrix[100];
};
layout (std140) uniform per_pass_area_lights
{
    float4 area_light_info;
    area_light_data area_lights[10];
};
layout (std140) uniform material_data
{
    float4 m_albedo;
    float2 m_uv_scale;
    float m_roughness;
    float m_reflectivity;
};
texture_2d( diffuse_texture, 0 );
texture_2d( normal_texture, 1 );
texture_2d( specular_texture, 2 );
texture_2d( ltc_mat, 13 );
texture_2d( ltc_mag, 12 );
texture_2d_array( area_light_textures, 11 );
depth_2d_array( shadowmap_texture, 15 );
float3 cook_torrence(
float4 light_pos_radius,
float3 light_colour,
float3 n,
float3 world_pos,
float3 view_pos,
float3 albedo,
float3 metalness,
float roughness,
float reflectivity
)
{
    float3 l = normalize( light_pos_radius.xyz - world_pos.xyz );
    float n_dot_l = dot( n, l );
    if( n_dot_l > 0.0f )
    {
        float roughness_sq = roughness * roughness;
        float k = reflectivity;
        float3 v_view = normalize( (view_pos.xyz - world_pos.xyz) );
        float3 hv = normalize( v_view + l );
        float n_dot_v = dot( n, v_view );
        float n_dot_h = dot( n, hv );
        float v_dot_h = dot( v_view, hv );
        float n_dot_h_2 = 2.0f * n_dot_h;
        float g1 = (n_dot_h_2 * n_dot_v) / v_dot_h;
        float g2 = (n_dot_h_2 * n_dot_l) / v_dot_h;
        float geom_atten = min(1.0, min(g1, g2));
        float r1 = 1.0f / ( 4.0f * roughness_sq * pow(n_dot_h, 4.0f));
        float r2 = (n_dot_h * n_dot_h - 1.0) / (roughness_sq * n_dot_h * n_dot_h);
        float roughness_atten = r1 * exp(r2);
        float fresnel = pow(1.0 - v_dot_h, 5.0);
        fresnel *= roughness;
        fresnel += reflectivity;
        float specular = (fresnel * geom_atten * roughness_atten) / (n_dot_v * n_dot_l * 3.1419);
        float3 lit_colour = metalness * light_colour * n_dot_l * ( k + specular * ( 1.0 - k ) );
        return saturate(lit_colour);
    }
    return float3( 0.0, 0.0, 0.0 );
}
float3 oren_nayar(
float4 light_pos_radius,
float3 light_colour,
float3 n,
float3 world_pos,
float3 view_pos,
float roughness,
float3 albedo)
{
    float3 v = normalize(view_pos-world_pos);
    float3 l = normalize(light_pos_radius.xyz-world_pos);
    float l_dot_v = dot(l, v);
    float n_dot_l = dot(n, l);
    float n_dot_v = dot(n, v);
    float s = l_dot_v - n_dot_l * n_dot_v;
    float t = lerp(1.0, max(n_dot_l, n_dot_v), step(0.0, s));
    float lum = length( albedo );
    float sigma2 = roughness * roughness;
    float A = 1.0 + sigma2 * (lum / (sigma2 + 0.13) + 0.5 / (sigma2 + 0.33));
    float B = 0.45 * sigma2 / (sigma2 + 0.09);
    return ( albedo * light_colour * max(0.0, n_dot_l) * (A + B * s / t) / 3.14159265 );
}
float spot_light_attenuation(
float4 light_pos_radius,
float4 light_dir_cutoff,
float falloff,
float3 world_pos)
{
    float co = light_dir_cutoff.w;
    float3 vl = normalize(world_pos.xyz - light_pos_radius.xyz);
    float3 sd = normalize(light_dir_cutoff.xyz);
    float dp = (1.0 - dot(vl, sd));
    return smoothstep(co, co - falloff, dp);
}
float point_light_attenuation_cutoff(
float4 light_pos_radius,
float3 world_pos)
{
    float r = light_pos_radius.w;
    float d = length(world_pos.xyz - light_pos_radius.xyz);
    d = max(d - r, 0.0);
    float denom = d/r + 1.0;
    float attenuation = 1.0 / (denom*denom);
    float cutoff = 0.2;
    attenuation = (attenuation - cutoff) / (1.0 - cutoff);
    attenuation = max(attenuation, 0.0);
    return attenuation;
}
float sample_shadow_array_pcf_9(float array_slice, float3 sp)
{
    float2 samples[9];
    float2 inv_sm_size = float2(1.0/2048.0, 1.0/2048.0);
    samples[0] = float2(-1.0, -1.0) * inv_sm_size;
    samples[1] = float2(-1.0, 0.0) * inv_sm_size;
    samples[2] = float2(-1.0, 1.0) * inv_sm_size;
    samples[3] = float2(0.0, -1.0) * inv_sm_size;
    samples[4] = float2(0.0, 0.0) * inv_sm_size;
    samples[5] = float2(0.0, 1.0) * inv_sm_size;
    samples[6] = float2(1.0, -1.0) * inv_sm_size;
    samples[7] = float2(1.0, 0.0) * inv_sm_size;
    samples[8] = float2(1.0, 1.0) * inv_sm_size;
    float shadow = 0.0;
    for(int j = 0; j < 9; ++j)
    {
        shadow += sample_depth_compare_array(shadowmap_texture, sp.xy + samples[j], array_slice, sp.z);
    }
    shadow /= 9.0;
    return shadow;
}
float integrate_edge(float3 v1, float3 v2)
{
    float cos_theta = dot(v1, v2);
    float theta = acos(cos_theta);
    float res = cross(v1, v2).z * ((theta > 0.001) ? theta/sin(theta) : 1.0);
    return res;
}
void clip_quad_to_horizon(inout float3 L[5], out int n)
{
    int config = 0;
    if (L[0].z > 0.0) config += 1;
    if (L[1].z > 0.0) config += 2;
    if (L[2].z > 0.0) config += 4;
    if (L[3].z > 0.0) config += 8;
    n = 0;
    if (config == 0)
    {
    }
    else if (config == 1)
    {
        n = 3;
        L[1] = -L[1].z * L[0] + L[0].z * L[1];
        L[2] = -L[3].z * L[0] + L[0].z * L[3];
    }
    else if (config == 2)
    {
        n = 3;
        L[0] = -L[0].z * L[1] + L[1].z * L[0];
        L[2] = -L[2].z * L[1] + L[1].z * L[2];
    }
    else if (config == 3)
    {
        n = 4;
        L[2] = -L[2].z * L[1] + L[1].z * L[2];
        L[3] = -L[3].z * L[0] + L[0].z * L[3];
    }
    else if (config == 4)
    {
        n = 3;
        L[0] = -L[3].z * L[2] + L[2].z * L[3];
        L[1] = -L[1].z * L[2] + L[2].z * L[1];
    }
    else if (config == 5)
    {
        n = 0;
    }
    else if (config == 6)
    {
        n = 4;
        L[0] = -L[0].z * L[1] + L[1].z * L[0];
        L[3] = -L[3].z * L[2] + L[2].z * L[3];
    }
    else if (config == 7)
    {
        n = 5;
        L[4] = -L[3].z * L[0] + L[0].z * L[3];
        L[3] = -L[3].z * L[2] + L[2].z * L[3];
    }
    else if (config == 8)
    {
        n = 3;
        L[0] = -L[0].z * L[3] + L[3].z * L[0];
        L[1] = -L[2].z * L[3] + L[3].z * L[2];
        L[2] = L[3];
    }
    else if (config == 9)
    {
        n = 4;
        L[1] = -L[1].z * L[0] + L[0].z * L[1];
        L[2] = -L[2].z * L[3] + L[3].z * L[2];
    }
    else if (config == 10)
    {
        n = 0;
    }
    else if (config == 11)
    {
        n = 5;
        L[4] = L[3];
        L[3] = -L[2].z * L[3] + L[3].z * L[2];
        L[2] = -L[2].z * L[1] + L[1].z * L[2];
    }
    else if (config == 12)
    {
        n = 4;
        L[1] = -L[1].z * L[2] + L[2].z * L[1];
        L[0] = -L[0].z * L[3] + L[3].z * L[0];
    }
    else if (config == 13)
    {
        n = 5;
        L[4] = L[3];
        L[3] = L[2];
        L[2] = -L[1].z * L[2] + L[2].z * L[1];
        L[1] = -L[1].z * L[0] + L[0].z * L[1];
    }
    else if (config == 14)
    {
        n = 5;
        L[4] = -L[0].z * L[3] + L[3].z * L[0];
        L[0] = -L[0].z * L[1] + L[1].z * L[0];
    }
    else if (config == 15)
    {
        n = 4;
    }
    if (n == 3)
    L[3] = L[0];
    if (n == 4)
    L[4] = L[0];
}
float3 ltc_uv_coord(float3 p[4])
{
    float3 v1 = p[1] - p[0];
    float3 v2 = p[3] - p[0];
    float3 plane_ortho = (cross(v1, v2));
    float plane_area_squared = dot(plane_ortho, plane_ortho);
    float plane_distx_plane_area = dot(plane_ortho, p[0]);
    float3 pp = plane_distx_plane_area * plane_ortho / plane_area_squared - p[0];
    float v1_dot_v2 = dot(v1, v2);
    float inv_v1_dot_v1 = 1.0 / dot(v1, v1);
    float3 vv2 = v2 - v1 * v1_dot_v2 * inv_v1_dot_v1;
    float2 puv;
    puv.y = dot(vv2, pp) / dot(vv2, vv2);
    puv.x = dot(v1, pp) * inv_v1_dot_v1 - v1_dot_v2 * inv_v1_dot_v1 * puv.y;
    float d = abs(plane_distx_plane_area) / pow(plane_area_squared, 0.75);
    return float3(puv, d);
}
float4 ltc_evaluate(
float3 n,
float3 v,
float3 p,
float3x3 minv,
float3 points[4],
bool two_sided)
{
    float3 t1, t2;
    t1 = normalize(v - n * dot(v, n));
    t2 = cross(n, t1);
    float3x3 ttn = from_columns_3x3(t1, t2, n);
    minv = mul(minv, ttn);
    float3 l[5];
    l[0] = mul(minv, points[0] - p);
    l[1] = mul(minv, points[1] - p);
    l[2] = mul(minv, points[2] - p);
    l[3] = mul(minv, points[3] - p);
    l[4] = l[3];
    float3 ll[4];
    ll[0] = l[0];
    ll[1] = l[1];
    ll[2] = l[2];
    ll[3] = l[3];
    float3 uvl = ltc_uv_coord(ll);
    int nc;
    clip_quad_to_horizon(l, nc);
    if (nc == 0)
    return float4(0, 0, 0, 0.0);
    l[0] = normalize(l[0]);
    l[1] = normalize(l[1]);
    l[2] = normalize(l[2]);
    l[3] = normalize(l[3]);
    l[4] = normalize(l[4]);
    float sum = 0.0;
    sum += integrate_edge(l[0], l[1]);
    sum += integrate_edge(l[1], l[2]);
    sum += integrate_edge(l[2], l[3]);
    if (nc >= 4)
    sum += integrate_edge(l[3], l[4]);
    if (nc == 5)
    sum += integrate_edge(l[4], l[0]);
    sum = two_sided ? abs(sum) : max(0.0, sum);
    float3 lo_i = float3(sum, sum, sum);
    return float4(uvl.x, uvl.y, uvl.z, sum);
}
float ltc_evaluate_cc(
float3 n,
float3 v,
float3 p,
float3x3 minv,
float3 points[4],
bool two_sided)
{
    float3 t1, t2;
    t1 = normalize(v - n * dot(v, n));
    t2 = cross(n, t1);
    float3x3 ttn = from_columns_3x3(t1, t2, n);
    minv = mul(minv, ttn);
    float3 l[5];
    for(int i = 0; i < 4; ++i)
    l[i] = mul(minv, points[i] - p);
    l[4] = l[3];
    int nc;
    clip_quad_to_horizon(l, nc);
    if (nc == 0)
    return 0.0;
    for(int i = 0; i < 5; ++i)
    l[i] = normalize(l[i]);
    float sum = 0.0;
    sum += integrate_edge(l[0], l[1]);
    sum += integrate_edge(l[1], l[2]);
    sum += integrate_edge(l[2], l[3]);
    if (nc >= 4)
    sum += integrate_edge(l[3], l[4]);
    if (nc == 5)
    sum += integrate_edge(l[4], l[0]);
    sum = two_sided ? abs(sum) : max(0.0, sum);
    return sum;
}
float4 area_light_specular_uv(
float3 points[4],
float3 pos,
float roughness,
float3 n,
float3 v)
{
    float pi = 3.14159265359;
    float lut_size = 64.0;
    float lut_scale = (lut_size - 1.0)/lut_size;
    float lut_bias = 0.5/lut_size;
    float theta = acos(dot(n, v));
    float2 uv = float2(roughness, theta / (0.5 * pi));
    uv = uv * lut_scale + lut_bias;
    float4 mat = sample_texture(ltc_mat, uv);
    float mag = sample_texture(ltc_mag, uv).w;
    float3x3 minv = from_rows_3x3(
    float3(1.0, 0.0, mat.y),
    float3(0.0, mat.z, 0.0),
    float3(mat.w, 0.0, mat.x)
    );
    float4 spec = ltc_evaluate(n, v, pos, minv, points, true);
    return spec;
}
float area_light_specular(
float3 points[4],
float3 pos,
float roughness,
float3 n,
float3 v)
{
    float pi = 3.14159265359;
    float lut_size = 64.0;
    float lut_scale = (lut_size - 1.0)/lut_size;
    float lut_bias = 0.5/lut_size;
    float theta = acos(dot(n, v));
    float2 uv = float2(roughness, theta / (0.5 * pi));
    uv = uv * lut_scale + lut_bias;
    float4 mat = sample_texture(ltc_mat, uv);
    float mag = sample_texture(ltc_mag, uv).w;
    float3x3 minv = from_rows_3x3(
    float3(1.0, 0.0, mat.y),
    float3(0.0, mat.z, 0.0),
    float3(mat.w, 0.0, mat.x)
    );
    float spec = ltc_evaluate_cc(n, v, pos, minv, points, true);
    return spec;
}
float4 area_light_diffuse_uv(
float3 points[4],
float3 pos,
float3 n,
float3 v)
{
    float3x3 difv = float3x3(
    float3(1.0, 0.0, 0.0),
    float3(0.0, 1.0, 0.0),
    float3(0.0, 0.0, 1.0)
    );
    float4 diff = ltc_evaluate(n, v, pos, difv, points, true);
    return diff;
}
float area_light_diffuse(
float3 points[4],
float3 pos,
float3 n,
float3 v)
{
    float3x3 difv = float3x3(
    float3(1.0, 0.0, 0.0),
    float3(0.0, 1.0, 0.0),
    float3(0.0, 0.0, 1.0)
    );
    float diff = ltc_evaluate_cc(n, v, pos, difv, points, true);
    return diff;
}
float3 transform_ts_normal( float3 t, float3 b, float3 n, float3 ts_normal )
{
    float3x3 tbn;
    tbn[0] = float3(t.x, b.x, n.x);
    tbn[1] = float3(t.y, b.y, n.y);
    tbn[2] = float3(t.z, b.z, n.z);
    return normalize( mul_tbn( tbn, ts_normal ) );
}
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.world_pos = world_pos_vs_output;
    _input.normal = normal_vs_output;
    _input.tangent = tangent_vs_output;
    _input.bitangent = bitangent_vs_output;
    _input.texcoord = texcoord_vs_output;
    _input.colour = colour_vs_output;
    ps_output _output;
    float4 albedo = sample_texture( diffuse_texture, _input.texcoord.xy );
    float3 normal_sample = sample_texture( normal_texture, _input.texcoord.xy ).rgb;
    float4 ro_sample = sample_texture( specular_texture, _input.texcoord.xy );
    float4 specular_sample = float4(1.0, 1.0, 1.0, 1.0);
    normal_sample = normal_sample * 2.0 - 1.0;
    float3 n = transform_ts_normal(
    _input.tangent,
    _input.bitangent,
    _input.normal,
    normal_sample );
    albedo *= _input.colour;
    float4 metalness = float4(1.0, 1.0, 1.0, 1.0);
    float3 lit_colour = float3( 0.0, 0.0, 0.0 );
    float reflectivity = saturate(user_data.z);
    float roughness = saturate(user_data.y);
    reflectivity = m_reflectivity;
    roughness = ro_sample.r;
    float t = 1.0;
    float3 lll = float3(0.0, 0.0, 0.0);
    int shadow_map_index = 0;
    _pmfx_loop
    for( int i = 0; i < int(light_info.x); ++i )
    {
        float3 light_col = float3( 0.0, 0.0, 0.0 );
        light_col += cook_torrence(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        albedo.rgb,
        metalness.rgb,
        roughness,
        reflectivity
        );
        light_col += oren_nayar(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        1.0 - roughness,
        albedo.rgb
        );
        if( lights[i].colour.a == 0.0 )
        {
            lit_colour += light_col;
            continue;
        }
        else
        {
            float shadow = 1.0;
            float d = 1.0;
            float4 offset_pos = float4(_input.world_pos.xyz + n.xyz * 0.01, 1.0);
            float4 sp = mul( offset_pos, shadow_matrix[i] );
            sp.xyz /= sp.w;
            sp.y *= -1.0;
            sp.xy = sp.xy * 0.5 + 0.5;
            sp.z = remap_depth(sp.z);
            shadow = sample_shadow_array_pcf_9(float(shadow_map_index), sp.xyz);
            lit_colour += light_col * shadow;
            ++shadow_map_index;
        }
    }
    int point_start = int(light_info.x);
    int point_end = int(light_info.x) + int(light_info.y);
    int omni_shadow_index = 0;
    _pmfx_loop
    for( int i = point_start; i < point_end; ++i )
    {
        float3 light_col = float3( 0.0, 0.0, 0.0 );
        light_col += cook_torrence(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        albedo.rgb,
        metalness.rgb,
        roughness,
        reflectivity
        );
        light_col += oren_nayar(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        roughness,
        albedo.rgb
        );
        float a = point_light_attenuation_cutoff( lights[i].pos_radius, _input.world_pos.xyz );
        light_col *= a;
        if( lights[i].colour.a == 0.0)
        {
            lit_colour += light_col;
            continue;
        }
        else
        {
            lit_colour += light_col;
            continue;
        }
    }
    int spot_start = point_end;
    int spot_end = spot_start + int(light_info.z);
    _pmfx_loop
    for(int i = spot_start; i < spot_end; ++i )
    {
        float3 light_col = float3( 0.0, 0.0, 0.0 );
        light_col += cook_torrence(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        albedo.rgb,
        metalness.rgb,
        roughness,
        reflectivity
        );
        light_col += oren_nayar(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        roughness,
        albedo.rgb
        );
        float a = spot_light_attenuation(lights[i].pos_radius,
        lights[i].dir_cutoff,
        lights[i].data.x,
        _input.world_pos.xyz );
        light_col *= a;
        if( lights[i].colour.a == 0.0 )
        {
            lit_colour += light_col;
            continue;
        }
        else
        {
            float shadow = 1.0;
            float d = 1.0;
            float4 offset_pos = float4(_input.world_pos.xyz + n.xyz * 0.01, 1.0);
            float4 sp = mul( offset_pos, shadow_matrix[shadow_map_index] );
            sp.xyz /= sp.w;
            sp.y *= -1.0;
            sp.xy = sp.xy * 0.5 + 0.5;
            sp.z = remap_depth(sp.z);
            shadow = sample_shadow_array_pcf_9(float(shadow_map_index), sp.xyz);
            lit_colour += light_col * shadow;
            ++shadow_map_index;
        }
    }
    {
        float pi = 3.14159265359;
        int num_area_lights = int(area_light_info.x);
        for(int i = 0; i < num_area_lights; ++i)
        {
            float3 v = -normalize(_input.world_pos.xyz - camera_view_pos.xyz);
            float3 pos = _input.world_pos.xyz;
            float3 points[4];
            for(int j = 0; j < 4; ++j)
            points[j] = area_lights[i].corners[j].xyz;
            float diff_sum = area_light_diffuse(points, pos, n, v);
            float3 diff = area_lights[i].colour.rgb * diff_sum;
            float spec_sum = area_light_specular(points, pos, ro_sample.x, n, v);
            float3 spec = area_lights[i].colour.rgb * spec_sum;
            float3 light_col = (spec.rgb + diff.rgb) / (2.0 * pi);
            lit_colour += light_col;
        }
        int ts = num_area_lights;
        int num_area_lights_textured = int(area_light_info.y);
        for(int i = ts; i < ts + num_area_lights_textured; ++i)
        {
            float slice = area_lights[i].colour.w;
            float levels = 8.0;
            float2 inv_texel = float2(1.0/640.0, 1.0/480.0);
            float2 inv_texel_x = float2(1.0, 1.0) - inv_texel;
            float3 points[4];
            for(int j = 0; j < 4; ++j)
            points[j] = area_lights[i].corners[j].xyz;
            float3 v = -normalize(_input.world_pos.xyz - camera_view_pos.xyz);
            float3 pos = _input.world_pos.xyz;
            float4 diff_uv = area_light_diffuse_uv(points, pos, n, v);
            float2 duv = clamp(diff_uv.xy, inv_texel, inv_texel_x);
            float3 diff = sample_texture_array_level( area_light_textures, duv, slice, diff_uv.z * levels).rgb * diff_uv.w;
            float4 spec_uv = area_light_specular_uv(points, pos, ro_sample.x, n, v);
            float2 suv = clamp(spec_uv.xy, inv_texel, inv_texel_x);
            float3 spec = sample_texture_array_level(area_light_textures, suv, slice, spec_uv.z * levels).rgb * spec_uv.w;
            float3 light_col = (spec.rgb + diff.rgb) / (2.0 * pi);
            lit_colour += light_col;
        }
    }
    _output.colour.rgb = lit_colour.rgb * albedo.a;
    _output.colour.a = albedo.a;
    if(albedo.a <= 0.0)
    discard;
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//forward_render forward_lit__1073741824__ vs 1073741824
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
layout(location = 0) in float4 position_vs_input;
layout(location = 1) in float4 normal_vs_input;
layout(location = 2) in float4 texcoord_vs_input;
layout(location = 3) in float4 tangent_vs_input;
layout(location = 4) in float4 bitangent_vs_input;
layout(location = 5) in float4 world_matrix_0_instance_input;
layout(location = 6) in float4 world_matrix_1_instance_input;
layout(location = 7) in float4 world_matrix_2_instance_input;
layout(location = 8) in float4 world_matrix_3_instance_input;
layout(location = 9) in float4 user_data_instance_input;
layout(location = 10) in float4 user_data2_instance_input;
out float4 world_pos_vs_output;
out float3 normal_vs_output;
out float3 tangent_vs_output;
out float3 bitangent_vs_output;
out float4 texcoord_vs_output;
out float4 colour_vs_output;
uniform float v_flip;
struct vs_input_multi
{
    float4 position;
    float4 normal;
    float4 texcoord;
    float4 tangent;
    float4 bitangent;
};
struct vs_instance_input
{
    float4 world_matrix_0;
    float4 world_matrix_1;
    float4 world_matrix_2;
    float4 world_matrix_3;
    float4 user_data;
    float4 user_data2;
};
struct vs_output
{
    float4 position;
    float4 world_pos;
    float3 normal;
    float3 tangent;
    float3 bitangent;
    float4 texcoord;
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
layout (std140) uniform per_draw_call
{
    float4x4 world_matrix;
    float4 user_data;
    float4 user_data2;
    float4x4 world_matrix_inv_transpose;
};
void main()
{
    //assign vs_input_multi struct from glsl inputs
    vs_input_multi _input;
    _input.position = position_vs_input;
    _input.normal = normal_vs_input;
    _input.texcoord = texcoord_vs_input;
    _input.tangent = tangent_vs_input;
    _input.bitangent = bitangent_vs_input;
    //assign vs_instance_input struct from glsl inputs
    vs_instance_input instance_input;
    instance_input.world_matrix_0 = world_matrix_0_instance_input;
    instance_input.world_matrix_1 = world_matrix_1_instance_input;
    instance_input.world_matrix_2 = world_matrix_2_instance_input;
    instance_input.world_matrix_3 = world_matrix_3_instance_input;
    instance_input.user_data = user_data_instance_input;
    instance_input.user_data2 = user_data2_instance_input;
    vs_output _output;
    float4x4 wvp = mul( world_matrix, vp_matrix );
    float4x4 wm = world_matrix;
    _output.texcoord = float4(_input.texcoord.x, 1.0 - _input.texcoord.y,
    _input.texcoord.z, 1.0 - _input.texcoord.w );
    float4x4 instance_world_mat;
    unpack_vb_instance_mat(
    instance_world_mat,
    instance_input.world_matrix_0,
    instance_input.world_matrix_1,
    instance_input.world_matrix_2,
    instance_input.world_matrix_3
    );
    wvp = mul( instance_world_mat, vp_matrix );
    wm = instance_world_mat;
    _output.colour = instance_input.user_data2;
    _output.position = mul( _input.position, wvp );
    _output.world_pos = mul( _input.position, wm );
    float3x3 wrm = to_3x3(wm);
    wrm[0] = normalize(wrm[0]);
    wrm[1] = normalize(wrm[1]);
    wrm[2] = normalize(wrm[2]);
    _output.normal = mul( _input.normal.xyz, wrm );
    _output.tangent = mul( _input.tangent.xyz, wrm );
    _output.bitangent = mul( _input.bitangent.xyz, wrm );
    //assign glsl global outputs from structs
    gl_Position = _output.position;
    gl_Position.y *= v_flip;
    world_pos_vs_output = _output.world_pos;
    normal_vs_output = _output.normal;
    tangent_vs_output = _output.tangent;
    bitangent_vs_output = _output.bitangent;
    texcoord_vs_output = _output.texcoord;
    colour_vs_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//forward_render simple_lighting__2147483652__ vs 2147483652
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
layout(location = 0) in float4 position_vs_input;
layout(location = 1) in float4 normal_vs_input;
layout(location = 2) in float4 texcoord_vs_input;
layout(location = 3) in float4 tangent_vs_input;
layout(location = 4) in float4 bitangent_vs_input;
layout(location = 5) in float4 blend_indices_vs_input;
layout(location = 6) in float4 blend_weights_vs_input;
out float4 world_pos_vs_output;
out float3 normal_vs_output;
out float3 tangent_vs_output;
out float3 bitangent_vs_output;
out float4 texcoord_vs_output;
out float4 colour_vs_output;
uniform float v_flip;
struct vs_input_multi
{
    float4 position;
    float4 normal;
    float4 texcoord;
    float4 tangent;
    float4 bitangent;
    float4 blend_indices;
    float4 blend_weights;
};
struct vs_output
{
    float4 position;
    float4 world_pos;
    float3 normal;
    float3 tangent;
    float3 bitangent;
    float4 texcoord;
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform skinning_info
{
    float4x4 bones[85];
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
layout (std140) uniform per_draw_call
{
    float4x4 world_matrix;
    float4 user_data;
    float4 user_data2;
    float4x4 world_matrix_inv_transpose;
};
layout (std140) uniform material_data
{
    float4 m_albedo;
    float m_roughness;
    float m_reflectivity;
    float m_sss_scale;
    float m_padding;
};
float4 skin_pos(float4 pos, float4 weights, float4 indices)
{
    int bone_indices[4];
    bone_indices[0] = int(indices.x);
    bone_indices[1] = int(indices.y);
    bone_indices[2] = int(indices.z);
    bone_indices[3] = int(indices.w);
    float4 sp = float4( 0.0, 0.0, 0.0, 0.0 );
    float final_weight = 1.0;
    for(int i = 3; i >= 0; --i)
    {
        sp += mul( pos, bones[bone_indices[i]] ) * weights[i];
        final_weight -= weights[i];
    }
    sp += mul( pos, bones[bone_indices[0]] ) * final_weight;
    sp.w = 1.0;
    return sp;
}
void skin_tbn(inout float3 t, inout float3 b, inout float3 n, float4 weights, float4 indices)
{
    int bone_indices[4];
    bone_indices[0] = int(indices.x);
    bone_indices[1] = int(indices.y);
    bone_indices[2] = int(indices.z);
    bone_indices[3] = int(indices.w);
    float3 rt = float3( 0.0, 0.0, 0.0);
    float3 rb = float3( 0.0, 0.0, 0.0);
    float3 rn = float3( 0.0, 0.0, 0.0);
    float final_weight = 1.0;
    for( int i = 0; i < 3; ++i)
    {
        float3x3 rot_mat = to_3x3(bones[bone_indices[i]]);
        rt += mul(t, rot_mat) * weights[i];
        rb += mul(b, rot_mat) * weights[i];
        rn += mul(n, rot_mat) * weights[i];
        final_weight -= weights[i];
    }
    float3x3 rot_mat = to_3x3(bones[bone_indices[3]]);
    rt += mul(t, rot_mat) * final_weight;
    rb += mul(b, rot_mat) * final_weight;
    rn += mul(n, rot_mat) * final_weight;
    t = rt;
    b = rb;
    n = rn;
}
void main()
{
    //assign vs_input_multi struct from glsl inputs
    vs_input_multi _input;
    _input.position = position_vs_input;
    _input.normal = normal_vs_input;
    _input.texcoord = texcoord_vs_input;
    _input.tangent = tangent_vs_input;
    _input.bitangent = bitangent_vs_input;
    _input.blend_indices = blend_indices_vs_input;
    _input.blend_weights = blend_weights_vs_input;
    vs_output _output;
    float4x4 wvp = mul( world_matrix, vp_matrix );
    float4x4 wm = world_matrix;
    _output.texcoord = float4(_input.texcoord.x, 1.0 - _input.texcoord.y,
    _input.texcoord.z, 1.0 - _input.texcoord.w );
    _output.colour = m_albedo;
    float4 sp = skin_pos(_input.position, _input.blend_weights, _input.blend_indices);
    _output.tangent = _input.tangent.xyz;
    _output.bitangent = _input.bitangent.xyz;
    _output.normal = _input.normal.xyz;
    skin_tbn(_output.tangent, _output.bitangent, _output.normal, _input.blend_weights, _input.blend_indices);
    _output.position = mul( sp, vp_matrix );
    _output.world_pos = sp;
    //assign glsl global outputs from structs
    gl_Position = _output.position;
    gl_Position.y *= v_flip;
    world_pos_vs_output = _output.world_pos;
    normal_vs_output = _output.normal;
    tangent_vs_output = _output.tangent;
    bitangent_vs_output = _output.bitangent;
    texcoord_vs_output = _output.texcoord;
    colour_vs_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//forward_render forward_lit__1073741834__ ps 1073741834
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 world_pos_vs_output;
in float3 normal_vs_output;
in float3 tangent_vs_output;
in float3 bitangent_vs_output;
in float4 texcoord_vs_output;
in float4 colour_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 world_pos;
    float3 normal;
    float3 tangent;
    float3 bitangent;
    float4 texcoord;
    float4 colour;
};
struct ps_output
{
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
layout (std140) uniform per_draw_call
{
    float4x4 world_matrix;
    float4 user_data;
    float4 user_data2;
    float4x4 world_matrix_inv_transpose;
};
layout (std140) uniform per_pass_lights
{
    float4 light_info;
    light_data lights[100];
};
layout (std140) uniform per_pass_shadow
{
    float4x4 shadow_matrix[100];
};
layout (std140) uniform per_pass_shadow_distance_fields
{
    distance_field_shadow sdf_shadow;
};
layout (std140) uniform per_pass_area_lights
{
    float4 area_light_info;
    area_light_data area_lights[10];
};
layout (std140) uniform material_data
{
    float4 m_albedo;
    float2 m_uv_scale;
    float m_roughness;
    float m_reflectivity;
    float m_surface_offset;
    float3 m_padding;
};
texture_2d( diffuse_texture, 0 );
texture_2d( normal_texture, 1 );
texture_2d( specular_texture, 2 );
texture_3d( sdf_volume, 14 );
texture_2d( ltc_mat, 13 );
texture_2d( ltc_mag, 12 );
texture_2d_array( area_light_textures, 11 );
depth_2d_array( shadowmap_texture, 15 );
float3 cook_torrence(
float4 light_pos_radius,
float3 light_colour,
float3 n,
float3 world_pos,
float3 view_pos,
float3 albedo,
float3 metalness,
float roughness,
float reflectivity
)
{
    float3 l = normalize( light_pos_radius.xyz - world_pos.xyz );
    float n_dot_l = dot( n, l );
    if( n_dot_l > 0.0f )
    {
        float roughness_sq = roughness * roughness;
        float k = reflectivity;
        float3 v_view = normalize( (view_pos.xyz - world_pos.xyz) );
        float3 hv = normalize( v_view + l );
        float n_dot_v = dot( n, v_view );
        float n_dot_h = dot( n, hv );
        float v_dot_h = dot( v_view, hv );
        float n_dot_h_2 = 2.0f * n_dot_h;
        float g1 = (n_dot_h_2 * n_dot_v) / v_dot_h;
        float g2 = (n_dot_h_2 * n_dot_l) / v_dot_h;
        float geom_atten = min(1.0, min(g1, g2));
        float r1 = 1.0f / ( 4.0f * roughness_sq * pow(n_dot_h, 4.0f));
        float r2 = (n_dot_h * n_dot_h - 1.0) / (roughness_sq * n_dot_h * n_dot_h);
        float roughness_atten = r1 * exp(r2);
        float fresnel = pow(1.0 - v_dot_h, 5.0);
        fresnel *= roughness;
        fresnel += reflectivity;
        float specular = (fresnel * geom_atten * roughness_atten) / (n_dot_v * n_dot_l * 3.1419);
        float3 lit_colour = metalness * light_colour * n_dot_l * ( k + specular * ( 1.0 - k ) );
        return saturate(lit_colour);
    }
    return float3( 0.0, 0.0, 0.0 );
}
float3 oren_nayar(
float4 light_pos_radius,
float3 light_colour,
float3 n,
float3 world_pos,
float3 view_pos,
float roughness,
float3 albedo)
{
    float3 v = normalize(view_pos-world_pos);
    float3 l = normalize(light_pos_radius.xyz-world_pos);
    float l_dot_v = dot(l, v);
    float n_dot_l = dot(n, l);
    float n_dot_v = dot(n, v);
    float s = l_dot_v - n_dot_l * n_dot_v;
    float t = lerp(1.0, max(n_dot_l, n_dot_v), step(0.0, s));
    float lum = length( albedo );
    float sigma2 = roughness * roughness;
    float A = 1.0 + sigma2 * (lum / (sigma2 + 0.13) + 0.5 / (sigma2 + 0.33));
    float B = 0.45 * sigma2 / (sigma2 + 0.09);
    return ( albedo * light_colour * max(0.0, n_dot_l) * (A + B * s / t) / 3.14159265 );
}
float spot_light_attenuation(
float4 light_pos_radius,
float4 light_dir_cutoff,
float falloff,
float3 world_pos)
{
    float co = light_dir_cutoff.w;
    float3 vl = normalize(world_pos.xyz - light_pos_radius.xyz);
    float3 sd = normalize(light_dir_cutoff.xyz);
    float dp = (1.0 - dot(vl, sd));
    return smoothstep(co, co - falloff, dp);
}
float point_light_attenuation_cutoff(
float4 light_pos_radius,
float3 world_pos)
{
    float r = light_pos_radius.w;
    float d = length(world_pos.xyz - light_pos_radius.xyz);
    d = max(d - r, 0.0);
    float denom = d/r + 1.0;
    float attenuation = 1.0 / (denom*denom);
    float cutoff = 0.2;
    attenuation = (attenuation - cutoff) / (1.0 - cutoff);
    attenuation = max(attenuation, 0.0);
    return attenuation;
}
float sample_shadow_array_pcf_9(float array_slice, float3 sp)
{
    float2 samples[9];
    float2 inv_sm_size = float2(1.0/2048.0, 1.0/2048.0);
    samples[0] = float2(-1.0, -1.0) * inv_sm_size;
    samples[1] = float2(-1.0, 0.0) * inv_sm_size;
    samples[2] = float2(-1.0, 1.0) * inv_sm_size;
    samples[3] = float2(0.0, -1.0) * inv_sm_size;
    samples[4] = float2(0.0, 0.0) * inv_sm_size;
    samples[5] = float2(0.0, 1.0) * inv_sm_size;
    samples[6] = float2(1.0, -1.0) * inv_sm_size;
    samples[7] = float2(1.0, 0.0) * inv_sm_size;
    samples[8] = float2(1.0, 1.0) * inv_sm_size;
    float shadow = 0.0;
    for(int j = 0; j < 9; ++j)
    {
        shadow += sample_depth_compare_array(shadowmap_texture, sp.xy + samples[j], array_slice, sp.z);
    }
    shadow /= 9.0;
    return shadow;
}
bool ray_vs_aabb(float3 emin, float3 emax, float3 r1, float3 rv, out float3 intersection)
{
    float3 dirfrac = float3(1.0, 1.0, 1.0) / rv;
    float t1 = (emin.x - r1.x)*dirfrac.x;
    float t2 = (emax.x - r1.x)*dirfrac.x;
    float t3 = (emin.y - r1.y)*dirfrac.y;
    float t4 = (emax.y - r1.y)*dirfrac.y;
    float t5 = (emin.z - r1.z)*dirfrac.z;
    float t6 = (emax.z - r1.z)*dirfrac.z;
    float tmin = max(max(min(t1, t2), min(t3, t4)), min(t5, t6));
    float tmax = min(min(max(t1, t2), max(t3, t4)), max(t5, t6));
    float t = 0.0;
    if (tmax < 0.0)
    {
        t = tmax;
        return false;
    }
    if (tmin > tmax)
    {
        t = tmax;
        return false;
    }
    t = tmin;
    intersection = r1 + rv * t;
    return true;
}
float sdf_shadow_trace(float max_samples, float3 light_pos, float3 world_pos, float3 scale, float3 ray_origin, float4x4 inv_mat, float3x3 inv_rot)
{
    float3 ray_dir = normalize(light_pos - world_pos);
    ray_dir = normalize( mul( ray_dir, inv_rot ) );
    float closest = 1.0;
    float3 uvw = ray_origin;
    if(abs(uvw.x) >= 1.0 || abs(uvw.y) >= 1.0 || abs(uvw.z) >= 1.0)
    {
        float3 emin = float3(-1.0, -1.0, -1.0);
        float3 emax = float3(1.0, 1.0, 1.0);
        float3 ip = float3(0.0, 0.0, 0.0);
        bool hit = ray_vs_aabb( emin, emax, uvw, ray_dir, ip);
        uvw = ip;
        if(!hit)
        {
            return closest;
        }
    }
    float3 light_uvw = mul( float4(light_pos, 1.0), inv_mat ).xyz * 0.5 + 0.5;
    uvw = uvw * 0.5 + 0.5;
    float3 v1 = normalize(light_uvw - uvw);
    for( int s = 0; s < int(max_samples); ++s )
    {
        float d = sample_texture_level( sdf_volume, uvw, 0.0 ).r;
        closest = min(d, closest);
        ray_dir = normalize(light_uvw - uvw);
        float3 step = ray_dir.xyz * float3(d, d, d) / scale * 0.7;
        uvw += step;
        if( d <= 0.0 )
        {
            closest = max( d, 0.0 );
            break;
        }
        if(uvw.x >= 1.0 || uvw.x < 0.0)
        break;
        if(uvw.y >= 1.0 || uvw.y < 0.0)
        break;
        if(uvw.z >= 1.0 || uvw.z < 0.0)
        break;
    }
    return closest;
}
float integrate_edge(float3 v1, float3 v2)
{
    float cos_theta = dot(v1, v2);
    float theta = acos(cos_theta);
    float res = cross(v1, v2).z * ((theta > 0.001) ? theta/sin(theta) : 1.0);
    return res;
}
void clip_quad_to_horizon(inout float3 L[5], out int n)
{
    int config = 0;
    if (L[0].z > 0.0) config += 1;
    if (L[1].z > 0.0) config += 2;
    if (L[2].z > 0.0) config += 4;
    if (L[3].z > 0.0) config += 8;
    n = 0;
    if (config == 0)
    {
    }
    else if (config == 1)
    {
        n = 3;
        L[1] = -L[1].z * L[0] + L[0].z * L[1];
        L[2] = -L[3].z * L[0] + L[0].z * L[3];
    }
    else if (config == 2)
    {
        n = 3;
        L[0] = -L[0].z * L[1] + L[1].z * L[0];
        L[2] = -L[2].z * L[1] + L[1].z * L[2];
    }
    else if (config == 3)
    {
        n = 4;
        L[2] = -L[2].z * L[1] + L[1].z * L[2];
        L[3] = -L[3].z * L[0] + L[0].z * L[3];
    }
    else if (config == 4)
    {
        n = 3;
        L[0] = -L[3].z * L[2] + L[2].z * L[3];
        L[1] = -L[1].z * L[2] + L[2].z * L[1];
    }
    else if (config == 5)
    {
        n = 0;
    }
    else if (config == 6)
    {
        n = 4;
        L[0] = -L[0].z * L[1] + L[1].z * L[0];
        L[3] = -L[3].z * L[2] + L[2].z * L[3];
    }
    else if (config == 7)
    {
        n = 5;
        L[4] = -L[3].z * L[0] + L[0].z * L[3];
        L[3] = -L[3].z * L[2] + L[2].z * L[3];
    }
    else if (config == 8)
    {
        n = 3;
        L[0] = -L[0].z * L[3] + L[3].z * L[0];
        L[1] = -L[2].z * L[3] + L[3].z * L[2];
        L[2] = L[3];
    }
    else if (config == 9)
    {
        n = 4;
        L[1] = -L[1].z * L[0] + L[0].z * L[1];
        L[2] = -L[2].z * L[3] + L[3].z * L[2];
    }
    else if (config == 10)
    {
        n = 0;
    }
    else if (config == 11)
    {
        n = 5;
        L[4] = L[3];
        L[3] = -L[2].z * L[3] + L[3].z * L[2];
        L[2] = -L[2].z * L[1] + L[1].z * L[2];
    }
    else if (config == 12)
    {
        n = 4;
        L[1] = -L[1].z * L[2] + L[2].z * L[1];
        L[0] = -L[0].z * L[3] + L[3].z * L[0];
    }
    else if (config == 13)
    {
        n = 5;
        L[4] = L[3];
        L[3] = L[2];
        L[2] = -L[1].z * L[2] + L[2].z * L[1];
        L[1] = -L[1].z * L[0] + L[0].z * L[1];
    }
    else if (config == 14)
    {
        n = 5;
        L[4] = -L[0].z * L[3] + L[3].z * L[0];
        L[0] = -L[0].z * L[1] + L[1].z * L[0];
    }
    else if (config == 15)
    {
        n = 4;
    }
    if (n == 3)
    L[3] = L[0];
    if (n == 4)
    L[4] = L[0];
}
float3 ltc_uv_coord(float3 p[4])
{
    float3 v1 = p[1] - p[0];
    float3 v2 = p[3] - p[0];
    float3 plane_ortho = (cross(v1, v2));
    float plane_area_squared = dot(plane_ortho, plane_ortho);
    float plane_distx_plane_area = dot(plane_ortho, p[0]);
    float3 pp = plane_distx_plane_area * plane_ortho / plane_area_squared - p[0];
    float v1_dot_v2 = dot(v1, v2);
    float inv_v1_dot_v1 = 1.0 / dot(v1, v1);
    float3 vv2 = v2 - v1 * v1_dot_v2 * inv_v1_dot_v1;
    float2 puv;
    puv.y = dot(vv2, pp) / dot(vv2, vv2);
    puv.x = dot(v1, pp) * inv_v1_dot_v1 - v1_dot_v2 * inv_v1_dot_v1 * puv.y;
    float d = abs(plane_distx_plane_area) / pow(plane_area_squared, 0.75);
    return float3(puv, d);
}
float4 ltc_evaluate(
float3 n,
float3 v,
float3 p,
float3x3 minv,
float3 points[4],
bool two_sided)
{
    float3 t1, t2;
    t1 = normalize(v - n * dot(v, n));
    t2 = cross(n, t1);
    float3x3 ttn = from_columns_3x3(t1, t2, n);
    minv = mul(minv, ttn);
    float3 l[5];
    l[0] = mul(minv, points[0] - p);
    l[1] = mul(minv, points[1] - p);
    l[2] = mul(minv, points[2] - p);
    l[3] = mul(minv, points[3] - p);
    l[4] = l[3];
    float3 ll[4];
    ll[0] = l[0];
    ll[1] = l[1];
    ll[2] = l[2];
    ll[3] = l[3];
    float3 uvl = ltc_uv_coord(ll);
    int nc;
    clip_quad_to_horizon(l, nc);
    if (nc == 0)
    return float4(0, 0, 0, 0.0);
    l[0] = normalize(l[0]);
    l[1] = normalize(l[1]);
    l[2] = normalize(l[2]);
    l[3] = normalize(l[3]);
    l[4] = normalize(l[4]);
    float sum = 0.0;
    sum += integrate_edge(l[0], l[1]);
    sum += integrate_edge(l[1], l[2]);
    sum += integrate_edge(l[2], l[3]);
    if (nc >= 4)
    sum += integrate_edge(l[3], l[4]);
    if (nc == 5)
    sum += integrate_edge(l[4], l[0]);
    sum = two_sided ? abs(sum) : max(0.0, sum);
    float3 lo_i = float3(sum, sum, sum);
    return float4(uvl.x, uvl.y, uvl.z, sum);
}
float ltc_evaluate_cc(
float3 n,
float3 v,
float3 p,
float3x3 minv,
float3 points[4],
bool two_sided)
{
    float3 t1, t2;
    t1 = normalize(v - n * dot(v, n));
    t2 = cross(n, t1);
    float3x3 ttn = from_columns_3x3(t1, t2, n);
    minv = mul(minv, ttn);
    float3 l[5];
    for(int i = 0; i < 4; ++i)
    l[i] = mul(minv, points[i] - p);
    l[4] = l[3];
    int nc;
    clip_quad_to_horizon(l, nc);
    if (nc == 0)
    return 0.0;
    for(int i = 0; i < 5; ++i)
    l[i] = normalize(l[i]);
    float sum = 0.0;
    sum += integrate_edge(l[0], l[1]);
    sum += integrate_edge(l[1], l[2]);
    sum += integrate_edge(l[2], l[3]);
    if (nc >= 4)
    sum += integrate_edge(l[3], l[4]);
    if (nc == 5)
    sum += integrate_edge(l[4], l[0]);
    sum = two_sided ? abs(sum) : max(0.0, sum);
    return sum;
}
float4 area_light_specular_uv(
float3 points[4],
float3 pos,
float roughness,
float3 n,
float3 v)
{
    float pi = 3.14159265359;
    float lut_size = 64.0;
    float lut_scale = (lut_size - 1.0)/lut_size;
    float lut_bias = 0.5/lut_size;
    float theta = acos(dot(n, v));
    float2 uv = float2(roughness, theta / (0.5 * pi));
    uv = uv * lut_scale + lut_bias;
    float4 mat = sample_texture(ltc_mat, uv);
    float mag = sample_texture(ltc_mag, uv).w;
    float3x3 minv = from_rows_3x3(
    float3(1.0, 0.0, mat.y),
    float3(0.0, mat.z, 0.0),
    float3(mat.w, 0.0, mat.x)
    );
    float4 spec = ltc_evaluate(n, v, pos, minv, points, true);
    return spec;
}
float area_light_specular(
float3 points[4],
float3 pos,
float roughness,
float3 n,
float3 v)
{
    float pi = 3.14159265359;
    float lut_size = 64.0;
    float lut_scale = (lut_size - 1.0)/lut_size;
    float lut_bias = 0.5/lut_size;
    float theta = acos(dot(n, v));
    float2 uv = float2(roughness, theta / (0.5 * pi));
    uv = uv * lut_scale + lut_bias;
    float4 mat = sample_texture(ltc_mat, uv);
    float mag = sample_texture(ltc_mag, uv).w;
    float3x3 minv = from_rows_3x3(
    float3(1.0, 0.0, mat.y),
    float3(0.0, mat.z, 0.0),
    float3(mat.w, 0.0, mat.x)
    );
    float spec = ltc_evaluate_cc(n, v, pos, minv, points, true);
    return spec;
}
float4 area_light_diffuse_uv(
float3 points[4],
float3 pos,
float3 n,
float3 v)
{
    float3x3 difv = float3x3(
    float3(1.0, 0.0, 0.0),
    float3(0.0, 1.0, 0.0),
    float3(0.0, 0.0, 1.0)
    );
    float4 diff = ltc_evaluate(n, v, pos, difv, points, true);
    return diff;
}
float area_light_diffuse(
float3 points[4],
float3 pos,
float3 n,
float3 v)
{
    float3x3 difv = float3x3(
    float3(1.0, 0.0, 0.0),
    float3(0.0, 1.0, 0.0),
    float3(0.0, 0.0, 1.0)
    );
    float diff = ltc_evaluate_cc(n, v, pos, difv, points, true);
    return diff;
}
float3 transform_ts_normal( float3 t, float3 b, float3 n, float3 ts_normal )
{
    float3x3 tbn;
    tbn[0] = float3(t.x, b.x, n.x);
    tbn[1] = float3(t.y, b.y, n.y);
    tbn[2] = float3(t.z, b.z, n.z);
    return normalize( mul_tbn( tbn, ts_normal ) );
}
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.world_pos = world_pos_vs_output;
    _input.normal = normal_vs_output;
    _input.tangent = tangent_vs_output;
    _input.bitangent = bitangent_vs_output;
    _input.texcoord = texcoord_vs_output;
    _input.colour = colour_vs_output;
    ps_output _output;
    float4 albedo = sample_texture( diffuse_texture, _input.texcoord.xy );
    float3 normal_sample = sample_texture( normal_texture, _input.texcoord.xy ).rgb;
    float4 ro_sample = sample_texture( specular_texture, _input.texcoord.xy );
    float4 specular_sample = float4(1.0, 1.0, 1.0, 1.0);
    normal_sample = normal_sample * 2.0 - 1.0;
    float3 n = transform_ts_normal(
    _input.tangent,
    _input.bitangent,
    _input.normal,
    normal_sample );
    albedo *= _input.colour;
    float4 metalness = float4(1.0, 1.0, 1.0, 1.0);
    float3 lit_colour = float3( 0.0, 0.0, 0.0 );
    float reflectivity = saturate(user_data.z);
    float roughness = saturate(user_data.y);
    reflectivity = m_reflectivity;
    roughness = ro_sample.r;
    roughness = _input.colour.a;
    albedo.a = 1.0;
    n = _input.normal.rgb;
    roughness = m_roughness;
    float max_samples = 128.0;
    float3x3 inv_rot = to_3x3(sdf_shadow.world_matrix_inv);
    float3 r1 = _input.world_pos.xyz + _input.normal.xyz * m_surface_offset;
    float3 tr1 = mul( float4(r1, 1.0), sdf_shadow.world_matrix_inv ).xyz;
    float3 scale = float3(length(sdf_shadow.world_matrix[0].xyz), length(sdf_shadow.world_matrix[1].xyz), length(sdf_shadow.world_matrix[2].xyz)) * 2.0;
    float3 vddx = ddx( r1 );
    float3 vddy = ddy( r1 );
    float t = 1.0;
    float3 lll = float3(0.0, 0.0, 0.0);
    int shadow_map_index = 0;
    _pmfx_loop
    for( int i = 0; i < int(light_info.x); ++i )
    {
        float3 light_col = float3( 0.0, 0.0, 0.0 );
        light_col += cook_torrence(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        albedo.rgb,
        metalness.rgb,
        roughness,
        reflectivity
        );
        light_col += oren_nayar(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        1.0 - roughness,
        albedo.rgb
        );
        float s = sdf_shadow_trace(max_samples, lights[i].pos_radius.xyz, _input.world_pos.xyz, scale, tr1, sdf_shadow.world_matrix_inv, inv_rot);
        light_col *= smoothstep( 0.0, 0.1, s);
        if( lights[i].colour.a == 0.0 )
        {
            lit_colour += light_col;
            continue;
        }
        else
        {
            float shadow = 1.0;
            float d = 1.0;
            float4 offset_pos = float4(_input.world_pos.xyz + n.xyz * 0.01, 1.0);
            float4 sp = mul( offset_pos, shadow_matrix[i] );
            sp.xyz /= sp.w;
            sp.y *= -1.0;
            sp.xy = sp.xy * 0.5 + 0.5;
            sp.z = remap_depth(sp.z);
            shadow = sample_shadow_array_pcf_9(float(shadow_map_index), sp.xyz);
            lit_colour += light_col * shadow;
            ++shadow_map_index;
        }
    }
    int point_start = int(light_info.x);
    int point_end = int(light_info.x) + int(light_info.y);
    int omni_shadow_index = 0;
    _pmfx_loop
    for( int i = point_start; i < point_end; ++i )
    {
        float3 light_col = float3( 0.0, 0.0, 0.0 );
        light_col += cook_torrence(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        albedo.rgb,
        metalness.rgb,
        roughness,
        reflectivity
        );
        light_col += oren_nayar(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        roughness,
        albedo.rgb
        );
        float a = point_light_attenuation_cutoff( lights[i].pos_radius, _input.world_pos.xyz );
        light_col *= a;
        float s = sdf_shadow_trace(max_samples, lights[i].pos_radius.xyz, _input.world_pos.xyz, scale, tr1, sdf_shadow.world_matrix_inv, inv_rot);
        light_col *= smoothstep( 0.0, 0.1, s);
        if( lights[i].colour.a == 0.0)
        {
            lit_colour += light_col;
            continue;
        }
        else
        {
            lit_colour += light_col;
            continue;
        }
    }
    int spot_start = point_end;
    int spot_end = spot_start + int(light_info.z);
    _pmfx_loop
    for(int i = spot_start; i < spot_end; ++i )
    {
        float3 light_col = float3( 0.0, 0.0, 0.0 );
        light_col += cook_torrence(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        albedo.rgb,
        metalness.rgb,
        roughness,
        reflectivity
        );
        light_col += oren_nayar(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        roughness,
        albedo.rgb
        );
        float a = spot_light_attenuation(lights[i].pos_radius,
        lights[i].dir_cutoff,
        lights[i].data.x,
        _input.world_pos.xyz );
        light_col *= a;
        float s = sdf_shadow_trace(max_samples, lights[i].pos_radius.xyz, _input.world_pos.xyz, scale, tr1, sdf_shadow.world_matrix_inv, inv_rot);
        light_col *= smoothstep( 0.0, 0.1, s);
        if( lights[i].colour.a == 0.0 )
        {
            lit_colour += light_col;
            continue;
        }
        else
        {
            float shadow = 1.0;
            float d = 1.0;
            float4 offset_pos = float4(_input.world_pos.xyz + n.xyz * 0.01, 1.0);
            float4 sp = mul( offset_pos, shadow_matrix[shadow_map_index] );
            sp.xyz /= sp.w;
            sp.y *= -1.0;
            sp.xy = sp.xy * 0.5 + 0.5;
            sp.z = remap_depth(sp.z);
            shadow = sample_shadow_array_pcf_9(float(shadow_map_index), sp.xyz);
            lit_colour += light_col * shadow;
            ++shadow_map_index;
        }
    }
    {
        float pi = 3.14159265359;
        int num_area_lights = int(area_light_info.x);
        for(int i = 0; i < num_area_lights; ++i)
        {
            float3 v = -normalize(_input.world_pos.xyz - camera_view_pos.xyz);
            float3 pos = _input.world_pos.xyz;
            float3 points[4];
            for(int j = 0; j < 4; ++j)
            points[j] = area_lights[i].corners[j].xyz;
            float diff_sum = area_light_diffuse(points, pos, n, v);
            float3 diff = area_lights[i].colour.rgb * diff_sum;
            float spec_sum = area_light_specular(points, pos, ro_sample.x, n, v);
            float3 spec = area_lights[i].colour.rgb * spec_sum;
            float3 light_col = (spec.rgb + diff.rgb) / (2.0 * pi);
            lit_colour += light_col;
        }
        int ts = num_area_lights;
        int num_area_lights_textured = int(area_light_info.y);
        for(int i = ts; i < ts + num_area_lights_textured; ++i)
        {
            float slice = area_lights[i].colour.w;
            float levels = 8.0;
            float2 inv_texel = float2(1.0/640.0, 1.0/480.0);
            float2 inv_texel_x = float2(1.0, 1.0) - inv_texel;
            float3 points[4];
            for(int j = 0; j < 4; ++j)
            points[j] = area_lights[i].corners[j].xyz;
            float3 v = -normalize(_input.world_pos.xyz - camera_view_pos.xyz);
            float3 pos = _input.world_pos.xyz;
            float4 diff_uv = area_light_diffuse_uv(points, pos, n, v);
            float2 duv = clamp(diff_uv.xy, inv_texel, inv_texel_x);
            float3 diff = sample_texture_array_level( area_light_textures, duv, slice, diff_uv.z * levels).rgb * diff_uv.w;
            float4 spec_uv = area_light_specular_uv(points, pos, ro_sample.x, n, v);
            float2 suv = clamp(spec_uv.xy, inv_texel, inv_texel_x);
            float3 spec = sample_texture_array_level(area_light_textures, suv, slice, spec_uv.z * levels).rgb * spec_uv.w;
            float3 light_col = (spec.rgb + diff.rgb) / (2.0 * pi);
            lit_colour += light_col;
        }
    }
    _output.colour.rgb = lit_colour.rgb * albedo.a;
    _output.colour.a = albedo.a;
    if(albedo.a <= 0.0)
    discard;
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//forward_render shadow_extrude vs 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
layout(location = 0) in float4 position_vs_input;
layout(location = 1) in float4 face_normal_0_vs_input;
layout(location = 2) in float4 face_normal_1_vs_input;
out float4 world_pos_vs_output;
out float3 normal_vs_output;
out float3 tangent_vs_output;
out float3 bitangent_vs_output;
out float4 texcoord_vs_output;
out float4 colour_vs_output;
uniform float v_flip;
struct vs_input_stencil_shadow
{
    float4 position;
    float4 face_normal_0;
    float4 face_normal_1;
};
struct vs_output
{
    float4 position;
    float4 world_pos;
    float3 normal;
    float3 tangent;
    float3 bitangent;
    float4 texcoord;
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
layout (std140) uniform per_draw_call
{
    float4x4 world_matrix;
    float4 user_data;
    float4 user_data2;
    float4x4 world_matrix_inv_transpose;
};
layout (std140) uniform cbuffer_single_light
{
    light_data single_light;
};
void main()
{
    //assign vs_input_stencil_shadow struct from glsl inputs
    vs_input_stencil_shadow _input;
    _input.position = position_vs_input;
    _input.face_normal_0 = face_normal_0_vs_input;
    _input.face_normal_1 = face_normal_1_vs_input;
    vs_output _output;
    float4 wp = mul( _input.position, world_matrix );
    float3x3 wrm = to_3x3(world_matrix);
    wrm[0] = normalize(wrm[0]);
    wrm[1] = normalize(wrm[1]);
    wrm[2] = normalize(wrm[2]);
    float3 wn_0 = mul( _input.face_normal_0.xyz, wrm );
    float3 wn_1 = mul( _input.face_normal_1.xyz, wrm );
    float3 ld = wp.xyz - single_light.pos_radius.xyz;
    float d0 = dot(ld, wn_0.xyz);
    float d1 = dot(ld, wn_1.xyz);
    if(d0 > 0.0 && d1 < 0.0)
    wp.xyz += ld * 100.0;
    _output.position = mul( wp, vp_matrix);
    //assign glsl global outputs from structs
    gl_Position = _output.position;
    gl_Position.y *= v_flip;
    world_pos_vs_output = _output.world_pos;
    normal_vs_output = _output.normal;
    tangent_vs_output = _output.tangent;
    bitangent_vs_output = _output.bitangent;
    texcoord_vs_output = _output.texcoord;
    colour_vs_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//forward_render simple_lighting ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 world_pos_vs_output;
in float3 normal_vs_output;
in float3 tangent_vs_output;
in float3 bitangent_vs_output;
in float4 texcoord_vs_output;
in float4 colour_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 world_pos;
    float3 normal;
    float3 tangent;
    float3 bitangent;
    float4 texcoord;
    float4 colour;
};
struct ps_output
{
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
layout (std140) uniform per_draw_call
{
    float4x4 world_matrix;
    float4 user_data;
    float4 user_data2;
    float4x4 world_matrix_inv_transpose;
};
layout (std140) uniform per_pass_lights
{
    float4 light_info;
    light_data lights[100];
};
layout (std140) uniform per_pass_shadow
{
    float4x4 shadow_matrix[100];
};
layout (std140) uniform material_data
{
    float4 m_albedo;
    float m_roughness;
    float m_reflectivity;
    float2 m_padding;
};
texture_2d( diffuse_texture, 0 );
texture_2d( normal_texture, 1 );
texture_2d( specular_texture, 2 );
depth_2d( single_shadowmap_texture, 7 );
float3 cook_torrence(
float4 light_pos_radius,
float3 light_colour,
float3 n,
float3 world_pos,
float3 view_pos,
float3 albedo,
float3 metalness,
float roughness,
float reflectivity
)
{
    float3 l = normalize( light_pos_radius.xyz - world_pos.xyz );
    float n_dot_l = dot( n, l );
    if( n_dot_l > 0.0f )
    {
        float roughness_sq = roughness * roughness;
        float k = reflectivity;
        float3 v_view = normalize( (view_pos.xyz - world_pos.xyz) );
        float3 hv = normalize( v_view + l );
        float n_dot_v = dot( n, v_view );
        float n_dot_h = dot( n, hv );
        float v_dot_h = dot( v_view, hv );
        float n_dot_h_2 = 2.0f * n_dot_h;
        float g1 = (n_dot_h_2 * n_dot_v) / v_dot_h;
        float g2 = (n_dot_h_2 * n_dot_l) / v_dot_h;
        float geom_atten = min(1.0, min(g1, g2));
        float r1 = 1.0f / ( 4.0f * roughness_sq * pow(n_dot_h, 4.0f));
        float r2 = (n_dot_h * n_dot_h - 1.0) / (roughness_sq * n_dot_h * n_dot_h);
        float roughness_atten = r1 * exp(r2);
        float fresnel = pow(1.0 - v_dot_h, 5.0);
        fresnel *= roughness;
        fresnel += reflectivity;
        float specular = (fresnel * geom_atten * roughness_atten) / (n_dot_v * n_dot_l * 3.1419);
        float3 lit_colour = metalness * light_colour * n_dot_l * ( k + specular * ( 1.0 - k ) );
        return saturate(lit_colour);
    }
    return float3( 0.0, 0.0, 0.0 );
}
float3 oren_nayar(
float4 light_pos_radius,
float3 light_colour,
float3 n,
float3 world_pos,
float3 view_pos,
float roughness,
float3 albedo)
{
    float3 v = normalize(view_pos-world_pos);
    float3 l = normalize(light_pos_radius.xyz-world_pos);
    float l_dot_v = dot(l, v);
    float n_dot_l = dot(n, l);
    float n_dot_v = dot(n, v);
    float s = l_dot_v - n_dot_l * n_dot_v;
    float t = lerp(1.0, max(n_dot_l, n_dot_v), step(0.0, s));
    float lum = length( albedo );
    float sigma2 = roughness * roughness;
    float A = 1.0 + sigma2 * (lum / (sigma2 + 0.13) + 0.5 / (sigma2 + 0.33));
    float B = 0.45 * sigma2 / (sigma2 + 0.09);
    return ( albedo * light_colour * max(0.0, n_dot_l) * (A + B * s / t) / 3.14159265 );
}
float sample_shadow_pcf_9(float3 sp)
{
    float2 samples[9];
    float2 inv_sm_size = float2(1.0/2048.0, 1.0/2048.0);
    samples[0] = float2(-1.0, -1.0) * inv_sm_size;
    samples[1] = float2(-1.0, 0.0) * inv_sm_size;
    samples[2] = float2(-1.0, 1.0) * inv_sm_size;
    samples[3] = float2(0.0, -1.0) * inv_sm_size;
    samples[4] = float2(0.0, 0.0) * inv_sm_size;
    samples[5] = float2(0.0, 1.0) * inv_sm_size;
    samples[6] = float2(1.0, -1.0) * inv_sm_size;
    samples[7] = float2(1.0, 0.0) * inv_sm_size;
    samples[8] = float2(1.0, 1.0) * inv_sm_size;
    float shadow = 0.0;
    for(int j = 0; j < 9; ++j)
    {
        shadow += sample_depth_compare(single_shadowmap_texture, sp.xy + samples[j], sp.z);
    }
    shadow /= 9.0;
    return shadow;
}
float3 transform_ts_normal( float3 t, float3 b, float3 n, float3 ts_normal )
{
    float3x3 tbn;
    tbn[0] = float3(t.x, b.x, n.x);
    tbn[1] = float3(t.y, b.y, n.y);
    tbn[2] = float3(t.z, b.z, n.z);
    return normalize( mul_tbn( tbn, ts_normal ) );
}
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.world_pos = world_pos_vs_output;
    _input.normal = normal_vs_output;
    _input.tangent = tangent_vs_output;
    _input.bitangent = bitangent_vs_output;
    _input.texcoord = texcoord_vs_output;
    _input.colour = colour_vs_output;
    ps_output _output;
    float4 albedo = sample_texture( diffuse_texture, _input.texcoord.xy );
    float3 normal_sample = sample_texture( normal_texture, _input.texcoord.xy ).rgb;
    float4 ro_sample = sample_texture( specular_texture, _input.texcoord.xy );
    float4 specular_sample = float4(1.0, 1.0, 1.0, 1.0);
    normal_sample = normal_sample * 2.0 - 1.0;
    float3 n = transform_ts_normal(
    _input.tangent,
    _input.bitangent,
    _input.normal,
    normal_sample );
    albedo *= _input.colour;
    float4 metalness = float4(1.0, 1.0, 1.0, 1.0);
    float3 lit_colour = float3( 0.0, 0.0, 0.0 );
    float reflectivity = saturate(user_data.z);
    float roughness = saturate(user_data.y);
    reflectivity = m_reflectivity;
    roughness = m_roughness;
    float3 lll = float3(0.0, 0.0, 0.0);
    int shadow_map_index = 0;
    _pmfx_loop
    for(int i = 0; i < 1; ++i )
    {
        float3 light_col = float3( 0.0, 0.0, 0.0 );
        light_col += cook_torrence(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        albedo.rgb,
        metalness.rgb,
        roughness,
        reflectivity
        );
        light_col += oren_nayar(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        1.0 - roughness,
        albedo.rgb
        );
        if( lights[i].colour.a == 0.0 )
        {
            lit_colour += light_col;
            continue;
        }
        else
        {
            float shadow = 1.0;
            float d = 1.0;
            float4 offset_pos = float4(_input.world_pos.xyz + n.xyz * 0.01, 1.0);
            float4 sp = mul( offset_pos, shadow_matrix[i] );
            sp.xyz /= sp.w;
            sp.y *= -1.0;
            sp.xy = sp.xy * 0.5 + 0.5;
            sp.z = remap_depth(sp.z);
            shadow = sample_shadow_pcf_9(sp.xyz);
            lit_colour += light_col * shadow;
            ++shadow_map_index;
        }
        lit_colour += oren_nayar(
        lights[i].pos_radius * -1.0,
        lights[i].colour.rgb * 0.25,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        1.0 - roughness,
        albedo.rgb
        );
    }
    _output.colour.rgb = lit_colour;
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//forward_render forward_lit vs 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
layout(location = 0) in float4 position_vs_input;
layout(location = 1) in float4 normal_vs_input;
layout(location = 2) in float4 texcoord_vs_input;
layout(location = 3) in float4 tangent_vs_input;
layout(location = 4) in float4 bitangent_vs_input;
out float4 world_pos_vs_output;
out float3 normal_vs_output;
out float3 tangent_vs_output;
out float3 bitangent_vs_output;
out float4 texcoord_vs_output;
out float4 colour_vs_output;
uniform float v_flip;
struct vs_input_multi
{
    float4 position;
    float4 normal;
    float4 texcoord;
    float4 tangent;
    float4 bitangent;
};
struct vs_output
{
    float4 position;
    float4 world_pos;
    float3 normal;
    float3 tangent;
    float3 bitangent;
    float4 texcoord;
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
layout (std140) uniform per_draw_call
{
    float4x4 world_matrix;
    float4 user_data;
    float4 user_data2;
    float4x4 world_matrix_inv_transpose;
};
layout (std140) uniform material_data
{
    float4 m_albedo;
    float m_roughness;
    float m_reflectivity;
    float2 m_padding;
};
void main()
{
    //assign vs_input_multi struct from glsl inputs
    vs_input_multi _input;
    _input.position = position_vs_input;
    _input.normal = normal_vs_input;
    _input.texcoord = texcoord_vs_input;
    _input.tangent = tangent_vs_input;
    _input.bitangent = bitangent_vs_input;
    vs_output _output;
    float4x4 wvp = mul( world_matrix, vp_matrix );
    float4x4 wm = world_matrix;
    _output.texcoord = float4(_input.texcoord.x, 1.0 - _input.texcoord.y,
    _input.texcoord.z, 1.0 - _input.texcoord.w );
    _output.colour = m_albedo;
    _output.position = mul( _input.position, wvp );
    _output.world_pos = mul( _input.position, wm );
    float3x3 wrm = to_3x3(wm);
    wrm[0] = normalize(wrm[0]);
    wrm[1] = normalize(wrm[1]);
    wrm[2] = normalize(wrm[2]);
    _output.normal = mul( _input.normal.xyz, wrm );
    _output.tangent = mul( _input.tangent.xyz, wrm );
    _output.bitangent = mul( _input.bitangent.xyz, wrm );
    //assign glsl global outputs from structs
    gl_Position = _output.position;
    gl_Position.y *= v_flip;
    world_pos_vs_output = _output.world_pos;
    normal_vs_output = _output.normal;
    tangent_vs_output = _output.tangent;
    bitangent_vs_output = _output.bitangent;
    texcoord_vs_output = _output.texcoord;
    colour_vs_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//forward_render simple_lighting__1073741824__ ps 1073741824
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 world_pos_vs_output;
in float3 normal_vs_output;
in float3 tangent_vs_output;
in float3 bitangent_vs_output;
in float4 texcoord_vs_output;
in float4 colour_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 world_pos;
    float3 normal;
    float3 tangent;
    float3 bitangent;
    float4 texcoord;
    float4 colour;
};
struct ps_output
{
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
layout (std140) uniform per_draw_call
{
    float4x4 world_matrix;
    float4 user_data;
    float4 user_data2;
    float4x4 world_matrix_inv_transpose;
};
layout (std140) uniform per_pass_lights
{
    float4 light_info;
    light_data lights[100];
};
layout (std140) uniform per_pass_shadow
{
    float4x4 shadow_matrix[100];
};
layout (std140) uniform material_data
{
    float4 m_albedo;
    float m_roughness;
    float m_reflectivity;
    float2 m_padding;
};
texture_2d( diffuse_texture, 0 );
texture_2d( normal_texture, 1 );
texture_2d( specular_texture, 2 );
depth_2d( single_shadowmap_texture, 7 );
float3 cook_torrence(
float4 light_pos_radius,
float3 light_colour,
float3 n,
float3 world_pos,
float3 view_pos,
float3 albedo,
float3 metalness,
float roughness,
float reflectivity
)
{
    float3 l = normalize( light_pos_radius.xyz - world_pos.xyz );
    float n_dot_l = dot( n, l );
    if( n_dot_l > 0.0f )
    {
        float roughness_sq = roughness * roughness;
        float k = reflectivity;
        float3 v_view = normalize( (view_pos.xyz - world_pos.xyz) );
        float3 hv = normalize( v_view + l );
        float n_dot_v = dot( n, v_view );
        float n_dot_h = dot( n, hv );
        float v_dot_h = dot( v_view, hv );
        float n_dot_h_2 = 2.0f * n_dot_h;
        float g1 = (n_dot_h_2 * n_dot_v) / v_dot_h;
        float g2 = (n_dot_h_2 * n_dot_l) / v_dot_h;
        float geom_atten = min(1.0, min(g1, g2));
        float r1 = 1.0f / ( 4.0f * roughness_sq * pow(n_dot_h, 4.0f));
        float r2 = (n_dot_h * n_dot_h - 1.0) / (roughness_sq * n_dot_h * n_dot_h);
        float roughness_atten = r1 * exp(r2);
        float fresnel = pow(1.0 - v_dot_h, 5.0);
        fresnel *= roughness;
        fresnel += reflectivity;
        float specular = (fresnel * geom_atten * roughness_atten) / (n_dot_v * n_dot_l * 3.1419);
        float3 lit_colour = metalness * light_colour * n_dot_l * ( k + specular * ( 1.0 - k ) );
        return saturate(lit_colour);
    }
    return float3( 0.0, 0.0, 0.0 );
}
float3 oren_nayar(
float4 light_pos_radius,
float3 light_colour,
float3 n,
float3 world_pos,
float3 view_pos,
float roughness,
float3 albedo)
{
    float3 v = normalize(view_pos-world_pos);
    float3 l = normalize(light_pos_radius.xyz-world_pos);
    float l_dot_v = dot(l, v);
    float n_dot_l = dot(n, l);
    float n_dot_v = dot(n, v);
    float s = l_dot_v - n_dot_l * n_dot_v;
    float t = lerp(1.0, max(n_dot_l, n_dot_v), step(0.0, s));
    float lum = length( albedo );
    float sigma2 = roughness * roughness;
    float A = 1.0 + sigma2 * (lum / (sigma2 + 0.13) + 0.5 / (sigma2 + 0.33));
    float B = 0.45 * sigma2 / (sigma2 + 0.09);
    return ( albedo * light_colour * max(0.0, n_dot_l) * (A + B * s / t) / 3.14159265 );
}
float sample_shadow_pcf_9(float3 sp)
{
    float2 samples[9];
    float2 inv_sm_size = float2(1.0/2048.0, 1.0/2048.0);
    samples[0] = float2(-1.0, -1.0) * inv_sm_size;
    samples[1] = float2(-1.0, 0.0) * inv_sm_size;
    samples[2] = float2(-1.0, 1.0) * inv_sm_size;
    samples[3] = float2(0.0, -1.0) * inv_sm_size;
    samples[4] = float2(0.0, 0.0) * inv_sm_size;
    samples[5] = float2(0.0, 1.0) * inv_sm_size;
    samples[6] = float2(1.0, -1.0) * inv_sm_size;
    samples[7] = float2(1.0, 0.0) * inv_sm_size;
    samples[8] = float2(1.0, 1.0) * inv_sm_size;
    float shadow = 0.0;
    for(int j = 0; j < 9; ++j)
    {
        shadow += sample_depth_compare(single_shadowmap_texture, sp.xy + samples[j], sp.z);
    }
    shadow /= 9.0;
    return shadow;
}
float3 transform_ts_normal( float3 t, float3 b, float3 n, float3 ts_normal )
{
    float3x3 tbn;
    tbn[0] = float3(t.x, b.x, n.x);
    tbn[1] = float3(t.y, b.y, n.y);
    tbn[2] = float3(t.z, b.z, n.z);
    return normalize( mul_tbn( tbn, ts_normal ) );
}
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.world_pos = world_pos_vs_output;
    _input.normal = normal_vs_output;
    _input.tangent = tangent_vs_output;
    _input.bitangent = bitangent_vs_output;
    _input.texcoord = texcoord_vs_output;
    _input.colour = colour_vs_output;
    ps_output _output;
    float4 albedo = sample_texture( diffuse_texture, _input.texcoord.xy );
    float3 normal_sample = sample_texture( normal_texture, _input.texcoord.xy ).rgb;
    float4 ro_sample = sample_texture( specular_texture, _input.texcoord.xy );
    float4 specular_sample = float4(1.0, 1.0, 1.0, 1.0);
    normal_sample = normal_sample * 2.0 - 1.0;
    float3 n = transform_ts_normal(
    _input.tangent,
    _input.bitangent,
    _input.normal,
    normal_sample );
    albedo *= _input.colour;
    float4 metalness = float4(1.0, 1.0, 1.0, 1.0);
    float3 lit_colour = float3( 0.0, 0.0, 0.0 );
    float reflectivity = saturate(user_data.z);
    float roughness = saturate(user_data.y);
    reflectivity = m_reflectivity;
    roughness = m_roughness;
    roughness = _input.colour.a;
    albedo.a = 1.0;
    float3 lll = float3(0.0, 0.0, 0.0);
    int shadow_map_index = 0;
    _pmfx_loop
    for(int i = 0; i < 1; ++i )
    {
        float3 light_col = float3( 0.0, 0.0, 0.0 );
        light_col += cook_torrence(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        albedo.rgb,
        metalness.rgb,
        roughness,
        reflectivity
        );
        light_col += oren_nayar(
        lights[i].pos_radius,
        lights[i].colour.rgb,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        1.0 - roughness,
        albedo.rgb
        );
        if( lights[i].colour.a == 0.0 )
        {
            lit_colour += light_col;
            continue;
        }
        else
        {
            float shadow = 1.0;
            float d = 1.0;
            float4 offset_pos = float4(_input.world_pos.xyz + n.xyz * 0.01, 1.0);
            float4 sp = mul( offset_pos, shadow_matrix[i] );
            sp.xyz /= sp.w;
            sp.y *= -1.0;
            sp.xy = sp.xy * 0.5 + 0.5;
            sp.z = remap_depth(sp.z);
            shadow = sample_shadow_pcf_9(sp.xyz);
            lit_colour += light_col * shadow;
            ++shadow_map_index;
        }
        lit_colour += oren_nayar(
        lights[i].pos_radius * -1.0,
        lights[i].colour.rgb * 0.25,
        n,
        _input.world_pos.xyz,
        camera_view_pos.xyz,
        1.0 - roughness,
        albedo.rgb
        );
    }
    _output.colour.rgb = lit_colour;
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//forward_render forward_lit__1073741826__ vs 1073741826
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
layout(location = 0) in float4 position_vs_input;
layout(location = 1) in float4 normal_vs_input;
layout(location = 2) in float4 texcoord_vs_input;
layout(location = 3) in float4 tangent_vs_input;
layout(location = 4) in float4 bitangent_vs_input;
layout(location = 5) in float4 world_matrix_0_instance_input;
layout(location = 6) in float4 world_matrix_1_instance_input;
layout(location = 7) in float4 world_matrix_2_instance_input;
layout(location = 8) in float4 world_matrix_3_instance_input;
layout(location = 9) in float4 user_data_instance_input;
layout(location = 10) in float4 user_data2_instance_input;
out float4 world_pos_vs_output;
out float3 normal_vs_output;
out float3 tangent_vs_output;
out float3 bitangent_vs_output;
out float4 texcoord_vs_output;
out float4 colour_vs_output;
uniform float v_flip;
struct vs_input_multi
{
    float4 position;
    float4 normal;
    float4 texcoord;
    float4 tangent;
    float4 bitangent;
};
struct vs_instance_input
{
    float4 world_matrix_0;
    float4 world_matrix_1;
    float4 world_matrix_2;
    float4 world_matrix_3;
    float4 user_data;
    float4 user_data2;
};
struct vs_output
{
    float4 position;
    float4 world_pos;
    float3 normal;
    float3 tangent;
    float3 bitangent;
    float4 texcoord;
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
layout (std140) uniform per_draw_call
{
    float4x4 world_matrix;
    float4 user_data;
    float4 user_data2;
    float4x4 world_matrix_inv_transpose;
};
layout (std140) uniform material_data
{
    float4 m_albedo;
    float2 m_uv_scale;
    float m_roughness;
    float m_reflectivity;
};
void main()
{
    //assign vs_input_multi struct from glsl inputs
    vs_input_multi _input;
    _input.position = position_vs_input;
    _input.normal = normal_vs_input;
    _input.texcoord = texcoord_vs_input;
    _input.tangent = tangent_vs_input;
    _input.bitangent = bitangent_vs_input;
    //assign vs_instance_input struct from glsl inputs
    vs_instance_input instance_input;
    instance_input.world_matrix_0 = world_matrix_0_instance_input;
    instance_input.world_matrix_1 = world_matrix_1_instance_input;
    instance_input.world_matrix_2 = world_matrix_2_instance_input;
    instance_input.world_matrix_3 = world_matrix_3_instance_input;
    instance_input.user_data = user_data_instance_input;
    instance_input.user_data2 = user_data2_instance_input;
    vs_output _output;
    float4x4 wvp = mul( world_matrix, vp_matrix );
    float4x4 wm = world_matrix;
    _output.texcoord = float4(_input.texcoord.x, 1.0 - _input.texcoord.y,
    _input.texcoord.z, 1.0 - _input.texcoord.w );
    float4x4 instance_world_mat;
    unpack_vb_instance_mat(
    instance_world_mat,
    instance_input.world_matrix_0,
    instance_input.world_matrix_1,
    instance_input.world_matrix_2,
    instance_input.world_matrix_3
    );
    wvp = mul( instance_world_mat, vp_matrix );
    wm = instance_world_mat;
    _output.colour = instance_input.user_data2;
    _output.position = mul( _input.position, wvp );
    _output.world_pos = mul( _input.position, wm );
    float3x3 wrm = to_3x3(wm);
    wrm[0] = normalize(wrm[0]);
    wrm[1] = normalize(wrm[1]);
    wrm[2] = normalize(wrm[2]);
    _output.normal = mul( _input.normal.xyz, wrm );
    _output.tangent = mul( _input.tangent.xyz, wrm );
    _output.bitangent = mul( _input.bitangent.xyz, wrm );
    float3 scale = float3(length(world_matrix[0].xyz),
    length(world_matrix[1].xyz),
    length(world_matrix[2].xyz));
    float xs = length(_input.tangent.xyz * scale);
    float ys = length(_input.bitangent.xyz * scale);
    _output.texcoord *= float4(m_uv_scale.x * xs, m_uv_scale.y * ys, m_uv_scale.x, m_uv_scale.y);
    //assign glsl global outputs from structs
    gl_Position = _output.position;
    gl_Position.y *= v_flip;
    world_pos_vs_output = _output.world_pos;
    normal_vs_output = _output.normal;
    tangent_vs_output = _output.tangent;
    bitangent_vs_output = _output.bitangent;
    texcoord_vs_output = _output.texcoord;
    colour_vs_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//imgui default vs 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
layout(location = 0) in float2 position_vs_input;
layout(location = 1) in float2 tex_coord_vs_input;
layout(location = 2) in float4 colour_vs_input;
out float4 colour_vs_output;
out float2 tex_coord_vs_output;
uniform float v_flip;
struct vs_input
{
    float2 position;
    float2 tex_coord;
    float4 colour;
};
struct vs_output
{
    float4 position;
    float4 colour;
    float2 tex_coord;
};
layout (std140) uniform per_pass_vs
{
    float4x4 projection_matrix;
};
void main()
{
    //assign vs_input struct from glsl inputs
    vs_input _input;
    _input.position = position_vs_input;
    _input.tex_coord = tex_coord_vs_input;
    _input.colour = colour_vs_input;
    vs_output _output;
    _output.position = mul( float4( _input.position.x, _input.position.y, 0.0f, 1.0f ), projection_matrix );
    _output.colour = _input.colour;
    _output.tex_coord = _input.tex_coord;
    //assign glsl global outputs from structs
    gl_Position = _output.position;
    gl_Position.y *= v_flip;
    colour_vs_output = _output.colour;
    tex_coord_vs_output = _output.tex_coord;
}
{
    "cmdline": "../third_party/pmbuild/scripts/pmfx-shader/build_pmfx.py -shader_platform gles -shader_version 300 -i assets/shaders ../assets/shaders -o build/web/data/pmfx/glsl -h shader_structs -t temp/shaders -v_flip -source ",
    "files": [
        {
            "name": "/Users/alex.dixon/dev/pmtech/third_party/pmbuild/scripts/pmfx-shader/build_pmfx.py",
            "timestamp": 1608637107.3205462
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/third_party/pmbuild/scripts/pmfx-shader/platform/pmfx.h",
            "timestamp": 1605953217.8167121
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/third_party/pmbuild/scripts/pmfx-shader/platform/glsl.h",
            "timestamp": 1608635330.6987193
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/examples/../assets/shaders/imgui.pmfx",
            "timestamp": 1608572067.2026095
        }
    ],
    "techniques": [
        {
            "vs": "vs_main",
            "ps": "ps_main",
            "name": "default",
            "texture_sampler_bindings": [
                {
                    "name": "tex",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "per_pass_vs",
                    "location": 1
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 8,
                    "element_size": 4,
                    "num_elements": 2,
                    "offset": 0
                },
                {
                    "name": "tex_coord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 8,
                    "element_size": 4,
                    "num_elements": 2,
                    "offset": 8
                },
                {
                    "name": "colour",
                    "semantic_index": 0,
                    "semantic_id": 7,
                    "size": 4,
                    "element_size": 1,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "colour",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "tex_coord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 8,
                    "element_size": 4,
                    "num_elements": 2,
                    "offset": 32
                }
            ],
            "vs_file": "default.vsc",
            "ps_file": "default.psc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        }
    ],
    "failures": {}
}#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//imgui default ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 colour_vs_output;
in float2 tex_coord_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 colour;
    float2 tex_coord;
};
struct ps_output
{
    float4 colour;
};
texture_2d( tex, 0 );
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.colour = colour_vs_output;
    _input.tex_coord = tex_coord_vs_output;
    ps_output _output;
    _output.colour = _input.colour * sample_texture( tex, _input.tex_coord.xy );
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//deferred_render spot_light ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 screen_coord_vs_output;
in float4 light_pos_radius_vs_output;
in float4 light_dir_cutoff_vs_output;
in float4 light_colour_vs_output;
in float4 light_data_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 screen_coord;
    float4 light_pos_radius;
    float4 light_dir_cutoff;
    float4 light_colour;
    float4 light_data;
};
struct ps_output
{
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
texture_2d( gbuffer_albedo, 0 );
texture_2d( gbuffer_normals, 1 );
texture_2d( gbuffer_world_pos, 2 );
float3 cook_torrence(
float4 light_pos_radius,
float3 light_colour,
float3 n,
float3 world_pos,
float3 view_pos,
float3 albedo,
float3 metalness,
float roughness,
float reflectivity
)
{
    float3 l = normalize( light_pos_radius.xyz - world_pos.xyz );
    float n_dot_l = dot( n, l );
    if( n_dot_l > 0.0f )
    {
        float roughness_sq = roughness * roughness;
        float k = reflectivity;
        float3 v_view = normalize( (view_pos.xyz - world_pos.xyz) );
        float3 hv = normalize( v_view + l );
        float n_dot_v = dot( n, v_view );
        float n_dot_h = dot( n, hv );
        float v_dot_h = dot( v_view, hv );
        float n_dot_h_2 = 2.0f * n_dot_h;
        float g1 = (n_dot_h_2 * n_dot_v) / v_dot_h;
        float g2 = (n_dot_h_2 * n_dot_l) / v_dot_h;
        float geom_atten = min(1.0, min(g1, g2));
        float r1 = 1.0f / ( 4.0f * roughness_sq * pow(n_dot_h, 4.0f));
        float r2 = (n_dot_h * n_dot_h - 1.0) / (roughness_sq * n_dot_h * n_dot_h);
        float roughness_atten = r1 * exp(r2);
        float fresnel = pow(1.0 - v_dot_h, 5.0);
        fresnel *= roughness;
        fresnel += reflectivity;
        float specular = (fresnel * geom_atten * roughness_atten) / (n_dot_v * n_dot_l * 3.1419);
        float3 lit_colour = metalness * light_colour * n_dot_l * ( k + specular * ( 1.0 - k ) );
        return saturate(lit_colour);
    }
    return float3( 0.0, 0.0, 0.0 );
}
float3 oren_nayar(
float4 light_pos_radius,
float3 light_colour,
float3 n,
float3 world_pos,
float3 view_pos,
float roughness,
float3 albedo)
{
    float3 v = normalize(view_pos-world_pos);
    float3 l = normalize(light_pos_radius.xyz-world_pos);
    float l_dot_v = dot(l, v);
    float n_dot_l = dot(n, l);
    float n_dot_v = dot(n, v);
    float s = l_dot_v - n_dot_l * n_dot_v;
    float t = lerp(1.0, max(n_dot_l, n_dot_v), step(0.0, s));
    float lum = length( albedo );
    float sigma2 = roughness * roughness;
    float A = 1.0 + sigma2 * (lum / (sigma2 + 0.13) + 0.5 / (sigma2 + 0.33));
    float B = 0.45 * sigma2 / (sigma2 + 0.09);
    return ( albedo * light_colour * max(0.0, n_dot_l) * (A + B * s / t) / 3.14159265 );
}
float spot_light_attenuation(
float4 light_pos_radius,
float4 light_dir_cutoff,
float falloff,
float3 world_pos)
{
    float co = light_dir_cutoff.w;
    float3 vl = normalize(world_pos.xyz - light_pos_radius.xyz);
    float3 sd = normalize(light_dir_cutoff.xyz);
    float dp = (1.0 - dot(vl, sd));
    return smoothstep(co, co - falloff, dp);
}
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.screen_coord = screen_coord_vs_output;
    _input.light_pos_radius = light_pos_radius_vs_output;
    _input.light_dir_cutoff = light_dir_cutoff_vs_output;
    _input.light_colour = light_colour_vs_output;
    _input.light_data = light_data_vs_output;
    ps_output _output;
    float2 sc = _input.screen_coord.xy;
    float x = _input.screen_coord.x / _input.screen_coord.w;
    float y = _input.screen_coord.y / _input.screen_coord.w;
    sc = float2(x * 0.5 + 0.5, -y * 0.5 + 0.5);
    float3 final_light_col = float3(0.0, 0.0, 0.0);
    int samples = 1;
    _pmfx_unroll
    for(int i = 0; i < samples; ++i)
    {
        float4 g_albedo = sample_texture(gbuffer_albedo, sc);
        float4 g_normals = sample_texture(gbuffer_normals, sc);
        float4 g_world_pos = sample_texture(gbuffer_world_pos, sc);
        float3 albedo = g_albedo.rgb;
        float3 n = normalize(g_normals.rgb);
        float3 world_pos = g_world_pos.rgb;
        float metalness = g_world_pos.a;
        float roughness = g_albedo.a;
        float reflectivity = g_normals.a;
        float3 light_col = cook_torrence(
        _input.light_pos_radius,
        _input.light_colour.rgb,
        n,
        world_pos,
        camera_view_pos.xyz,
        albedo,
        float3(0.5, 0.5, 0.5),
        roughness,
        reflectivity);
        light_col += oren_nayar(
        _input.light_pos_radius,
        _input.light_colour.rgb,
        n,
        world_pos,
        camera_view_pos.xyz,
        roughness,
        albedo.rgb
        );
        light_col *= spot_light_attenuation(_input.light_pos_radius,
        _input.light_dir_cutoff,
        _input.light_data.x,
        world_pos);
        final_light_col += light_col;
    }
    _output.colour.rgb = final_light_col / float(samples);
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//deferred_render point_light ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 screen_coord_vs_output;
in float4 light_pos_radius_vs_output;
in float4 light_dir_cutoff_vs_output;
in float4 light_colour_vs_output;
in float4 light_data_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 screen_coord;
    float4 light_pos_radius;
    float4 light_dir_cutoff;
    float4 light_colour;
    float4 light_data;
};
struct ps_output
{
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
texture_2d( gbuffer_albedo, 0 );
texture_2d( gbuffer_normals, 1 );
texture_2d( gbuffer_world_pos, 2 );
float3 cook_torrence(
float4 light_pos_radius,
float3 light_colour,
float3 n,
float3 world_pos,
float3 view_pos,
float3 albedo,
float3 metalness,
float roughness,
float reflectivity
)
{
    float3 l = normalize( light_pos_radius.xyz - world_pos.xyz );
    float n_dot_l = dot( n, l );
    if( n_dot_l > 0.0f )
    {
        float roughness_sq = roughness * roughness;
        float k = reflectivity;
        float3 v_view = normalize( (view_pos.xyz - world_pos.xyz) );
        float3 hv = normalize( v_view + l );
        float n_dot_v = dot( n, v_view );
        float n_dot_h = dot( n, hv );
        float v_dot_h = dot( v_view, hv );
        float n_dot_h_2 = 2.0f * n_dot_h;
        float g1 = (n_dot_h_2 * n_dot_v) / v_dot_h;
        float g2 = (n_dot_h_2 * n_dot_l) / v_dot_h;
        float geom_atten = min(1.0, min(g1, g2));
        float r1 = 1.0f / ( 4.0f * roughness_sq * pow(n_dot_h, 4.0f));
        float r2 = (n_dot_h * n_dot_h - 1.0) / (roughness_sq * n_dot_h * n_dot_h);
        float roughness_atten = r1 * exp(r2);
        float fresnel = pow(1.0 - v_dot_h, 5.0);
        fresnel *= roughness;
        fresnel += reflectivity;
        float specular = (fresnel * geom_atten * roughness_atten) / (n_dot_v * n_dot_l * 3.1419);
        float3 lit_colour = metalness * light_colour * n_dot_l * ( k + specular * ( 1.0 - k ) );
        return saturate(lit_colour);
    }
    return float3( 0.0, 0.0, 0.0 );
}
float3 oren_nayar(
float4 light_pos_radius,
float3 light_colour,
float3 n,
float3 world_pos,
float3 view_pos,
float roughness,
float3 albedo)
{
    float3 v = normalize(view_pos-world_pos);
    float3 l = normalize(light_pos_radius.xyz-world_pos);
    float l_dot_v = dot(l, v);
    float n_dot_l = dot(n, l);
    float n_dot_v = dot(n, v);
    float s = l_dot_v - n_dot_l * n_dot_v;
    float t = lerp(1.0, max(n_dot_l, n_dot_v), step(0.0, s));
    float lum = length( albedo );
    float sigma2 = roughness * roughness;
    float A = 1.0 + sigma2 * (lum / (sigma2 + 0.13) + 0.5 / (sigma2 + 0.33));
    float B = 0.45 * sigma2 / (sigma2 + 0.09);
    return ( albedo * light_colour * max(0.0, n_dot_l) * (A + B * s / t) / 3.14159265 );
}
float point_light_attenuation_cutoff(
float4 light_pos_radius,
float3 world_pos)
{
    float r = light_pos_radius.w;
    float d = length(world_pos.xyz - light_pos_radius.xyz);
    d = max(d - r, 0.0);
    float denom = d/r + 1.0;
    float attenuation = 1.0 / (denom*denom);
    float cutoff = 0.2;
    attenuation = (attenuation - cutoff) / (1.0 - cutoff);
    attenuation = max(attenuation, 0.0);
    return attenuation;
}
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.screen_coord = screen_coord_vs_output;
    _input.light_pos_radius = light_pos_radius_vs_output;
    _input.light_dir_cutoff = light_dir_cutoff_vs_output;
    _input.light_colour = light_colour_vs_output;
    _input.light_data = light_data_vs_output;
    ps_output _output;
    float2 sc = _input.screen_coord.xy;
    float x = _input.screen_coord.x / _input.screen_coord.w;
    float y = _input.screen_coord.y / _input.screen_coord.w;
    sc = float2(x * 0.5 + 0.5, -y * 0.5 + 0.5);
    float3 final_light_col = float3(0.0, 0.0, 0.0);
    int samples = 1;
    _pmfx_unroll
    for(int i = 0; i < samples; ++i)
    {
        float4 g_albedo = sample_texture(gbuffer_albedo, sc);
        float4 g_normals = sample_texture(gbuffer_normals, sc);
        float4 g_world_pos = sample_texture(gbuffer_world_pos, sc);
        float3 albedo = g_albedo.rgb;
        float3 n = normalize(g_normals.rgb);
        float3 world_pos = g_world_pos.rgb;
        float metalness = g_world_pos.a;
        float roughness = g_albedo.a;
        float reflectivity = g_normals.a;
        float3 light_col = cook_torrence(
        _input.light_pos_radius,
        _input.light_colour.rgb,
        n,
        world_pos,
        camera_view_pos.xyz,
        albedo,
        float3(0.5, 0.5, 0.5),
        roughness,
        reflectivity);
        light_col += oren_nayar(
        _input.light_pos_radius,
        _input.light_colour.rgb,
        n,
        world_pos,
        camera_view_pos.xyz,
        roughness,
        albedo.rgb
        );
        light_col *= point_light_attenuation_cutoff(_input.light_pos_radius, world_pos);
        final_light_col += light_col;
    }
    _output.colour.rgb = final_light_col / float(samples);
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//deferred_render directional_light ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 screen_coord_vs_output;
in float4 light_pos_radius_vs_output;
in float4 light_dir_cutoff_vs_output;
in float4 light_colour_vs_output;
in float4 light_data_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 screen_coord;
    float4 light_pos_radius;
    float4 light_dir_cutoff;
    float4 light_colour;
    float4 light_data;
};
struct ps_output
{
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
texture_2d( gbuffer_albedo, 0 );
texture_2d( gbuffer_normals, 1 );
texture_2d( gbuffer_world_pos, 2 );
float3 cook_torrence(
float4 light_pos_radius,
float3 light_colour,
float3 n,
float3 world_pos,
float3 view_pos,
float3 albedo,
float3 metalness,
float roughness,
float reflectivity
)
{
    float3 l = normalize( light_pos_radius.xyz - world_pos.xyz );
    float n_dot_l = dot( n, l );
    if( n_dot_l > 0.0f )
    {
        float roughness_sq = roughness * roughness;
        float k = reflectivity;
        float3 v_view = normalize( (view_pos.xyz - world_pos.xyz) );
        float3 hv = normalize( v_view + l );
        float n_dot_v = dot( n, v_view );
        float n_dot_h = dot( n, hv );
        float v_dot_h = dot( v_view, hv );
        float n_dot_h_2 = 2.0f * n_dot_h;
        float g1 = (n_dot_h_2 * n_dot_v) / v_dot_h;
        float g2 = (n_dot_h_2 * n_dot_l) / v_dot_h;
        float geom_atten = min(1.0, min(g1, g2));
        float r1 = 1.0f / ( 4.0f * roughness_sq * pow(n_dot_h, 4.0f));
        float r2 = (n_dot_h * n_dot_h - 1.0) / (roughness_sq * n_dot_h * n_dot_h);
        float roughness_atten = r1 * exp(r2);
        float fresnel = pow(1.0 - v_dot_h, 5.0);
        fresnel *= roughness;
        fresnel += reflectivity;
        float specular = (fresnel * geom_atten * roughness_atten) / (n_dot_v * n_dot_l * 3.1419);
        float3 lit_colour = metalness * light_colour * n_dot_l * ( k + specular * ( 1.0 - k ) );
        return saturate(lit_colour);
    }
    return float3( 0.0, 0.0, 0.0 );
}
float3 oren_nayar(
float4 light_pos_radius,
float3 light_colour,
float3 n,
float3 world_pos,
float3 view_pos,
float roughness,
float3 albedo)
{
    float3 v = normalize(view_pos-world_pos);
    float3 l = normalize(light_pos_radius.xyz-world_pos);
    float l_dot_v = dot(l, v);
    float n_dot_l = dot(n, l);
    float n_dot_v = dot(n, v);
    float s = l_dot_v - n_dot_l * n_dot_v;
    float t = lerp(1.0, max(n_dot_l, n_dot_v), step(0.0, s));
    float lum = length( albedo );
    float sigma2 = roughness * roughness;
    float A = 1.0 + sigma2 * (lum / (sigma2 + 0.13) + 0.5 / (sigma2 + 0.33));
    float B = 0.45 * sigma2 / (sigma2 + 0.09);
    return ( albedo * light_colour * max(0.0, n_dot_l) * (A + B * s / t) / 3.14159265 );
}
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.screen_coord = screen_coord_vs_output;
    _input.light_pos_radius = light_pos_radius_vs_output;
    _input.light_dir_cutoff = light_dir_cutoff_vs_output;
    _input.light_colour = light_colour_vs_output;
    _input.light_data = light_data_vs_output;
    ps_output _output;
    float2 sc = _input.screen_coord.xy;
    float3 final_light_col = float3(0.0, 0.0, 0.0);
    int samples = 1;
    _pmfx_unroll
    for(int i = 0; i < samples; ++i)
    {
        float4 g_albedo = sample_texture(gbuffer_albedo, sc);
        float4 g_normals = sample_texture(gbuffer_normals, sc);
        float4 g_world_pos = sample_texture(gbuffer_world_pos, sc);
        float3 albedo = g_albedo.rgb;
        float3 n = normalize(g_normals.rgb);
        float3 world_pos = g_world_pos.rgb;
        float metalness = g_world_pos.a;
        float roughness = g_albedo.a;
        float reflectivity = g_normals.a;
        float3 light_col = cook_torrence(
        _input.light_pos_radius,
        _input.light_colour.rgb,
        n,
        world_pos,
        camera_view_pos.xyz,
        albedo,
        float3(0.5, 0.5, 0.5),
        roughness,
        reflectivity);
        light_col += oren_nayar(
        _input.light_pos_radius,
        _input.light_colour.rgb,
        n,
        world_pos,
        camera_view_pos.xyz,
        roughness,
        albedo.rgb
        );
        final_light_col += light_col;
    }
    _output.colour.rgb = final_light_col / float(samples);
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//deferred_render point_light__2__ ps 2
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 screen_coord_vs_output;
in float4 light_pos_radius_vs_output;
in float4 light_dir_cutoff_vs_output;
in float4 light_colour_vs_output;
in float4 light_data_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 screen_coord;
    float4 light_pos_radius;
    float4 light_dir_cutoff;
    float4 light_colour;
    float4 light_data;
};
struct ps_output
{
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
texture_2dms( float4, 4, gbuffer_albedo_msaa, 4 );
texture_2dms( float4, 4, gbuffer_normals_msaa, 5 );
texture_2dms( float4, 4, gbuffer_world_pos_msaa, 6 );
float3 cook_torrence(
float4 light_pos_radius,
float3 light_colour,
float3 n,
float3 world_pos,
float3 view_pos,
float3 albedo,
float3 metalness,
float roughness,
float reflectivity
)
{
    float3 l = normalize( light_pos_radius.xyz - world_pos.xyz );
    float n_dot_l = dot( n, l );
    if( n_dot_l > 0.0f )
    {
        float roughness_sq = roughness * roughness;
        float k = reflectivity;
        float3 v_view = normalize( (view_pos.xyz - world_pos.xyz) );
        float3 hv = normalize( v_view + l );
        float n_dot_v = dot( n, v_view );
        float n_dot_h = dot( n, hv );
        float v_dot_h = dot( v_view, hv );
        float n_dot_h_2 = 2.0f * n_dot_h;
        float g1 = (n_dot_h_2 * n_dot_v) / v_dot_h;
        float g2 = (n_dot_h_2 * n_dot_l) / v_dot_h;
        float geom_atten = min(1.0, min(g1, g2));
        float r1 = 1.0f / ( 4.0f * roughness_sq * pow(n_dot_h, 4.0f));
        float r2 = (n_dot_h * n_dot_h - 1.0) / (roughness_sq * n_dot_h * n_dot_h);
        float roughness_atten = r1 * exp(r2);
        float fresnel = pow(1.0 - v_dot_h, 5.0);
        fresnel *= roughness;
        fresnel += reflectivity;
        float specular = (fresnel * geom_atten * roughness_atten) / (n_dot_v * n_dot_l * 3.1419);
        float3 lit_colour = metalness * light_colour * n_dot_l * ( k + specular * ( 1.0 - k ) );
        return saturate(lit_colour);
    }
    return float3( 0.0, 0.0, 0.0 );
}
float3 oren_nayar(
float4 light_pos_radius,
float3 light_colour,
float3 n,
float3 world_pos,
float3 view_pos,
float roughness,
float3 albedo)
{
    float3 v = normalize(view_pos-world_pos);
    float3 l = normalize(light_pos_radius.xyz-world_pos);
    float l_dot_v = dot(l, v);
    float n_dot_l = dot(n, l);
    float n_dot_v = dot(n, v);
    float s = l_dot_v - n_dot_l * n_dot_v;
    float t = lerp(1.0, max(n_dot_l, n_dot_v), step(0.0, s));
    float lum = length( albedo );
    float sigma2 = roughness * roughness;
    float A = 1.0 + sigma2 * (lum / (sigma2 + 0.13) + 0.5 / (sigma2 + 0.33));
    float B = 0.45 * sigma2 / (sigma2 + 0.09);
    return ( albedo * light_colour * max(0.0, n_dot_l) * (A + B * s / t) / 3.14159265 );
}
float point_light_attenuation_cutoff(
float4 light_pos_radius,
float3 world_pos)
{
    float r = light_pos_radius.w;
    float d = length(world_pos.xyz - light_pos_radius.xyz);
    d = max(d - r, 0.0);
    float denom = d/r + 1.0;
    float attenuation = 1.0 / (denom*denom);
    float cutoff = 0.2;
    attenuation = (attenuation - cutoff) / (1.0 - cutoff);
    attenuation = max(attenuation, 0.0);
    return attenuation;
}
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.screen_coord = screen_coord_vs_output;
    _input.light_pos_radius = light_pos_radius_vs_output;
    _input.light_dir_cutoff = light_dir_cutoff_vs_output;
    _input.light_colour = light_colour_vs_output;
    _input.light_data = light_data_vs_output;
    ps_output _output;
    float2 sc = _input.screen_coord.xy;
    float x = _input.screen_coord.x / _input.screen_coord.w;
    float y = _input.screen_coord.y / _input.screen_coord.w;
    sc = float2(x * 0.5 + 0.5, -y * 0.5 + 0.5);
    float3 final_light_col = float3(0.0, 0.0, 0.0);
    int samples = 4;
    _pmfx_unroll
    for(int i = 0; i < samples; ++i)
    {
        float4 g_albedo = sample_texture_2dms(gbuffer_albedo_msaa, sc.x * 1280.0, sc.y * 720.0, i);
        float4 g_normals = sample_texture_2dms(gbuffer_normals_msaa, sc.x * 1280.0, sc.y * 720.0, i);
        float4 g_world_pos = sample_texture_2dms(gbuffer_world_pos_msaa, sc.x * 1280.0, sc.y * 720.0, i);
        float3 albedo = g_albedo.rgb;
        float3 n = normalize(g_normals.rgb);
        float3 world_pos = g_world_pos.rgb;
        float metalness = g_world_pos.a;
        float roughness = g_albedo.a;
        float reflectivity = g_normals.a;
        float3 light_col = cook_torrence(
        _input.light_pos_radius,
        _input.light_colour.rgb,
        n,
        world_pos,
        camera_view_pos.xyz,
        albedo,
        float3(0.5, 0.5, 0.5),
        roughness,
        reflectivity);
        light_col += oren_nayar(
        _input.light_pos_radius,
        _input.light_colour.rgb,
        n,
        world_pos,
        camera_view_pos.xyz,
        roughness,
        albedo.rgb
        );
        light_col *= point_light_attenuation_cutoff(_input.light_pos_radius, world_pos);
        final_light_col += light_col;
    }
    _output.colour.rgb = final_light_col / float(samples);
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//deferred_render spot_light vs 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
layout(location = 0) in float4 position_vs_input;
layout(location = 1) in float4 normal_vs_input;
layout(location = 2) in float4 texcoord_vs_input;
layout(location = 3) in float4 tangent_vs_input;
layout(location = 4) in float4 bitangent_vs_input;
out float4 screen_coord_vs_output;
out float4 light_pos_radius_vs_output;
out float4 light_dir_cutoff_vs_output;
out float4 light_colour_vs_output;
out float4 light_data_vs_output;
uniform float v_flip;
struct vs_input
{
    float4 position;
    float4 normal;
    float4 texcoord;
    float4 tangent;
    float4 bitangent;
};
struct vs_output
{
    float4 position;
    float4 screen_coord;
    float4 light_pos_radius;
    float4 light_dir_cutoff;
    float4 light_colour;
    float4 light_data;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
layout (std140) uniform per_draw_call
{
    float4x4 world_matrix;
    float4 user_data;
    float4 user_data2;
    float4x4 world_matrix_inv_transpose;
};
void unpack_light_data(inout vs_output _output)
{
    float4x4 ld = to_data_matrix(world_matrix_inv_transpose);
    _output.light_pos_radius = ld[0];
    _output.light_dir_cutoff = ld[1];
    _output.light_colour = ld[2];
    _output.light_data = ld[3];
}
void main()
{
    //assign vs_input struct from glsl inputs
    vs_input _input;
    _input.position = position_vs_input;
    _input.normal = normal_vs_input;
    _input.texcoord = texcoord_vs_input;
    _input.tangent = tangent_vs_input;
    _input.bitangent = bitangent_vs_input;
    vs_output _output;
    float4x4 wvp = mul(world_matrix, vp_matrix);
    _output.position = mul(_input.position, wvp);
    _output.screen_coord = _output.position;
    unpack_light_data(_output);
    //assign glsl global outputs from structs
    gl_Position = _output.position;
    gl_Position.y *= v_flip;
    screen_coord_vs_output = _output.screen_coord;
    light_pos_radius_vs_output = _output.light_pos_radius;
    light_dir_cutoff_vs_output = _output.light_dir_cutoff;
    light_colour_vs_output = _output.light_colour;
    light_data_vs_output = _output.light_data;
}
{
    "cmdline": "../third_party/pmbuild/scripts/pmfx-shader/build_pmfx.py -shader_platform gles -shader_version 300 -i assets/shaders ../assets/shaders -o build/web/data/pmfx/glsl -h shader_structs -t temp/shaders -v_flip -source ",
    "files": [
        {
            "name": "/Users/alex.dixon/dev/pmtech/third_party/pmbuild/scripts/pmfx-shader/build_pmfx.py",
            "timestamp": 1608637107.3205462
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/third_party/pmbuild/scripts/pmfx-shader/platform/pmfx.h",
            "timestamp": 1605953217.8167121
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/third_party/pmbuild/scripts/pmfx-shader/platform/glsl.h",
            "timestamp": 1608635330.6987193
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/examples/../assets/shaders/deferred_render.pmfx",
            "timestamp": 1608572067.202406
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/examples/../assets/shaders/libs/lighting.pmfx",
            "timestamp": 1608572067.1994717
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/examples/../assets/shaders/libs/globals.pmfx",
            "timestamp": 1608572067.200933
        }
    ],
    "techniques": [
        {
            "vs": "vs_directional_light",
            "ps": "ps_light",
            "name": "directional_light",
            "texture_sampler_bindings": [
                {
                    "name": "gbuffer_albedo",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "gbuffer_normals",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "gbuffer_world_pos",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "gbuffer_depth",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 3
                },
                {
                    "name": "gbuffer_albedo_msaa",
                    "data_type": "float4",
                    "fragments": "4",
                    "type": "texture_2dms",
                    "unit": 4
                },
                {
                    "name": "gbuffer_normals_msaa",
                    "data_type": "float4",
                    "fragments": "4",
                    "type": "texture_2dms",
                    "unit": 5
                },
                {
                    "name": "gbuffer_world_pos_msaa",
                    "data_type": "float4",
                    "fragments": "4",
                    "type": "texture_2dms",
                    "unit": 6
                },
                {
                    "name": "gbuffer_depth_msaa",
                    "data_type": "float4",
                    "fragments": "4",
                    "type": "texture_2dms",
                    "unit": 7
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "texcoord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "screen_coord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "light_pos_radius",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "light_dir_cutoff",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "light_colour",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "light_data",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                }
            ],
            "vs_file": "directional_light.vsc",
            "ps_file": "directional_light.psc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        },
        {
            "vs": "vs_point_light",
            "ps": "ps_light",
            "defines": [
                "POINT_LIGHT"
            ],
            "permutations": {
                "MSAA": {
                    "val": 2,
                    "type": "checkbox"
                }
            },
            "name": "point_light",
            "texture_sampler_bindings": [
                {
                    "name": "gbuffer_albedo",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "gbuffer_normals",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "gbuffer_world_pos",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "gbuffer_depth",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 3
                },
                {
                    "name": "gbuffer_albedo_msaa",
                    "data_type": "float4",
                    "fragments": "4",
                    "type": "texture_2dms",
                    "unit": 4
                },
                {
                    "name": "gbuffer_normals_msaa",
                    "data_type": "float4",
                    "fragments": "4",
                    "type": "texture_2dms",
                    "unit": 5
                },
                {
                    "name": "gbuffer_world_pos_msaa",
                    "data_type": "float4",
                    "fragments": "4",
                    "type": "texture_2dms",
                    "unit": 6
                },
                {
                    "name": "gbuffer_depth_msaa",
                    "data_type": "float4",
                    "fragments": "4",
                    "type": "texture_2dms",
                    "unit": 7
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "screen_coord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "light_pos_radius",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "light_dir_cutoff",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "light_colour",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "light_data",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                }
            ],
            "vs_file": "point_light.vsc",
            "ps_file": "point_light.psc",
            "permutation_id": 0,
            "permutation_option_mask": 2
        },
        {
            "vs": "vs_point_light",
            "ps": "ps_light",
            "defines": [
                "POINT_LIGHT"
            ],
            "permutations": {
                "MSAA": {
                    "val": 2,
                    "type": "checkbox"
                }
            },
            "name": "point_light",
            "texture_sampler_bindings": [
                {
                    "name": "gbuffer_albedo",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "gbuffer_normals",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "gbuffer_world_pos",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "gbuffer_depth",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 3
                },
                {
                    "name": "gbuffer_albedo_msaa",
                    "data_type": "float4",
                    "fragments": "4",
                    "type": "texture_2dms",
                    "unit": 4
                },
                {
                    "name": "gbuffer_normals_msaa",
                    "data_type": "float4",
                    "fragments": "4",
                    "type": "texture_2dms",
                    "unit": 5
                },
                {
                    "name": "gbuffer_world_pos_msaa",
                    "data_type": "float4",
                    "fragments": "4",
                    "type": "texture_2dms",
                    "unit": 6
                },
                {
                    "name": "gbuffer_depth_msaa",
                    "data_type": "float4",
                    "fragments": "4",
                    "type": "texture_2dms",
                    "unit": 7
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "screen_coord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "light_pos_radius",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "light_dir_cutoff",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "light_colour",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "light_data",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                }
            ],
            "vs_file": "point_light.vsc",
            "ps_file": "point_light__2__.psc",
            "permutation_id": 2,
            "permutation_option_mask": 2
        },
        {
            "vs": "vs_spot_light",
            "ps": "ps_light",
            "defines": [
                "SPOT_LIGHT"
            ],
            "name": "spot_light",
            "texture_sampler_bindings": [
                {
                    "name": "gbuffer_albedo",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "gbuffer_normals",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "gbuffer_world_pos",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "gbuffer_depth",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 3
                },
                {
                    "name": "gbuffer_albedo_msaa",
                    "data_type": "float4",
                    "fragments": "4",
                    "type": "texture_2dms",
                    "unit": 4
                },
                {
                    "name": "gbuffer_normals_msaa",
                    "data_type": "float4",
                    "fragments": "4",
                    "type": "texture_2dms",
                    "unit": 5
                },
                {
                    "name": "gbuffer_world_pos_msaa",
                    "data_type": "float4",
                    "fragments": "4",
                    "type": "texture_2dms",
                    "unit": 6
                },
                {
                    "name": "gbuffer_depth_msaa",
                    "data_type": "float4",
                    "fragments": "4",
                    "type": "texture_2dms",
                    "unit": 7
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "screen_coord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "light_pos_radius",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "light_dir_cutoff",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "light_colour",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "light_data",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                }
            ],
            "vs_file": "spot_light.vsc",
            "ps_file": "spot_light.psc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        }
    ],
    "failures": {}
}#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//deferred_render point_light vs 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
layout(location = 0) in float4 position_vs_input;
layout(location = 1) in float4 normal_vs_input;
layout(location = 2) in float4 texcoord_vs_input;
layout(location = 3) in float4 tangent_vs_input;
layout(location = 4) in float4 bitangent_vs_input;
out float4 screen_coord_vs_output;
out float4 light_pos_radius_vs_output;
out float4 light_dir_cutoff_vs_output;
out float4 light_colour_vs_output;
out float4 light_data_vs_output;
uniform float v_flip;
struct vs_input
{
    float4 position;
    float4 normal;
    float4 texcoord;
    float4 tangent;
    float4 bitangent;
};
struct vs_output
{
    float4 position;
    float4 screen_coord;
    float4 light_pos_radius;
    float4 light_dir_cutoff;
    float4 light_colour;
    float4 light_data;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
layout (std140) uniform per_draw_call
{
    float4x4 world_matrix;
    float4 user_data;
    float4 user_data2;
    float4x4 world_matrix_inv_transpose;
};
void unpack_light_data(inout vs_output _output)
{
    float4x4 ld = to_data_matrix(world_matrix_inv_transpose);
    _output.light_pos_radius = ld[0];
    _output.light_dir_cutoff = ld[1];
    _output.light_colour = ld[2];
    _output.light_data = ld[3];
}
void main()
{
    //assign vs_input struct from glsl inputs
    vs_input _input;
    _input.position = position_vs_input;
    _input.normal = normal_vs_input;
    _input.texcoord = texcoord_vs_input;
    _input.tangent = tangent_vs_input;
    _input.bitangent = bitangent_vs_input;
    vs_output _output;
    float4x4 wvp = mul(world_matrix, vp_matrix);
    _output.position = mul(_input.position, wvp);
    _output.screen_coord = _output.position;
    unpack_light_data(_output);
    //assign glsl global outputs from structs
    gl_Position = _output.position;
    gl_Position.y *= v_flip;
    screen_coord_vs_output = _output.screen_coord;
    light_pos_radius_vs_output = _output.light_pos_radius;
    light_dir_cutoff_vs_output = _output.light_dir_cutoff;
    light_colour_vs_output = _output.light_colour;
    light_data_vs_output = _output.light_data;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//deferred_render directional_light vs 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
layout(location = 0) in float4 position_vs_input;
layout(location = 1) in float4 texcoord_vs_input;
out float4 screen_coord_vs_output;
out float4 light_pos_radius_vs_output;
out float4 light_dir_cutoff_vs_output;
out float4 light_colour_vs_output;
out float4 light_data_vs_output;
uniform float v_flip;
struct vs_input_2d
{
    float4 position;
    float4 texcoord;
};
struct vs_output
{
    float4 position;
    float4 screen_coord;
    float4 light_pos_radius;
    float4 light_dir_cutoff;
    float4 light_colour;
    float4 light_data;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform per_draw_call
{
    float4x4 world_matrix;
    float4 user_data;
    float4 user_data2;
    float4x4 world_matrix_inv_transpose;
};
void unpack_light_data(inout vs_output _output)
{
    float4x4 ld = to_data_matrix(world_matrix_inv_transpose);
    _output.light_pos_radius = ld[0];
    _output.light_dir_cutoff = ld[1];
    _output.light_colour = ld[2];
    _output.light_data = ld[3];
}
void main()
{
    //assign vs_input_2d struct from glsl inputs
    vs_input_2d _input;
    _input.position = position_vs_input;
    _input.texcoord = texcoord_vs_input;
    vs_output _output;
    float x = _input.position.x;
    float y = _input.position.y;
    _output.position = _input.position;
    _output.screen_coord = float4(x * 0.5 + 0.5, -y * 0.5 + 0.5, 0.0, 0.0);
    unpack_light_data(_output);
    //assign glsl global outputs from structs
    gl_Position = _output.position;
    gl_Position.y *= v_flip;
    screen_coord_vs_output = _output.screen_coord;
    light_pos_radius_vs_output = _output.light_pos_radius;
    light_dir_cutoff_vs_output = _output.light_dir_cutoff;
    light_colour_vs_output = _output.light_colour;
    light_data_vs_output = _output.light_data;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//pmfx_utility diffuse ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 world_pos_vs_output;
in float3 normal_vs_output;
in float3 tangent_vs_output;
in float3 bitangent_vs_output;
in float4 texcoord_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 world_pos;
    float3 normal;
    float3 tangent;
    float3 bitangent;
    float4 texcoord;
};
struct ps_output
{
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
texture_2d( diffuse_texture, 0 );
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.world_pos = world_pos_vs_output;
    _input.normal = normal_vs_output;
    _input.tangent = tangent_vs_output;
    _input.bitangent = bitangent_vs_output;
    _input.texcoord = texcoord_vs_output;
    ps_output _output;
    _output.colour = sample_texture( diffuse_texture, _input.texcoord.xy );
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//pmfx_utility fixed_light vs 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
layout(location = 0) in float4 position_vs_input;
layout(location = 1) in float4 normal_vs_input;
layout(location = 2) in float4 texcoord_vs_input;
layout(location = 3) in float4 tangent_vs_input;
layout(location = 4) in float4 bitangent_vs_input;
out float4 world_pos_vs_output;
out float3 normal_vs_output;
out float3 tangent_vs_output;
out float3 bitangent_vs_output;
out float4 texcoord_vs_output;
uniform float v_flip;
struct vs_input
{
    float4 position;
    float4 normal;
    float4 texcoord;
    float4 tangent;
    float4 bitangent;
};
struct vs_output
{
    float4 position;
    float4 world_pos;
    float3 normal;
    float3 tangent;
    float3 bitangent;
    float4 texcoord;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
layout (std140) uniform per_draw_call
{
    float4x4 world_matrix;
    float4 user_data;
    float4 user_data2;
    float4x4 world_matrix_inv_transpose;
};
void main()
{
    //assign vs_input struct from glsl inputs
    vs_input _input;
    _input.position = position_vs_input;
    _input.normal = normal_vs_input;
    _input.texcoord = texcoord_vs_input;
    _input.tangent = tangent_vs_input;
    _input.bitangent = bitangent_vs_input;
    vs_output _output;
    float4x4 wvp = mul( world_matrix, vp_matrix );
    _output.position = mul( _input.position, wvp );
    _output.world_pos = mul( _input.position, world_matrix );
    float3x3 rotation_matrix = to_3x3(world_matrix);
    _output.normal = mul( _input.normal.xyz, rotation_matrix );
    _output.tangent = mul( _input.tangent.xyz, rotation_matrix );
    _output.bitangent = mul( _input.bitangent.xyz, rotation_matrix );
    _output.texcoord = float4( _input.texcoord.x, 1.0f - _input.texcoord.y, _input.texcoord.z, 1.0f - _input.texcoord.w );
    //assign glsl global outputs from structs
    gl_Position = _output.position;
    gl_Position.y *= v_flip;
    world_pos_vs_output = _output.world_pos;
    normal_vs_output = _output.normal;
    tangent_vs_output = _output.tangent;
    bitangent_vs_output = _output.bitangent;
    texcoord_vs_output = _output.texcoord;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//pmfx_utility vertex_normals ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 world_pos_vs_output;
in float3 normal_vs_output;
in float3 tangent_vs_output;
in float3 bitangent_vs_output;
in float4 texcoord_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 world_pos;
    float3 normal;
    float3 tangent;
    float3 bitangent;
    float4 texcoord;
};
struct ps_output
{
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.world_pos = world_pos_vs_output;
    _input.normal = normal_vs_output;
    _input.tangent = tangent_vs_output;
    _input.bitangent = bitangent_vs_output;
    _input.texcoord = texcoord_vs_output;
    ps_output _output;
    _output.colour.rgb = _input.normal * 0.5 + 0.5;
    _output.colour.a = 1.0;
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//pmfx_utility area_light_texture ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 world_pos_vs_output;
in float3 normal_vs_output;
in float3 tangent_vs_output;
in float3 bitangent_vs_output;
in float4 texcoord_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 world_pos;
    float3 normal;
    float3 tangent;
    float3 bitangent;
    float4 texcoord;
};
struct ps_output
{
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform per_draw_call
{
    float4x4 world_matrix;
    float4 user_data;
    float4 user_data2;
    float4x4 world_matrix_inv_transpose;
};
texture_2d_array( area_light_textures, 11 );
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.world_pos = world_pos_vs_output;
    _input.normal = normal_vs_output;
    _input.tangent = tangent_vs_output;
    _input.bitangent = bitangent_vs_output;
    _input.texcoord = texcoord_vs_output;
    ps_output _output;
    _output.colour = sample_texture_array_level( area_light_textures, _input.texcoord.xy, user_data.z, 0.0);
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//pmfx_utility shadow_sdf ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 world_pos_vs_output;
in float3 normal_vs_output;
in float3 tangent_vs_output;
in float3 bitangent_vs_output;
in float4 texcoord_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 world_pos;
    float3 normal;
    float3 tangent;
    float3 bitangent;
    float4 texcoord;
};
struct ps_output
{
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform per_draw_call
{
    float4x4 world_matrix;
    float4 user_data;
    float4 user_data2;
    float4x4 world_matrix_inv_transpose;
};
layout (std140) uniform per_pass_lights
{
    float4 light_info;
    light_data lights[100];
};
layout (std140) uniform per_pass_shadow_distance_fields
{
    distance_field_shadow sdf_shadow;
};
texture_3d( sdf_volume, 14 );
float3 lambert(
float4 light_pos_radius,
float3 light_colour,
float3 n,
float3 world_pos,
float3 albedo
)
{
    float3 l = normalize( light_pos_radius.xyz - world_pos.xyz );
    float n_dot_l = max( dot( n, l ), 0.0 );
    float3 lit_colour = light_colour * n_dot_l * albedo.rgb;
    return lit_colour;
}
float point_light_attenuation(
float4 light_pos_radius,
float3 world_pos)
{
    float d = length( world_pos.xyz - light_pos_radius.xyz );
    float r = light_pos_radius.w;
    float denom = d/r + 1.0;
    float attenuation = 1.0 / (denom*denom);
    return attenuation;
}
bool ray_vs_aabb(float3 emin, float3 emax, float3 r1, float3 rv, out float3 intersection)
{
    float3 dirfrac = float3(1.0, 1.0, 1.0) / rv;
    float t1 = (emin.x - r1.x)*dirfrac.x;
    float t2 = (emax.x - r1.x)*dirfrac.x;
    float t3 = (emin.y - r1.y)*dirfrac.y;
    float t4 = (emax.y - r1.y)*dirfrac.y;
    float t5 = (emin.z - r1.z)*dirfrac.z;
    float t6 = (emax.z - r1.z)*dirfrac.z;
    float tmin = max(max(min(t1, t2), min(t3, t4)), min(t5, t6));
    float tmax = min(min(max(t1, t2), max(t3, t4)), max(t5, t6));
    float t = 0.0;
    if (tmax < 0.0)
    {
        t = tmax;
        return false;
    }
    if (tmin > tmax)
    {
        t = tmax;
        return false;
    }
    t = tmin;
    intersection = r1 + rv * t;
    return true;
}
float sdf_shadow_trace(float max_samples, float3 light_pos, float3 world_pos, float3 scale, float3 ray_origin, float4x4 inv_mat, float3x3 inv_rot)
{
    float3 ray_dir = normalize(light_pos - world_pos);
    ray_dir = normalize( mul( ray_dir, inv_rot ) );
    float closest = 1.0;
    float3 uvw = ray_origin;
    if(abs(uvw.x) >= 1.0 || abs(uvw.y) >= 1.0 || abs(uvw.z) >= 1.0)
    {
        float3 emin = float3(-1.0, -1.0, -1.0);
        float3 emax = float3(1.0, 1.0, 1.0);
        float3 ip = float3(0.0, 0.0, 0.0);
        bool hit = ray_vs_aabb( emin, emax, uvw, ray_dir, ip);
        uvw = ip;
        if(!hit)
        {
            return closest;
        }
    }
    float3 light_uvw = mul( float4(light_pos, 1.0), inv_mat ).xyz * 0.5 + 0.5;
    uvw = uvw * 0.5 + 0.5;
    float3 v1 = normalize(light_uvw - uvw);
    for( int s = 0; s < int(max_samples); ++s )
    {
        float d = sample_texture_level( sdf_volume, uvw, 0.0 ).r;
        closest = min(d, closest);
        ray_dir = normalize(light_uvw - uvw);
        float3 step = ray_dir.xyz * float3(d, d, d) / scale * 0.7;
        uvw += step;
        if( d <= 0.0 )
        {
            closest = max( d, 0.0 );
            break;
        }
        if(uvw.x >= 1.0 || uvw.x < 0.0)
        break;
        if(uvw.y >= 1.0 || uvw.y < 0.0)
        break;
        if(uvw.z >= 1.0 || uvw.z < 0.0)
        break;
    }
    return closest;
}
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.world_pos = world_pos_vs_output;
    _input.normal = normal_vs_output;
    _input.tangent = tangent_vs_output;
    _input.bitangent = bitangent_vs_output;
    _input.texcoord = texcoord_vs_output;
    ps_output _output;
    _output.colour = float4(0.0, 0.0, 0.0, 1.0);
    float3 albedo = float3(1.0, 1.0, 1.0);
    float max_samples = 128.0;
    float3x3 inv_rot = to_3x3(sdf_shadow.world_matrix_inv);
    float3 r1 = _input.world_pos.xyz + _input.normal.xyz * 0.3;
    float3 tr1 = mul( float4(r1, 1.0), sdf_shadow.world_matrix_inv ).xyz;
    float3 scale = float3(length(sdf_shadow.world_matrix[0].xyz), length(sdf_shadow.world_matrix[1].xyz), length(sdf_shadow.world_matrix[2].xyz)) * 2.0;
    float3 vddx = ddx( r1 );
    float3 vddy = ddy( r1 );
    float3 v1;
    int point_start = int(light_info.x);
    int point_end = int(light_info.x) + int(light_info.y);
    for( int i = point_start; i < point_end; ++i )
    {
        float3 light_col = float3( 0.0, 0.0, 0.0 );
        light_col += lambert(lights[i].pos_radius,
        lights[i].colour.rgb,
        _input.normal.xyz,
        _input.world_pos.xyz,
        albedo.rgb);
        if(length(light_col) <= 0.0)
        continue;
        float atten = point_light_attenuation(lights[i].pos_radius , _input.world_pos.xyz);
        light_col *= atten;
        float closest = sdf_shadow_trace(max_samples, lights[i].pos_radius.xyz, _input.world_pos.xyz, scale, tr1, sdf_shadow.world_matrix_inv, inv_rot);
        light_col *= smoothstep( 0.0, 0.1, closest);
        _output.colour.rgb += light_col;
    }
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//pmfx_utility picking__1073741824__ vs 1073741824
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
layout(location = 0) in float4 position_vs_input;
layout(location = 1) in float4 normal_vs_input;
layout(location = 2) in float4 texcoord_vs_input;
layout(location = 3) in float4 tangent_vs_input;
layout(location = 4) in float4 bitangent_vs_input;
layout(location = 5) in float4 world_matrix_0_instance_input;
layout(location = 6) in float4 world_matrix_1_instance_input;
layout(location = 7) in float4 world_matrix_2_instance_input;
layout(location = 8) in float4 world_matrix_3_instance_input;
layout(location = 9) in float4 user_data_instance_input;
layout(location = 10) in float4 user_data2_instance_input;
out float4 index_vs_output;
uniform float v_flip;
struct vs_input
{
    float4 position;
    float4 normal;
    float4 texcoord;
    float4 tangent;
    float4 bitangent;
};
struct vs_instance_input
{
    float4 world_matrix_0;
    float4 world_matrix_1;
    float4 world_matrix_2;
    float4 world_matrix_3;
    float4 user_data;
    float4 user_data2;
};
struct vs_output_picking
{
    float4 position;
    float4 index;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
layout (std140) uniform per_draw_call
{
    float4x4 world_matrix;
    float4 user_data;
    float4 user_data2;
    float4x4 world_matrix_inv_transpose;
};
void main()
{
    //assign vs_input struct from glsl inputs
    vs_input _input;
    _input.position = position_vs_input;
    _input.normal = normal_vs_input;
    _input.texcoord = texcoord_vs_input;
    _input.tangent = tangent_vs_input;
    _input.bitangent = bitangent_vs_input;
    //assign vs_instance_input struct from glsl inputs
    vs_instance_input instance_input;
    instance_input.world_matrix_0 = world_matrix_0_instance_input;
    instance_input.world_matrix_1 = world_matrix_1_instance_input;
    instance_input.world_matrix_2 = world_matrix_2_instance_input;
    instance_input.world_matrix_3 = world_matrix_3_instance_input;
    instance_input.user_data = user_data_instance_input;
    instance_input.user_data2 = user_data2_instance_input;
    vs_output_picking _output;
    float4x4 instance_world_mat;
    unpack_vb_instance_mat(instance_world_mat,
    instance_input.world_matrix_0,
    instance_input.world_matrix_1,
    instance_input.world_matrix_2,
    instance_input.world_matrix_3);
    float4x4 wvp = mul( instance_world_mat, vp_matrix );
    _output.position = mul( _input.position, wvp );
    _output.index = float4(instance_input.user_data.x, 0.0, 0.0, 0.0);
    //assign glsl global outputs from structs
    gl_Position = _output.position;
    gl_Position.y *= v_flip;
    index_vs_output = _output.index;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//pmfx_utility skinning_debug vs 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
layout(location = 0) in float4 position_vs_input;
layout(location = 1) in float4 normal_vs_input;
layout(location = 2) in float4 texcoord_vs_input;
layout(location = 3) in float4 tangent_vs_input;
layout(location = 4) in float4 bitangent_vs_input;
layout(location = 5) in float4 blend_indices_vs_input;
layout(location = 6) in float4 blend_weights_vs_input;
out float4 debug1_vs_output;
out float4 debug2_vs_output;
uniform float v_flip;
struct vs_input
{
    float4 position;
    float4 normal;
    float4 texcoord;
    float4 tangent;
    float4 bitangent;
    float4 blend_indices;
    float4 blend_weights;
};
struct vs_output_debug
{
    float4 position;
    float4 debug1;
    float4 debug2;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
void main()
{
    //assign vs_input struct from glsl inputs
    vs_input _input;
    _input.position = position_vs_input;
    _input.normal = normal_vs_input;
    _input.texcoord = texcoord_vs_input;
    _input.tangent = tangent_vs_input;
    _input.bitangent = bitangent_vs_input;
    _input.blend_indices = blend_indices_vs_input;
    _input.blend_weights = blend_weights_vs_input;
    vs_output_debug _output;
    _output.position = mul( _input.position, vp_matrix );
    _output.debug1 = _input.blend_weights;
    _output.debug2 = _input.blend_indices;
    //assign glsl global outputs from structs
    gl_Position = _output.position;
    gl_Position.y *= v_flip;
    debug1_vs_output = _output.debug1;
    debug2_vs_output = _output.debug2;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//pmfx_utility area_light_colour ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 world_pos_vs_output;
in float3 normal_vs_output;
in float3 tangent_vs_output;
in float3 bitangent_vs_output;
in float4 texcoord_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 world_pos;
    float3 normal;
    float3 tangent;
    float3 bitangent;
    float4 texcoord;
};
struct ps_output
{
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform per_draw_call
{
    float4x4 world_matrix;
    float4 user_data;
    float4 user_data2;
    float4x4 world_matrix_inv_transpose;
};
layout (std140) uniform per_pass_area_lights
{
    float4 area_light_info;
    area_light_data area_lights[10];
};
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.world_pos = world_pos_vs_output;
    _input.normal = normal_vs_output;
    _input.tangent = tangent_vs_output;
    _input.bitangent = bitangent_vs_output;
    _input.texcoord = texcoord_vs_output;
    ps_output _output;
    _output.colour = area_lights[int(user_data.z)].colour;
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//pmfx_utility volume_texture ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 world_pos_vs_output;
in float3 normal_vs_output;
in float3 tangent_vs_output;
in float3 bitangent_vs_output;
in float4 texcoord_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 world_pos;
    float3 normal;
    float3 tangent;
    float3 bitangent;
    float4 texcoord;
};
struct ps_output
{
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
layout (std140) uniform per_draw_call
{
    float4x4 world_matrix;
    float4 user_data;
    float4 user_data2;
    float4x4 world_matrix_inv_transpose;
};
texture_3d( volume_texture, 4 );
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.world_pos = world_pos_vs_output;
    _input.normal = normal_vs_output;
    _input.tangent = tangent_vs_output;
    _input.bitangent = bitangent_vs_output;
    _input.texcoord = texcoord_vs_output;
    ps_output _output;
    float3 v = _input.texcoord.xyz;
    float3 chebyshev_norm = chebyshev_normalize(v);
    float3 uvw = chebyshev_norm * 0.5 + 0.5;
    float depth = 1.0;
    float max_samples = 256.0;
    float3 ray_dir = normalize(_input.world_pos.xyz - camera_view_pos.xyz);
    float3x3 inv_rot = to_3x3(world_matrix_inv_transpose);
    ray_dir = mul( inv_rot, ray_dir );
    float3 ray_step = chebyshev_normalize(ray_dir.xyz) / max_samples;
    float depth_step = 1.0 / max_samples;
    float3 vddx = ddx( uvw );
    float3 vddy = ddy( uvw );
    for(int s = 0; s < int(max_samples); ++s )
    {
        _output.colour = sample_texture_grad( volume_texture, uvw, vddx, vddy );
        if(_output.colour.a != 0.0)
        break;
        depth -= depth_step;
        uvw += ray_step;
        if(uvw.x > 1.0 || uvw.x < 0.0)
        discard;
        if(uvw.y > 1.0 || uvw.y < 0.0)
        discard;
        if(uvw.z > 1.0 || uvw.z < 0.0)
        discard;
        if(s == int(max_samples)-1)
        discard;
    }
    _output.colour.rgb *= lerp( 0.5, 1.0, depth );
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//pmfx_utility picking vs 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
layout(location = 0) in float4 position_vs_input;
layout(location = 1) in float4 normal_vs_input;
layout(location = 2) in float4 texcoord_vs_input;
layout(location = 3) in float4 tangent_vs_input;
layout(location = 4) in float4 bitangent_vs_input;
out float4 index_vs_output;
uniform float v_flip;
struct vs_input
{
    float4 position;
    float4 normal;
    float4 texcoord;
    float4 tangent;
    float4 bitangent;
};
struct vs_output_picking
{
    float4 position;
    float4 index;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
layout (std140) uniform per_draw_call
{
    float4x4 world_matrix;
    float4 user_data;
    float4 user_data2;
    float4x4 world_matrix_inv_transpose;
};
void main()
{
    //assign vs_input struct from glsl inputs
    vs_input _input;
    _input.position = position_vs_input;
    _input.normal = normal_vs_input;
    _input.texcoord = texcoord_vs_input;
    _input.tangent = tangent_vs_input;
    _input.bitangent = bitangent_vs_input;
    vs_output_picking _output;
    float4x4 wvp = mul( world_matrix, vp_matrix );
    _output.position = mul( _input.position, wvp );
    _output.index = float4(user_data.x, 0.0, 0.0, 0.0);
    //assign glsl global outputs from structs
    gl_Position = _output.position;
    gl_Position.y *= v_flip;
    index_vs_output = _output.index;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//pmfx_utility vertex_tangents ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 world_pos_vs_output;
in float3 normal_vs_output;
in float3 tangent_vs_output;
in float3 bitangent_vs_output;
in float4 texcoord_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 world_pos;
    float3 normal;
    float3 tangent;
    float3 bitangent;
    float4 texcoord;
};
struct ps_output
{
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.world_pos = world_pos_vs_output;
    _input.normal = normal_vs_output;
    _input.tangent = tangent_vs_output;
    _input.bitangent = bitangent_vs_output;
    _input.texcoord = texcoord_vs_output;
    ps_output _output;
    _output.colour.rgb = _input.tangent * 0.5 + 0.5;
    _output.colour.a = 1.0;
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//pmfx_utility texcoord_0 ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 world_pos_vs_output;
in float3 normal_vs_output;
in float3 tangent_vs_output;
in float3 bitangent_vs_output;
in float4 texcoord_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 world_pos;
    float3 normal;
    float3 tangent;
    float3 bitangent;
    float4 texcoord;
};
struct ps_output
{
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.world_pos = world_pos_vs_output;
    _input.normal = normal_vs_output;
    _input.tangent = tangent_vs_output;
    _input.bitangent = bitangent_vs_output;
    _input.texcoord = texcoord_vs_output;
    ps_output _output;
    _output.colour.rg = _input.texcoord.xy;
    _output.colour.b = 0.0;
    _output.colour.a = 1.0;
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//pmfx_utility picking__3221225472__ vs 3221225472
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
layout(location = 0) in float4 position_vs_input;
layout(location = 1) in float4 normal_vs_input;
layout(location = 2) in float4 texcoord_vs_input;
layout(location = 3) in float4 tangent_vs_input;
layout(location = 4) in float4 bitangent_vs_input;
layout(location = 5) in float4 blend_indices_vs_input;
layout(location = 6) in float4 blend_weights_vs_input;
layout(location = 7) in float4 world_matrix_0_instance_input;
layout(location = 8) in float4 world_matrix_1_instance_input;
layout(location = 9) in float4 world_matrix_2_instance_input;
layout(location = 10) in float4 world_matrix_3_instance_input;
layout(location = 11) in float4 user_data_instance_input;
layout(location = 12) in float4 user_data2_instance_input;
out float4 index_vs_output;
uniform float v_flip;
struct vs_input
{
    float4 position;
    float4 normal;
    float4 texcoord;
    float4 tangent;
    float4 bitangent;
    float4 blend_indices;
    float4 blend_weights;
};
struct vs_instance_input
{
    float4 world_matrix_0;
    float4 world_matrix_1;
    float4 world_matrix_2;
    float4 world_matrix_3;
    float4 user_data;
    float4 user_data2;
};
struct vs_output_picking
{
    float4 position;
    float4 index;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform skinning_info
{
    float4x4 bones[85];
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
layout (std140) uniform per_draw_call
{
    float4x4 world_matrix;
    float4 user_data;
    float4 user_data2;
    float4x4 world_matrix_inv_transpose;
};
float4 skin_pos(float4 pos, float4 weights, float4 indices)
{
    int bone_indices[4];
    bone_indices[0] = int(indices.x);
    bone_indices[1] = int(indices.y);
    bone_indices[2] = int(indices.z);
    bone_indices[3] = int(indices.w);
    float4 sp = float4( 0.0, 0.0, 0.0, 0.0 );
    float final_weight = 1.0;
    for(int i = 3; i >= 0; --i)
    {
        sp += mul( pos, bones[bone_indices[i]] ) * weights[i];
        final_weight -= weights[i];
    }
    sp += mul( pos, bones[bone_indices[0]] ) * final_weight;
    sp.w = 1.0;
    return sp;
}
void main()
{
    //assign vs_input struct from glsl inputs
    vs_input _input;
    _input.position = position_vs_input;
    _input.normal = normal_vs_input;
    _input.texcoord = texcoord_vs_input;
    _input.tangent = tangent_vs_input;
    _input.bitangent = bitangent_vs_input;
    _input.blend_indices = blend_indices_vs_input;
    _input.blend_weights = blend_weights_vs_input;
    //assign vs_instance_input struct from glsl inputs
    vs_instance_input instance_input;
    instance_input.world_matrix_0 = world_matrix_0_instance_input;
    instance_input.world_matrix_1 = world_matrix_1_instance_input;
    instance_input.world_matrix_2 = world_matrix_2_instance_input;
    instance_input.world_matrix_3 = world_matrix_3_instance_input;
    instance_input.user_data = user_data_instance_input;
    instance_input.user_data2 = user_data2_instance_input;
    vs_output_picking _output;
    float4x4 instance_world_mat;
    unpack_vb_instance_mat(instance_world_mat,
    instance_input.world_matrix_0,
    instance_input.world_matrix_1,
    instance_input.world_matrix_2,
    instance_input.world_matrix_3);
    float4x4 wvp = mul( instance_world_mat, vp_matrix );
    _output.position = mul( _input.position, wvp );
    _output.index = float4(instance_input.user_data.x, 0.0, 0.0, 0.0);
    float4 sp = skin_pos(_input.position, _input.blend_weights, _input.blend_indices);
    _output.position = mul( sp, vp_matrix );
    _output.index = float4(user_data.x, 0.0, 0.0, 0.0);
    //assign glsl global outputs from structs
    gl_Position = _output.position;
    gl_Position.y *= v_flip;
    index_vs_output = _output.index;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//pmfx_utility texcoord_1 ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 world_pos_vs_output;
in float3 normal_vs_output;
in float3 tangent_vs_output;
in float3 bitangent_vs_output;
in float4 texcoord_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 world_pos;
    float3 normal;
    float3 tangent;
    float3 bitangent;
    float4 texcoord;
};
struct ps_output
{
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.world_pos = world_pos_vs_output;
    _input.normal = normal_vs_output;
    _input.tangent = tangent_vs_output;
    _input.bitangent = bitangent_vs_output;
    _input.texcoord = texcoord_vs_output;
    ps_output _output;
    _output.colour.rg = _input.texcoord.zw;
    _output.colour.b = 0.0;
    _output.colour.a = 1.0;
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//pmfx_utility fixed_light ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 world_pos_vs_output;
in float3 normal_vs_output;
in float3 tangent_vs_output;
in float3 bitangent_vs_output;
in float4 texcoord_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 world_pos;
    float3 normal;
    float3 tangent;
    float3 bitangent;
    float4 texcoord;
};
struct ps_output
{
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.world_pos = world_pos_vs_output;
    _input.normal = normal_vs_output;
    _input.tangent = tangent_vs_output;
    _input.bitangent = bitangent_vs_output;
    _input.texcoord = texcoord_vs_output;
    ps_output _output;
    float dp = max(dot(_input.normal.xyz, normalize(float3(-1.0, -1.0, 1.0))), 0.5);
    _output.colour = float4(dp, dp, dp, 1.0);
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//pmfx_utility volume_sdf ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 world_pos_vs_output;
in float3 normal_vs_output;
in float3 tangent_vs_output;
in float3 bitangent_vs_output;
in float4 texcoord_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 world_pos;
    float3 normal;
    float3 tangent;
    float3 bitangent;
    float4 texcoord;
};
struct ps_output
{
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
layout (std140) uniform per_draw_call
{
    float4x4 world_matrix;
    float4 user_data;
    float4 user_data2;
    float4x4 world_matrix_inv_transpose;
};
texture_3d( volume_texture, 4 );
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.world_pos = world_pos_vs_output;
    _input.normal = normal_vs_output;
    _input.tangent = tangent_vs_output;
    _input.bitangent = bitangent_vs_output;
    _input.texcoord = texcoord_vs_output;
    ps_output _output;
    float3 v = _input.texcoord.xyz;
    float3 chebyshev_norm = chebyshev_normalize(v);
    float3 uvw = chebyshev_norm * 0.5 + 0.5;
    float max_samples = 64.0;
    float3 ray_dir = normalize(_input.world_pos.xyz - camera_view_pos.xyz);
    float3x3 inv_rot = to_3x3(world_matrix_inv_transpose);
    ray_dir = mul(inv_rot, ray_dir);
    ray_dir = normalize(ray_dir);
    float3 vddx = ddx( uvw );
    float3 vddy = ddy( uvw );
    float3 scale = float3(length(world_matrix[0].xyz), length(world_matrix[1].xyz), length(world_matrix[2].xyz)) * 2.0;
    float d;
    d = sample_texture_grad( volume_texture, uvw, vddx, vddy ).r;
    float3 col = float3( 0.0, 0.0, 0.0 );
    float3 ray_pos = _input.world_pos.xyz;
    float taken = 0.0;
    float3 min_step = (scale / max_samples);
    for( int s = 0; s < int(max_samples); ++s )
    {
        taken += 1.0/max_samples;
        d = sample_texture_grad(volume_texture, uvw, vddx, vddy).r;
        float3 step = ray_dir.xyz * float3(d / scale) * 0.5;
        uvw += step;
        if(uvw.x >= 1.0 || uvw.x <= 0.0)
        discard;
        if(uvw.y >= 1.0 || uvw.y <= 0.0)
        discard;
        if(uvw.z >= 1.0 || uvw.z <= 0.0)
        discard;
        if( d <= 0.01 )
        break;
    }
    float vd = (1.0 - d);
    _output.colour.rgb = float3(vd*vd,vd*vd, vd*vd);
    _output.colour.rgb = float3(taken, taken, taken);
    _output.colour.a = 1.0;
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//pmfx_utility skinning_debug ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 debug1_vs_output;
in float4 debug2_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output_debug
{
    float4 position;
    float4 debug1;
    float4 debug2;
};
struct ps_output
{
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform material_data
{
    float m_index_range;
    float3 m_padding;
};
void main()
{
    //assign vs_output_debug struct from glsl inputs
    vs_output_debug _input;
    _input.debug1 = debug1_vs_output;
    _input.debug2 = debug2_vs_output;
    ps_output _output;
    _output.colour = _input.debug2 / m_index_range;
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//pmfx_utility constant_colour ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 world_pos_vs_output;
in float3 normal_vs_output;
in float3 tangent_vs_output;
in float3 bitangent_vs_output;
in float4 texcoord_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 world_pos;
    float3 normal;
    float3 tangent;
    float3 bitangent;
    float4 texcoord;
};
struct ps_output
{
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform per_draw_call
{
    float4x4 world_matrix;
    float4 user_data;
    float4 user_data2;
    float4x4 world_matrix_inv_transpose;
};
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.world_pos = world_pos_vs_output;
    _input.normal = normal_vs_output;
    _input.tangent = tangent_vs_output;
    _input.bitangent = bitangent_vs_output;
    _input.texcoord = texcoord_vs_output;
    ps_output _output;
    _output.colour = float4( user_data2.rgb, 1.0 );
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//pmfx_utility vertex_bitangents ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 world_pos_vs_output;
in float3 normal_vs_output;
in float3 tangent_vs_output;
in float3 bitangent_vs_output;
in float4 texcoord_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 world_pos;
    float3 normal;
    float3 tangent;
    float3 bitangent;
    float4 texcoord;
};
struct ps_output
{
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.world_pos = world_pos_vs_output;
    _input.normal = normal_vs_output;
    _input.tangent = tangent_vs_output;
    _input.bitangent = bitangent_vs_output;
    _input.texcoord = texcoord_vs_output;
    ps_output _output;
    _output.colour.rgb = _input.bitangent * 0.5 + 0.5;
    _output.colour.a = 1.0;
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//pmfx_utility cubemap ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 world_pos_vs_output;
in float3 normal_vs_output;
in float3 tangent_vs_output;
in float3 bitangent_vs_output;
in float4 texcoord_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 world_pos;
    float3 normal;
    float3 tangent;
    float3 bitangent;
    float4 texcoord;
};
struct ps_output
{
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
texture_cube( cubemap_texture, 3 );
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.world_pos = world_pos_vs_output;
    _input.normal = normal_vs_output;
    _input.tangent = tangent_vs_output;
    _input.bitangent = bitangent_vs_output;
    _input.texcoord = texcoord_vs_output;
    ps_output _output;
    float3 rd = normalize(_input.world_pos.xyz - camera_view_pos.xyz) * float3(1.0, 1.0, -1.0);
    float3 n = normalize(_input.normal.xyz * float3(1.0, 1.0, -1.0));
    float3 r = reflect(rd, n);
    _output.colour = sample_texture( cubemap_texture, r);
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
{
    "cmdline": "../third_party/pmbuild/scripts/pmfx-shader/build_pmfx.py -shader_platform gles -shader_version 300 -i assets/shaders ../assets/shaders -o build/web/data/pmfx/glsl -h shader_structs -t temp/shaders -v_flip -source ",
    "files": [
        {
            "name": "/Users/alex.dixon/dev/pmtech/third_party/pmbuild/scripts/pmfx-shader/build_pmfx.py",
            "timestamp": 1608637107.3205462
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/third_party/pmbuild/scripts/pmfx-shader/platform/pmfx.h",
            "timestamp": 1605953217.8167121
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/third_party/pmbuild/scripts/pmfx-shader/platform/glsl.h",
            "timestamp": 1608635330.6987193
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/examples/../assets/shaders/pmfx_utility.pmfx",
            "timestamp": 1608572067.2018285
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/examples/../assets/shaders/libs/lighting.pmfx",
            "timestamp": 1608572067.1994717
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/examples/../assets/shaders/libs/skinning.pmfx",
            "timestamp": 1608572067.2003047
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/examples/../assets/shaders/libs/globals.pmfx",
            "timestamp": 1608572067.200933
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/examples/../assets/shaders/libs/maths.pmfx",
            "timestamp": 1608572067.2011206
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/examples/../assets/shaders/libs/sdf.pmfx",
            "timestamp": 1608572067.2005048
        }
    ],
    "techniques": [
        {
            "vs": "vs_main",
            "ps": "ps_fixed_light",
            "name": "fixed_light",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "cubemap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_cube",
                    "unit": 3
                },
                {
                    "name": "volume_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 4
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                }
            ],
            "vs_file": "fixed_light.vsc",
            "ps_file": "fixed_light.psc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        },
        {
            "vs": "vs_main",
            "ps": "ps_constant_colour",
            "name": "constant_colour",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "cubemap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_cube",
                    "unit": 3
                },
                {
                    "name": "volume_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 4
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                }
            ],
            "vs_file": "fixed_light.vsc",
            "ps_file": "constant_colour.psc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        },
        {
            "vs": "vs_main",
            "ps": "ps_diffuse",
            "name": "diffuse",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "cubemap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_cube",
                    "unit": 3
                },
                {
                    "name": "volume_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 4
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                }
            ],
            "vs_file": "fixed_light.vsc",
            "ps_file": "diffuse.psc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        },
        {
            "vs": "vs_main",
            "ps": "ps_vertex_normals",
            "name": "vertex_normals",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "cubemap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_cube",
                    "unit": 3
                },
                {
                    "name": "volume_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 4
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                }
            ],
            "vs_file": "fixed_light.vsc",
            "ps_file": "vertex_normals.psc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        },
        {
            "vs": "vs_main",
            "ps": "ps_vertex_tangents",
            "name": "vertex_tangents",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "cubemap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_cube",
                    "unit": 3
                },
                {
                    "name": "volume_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 4
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                }
            ],
            "vs_file": "fixed_light.vsc",
            "ps_file": "vertex_tangents.psc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        },
        {
            "vs": "vs_main",
            "ps": "ps_vertex_bitangents",
            "name": "vertex_bitangents",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "cubemap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_cube",
                    "unit": 3
                },
                {
                    "name": "volume_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 4
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                }
            ],
            "vs_file": "fixed_light.vsc",
            "ps_file": "vertex_bitangents.psc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        },
        {
            "vs": "vs_main",
            "ps": "ps_texcoord_0",
            "name": "texcoord_0",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "cubemap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_cube",
                    "unit": 3
                },
                {
                    "name": "volume_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 4
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                }
            ],
            "vs_file": "fixed_light.vsc",
            "ps_file": "texcoord_0.psc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        },
        {
            "vs": "vs_main",
            "ps": "ps_texcoord_1",
            "name": "texcoord_1",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "cubemap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_cube",
                    "unit": 3
                },
                {
                    "name": "volume_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 4
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                }
            ],
            "vs_file": "fixed_light.vsc",
            "ps_file": "texcoord_1.psc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        },
        {
            "vs": "vs_main_skinned_debug",
            "ps": "ps_skinning_debug",
            "defines": [
                "SKINNED"
            ],
            "constants": {
                "index_range": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1000,
                    "default": 1.0,
                    "offset": 0,
                    "num_elements": 1
                }
            },
            "permutations": {
                "WEIGHTS": {
                    "val": 2,
                    "type": "checkbox"
                }
            },
            "constants_used_bytes": 4,
            "constants_size_bytes": 16,
            "name": "skinning_debug",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "cubemap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_cube",
                    "unit": 3
                },
                {
                    "name": "volume_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 4
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "material_data",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "blend_indices",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                },
                {
                    "name": "blend_weights",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 96
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "debug1",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "debug2",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                }
            ],
            "vs_file": "skinning_debug.vsc",
            "ps_file": "skinning_debug.psc",
            "permutation_id": 0,
            "permutation_option_mask": 2
        },
        {
            "vs": "vs_main_skinned_debug",
            "ps": "ps_skinning_debug",
            "defines": [
                "SKINNED"
            ],
            "constants": {
                "index_range": {
                    "type": "float",
                    "widget": "slider",
                    "min": 0,
                    "max": 1000,
                    "default": 1.0,
                    "offset": 0,
                    "num_elements": 1
                }
            },
            "permutations": {
                "WEIGHTS": {
                    "val": 2,
                    "type": "checkbox"
                }
            },
            "constants_used_bytes": 4,
            "constants_size_bytes": 16,
            "name": "skinning_debug",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "cubemap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_cube",
                    "unit": 3
                },
                {
                    "name": "volume_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 4
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "material_data",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "blend_indices",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                },
                {
                    "name": "blend_weights",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 96
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "debug1",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "debug2",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                }
            ],
            "vs_file": "skinning_debug.vsc",
            "ps_file": "skinning_debug__2__.psc",
            "permutation_id": 2,
            "permutation_option_mask": 2
        },
        {
            "vs": "vs_main",
            "ps": "ps_cubemapped",
            "name": "cubemap",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "cubemap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_cube",
                    "unit": 3
                },
                {
                    "name": "volume_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 4
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                }
            ],
            "vs_file": "fixed_light.vsc",
            "ps_file": "cubemap.psc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        },
        {
            "vs": "vs_main",
            "ps": "ps_cubemapped",
            "name": "skybox",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "cubemap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_cube",
                    "unit": 3
                },
                {
                    "name": "volume_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 4
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                }
            ],
            "vs_file": "fixed_light.vsc",
            "ps_file": "cubemap.psc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        },
        {
            "vs": "vs_main",
            "ps": "ps_glass",
            "name": "glass",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "cubemap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_cube",
                    "unit": 3
                },
                {
                    "name": "volume_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 4
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                }
            ],
            "vs_file": "fixed_light.vsc",
            "ps_file": "glass.psc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        },
        {
            "vs": "vs_main_volume_texture",
            "ps": "ps_volume_texture",
            "name": "volume_texture",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "cubemap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_cube",
                    "unit": 3
                },
                {
                    "name": "volume_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 4
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                }
            ],
            "vs_file": "volume_texture.vsc",
            "ps_file": "volume_texture.psc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        },
        {
            "vs": "vs_main_volume_texture",
            "ps": "ps_volume_sdf",
            "name": "volume_sdf",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "cubemap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_cube",
                    "unit": 3
                },
                {
                    "name": "volume_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 4
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                }
            ],
            "vs_file": "volume_texture.vsc",
            "ps_file": "volume_sdf.psc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        },
        {
            "vs": "vs_main_volume_texture",
            "ps": "ps_shadow_sdf",
            "name": "shadow_sdf",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "cubemap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_cube",
                    "unit": 3
                },
                {
                    "name": "volume_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 4
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                }
            ],
            "vs_file": "volume_texture.vsc",
            "ps_file": "shadow_sdf.psc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        },
        {
            "vs": "vs_picking",
            "ps": "ps_picking",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                }
            },
            "name": "picking",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "cubemap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_cube",
                    "unit": 3
                },
                {
                    "name": "volume_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 4
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "index",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "vs_file": "picking.vsc",
            "ps_file": "picking.psc",
            "permutation_id": 0,
            "permutation_option_mask": 3221225472
        },
        {
            "vs": "vs_picking",
            "ps": "ps_picking",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                }
            },
            "name": "picking",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "cubemap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_cube",
                    "unit": 3
                },
                {
                    "name": "volume_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 4
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "blend_indices",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                },
                {
                    "name": "blend_weights",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 96
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "index",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "vs_file": "picking__2147483648__.vsc",
            "ps_file": "picking.psc",
            "permutation_id": 2147483648,
            "permutation_option_mask": 3221225472
        },
        {
            "vs": "vs_picking",
            "ps": "ps_picking",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                }
            },
            "name": "picking",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "cubemap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_cube",
                    "unit": 3
                },
                {
                    "name": "volume_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 4
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                }
            ],
            "instance_inputs": [
                {
                    "name": "world_matrix_0",
                    "semantic_index": 6,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_matrix_1",
                    "semantic_index": 7,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "world_matrix_2",
                    "semantic_index": 8,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "world_matrix_3",
                    "semantic_index": 9,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "user_data",
                    "semantic_index": 10,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "user_data2",
                    "semantic_index": 11,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                }
            ],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "index",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "vs_file": "picking__1073741824__.vsc",
            "ps_file": "picking.psc",
            "permutation_id": 1073741824,
            "permutation_option_mask": 3221225472
        },
        {
            "vs": "vs_picking",
            "ps": "ps_picking",
            "permutations": {
                "SKINNED": {
                    "val": 2147483648,
                    "type": "checkbox"
                },
                "INSTANCED": {
                    "val": 1073741824,
                    "type": "checkbox"
                }
            },
            "name": "picking",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "cubemap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_cube",
                    "unit": 3
                },
                {
                    "name": "volume_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 4
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "blend_indices",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                },
                {
                    "name": "blend_weights",
                    "semantic_index": 5,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 96
                }
            ],
            "instance_inputs": [
                {
                    "name": "world_matrix_0",
                    "semantic_index": 6,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_matrix_1",
                    "semantic_index": 7,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "world_matrix_2",
                    "semantic_index": 8,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "world_matrix_3",
                    "semantic_index": 9,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "user_data",
                    "semantic_index": 10,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                },
                {
                    "name": "user_data2",
                    "semantic_index": 11,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 80
                }
            ],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "index",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "vs_file": "picking__3221225472__.vsc",
            "ps_file": "picking.psc",
            "permutation_id": 3221225472,
            "permutation_option_mask": 3221225472
        },
        {
            "vs": "vs_main",
            "ps": "ps_diffuse",
            "name": "volume_raster_albedo",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "cubemap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_cube",
                    "unit": 3
                },
                {
                    "name": "volume_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 4
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                }
            ],
            "vs_file": "fixed_light.vsc",
            "ps_file": "diffuse.psc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        },
        {
            "vs": "vs_main",
            "ps": "ps_area_light_texture",
            "name": "area_light_texture",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "cubemap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_cube",
                    "unit": 3
                },
                {
                    "name": "volume_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 4
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                }
            ],
            "vs_file": "fixed_light.vsc",
            "ps_file": "area_light_texture.psc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        },
        {
            "vs": "vs_main",
            "ps": "ps_area_light_colour",
            "name": "area_light_colour",
            "texture_sampler_bindings": [
                {
                    "name": "diffuse_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "normal_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 1
                },
                {
                    "name": "specular_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 2
                },
                {
                    "name": "cubemap_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_cube",
                    "unit": 3
                },
                {
                    "name": "volume_texture",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 4
                },
                {
                    "name": "sdf_volume",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 14
                },
                {
                    "name": "area_light_textures",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 11
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "skinning_info",
                    "location": 2
                },
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "normal",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "texcoord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 48
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 64
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "world_pos",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "normal",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 32
                },
                {
                    "name": "tangent",
                    "semantic_index": 2,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 44
                },
                {
                    "name": "bitangent",
                    "semantic_index": 3,
                    "semantic_id": 2,
                    "size": 12,
                    "element_size": 4,
                    "num_elements": 3,
                    "offset": 56
                },
                {
                    "name": "texcoord",
                    "semantic_index": 4,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 68
                }
            ],
            "vs_file": "fixed_light.vsc",
            "ps_file": "area_light_colour.psc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        }
    ],
    "failures": {}
}#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//pmfx_utility picking ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 index_vs_output;
out uint colour_ps_output;
uniform float v_flip;
struct vs_output_picking
{
    float4 position;
    float4 index;
};
struct ps_output_picking
{
    uint colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
void main()
{
    //assign vs_output_picking struct from glsl inputs
    vs_output_picking _input;
    _input.index = index_vs_output;
    ps_output_picking _output;
    _output.colour = uint(_input.index.x + 0.5);
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//pmfx_utility skinning_debug__2__ ps 2
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 debug1_vs_output;
in float4 debug2_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output_debug
{
    float4 position;
    float4 debug1;
    float4 debug2;
};
struct ps_output
{
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
void main()
{
    //assign vs_output_debug struct from glsl inputs
    vs_output_debug _input;
    _input.debug1 = debug1_vs_output;
    _input.debug2 = debug2_vs_output;
    ps_output _output;
    _output.colour = _input.debug1;
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//pmfx_utility picking__2147483648__ vs 2147483648
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
layout(location = 0) in float4 position_vs_input;
layout(location = 1) in float4 normal_vs_input;
layout(location = 2) in float4 texcoord_vs_input;
layout(location = 3) in float4 tangent_vs_input;
layout(location = 4) in float4 bitangent_vs_input;
layout(location = 5) in float4 blend_indices_vs_input;
layout(location = 6) in float4 blend_weights_vs_input;
out float4 index_vs_output;
uniform float v_flip;
struct vs_input
{
    float4 position;
    float4 normal;
    float4 texcoord;
    float4 tangent;
    float4 bitangent;
    float4 blend_indices;
    float4 blend_weights;
};
struct vs_output_picking
{
    float4 position;
    float4 index;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform skinning_info
{
    float4x4 bones[85];
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
layout (std140) uniform per_draw_call
{
    float4x4 world_matrix;
    float4 user_data;
    float4 user_data2;
    float4x4 world_matrix_inv_transpose;
};
float4 skin_pos(float4 pos, float4 weights, float4 indices)
{
    int bone_indices[4];
    bone_indices[0] = int(indices.x);
    bone_indices[1] = int(indices.y);
    bone_indices[2] = int(indices.z);
    bone_indices[3] = int(indices.w);
    float4 sp = float4( 0.0, 0.0, 0.0, 0.0 );
    float final_weight = 1.0;
    for(int i = 3; i >= 0; --i)
    {
        sp += mul( pos, bones[bone_indices[i]] ) * weights[i];
        final_weight -= weights[i];
    }
    sp += mul( pos, bones[bone_indices[0]] ) * final_weight;
    sp.w = 1.0;
    return sp;
}
void main()
{
    //assign vs_input struct from glsl inputs
    vs_input _input;
    _input.position = position_vs_input;
    _input.normal = normal_vs_input;
    _input.texcoord = texcoord_vs_input;
    _input.tangent = tangent_vs_input;
    _input.bitangent = bitangent_vs_input;
    _input.blend_indices = blend_indices_vs_input;
    _input.blend_weights = blend_weights_vs_input;
    vs_output_picking _output;
    float4 sp = skin_pos(_input.position, _input.blend_weights, _input.blend_indices);
    _output.position = mul( sp, vp_matrix );
    _output.index = float4(user_data.x, 0.0, 0.0, 0.0);
    //assign glsl global outputs from structs
    gl_Position = _output.position;
    gl_Position.y *= v_flip;
    index_vs_output = _output.index;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//pmfx_utility volume_texture vs 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
layout(location = 0) in float4 position_vs_input;
layout(location = 1) in float4 normal_vs_input;
layout(location = 2) in float4 texcoord_vs_input;
layout(location = 3) in float4 tangent_vs_input;
layout(location = 4) in float4 bitangent_vs_input;
out float4 world_pos_vs_output;
out float3 normal_vs_output;
out float3 tangent_vs_output;
out float3 bitangent_vs_output;
out float4 texcoord_vs_output;
uniform float v_flip;
struct vs_input
{
    float4 position;
    float4 normal;
    float4 texcoord;
    float4 tangent;
    float4 bitangent;
};
struct vs_output
{
    float4 position;
    float4 world_pos;
    float3 normal;
    float3 tangent;
    float3 bitangent;
    float4 texcoord;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
layout (std140) uniform per_draw_call
{
    float4x4 world_matrix;
    float4 user_data;
    float4 user_data2;
    float4x4 world_matrix_inv_transpose;
};
void main()
{
    //assign vs_input struct from glsl inputs
    vs_input _input;
    _input.position = position_vs_input;
    _input.normal = normal_vs_input;
    _input.texcoord = texcoord_vs_input;
    _input.tangent = tangent_vs_input;
    _input.bitangent = bitangent_vs_input;
    vs_output _output;
    float4x4 wvp = mul( world_matrix, vp_matrix );
    _output.position = mul( _input.position, wvp );
    _output.world_pos = mul( _input.position, world_matrix );
    _output.normal = _input.normal.xyz;
    _output.tangent = _input.tangent.xyz;
    _output.bitangent = _input.bitangent.xyz;
    _output.texcoord = _input.position;
    //assign glsl global outputs from structs
    gl_Position = _output.position;
    gl_Position.y *= v_flip;
    world_pos_vs_output = _output.world_pos;
    normal_vs_output = _output.normal;
    tangent_vs_output = _output.tangent;
    bitangent_vs_output = _output.bitangent;
    texcoord_vs_output = _output.texcoord;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//pmfx_utility glass ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 world_pos_vs_output;
in float3 normal_vs_output;
in float3 tangent_vs_output;
in float3 bitangent_vs_output;
in float4 texcoord_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 world_pos;
    float3 normal;
    float3 tangent;
    float3 bitangent;
    float4 texcoord;
};
struct ps_output
{
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
texture_cube( cubemap_texture, 3 );
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.world_pos = world_pos_vs_output;
    _input.normal = normal_vs_output;
    _input.tangent = tangent_vs_output;
    _input.bitangent = bitangent_vs_output;
    _input.texcoord = texcoord_vs_output;
    ps_output _output;
    float3 rd = normalize(_input.world_pos.xyz - camera_view_pos.xyz) * float3(1.0, 1.0, -1.0);
    float3 n = normalize(_input.normal.xyz) * float3(1.0, 1.0, -1.0);
    float3 r = refract(rd, n, 1.458);
    _output.colour = sample_texture(cubemap_texture, rd);
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//textured default vs 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
layout(location = 0) in float4 position_vs_input;
layout(location = 1) in float2 tex_coord_vs_input;
out float2 tex_coord_vs_output;
uniform float v_flip;
struct vs_input
{
    float4 position;
    float2 tex_coord;
};
struct vs_output
{
    float4 position;
    float2 tex_coord;
};
void main()
{
    //assign vs_input struct from glsl inputs
    vs_input _input;
    _input.position = position_vs_input;
    _input.tex_coord = tex_coord_vs_input;
    vs_output _output;
    _output.position = _input.position;
    _output.tex_coord = _input.tex_coord;
    //assign glsl global outputs from structs
    gl_Position = _output.position;
    gl_Position.y *= v_flip;
    tex_coord_vs_output = _output.tex_coord;
}
{
    "cmdline": "../third_party/pmbuild/scripts/pmfx-shader/build_pmfx.py -shader_platform gles -shader_version 300 -i assets/shaders ../assets/shaders -o build/web/data/pmfx/glsl -h shader_structs -t temp/shaders -v_flip -source ",
    "files": [
        {
            "name": "/Users/alex.dixon/dev/pmtech/third_party/pmbuild/scripts/pmfx-shader/build_pmfx.py",
            "timestamp": 1608637107.3205462
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/third_party/pmbuild/scripts/pmfx-shader/platform/pmfx.h",
            "timestamp": 1605953217.8167121
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/third_party/pmbuild/scripts/pmfx-shader/platform/glsl.h",
            "timestamp": 1608635330.6987193
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/examples/assets/shaders/textured.pmfx",
            "timestamp": 1608572067.1979926
        }
    ],
    "techniques": [
        {
            "vs": "vs_main",
            "ps": "ps_main",
            "name": "default",
            "texture_sampler_bindings": [
                {
                    "name": "tex",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                }
            ],
            "structured_buffers": [],
            "cbuffers": [],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "tex_coord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 8,
                    "element_size": 4,
                    "num_elements": 2,
                    "offset": 16
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "tex_coord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 8,
                    "element_size": 4,
                    "num_elements": 2,
                    "offset": 16
                }
            ],
            "vs_file": "default.vsc",
            "ps_file": "default.psc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        }
    ],
    "failures": {}
}#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//textured default ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float2 tex_coord_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float2 tex_coord;
};
struct ps_output
{
    float4 colour;
};
texture_2d( tex, 0 );
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.tex_coord = tex_coord_vs_output;
    ps_output _output;
    _output.colour = sample_texture( tex, _input.tex_coord.xy );
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//depth_only default vs 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
layout(location = 0) in float4 position_vs_input;
uniform float v_flip;
struct vs_input
{
    float4 position;
};
struct vs_output
{
    float4 position;
};
void main()
{
    //assign vs_input struct from glsl inputs
    vs_input _input;
    _input.position = position_vs_input;
    vs_output _output;
    _output.position = _input.position;
    //assign glsl global outputs from structs
    gl_Position = _output.position;
    gl_Position.y *= v_flip;
}
{
    "cmdline": "../third_party/pmbuild/scripts/pmfx-shader/build_pmfx.py -shader_platform gles -shader_version 300 -i assets/shaders ../assets/shaders -o build/web/data/pmfx/glsl -h shader_structs -t temp/shaders -v_flip -source ",
    "files": [
        {
            "name": "/Users/alex.dixon/dev/pmtech/third_party/pmbuild/scripts/pmfx-shader/build_pmfx.py",
            "timestamp": 1608637107.3205462
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/third_party/pmbuild/scripts/pmfx-shader/platform/pmfx.h",
            "timestamp": 1605953217.8167121
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/third_party/pmbuild/scripts/pmfx-shader/platform/glsl.h",
            "timestamp": 1608635330.6987193
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/examples/assets/shaders/depth_only.pmfx",
            "timestamp": 1608572067.1977928
        }
    ],
    "techniques": [
        {
            "vs": "vs_main",
            "ps": "ps_main",
            "name": "default",
            "texture_sampler_bindings": [],
            "structured_buffers": [],
            "cbuffers": [],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                }
            ],
            "vs_file": "default.vsc",
            "ps_file": "default.psc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        }
    ],
    "failures": {}
}#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//depth_only default ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
};
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    //assign glsl global outputs from structs
}
{
    "cmdline": "../third_party/pmbuild/scripts/pmfx-shader/build_pmfx.py -shader_platform gles -shader_version 300 -i assets/shaders ../assets/shaders -o build/web/data/pmfx/glsl -h shader_structs -t temp/shaders -v_flip -source ",
    "files": [
        {
            "name": "/Users/alex.dixon/dev/pmtech/third_party/pmbuild/scripts/pmfx-shader/build_pmfx.py",
            "timestamp": 1608637107.3205462
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/third_party/pmbuild/scripts/pmfx-shader/platform/pmfx.h",
            "timestamp": 1605953217.8167121
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/third_party/pmbuild/scripts/pmfx-shader/platform/glsl.h",
            "timestamp": 1608635330.6987193
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/examples/../assets/shaders/compute.pmfx",
            "timestamp": 1608572067.198758
        }
    ],
    "techniques": [],
    "failures": {}
}#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//buffer_multi_update default vs 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
layout(location = 0) in float4 position_vs_input;
out float4 colour_vs_output;
uniform float v_flip;
struct vs_input
{
    float4 position;
};
struct vs_output
{
    float4 position;
    float4 colour;
};
layout (std140) uniform draw_call
{
    float4 pos;
    float4 colour;
};
void main()
{
    //assign vs_input struct from glsl inputs
    vs_input _input;
    _input.position = position_vs_input;
    vs_output _output;
    _output.position = _input.position;
    _output.position.xy += pos.xy;
    _output.colour = colour;
    //assign glsl global outputs from structs
    gl_Position = _output.position;
    gl_Position.y *= v_flip;
    colour_vs_output = _output.colour;
}
{
    "cmdline": "../third_party/pmbuild/scripts/pmfx-shader/build_pmfx.py -shader_platform gles -shader_version 300 -i assets/shaders ../assets/shaders -o build/web/data/pmfx/glsl -h shader_structs -t temp/shaders -v_flip -source ",
    "files": [
        {
            "name": "/Users/alex.dixon/dev/pmtech/third_party/pmbuild/scripts/pmfx-shader/build_pmfx.py",
            "timestamp": 1608637107.3205462
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/third_party/pmbuild/scripts/pmfx-shader/platform/pmfx.h",
            "timestamp": 1605953217.8167121
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/third_party/pmbuild/scripts/pmfx-shader/platform/glsl.h",
            "timestamp": 1608635330.6987193
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/examples/assets/shaders/buffer_multi_update.pmfx",
            "timestamp": 1608572067.1961288
        }
    ],
    "techniques": [
        {
            "vs": "vs_main",
            "ps": "ps_main",
            "name": "default",
            "texture_sampler_bindings": [],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "draw_call",
                    "location": 0
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "colour",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "vs_file": "default.vsc",
            "ps_file": "default.psc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        }
    ],
    "failures": {}
}#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//buffer_multi_update default ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 colour_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 colour;
};
struct ps_output
{
    float4 colour;
};
layout (std140) uniform draw_call
{
    float4 pos;
    float4 colour;
};
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.colour = colour_vs_output;
    ps_output _output;
    _output.colour = _input.colour;
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//basictri default vs 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
layout(location = 0) in float4 position_vs_input;
uniform float v_flip;
struct vs_input
{
    float4 position;
};
struct vs_output
{
    float4 position;
};
void main()
{
    //assign vs_input struct from glsl inputs
    vs_input _input;
    _input.position = position_vs_input;
    vs_output _output;
    _output.position = _input.position;
    //assign glsl global outputs from structs
    gl_Position = _output.position;
    gl_Position.y *= v_flip;
}
{
    "cmdline": "../third_party/pmbuild/scripts/pmfx-shader/build_pmfx.py -shader_platform gles -shader_version 300 -i assets/shaders ../assets/shaders -o build/web/data/pmfx/glsl -h shader_structs -t temp/shaders -v_flip -source ",
    "files": [
        {
            "name": "/Users/alex.dixon/dev/pmtech/third_party/pmbuild/scripts/pmfx-shader/build_pmfx.py",
            "timestamp": 1608637107.3205462
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/third_party/pmbuild/scripts/pmfx-shader/platform/pmfx.h",
            "timestamp": 1605953217.8167121
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/third_party/pmbuild/scripts/pmfx-shader/platform/glsl.h",
            "timestamp": 1608635330.6987193
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/examples/assets/shaders/basictri.pmfx",
            "timestamp": 1608572067.1963584
        }
    ],
    "techniques": [
        {
            "vs": "vs_main",
            "ps": "ps_main",
            "name": "default",
            "texture_sampler_bindings": [],
            "structured_buffers": [],
            "cbuffers": [],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                }
            ],
            "vs_file": "default.vsc",
            "ps_file": "default.psc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        }
    ],
    "failures": {}
}#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//basictri default ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
};
struct ps_output
{
    float4 colour;
};
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    ps_output _output;
    _output.colour = float4( 1.0f, 1.0f, 1.0f, 1.0f );
    {
    }
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//texture_array default vs 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
layout(location = 0) in float4 position_vs_input;
layout(location = 1) in float2 tex_coord_vs_input;
out float2 tex_coord_vs_output;
uniform float v_flip;
struct vs_input
{
    float4 position;
    float2 tex_coord;
};
struct vs_output
{
    float4 position;
    float2 tex_coord;
};
void main()
{
    //assign vs_input struct from glsl inputs
    vs_input _input;
    _input.position = position_vs_input;
    _input.tex_coord = tex_coord_vs_input;
    vs_output _output;
    _output.position = _input.position;
    _output.tex_coord = _input.tex_coord;
    //assign glsl global outputs from structs
    gl_Position = _output.position;
    gl_Position.y *= v_flip;
    tex_coord_vs_output = _output.tex_coord;
}
{
    "cmdline": "../third_party/pmbuild/scripts/pmfx-shader/build_pmfx.py -shader_platform gles -shader_version 300 -i assets/shaders ../assets/shaders -o build/web/data/pmfx/glsl -h shader_structs -t temp/shaders -v_flip -source ",
    "files": [
        {
            "name": "/Users/alex.dixon/dev/pmtech/third_party/pmbuild/scripts/pmfx-shader/build_pmfx.py",
            "timestamp": 1608637107.3205462
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/third_party/pmbuild/scripts/pmfx-shader/platform/pmfx.h",
            "timestamp": 1605953217.8167121
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/third_party/pmbuild/scripts/pmfx-shader/platform/glsl.h",
            "timestamp": 1608635330.6987193
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/examples/assets/shaders/texture_array.pmfx",
            "timestamp": 1608572067.1975849
        }
    ],
    "techniques": [
        {
            "vs": "vs_main",
            "ps": "ps_main",
            "name": "default",
            "texture_sampler_bindings": [
                {
                    "name": "tex_array",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 0
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "time",
                    "location": 0
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "tex_coord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 8,
                    "element_size": 4,
                    "num_elements": 2,
                    "offset": 16
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "tex_coord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 8,
                    "element_size": 4,
                    "num_elements": 2,
                    "offset": 16
                }
            ],
            "vs_file": "default.vsc",
            "ps_file": "default.psc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        }
    ],
    "failures": {}
}#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//texture_array default ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float2 tex_coord_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float2 tex_coord;
};
struct ps_output
{
    float4 colour;
};
layout (std140) uniform time
{
    float4 slice;
};
texture_2d_array( tex_array, 0 );
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.tex_coord = tex_coord_vs_output;
    ps_output _output;
    _output.colour = sample_texture_array(tex_array, _input.tex_coord.xy, slice.x);
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//dynamic_cubemap_sky default vs 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
layout(location = 0) in float4 position_vs_input;
layout(location = 1) in float2 texcoord_vs_input;
out float2 texcoord_vs_output;
uniform float v_flip;
struct vs_input
{
    float4 position;
    float2 texcoord;
};
struct vs_output
{
    float4 position;
    float2 texcoord;
};
void main()
{
    //assign vs_input struct from glsl inputs
    vs_input _input;
    _input.position = position_vs_input;
    _input.texcoord = texcoord_vs_input;
    vs_output _output;
    _output.position = _input.position;
    _output.texcoord = _input.texcoord;
    //assign glsl global outputs from structs
    gl_Position = _output.position;
    gl_Position.y *= v_flip;
    texcoord_vs_output = _output.texcoord;
}
{
    "cmdline": "../third_party/pmbuild/scripts/pmfx-shader/build_pmfx.py -shader_platform gles -shader_version 300 -i assets/shaders ../assets/shaders -o build/web/data/pmfx/glsl -h shader_structs -t temp/shaders -v_flip -source ",
    "files": [
        {
            "name": "/Users/alex.dixon/dev/pmtech/third_party/pmbuild/scripts/pmfx-shader/build_pmfx.py",
            "timestamp": 1608637107.3205462
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/third_party/pmbuild/scripts/pmfx-shader/platform/pmfx.h",
            "timestamp": 1605953217.8167121
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/third_party/pmbuild/scripts/pmfx-shader/platform/glsl.h",
            "timestamp": 1608635330.6987193
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/examples/assets/shaders/dynamic_cubemap_sky.pmfx",
            "timestamp": 1608637372.8785493
        }
    ],
    "techniques": [
        {
            "vs": "vs_main",
            "ps": "ps_main",
            "name": "default",
            "texture_sampler_bindings": [],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "per_pass_view",
                    "location": 0
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "texcoord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 8,
                    "element_size": 4,
                    "num_elements": 2,
                    "offset": 16
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "texcoord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 8,
                    "element_size": 4,
                    "num_elements": 2,
                    "offset": 16
                }
            ],
            "vs_file": "default.vsc",
            "ps_file": "default.psc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        }
    ],
    "failures": {}
}#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//dynamic_cubemap_sky default ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float2 texcoord_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float2 texcoord;
};
struct ps_output
{
    float4 colour;
};
layout (std140) uniform per_pass_view
{
    float4x4 vp_matrix;
    float4x4 view_matrix;
    float4x4 vp_matrix_inverse;
    float4x4 view_matrix_inverse;
    float4 camera_view_pos;
    float4 camera_view_dir;
};
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.texcoord = texcoord_vs_output;
    ps_output _output;
    _output.colour = float4(1.0, 0.0, 1.0, 1.0);
    float2 ndc = _input.texcoord.xy * float2(2.0, 2.0) - float2(1.0, 1.0);
    ndc = remap_ndc_ray(ndc);
    ndc.y *= -1.0;
    float4 near = float4(ndc.x, ndc.y, 0.0, 1.0);
    float4 far = float4(ndc.x, ndc.y, 1.0, 1.0);
    float4 wnear = mul(near, vp_matrix_inverse);
    wnear /= wnear.w;
    float4 wfar = mul(far, vp_matrix_inverse);
    wfar /= wfar.w;
    float3 ray_origin = wnear.xyz;
    float3 ray_dir = normalize(wfar.xyz - wnear.xyz);
    float3 grad_a = float3(0.9, 0.5, 0.0);
    float3 grad_b = float3(0.5, 0.0, 1.0);
    float grad_t = ray_dir.y * 0.5 + 0.5;
    float4 sky = float4(lerp(grad_a, grad_b, grad_t), 1.0);
    _output.colour = sky;
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//imgui_ex tex_volume_sdf ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 colour_vs_output;
in float2 tex_coord_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 colour;
    float2 tex_coord;
};
struct ps_output
{
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform image_ex
{
    float4 colour_mask;
    float4 params;
    float4x4 inverse_wvp;
};
texture_3d( tex_3d, 0 );
float sd_box(float3 p, float3 b)
{
    float3 d = abs(p) - b;
    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
}
void unit_cube_trace(float2 tc, out float3 p, out float3 ro, out float3 rd)
{
    float2 ndc = tc.xy * float2(2.0, 2.0) - float2(1.0, 1.0);
    ndc = remap_ndc_ray(ndc);
    float4 near = float4(ndc.x, ndc.y, 0.0, 1.0);
    float4 far = float4(ndc.x, ndc.y, 1.0, 1.0);
    float4 wnear = mul(near, inverse_wvp);
    wnear /= wnear.w;
    float4 wfar = mul(far, inverse_wvp);
    wfar /= wfar.w;
    ro = wnear.xyz;
    rd = normalize(wfar.xyz - wnear.xyz);
    p = float3(0.0, 0.0, 0.0);
    for(float t = 0.0; t < 10.0;)
    {
        p = ro + rd * t;
        float d = sd_box(p, float3(1.0, 1.0, 1.0));
        if(d < 0.001)
        break;
        t += d;
    }
}
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.colour = colour_vs_output;
    _input.tex_coord = tex_coord_vs_output;
    ps_output _output;
    float3 p, ro, rd;
    unit_cube_trace(_input.tex_coord, p, ro, rd);
    float3 uvw = p * 0.5 + 0.5;
    float3 vddx = ddx( uvw );
    float3 vddy = ddy( uvw );
    float max_samples = 64.0;
    float d = sample_texture_grad(tex_3d, uvw, vddx, vddy).r;
    float3 ray_pos = p.xyz;
    float taken = 0.0;
    for( int s = 0; s < int(max_samples); ++s )
    {
        taken += 1.0/max_samples;
        d = sample_texture_grad(tex_3d, uvw, vddx, vddy).r;
        float3 step = rd.xyz * float3(d, d, d) * 0.01;
        uvw += step;
        if(uvw.x >= 1.0 || uvw.x <= 0.0)
        discard;
        if(uvw.y >= 1.0 || uvw.y <= 0.0)
        discard;
        if(uvw.z >= 1.0 || uvw.z <= 0.0)
        discard;
        if( d <= 0.01 )
        break;
    }
    float vd = (1.0 - d);
    _output.colour.rgb = float3(vd*vd, vd*vd, vd*vd);
    _output.colour.rgb = float3(taken, taken, taken);
    _output.colour.a = 1.0;
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//imgui_ex tex_volume ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 colour_vs_output;
in float2 tex_coord_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 colour;
    float2 tex_coord;
};
struct ps_output
{
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform image_ex
{
    float4 colour_mask;
    float4 params;
    float4x4 inverse_wvp;
};
texture_3d( tex_3d, 0 );
float sd_box(float3 p, float3 b)
{
    float3 d = abs(p) - b;
    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
}
void unit_cube_trace(float2 tc, out float3 p, out float3 ro, out float3 rd)
{
    float2 ndc = tc.xy * float2(2.0, 2.0) - float2(1.0, 1.0);
    ndc = remap_ndc_ray(ndc);
    float4 near = float4(ndc.x, ndc.y, 0.0, 1.0);
    float4 far = float4(ndc.x, ndc.y, 1.0, 1.0);
    float4 wnear = mul(near, inverse_wvp);
    wnear /= wnear.w;
    float4 wfar = mul(far, inverse_wvp);
    wfar /= wfar.w;
    ro = wnear.xyz;
    rd = normalize(wfar.xyz - wnear.xyz);
    p = float3(0.0, 0.0, 0.0);
    for(float t = 0.0; t < 10.0;)
    {
        p = ro + rd * t;
        float d = sd_box(p, float3(1.0, 1.0, 1.0));
        if(d < 0.001)
        break;
        t += d;
    }
}
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.colour = colour_vs_output;
    _input.tex_coord = tex_coord_vs_output;
    ps_output _output;
    float3 p, ro, rd;
    unit_cube_trace(_input.tex_coord, p, ro, rd);
    float3 uvw = p * 0.5 + 0.5;
    float3 vddx = ddx( uvw );
    float3 vddy = ddy( uvw );
    float max_samples = 64.0;
    float d = sample_texture_grad(tex_3d, uvw, vddx, vddy).r;
    float3 ray_pos = p.xyz;
    float taken = 0.0;
    for( int s = 0; s < int(max_samples); ++s )
    {
        taken += 1.0/max_samples;
        d = sample_texture_grad(tex_3d, uvw, vddx, vddy).r;
        float3 step = rd.xyz * float3(d, d, d) * 0.01;
        uvw += step;
        if(uvw.x >= 1.0 || uvw.x <= 0.0)
        discard;
        if(uvw.y >= 1.0 || uvw.y <= 0.0)
        discard;
        if(uvw.z >= 1.0 || uvw.z <= 0.0)
        discard;
        if( d <= 0.01 )
        break;
    }
    float vd = (1.0 - d);
    _output.colour.rgb = float3(vd*vd,vd*vd, vd*vd);
    _output.colour.rgb = float3(taken, taken, taken);
    _output.colour.a = 1.0;
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//imgui_ex tex_cube_array ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 colour_vs_output;
in float2 tex_coord_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 colour;
    float2 tex_coord;
};
struct ps_output
{
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform image_ex
{
    float4 colour_mask;
    float4 params;
    float4x4 inverse_wvp;
};
float sd_sphere(float3 p, float s)
{
    return length(p)-s;
}
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.colour = colour_vs_output;
    _input.tex_coord = tex_coord_vs_output;
    ps_output _output;
    float2 ndc = _input.tex_coord.xy * float2(2.0, 2.0) - float2(1.0, 1.0);
    ndc = remap_ndc_ray(ndc);
    float4 near = float4(ndc.x, ndc.y, 0.0, 1.0);
    float4 far = float4(ndc.x, ndc.y, 1.0, 1.0);
    float4 wnear = mul(near, inverse_wvp);
    wnear /= wnear.w;
    float4 wfar = mul(far, inverse_wvp);
    wfar /= wfar.w;
    float4 col = float4(0.0, 0.0, 0.0, 1.0);
    float3 ro = wnear.xyz;
    float3 rd = normalize(wfar.xyz - wnear.xyz);
    float3 n = float3(0.0, 0.0, 0.0);
    float e = 0.0;
    for(float t = 0.0; t < 10.0;)
    {
        float3 p = ro + rd * t;
        float d = sd_sphere(p, 1.5);
        if(d < 0.001)
        {
            n = normalize(p);
            break;
        }
        if(e > 10.0)
        break;
        e += 1.0;
        t += d;
    }
    float3 r = reflect(rd, n);
    _output.colour = float4(1.0, 0.0, 0.0, 1.0);
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//imgui_ex tex_cube ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 colour_vs_output;
in float2 tex_coord_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 colour;
    float2 tex_coord;
};
struct ps_output
{
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform image_ex
{
    float4 colour_mask;
    float4 params;
    float4x4 inverse_wvp;
};
texture_cube( tex_cube, 0 );
float sd_sphere(float3 p, float s)
{
    return length(p)-s;
}
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.colour = colour_vs_output;
    _input.tex_coord = tex_coord_vs_output;
    ps_output _output;
    float2 ndc = _input.tex_coord.xy * float2(2.0, 2.0) - float2(1.0, 1.0);
    ndc = remap_ndc_ray(ndc);
    float4 near = float4(ndc.x, ndc.y, 0.0, 1.0);
    float4 far = float4(ndc.x, ndc.y, 1.0, 1.0);
    float4 wnear = mul(near, inverse_wvp);
    wnear /= wnear.w;
    float4 wfar = mul(far, inverse_wvp);
    wfar /= wfar.w;
    float4 col = float4(0.0, 0.0, 0.0, 1.0);
    float3 ro = wnear.xyz;
    float3 rd = normalize(wfar.xyz - wnear.xyz);
    float3 n = float3(0.0, 0.0, 0.0);
    float e = 0.0;
    for(float t = 0.0; t < 10.0;)
    {
        float3 p = ro + rd * t;
        float d = sd_sphere(p, 1.5);
        if(d < 0.001)
        {
            n = normalize(p);
            break;
        }
        if(e > 10.0)
        break;
        e += 1.0;
        t += d;
    }
    float3 r = reflect(rd, n);
    _output.colour = sample_texture(tex_cube, rd);
    if(length(n) > 0.0)
    _output.colour = sample_texture(tex_cube, r);
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//imgui_ex tex_2d_array ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 colour_vs_output;
in float2 tex_coord_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 colour;
    float2 tex_coord;
};
struct ps_output
{
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform image_ex
{
    float4 colour_mask;
    float4 params;
    float4x4 inverse_wvp;
};
texture_2d_array( tex_array, 0 );
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.colour = colour_vs_output;
    _input.tex_coord = tex_coord_vs_output;
    ps_output _output;
    _output.colour = float4(0.0, 1.0, 1.0, 1.0);
    _output.colour = sample_texture_array( tex_array, _input.tex_coord.xy, params.y);
    _output.colour *= colour_mask;
    if(length(colour_mask) == 1.0)
    {
        float f = max4(_output.colour);
        _output.colour = float4(f, f, f, 1.0);
    }
    else
    {
        if(colour_mask.a == 0.0)
        _output.colour.a = 1.0;
    }
    _output.colour.rgb = pow(_output.colour.rgb, float3(params.z, params.z, params.z));
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//imgui_ex tex_2d ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 colour_vs_output;
in float2 tex_coord_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 colour;
    float2 tex_coord;
};
struct ps_output
{
    float4 colour;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform image_ex
{
    float4 colour_mask;
    float4 params;
    float4x4 inverse_wvp;
};
texture_2d( tex, 0 );
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.colour = colour_vs_output;
    _input.tex_coord = tex_coord_vs_output;
    ps_output _output;
    _output.colour = float4(0.0, 0.0, 1.0, 1.0);
    if(params.x < 0.0)
    {
        _output.colour = sample_texture( tex, _input.tex_coord.xy );
    }
    else
    {
        _output.colour = sample_texture_level( tex, _input.tex_coord.xy, params.x );
    }
    _output.colour *= colour_mask;
    if(length(colour_mask) == 1.0)
    {
        float f = max4(_output.colour);
        _output.colour = float4(f, f, f, 1.0);
    }
    else
    {
        if(colour_mask.a == 0.0)
        _output.colour.a = 1.0;
    }
    _output.colour.rgb = pow(_output.colour.rgb, float3(params.z, params.z, params.z));
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
{
    "cmdline": "../third_party/pmbuild/scripts/pmfx-shader/build_pmfx.py -shader_platform gles -shader_version 300 -i assets/shaders ../assets/shaders -o build/web/data/pmfx/glsl -h shader_structs -t temp/shaders -v_flip -source ",
    "files": [
        {
            "name": "/Users/alex.dixon/dev/pmtech/third_party/pmbuild/scripts/pmfx-shader/build_pmfx.py",
            "timestamp": 1608637107.3205462
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/third_party/pmbuild/scripts/pmfx-shader/platform/pmfx.h",
            "timestamp": 1605953217.8167121
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/third_party/pmbuild/scripts/pmfx-shader/platform/glsl.h",
            "timestamp": 1608635330.6987193
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/examples/../assets/shaders/imgui_ex.pmfx",
            "timestamp": 1608572067.1982224
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/examples/../assets/shaders/ray_march.pmfx",
            "timestamp": 1608572067.2020185
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/examples/../assets/shaders/libs/globals.pmfx",
            "timestamp": 1608572067.200933
        }
    ],
    "techniques": [
        {
            "vs": "vs_main",
            "ps": "ps_tex_cube",
            "name": "tex_cube",
            "texture_sampler_bindings": [
                {
                    "name": "tex",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "tex_cube",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_cube",
                    "unit": 0
                },
                {
                    "name": "tex_3d",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 0
                },
                {
                    "name": "tex_array",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 0
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "per_pass_vs",
                    "location": 1
                },
                {
                    "name": "image_ex",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 8,
                    "element_size": 4,
                    "num_elements": 2,
                    "offset": 0
                },
                {
                    "name": "tex_coord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 8,
                    "element_size": 4,
                    "num_elements": 2,
                    "offset": 8
                },
                {
                    "name": "colour",
                    "semantic_index": 0,
                    "semantic_id": 7,
                    "size": 4,
                    "element_size": 1,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "colour",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "tex_coord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 8,
                    "element_size": 4,
                    "num_elements": 2,
                    "offset": 32
                }
            ],
            "vs_file": "tex_cube.vsc",
            "ps_file": "tex_cube.psc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        },
        {
            "vs": "vs_main",
            "ps": "ps_tex_volume",
            "name": "tex_volume",
            "texture_sampler_bindings": [
                {
                    "name": "tex",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "tex_cube",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_cube",
                    "unit": 0
                },
                {
                    "name": "tex_3d",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 0
                },
                {
                    "name": "tex_array",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 0
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "per_pass_vs",
                    "location": 1
                },
                {
                    "name": "image_ex",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 8,
                    "element_size": 4,
                    "num_elements": 2,
                    "offset": 0
                },
                {
                    "name": "tex_coord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 8,
                    "element_size": 4,
                    "num_elements": 2,
                    "offset": 8
                },
                {
                    "name": "colour",
                    "semantic_index": 0,
                    "semantic_id": 7,
                    "size": 4,
                    "element_size": 1,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "colour",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "tex_coord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 8,
                    "element_size": 4,
                    "num_elements": 2,
                    "offset": 32
                }
            ],
            "vs_file": "tex_cube.vsc",
            "ps_file": "tex_volume.psc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        },
        {
            "vs": "vs_main",
            "ps": "ps_tex_volume_sdf",
            "name": "tex_volume_sdf",
            "texture_sampler_bindings": [
                {
                    "name": "tex",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "tex_cube",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_cube",
                    "unit": 0
                },
                {
                    "name": "tex_3d",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 0
                },
                {
                    "name": "tex_array",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 0
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "per_pass_vs",
                    "location": 1
                },
                {
                    "name": "image_ex",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 8,
                    "element_size": 4,
                    "num_elements": 2,
                    "offset": 0
                },
                {
                    "name": "tex_coord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 8,
                    "element_size": 4,
                    "num_elements": 2,
                    "offset": 8
                },
                {
                    "name": "colour",
                    "semantic_index": 0,
                    "semantic_id": 7,
                    "size": 4,
                    "element_size": 1,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "colour",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "tex_coord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 8,
                    "element_size": 4,
                    "num_elements": 2,
                    "offset": 32
                }
            ],
            "vs_file": "tex_cube.vsc",
            "ps_file": "tex_volume_sdf.psc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        },
        {
            "vs": "vs_main",
            "ps": "ps_tex_2d",
            "name": "tex_2d",
            "texture_sampler_bindings": [
                {
                    "name": "tex",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "tex_cube",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_cube",
                    "unit": 0
                },
                {
                    "name": "tex_3d",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 0
                },
                {
                    "name": "tex_array",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 0
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "per_pass_vs",
                    "location": 1
                },
                {
                    "name": "image_ex",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 8,
                    "element_size": 4,
                    "num_elements": 2,
                    "offset": 0
                },
                {
                    "name": "tex_coord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 8,
                    "element_size": 4,
                    "num_elements": 2,
                    "offset": 8
                },
                {
                    "name": "colour",
                    "semantic_index": 0,
                    "semantic_id": 7,
                    "size": 4,
                    "element_size": 1,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "colour",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "tex_coord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 8,
                    "element_size": 4,
                    "num_elements": 2,
                    "offset": 32
                }
            ],
            "vs_file": "tex_cube.vsc",
            "ps_file": "tex_2d.psc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        },
        {
            "vs": "vs_main",
            "ps": "ps_tex_2d_array",
            "name": "tex_2d_array",
            "texture_sampler_bindings": [
                {
                    "name": "tex",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "tex_cube",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_cube",
                    "unit": 0
                },
                {
                    "name": "tex_3d",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 0
                },
                {
                    "name": "tex_array",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 0
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "per_pass_vs",
                    "location": 1
                },
                {
                    "name": "image_ex",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 8,
                    "element_size": 4,
                    "num_elements": 2,
                    "offset": 0
                },
                {
                    "name": "tex_coord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 8,
                    "element_size": 4,
                    "num_elements": 2,
                    "offset": 8
                },
                {
                    "name": "colour",
                    "semantic_index": 0,
                    "semantic_id": 7,
                    "size": 4,
                    "element_size": 1,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "colour",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "tex_coord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 8,
                    "element_size": 4,
                    "num_elements": 2,
                    "offset": 32
                }
            ],
            "vs_file": "tex_cube.vsc",
            "ps_file": "tex_2d_array.psc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        },
        {
            "vs": "vs_main",
            "ps": "ps_tex_cube_array",
            "name": "tex_cube_array",
            "texture_sampler_bindings": [
                {
                    "name": "tex",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "tex_cube",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_cube",
                    "unit": 0
                },
                {
                    "name": "tex_3d",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_3d",
                    "unit": 0
                },
                {
                    "name": "tex_array",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d_array",
                    "unit": 0
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_draw_call",
                    "location": 1
                },
                {
                    "name": "per_pass_lights",
                    "location": 3
                },
                {
                    "name": "per_pass_shadow",
                    "location": 4
                },
                {
                    "name": "per_pass_shadow_distance_fields",
                    "location": 5
                },
                {
                    "name": "per_pass_area_lights",
                    "location": 6
                },
                {
                    "name": "cbuffer_single_light",
                    "location": 10
                },
                {
                    "name": "cbuffer_gi_volume",
                    "location": 11
                },
                {
                    "name": "per_pass_vs",
                    "location": 1
                },
                {
                    "name": "image_ex",
                    "location": 7
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 8,
                    "element_size": 4,
                    "num_elements": 2,
                    "offset": 0
                },
                {
                    "name": "tex_coord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 8,
                    "element_size": 4,
                    "num_elements": 2,
                    "offset": 8
                },
                {
                    "name": "colour",
                    "semantic_index": 0,
                    "semantic_id": 7,
                    "size": 4,
                    "element_size": 1,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "colour",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                },
                {
                    "name": "tex_coord",
                    "semantic_index": 1,
                    "semantic_id": 2,
                    "size": 8,
                    "element_size": 4,
                    "num_elements": 2,
                    "offset": 32
                }
            ],
            "vs_file": "tex_cube.vsc",
            "ps_file": "tex_cube_array.psc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        }
    ],
    "failures": {}
}#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//imgui_ex tex_cube vs 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
layout(location = 0) in float2 position_vs_input;
layout(location = 1) in float2 tex_coord_vs_input;
layout(location = 2) in float4 colour_vs_input;
out float4 colour_vs_output;
out float2 tex_coord_vs_output;
uniform float v_flip;
struct vs_input
{
    float2 position;
    float2 tex_coord;
    float4 colour;
};
struct vs_output
{
    float4 position;
    float4 colour;
    float2 tex_coord;
};
struct light_data
{
    float4 pos_radius;
    float4 dir_cutoff;
    float4 colour;
    float4 data;
};
struct distance_field_shadow
{
    float4x4 world_matrix;
    float4x4 world_matrix_inv;
};
struct area_light_data
{
    float4 corners[4];
    float4 colour;
};
layout (std140) uniform per_pass_vs
{
    float4x4 projection_matrix;
};
layout (std140) uniform image_ex
{
    float4 colour_mask;
    float4 params;
    float4x4 inverse_wvp;
};
void main()
{
    //assign vs_input struct from glsl inputs
    vs_input _input;
    _input.position = position_vs_input;
    _input.tex_coord = tex_coord_vs_input;
    _input.colour = colour_vs_input;
    vs_output _output;
    _output.position = mul( float4( _input.position.x, _input.position.y, 0.0f, 1.0f ), projection_matrix );
    _output.colour = _input.colour;
    _output.tex_coord = _input.tex_coord;
    if(params.w > 0.9)
    _output.tex_coord.y = 1.0 - _output.tex_coord.y;
    //assign glsl global outputs from structs
    gl_Position = _output.position;
    gl_Position.y *= v_flip;
    colour_vs_output = _output.colour;
    tex_coord_vs_output = _output.tex_coord;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//msaa_resolve depth_4x ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 tex_coord_vs_output;
uniform float v_flip;
struct vs_output_textured
{
    float4 position;
    float4 tex_coord;
};
struct ps_output_depth
{
    float depth;
};
layout (std140) uniform per_pass
{
    float4 output_buffer_dimension;
};
texture_2dms( float4, 4, texture_msaa_4, 0 );
void main()
{
    //assign vs_output_textured struct from glsl inputs
    vs_output_textured _input;
    _input.tex_coord = tex_coord_vs_output;
    ps_output_depth _output;
    _output.depth = sample_texture_2dms( texture_msaa_4, _input.tex_coord.x * output_buffer_dimension.x, _input.tex_coord.y * output_buffer_dimension.y, 0 ).r;
    _pmfx_unroll
    for( int i = 1; i < 4; ++i )
    {
        float depth = sample_texture_2dms( texture_msaa_4, _input.tex_coord.x * output_buffer_dimension.x, _input.tex_coord.y * output_buffer_dimension.y, i ).r;
        _output.depth = max( depth, _output.depth );
    }
    _output.depth = 0.0;
    //assign glsl global outputs from structs
    depth_ps_output = _output.depth;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//msaa_resolve average_2x vs 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
layout(location = 0) in float4 position_vs_input;
layout(location = 1) in float2 tex_coord_vs_input;
out float4 tex_coord_vs_output;
uniform float v_flip;
struct vs_input_2d_textured
{
    float4 position;
    float2 tex_coord;
};
struct vs_output_textured
{
    float4 position;
    float4 tex_coord;
};
void main()
{
    //assign vs_input_2d_textured struct from glsl inputs
    vs_input_2d_textured _input;
    _input.position = position_vs_input;
    _input.tex_coord = tex_coord_vs_input;
    vs_output_textured _output;
    _output.position = _input.position;
    _output.tex_coord = float4(_input.tex_coord.x, _input.tex_coord.y, 0.0, 0.0);
    //assign glsl global outputs from structs
    gl_Position = _output.position;
    gl_Position.y *= v_flip;
    tex_coord_vs_output = _output.tex_coord;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//msaa_resolve average_16x ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 tex_coord_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output_textured
{
    float4 position;
    float4 tex_coord;
};
struct ps_output
{
    float4 colour;
};
layout (std140) uniform per_pass
{
    float4 output_buffer_dimension;
};
texture_2dms( float4, 16, texture_msaa_16, 0 );
void main()
{
    //assign vs_output_textured struct from glsl inputs
    vs_output_textured _input;
    _input.tex_coord = tex_coord_vs_output;
    ps_output _output;
    _output.colour = float4( 0.0, 0.0, 0.0, 0.0 );
    _pmfx_unroll
    for( int i = 0; i < 16; ++i )
    _output.colour += sample_texture_2dms( texture_msaa_16, _input.tex_coord.x * output_buffer_dimension.x, _input.tex_coord.y * output_buffer_dimension.y, i );
    _output.colour /= 16.0;
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//msaa_resolve average_8x ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 tex_coord_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output_textured
{
    float4 position;
    float4 tex_coord;
};
struct ps_output
{
    float4 colour;
};
layout (std140) uniform per_pass
{
    float4 output_buffer_dimension;
};
texture_2dms( float4, 8, texture_msaa_8, 0 );
void main()
{
    //assign vs_output_textured struct from glsl inputs
    vs_output_textured _input;
    _input.tex_coord = tex_coord_vs_output;
    ps_output _output;
    _output.colour = float4( 0.0, 0.0, 0.0, 0.0 );
    _pmfx_unroll
    for( int i = 0; i < 8; ++i )
    _output.colour += sample_texture_2dms( texture_msaa_8, _input.tex_coord.x * output_buffer_dimension.x, _input.tex_coord.y * output_buffer_dimension.y, i );
    _output.colour /= 8.0;
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//msaa_resolve max_4x ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 tex_coord_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output_textured
{
    float4 position;
    float4 tex_coord;
};
struct ps_output
{
    float4 colour;
};
layout (std140) uniform per_pass
{
    float4 output_buffer_dimension;
};
texture_2dms( float4, 4, texture_msaa_4, 0 );
void main()
{
    //assign vs_output_textured struct from glsl inputs
    vs_output_textured _input;
    _input.tex_coord = tex_coord_vs_output;
    ps_output _output;
    _output.colour.r = sample_texture_2dms( texture_msaa_4, _input.tex_coord.x * output_buffer_dimension.x, _input.tex_coord.y * output_buffer_dimension.y, 0 ).r;
    _pmfx_unroll
    for( int i = 1; i < 4; ++i )
    {
        float depth = sample_texture_2dms( texture_msaa_4, _input.tex_coord.x * output_buffer_dimension.x, _input.tex_coord.y * output_buffer_dimension.y, i ).r;
        _output.colour.r = max( depth, _output.colour.r );
    }
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//msaa_resolve average_4x ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 tex_coord_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output_textured
{
    float4 position;
    float4 tex_coord;
};
struct ps_output
{
    float4 colour;
};
layout (std140) uniform per_pass
{
    float4 output_buffer_dimension;
};
texture_2dms( float4, 4, texture_msaa_4, 0 );
void main()
{
    //assign vs_output_textured struct from glsl inputs
    vs_output_textured _input;
    _input.tex_coord = tex_coord_vs_output;
    ps_output _output;
    _output.colour = float4( 0.0, 0.0, 0.0, 0.0 );
    _pmfx_unroll
    for( int i = 0; i < 4; ++i )
    _output.colour += sample_texture_2dms( texture_msaa_4, _input.tex_coord.x * output_buffer_dimension.x, _input.tex_coord.y * output_buffer_dimension.y, i );
    _output.colour /= 4.0;
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
{
    "cmdline": "../third_party/pmbuild/scripts/pmfx-shader/build_pmfx.py -shader_platform gles -shader_version 300 -i assets/shaders ../assets/shaders -o build/web/data/pmfx/glsl -h shader_structs -t temp/shaders -v_flip -source ",
    "files": [
        {
            "name": "/Users/alex.dixon/dev/pmtech/third_party/pmbuild/scripts/pmfx-shader/build_pmfx.py",
            "timestamp": 1608637107.3205462
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/third_party/pmbuild/scripts/pmfx-shader/platform/pmfx.h",
            "timestamp": 1605953217.8167121
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/third_party/pmbuild/scripts/pmfx-shader/platform/glsl.h",
            "timestamp": 1608635330.6987193
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/examples/../assets/shaders/msaa_resolve.pmfx",
            "timestamp": 1608572067.198992
        }
    ],
    "techniques": [
        {
            "vs": "vs_resolve",
            "ps": "ps_resolve_average_2x",
            "name": "average_2x",
            "texture_sampler_bindings": [
                {
                    "name": "texture_msaa_2",
                    "data_type": "float4",
                    "fragments": "2",
                    "type": "texture_2dms",
                    "unit": 0
                },
                {
                    "name": "texture_msaa_4",
                    "data_type": "float4",
                    "fragments": "4",
                    "type": "texture_2dms",
                    "unit": 0
                },
                {
                    "name": "texture_msaa_8",
                    "data_type": "float4",
                    "fragments": "8",
                    "type": "texture_2dms",
                    "unit": 0
                },
                {
                    "name": "texture_msaa_16",
                    "data_type": "float4",
                    "fragments": "16",
                    "type": "texture_2dms",
                    "unit": 0
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "per_pass",
                    "location": 0
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "tex_coord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 8,
                    "element_size": 4,
                    "num_elements": 2,
                    "offset": 16
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "tex_coord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "vs_file": "average_2x.vsc",
            "ps_file": "average_2x.psc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        },
        {
            "vs": "vs_resolve",
            "ps": "ps_resolve_average_4x",
            "name": "average_4x",
            "texture_sampler_bindings": [
                {
                    "name": "texture_msaa_2",
                    "data_type": "float4",
                    "fragments": "2",
                    "type": "texture_2dms",
                    "unit": 0
                },
                {
                    "name": "texture_msaa_4",
                    "data_type": "float4",
                    "fragments": "4",
                    "type": "texture_2dms",
                    "unit": 0
                },
                {
                    "name": "texture_msaa_8",
                    "data_type": "float4",
                    "fragments": "8",
                    "type": "texture_2dms",
                    "unit": 0
                },
                {
                    "name": "texture_msaa_16",
                    "data_type": "float4",
                    "fragments": "16",
                    "type": "texture_2dms",
                    "unit": 0
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "per_pass",
                    "location": 0
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "tex_coord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 8,
                    "element_size": 4,
                    "num_elements": 2,
                    "offset": 16
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "tex_coord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "vs_file": "average_2x.vsc",
            "ps_file": "average_4x.psc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        },
        {
            "vs": "vs_resolve",
            "ps": "ps_resolve_average_8x",
            "name": "average_8x",
            "texture_sampler_bindings": [
                {
                    "name": "texture_msaa_2",
                    "data_type": "float4",
                    "fragments": "2",
                    "type": "texture_2dms",
                    "unit": 0
                },
                {
                    "name": "texture_msaa_4",
                    "data_type": "float4",
                    "fragments": "4",
                    "type": "texture_2dms",
                    "unit": 0
                },
                {
                    "name": "texture_msaa_8",
                    "data_type": "float4",
                    "fragments": "8",
                    "type": "texture_2dms",
                    "unit": 0
                },
                {
                    "name": "texture_msaa_16",
                    "data_type": "float4",
                    "fragments": "16",
                    "type": "texture_2dms",
                    "unit": 0
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "per_pass",
                    "location": 0
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "tex_coord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 8,
                    "element_size": 4,
                    "num_elements": 2,
                    "offset": 16
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "tex_coord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "vs_file": "average_2x.vsc",
            "ps_file": "average_8x.psc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        },
        {
            "vs": "vs_resolve",
            "ps": "ps_resolve_average_16x",
            "name": "average_16x",
            "texture_sampler_bindings": [
                {
                    "name": "texture_msaa_2",
                    "data_type": "float4",
                    "fragments": "2",
                    "type": "texture_2dms",
                    "unit": 0
                },
                {
                    "name": "texture_msaa_4",
                    "data_type": "float4",
                    "fragments": "4",
                    "type": "texture_2dms",
                    "unit": 0
                },
                {
                    "name": "texture_msaa_8",
                    "data_type": "float4",
                    "fragments": "8",
                    "type": "texture_2dms",
                    "unit": 0
                },
                {
                    "name": "texture_msaa_16",
                    "data_type": "float4",
                    "fragments": "16",
                    "type": "texture_2dms",
                    "unit": 0
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "per_pass",
                    "location": 0
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "tex_coord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 8,
                    "element_size": 4,
                    "num_elements": 2,
                    "offset": 16
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "tex_coord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "vs_file": "average_2x.vsc",
            "ps_file": "average_16x.psc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        },
        {
            "vs": "vs_resolve",
            "ps": "ps_resolve_depth_4x",
            "name": "depth_4x",
            "texture_sampler_bindings": [
                {
                    "name": "texture_msaa_2",
                    "data_type": "float4",
                    "fragments": "2",
                    "type": "texture_2dms",
                    "unit": 0
                },
                {
                    "name": "texture_msaa_4",
                    "data_type": "float4",
                    "fragments": "4",
                    "type": "texture_2dms",
                    "unit": 0
                },
                {
                    "name": "texture_msaa_8",
                    "data_type": "float4",
                    "fragments": "8",
                    "type": "texture_2dms",
                    "unit": 0
                },
                {
                    "name": "texture_msaa_16",
                    "data_type": "float4",
                    "fragments": "16",
                    "type": "texture_2dms",
                    "unit": 0
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "per_pass",
                    "location": 0
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "tex_coord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 8,
                    "element_size": 4,
                    "num_elements": 2,
                    "offset": 16
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "tex_coord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "vs_file": "average_2x.vsc",
            "ps_file": "depth_4x.psc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        },
        {
            "vs": "vs_resolve",
            "ps": "ps_resolve_max_4x",
            "name": "max_4x",
            "texture_sampler_bindings": [
                {
                    "name": "texture_msaa_2",
                    "data_type": "float4",
                    "fragments": "2",
                    "type": "texture_2dms",
                    "unit": 0
                },
                {
                    "name": "texture_msaa_4",
                    "data_type": "float4",
                    "fragments": "4",
                    "type": "texture_2dms",
                    "unit": 0
                },
                {
                    "name": "texture_msaa_8",
                    "data_type": "float4",
                    "fragments": "8",
                    "type": "texture_2dms",
                    "unit": 0
                },
                {
                    "name": "texture_msaa_16",
                    "data_type": "float4",
                    "fragments": "16",
                    "type": "texture_2dms",
                    "unit": 0
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "per_pass",
                    "location": 0
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "tex_coord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 8,
                    "element_size": 4,
                    "num_elements": 2,
                    "offset": 16
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "tex_coord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "vs_file": "average_2x.vsc",
            "ps_file": "max_4x.psc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        },
        {
            "vs": "vs_resolve",
            "ps": "ps_resolve_custom_4x",
            "name": "custom_4x",
            "texture_sampler_bindings": [
                {
                    "name": "texture_msaa_2",
                    "data_type": "float4",
                    "fragments": "2",
                    "type": "texture_2dms",
                    "unit": 0
                },
                {
                    "name": "texture_msaa_4",
                    "data_type": "float4",
                    "fragments": "4",
                    "type": "texture_2dms",
                    "unit": 0
                },
                {
                    "name": "texture_msaa_8",
                    "data_type": "float4",
                    "fragments": "8",
                    "type": "texture_2dms",
                    "unit": 0
                },
                {
                    "name": "texture_msaa_16",
                    "data_type": "float4",
                    "fragments": "16",
                    "type": "texture_2dms",
                    "unit": 0
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "per_pass",
                    "location": 0
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "tex_coord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 8,
                    "element_size": 4,
                    "num_elements": 2,
                    "offset": 16
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "tex_coord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "vs_file": "average_2x.vsc",
            "ps_file": "custom_4x.psc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        }
    ],
    "failures": {}
}#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//msaa_resolve average_2x ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 tex_coord_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output_textured
{
    float4 position;
    float4 tex_coord;
};
struct ps_output
{
    float4 colour;
};
layout (std140) uniform per_pass
{
    float4 output_buffer_dimension;
};
texture_2dms( float4, 2, texture_msaa_2, 0 );
void main()
{
    //assign vs_output_textured struct from glsl inputs
    vs_output_textured _input;
    _input.tex_coord = tex_coord_vs_output;
    ps_output _output;
    _output.colour = float4( 0.0, 0.0, 0.0, 0.0 );
    _pmfx_unroll
    for( int i = 0; i < 2; ++i )
    _output.colour += sample_texture_2dms( texture_msaa_2, _input.tex_coord.x * output_buffer_dimension.x, _input.tex_coord.y * output_buffer_dimension.y, i );
    _output.colour /= 2.0;
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//msaa_resolve custom_4x ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 tex_coord_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output_textured
{
    float4 position;
    float4 tex_coord;
};
struct ps_output
{
    float4 colour;
};
layout (std140) uniform per_pass
{
    float4 output_buffer_dimension;
};
texture_2dms( float4, 4, texture_msaa_4, 0 );
void main()
{
    //assign vs_output_textured struct from glsl inputs
    vs_output_textured _input;
    _input.tex_coord = tex_coord_vs_output;
    ps_output _output;
    _output.colour = float4( 0.0, 0.0, 0.0, 0.0 );
    _pmfx_unroll
    for( int i = 0; i < 4; ++i )
    _output.colour += sample_texture_2dms( texture_msaa_4, _input.tex_coord.x * output_buffer_dimension.x, _input.tex_coord.y * output_buffer_dimension.y, i );
    _output.colour /= 4.0;
    _output.colour.rg += _input.tex_coord.xy;
    _output.colour.rgb = _output.colour.bgr;
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//debug sceen_quad ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 tex_coord_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output_textured
{
    float4 position;
    float4 tex_coord;
};
struct ps_output
{
    float4 colour;
};
texture_2d( texture_0, 0 );
void main()
{
    //assign vs_output_textured struct from glsl inputs
    vs_output_textured _input;
    _input.tex_coord = tex_coord_vs_output;
    ps_output _output;
    _output.colour = sample_texture( texture_0, _input.tex_coord.xy );
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//debug debug_2d ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 colour_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output
{
    float4 position;
    float4 colour;
};
struct ps_output
{
    float4 colour;
};
void main()
{
    //assign vs_output struct from glsl inputs
    vs_output _input;
    _input.colour = colour_vs_output;
    ps_output _output;
    _output.colour = _input.colour;
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//debug sceen_quad_msaa ps 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
in float4 position_vs_output;
in float4 tex_coord_vs_output;
out float4 colour_ps_output;
uniform float v_flip;
struct vs_output_textured
{
    float4 position;
    float4 tex_coord;
};
struct ps_output
{
    float4 colour;
};
texture_2dms( float4, 4, texture_msaa, 1 );
void main()
{
    //assign vs_output_textured struct from glsl inputs
    vs_output_textured _input;
    _input.tex_coord = tex_coord_vs_output;
    ps_output _output;
    _output.colour = sample_texture_2dms( texture_msaa, _input.tex_coord.x * 1280, _input.tex_coord.y * 720, 0 );
    _output.colour += sample_texture_2dms( texture_msaa, _input.tex_coord.x * 1280, _input.tex_coord.y * 720, 1 );
    _output.colour += sample_texture_2dms( texture_msaa, _input.tex_coord.x * 1280, _input.tex_coord.y * 720, 2 );
    _output.colour += sample_texture_2dms( texture_msaa, _input.tex_coord.x * 1280, _input.tex_coord.y * 720, 3 );
    _output.colour /= 4.0;
    //assign glsl global outputs from structs
    colour_ps_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//debug sceen_quad vs 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
layout(location = 0) in float4 position_vs_input;
layout(location = 1) in float2 tex_coord_vs_input;
out float4 tex_coord_vs_output;
uniform float v_flip;
struct vs_input_2d_textured
{
    float4 position;
    float2 tex_coord;
};
struct vs_output_textured
{
    float4 position;
    float4 tex_coord;
};
void main()
{
    //assign vs_input_2d_textured struct from glsl inputs
    vs_input_2d_textured _input;
    _input.position = position_vs_input;
    _input.tex_coord = tex_coord_vs_input;
    vs_output_textured _output;
    _output.position = _input.position;
    _output.tex_coord = float4(_input.tex_coord.x, _input.tex_coord.y, 0.0, 0.0);
    //assign glsl global outputs from structs
    gl_Position = _output.position;
    gl_Position.y *= v_flip;
    tex_coord_vs_output = _output.tex_coord;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//debug debug_2d vs 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
layout(location = 0) in float2 position_vs_input;
layout(location = 1) in float4 colour_vs_input;
out float4 colour_vs_output;
uniform float v_flip;
struct vs_input_2d
{
    float2 position;
    float4 colour;
};
struct vs_output
{
    float4 position;
    float4 colour;
};
layout (std140) uniform per_pass_view_2d
{
    float4x4 projection_matrix;
    float4 user_data;
};
void main()
{
    //assign vs_input_2d struct from glsl inputs
    vs_input_2d _input;
    _input.position = position_vs_input;
    _input.colour = colour_vs_input;
    vs_output _output;
    float4 pos4 = float4( _input.position.x, _input.position.y, 0.0, 1.0);
    pos4 = mul( projection_matrix, pos4 );
    _output.position = pos4;
    _output.colour = _input.colour;
    //assign glsl global outputs from structs
    gl_Position = _output.position;
    gl_Position.y *= v_flip;
    colour_vs_output = _output.colour;
}
#version 300 es
#define GLSL
#define GLES
#define PMFX_TEXTURE_ARRAYS
#define PMFX_TEXTURE_OFFSET 0
//debug debug_3d vs 0
// precision qualifiers
#ifdef GLES
precision highp float;
precision highp sampler2DArray;
precision highp sampler2DArrayShadow;
precision highp sampler2DShadow;
precision highp sampler3D;
precision highp samplerCube;
#endif
// defs
#define float4x4 mat4
#define float3x3 mat3
#define float2x2 mat2
#define float4 vec4
#define float3 vec3
#define float2 vec2
#define uint4 uvec4
#define uint3 uvec3
#define uint2 uvec2
#define int4 ivec4
#define int3 ivec3
#define int2 ivec2
#define modf mod
#define fmod mod
#define frac fract
#define lerp mix
#define mul( A, B ) ((A) * (B))
#define mul_tbn( A, B ) ((B) * (A))
#define saturate( A ) (clamp( A, 0.0, 1.0 ))
#define atan2( A, B ) (atan(A, B))
#define ddx dFdx
#define ddy dFdy
#define _pmfx_unroll
#define _pmfx_loop
// texture location binding is not supported on all glsl version's
#ifdef PMFX_BINDING_POINTS
#if PMFX_TEXTURE_OFFSET
#define _tex_binding(sampler_index) layout(binding = sampler_index + PMFX_TEXTURE_OFFSET)
#define _compute_tex_binding binding(layout_index) = layout_index + PMFX_TEXTURE_OFFSET
#else
#define _tex_binding(sampler_index) layout(binding = sampler_index)
#define _compute_tex_binding(layout_index) binding = layout_index
#endif
#else
#define _tex_binding(sampler_index)
#endif
// textures
#define texture_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2D sampler_name
#define texture_3d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler3D sampler_name
#define texture_cube( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCube sampler_name
#define texture_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArray sampler_name
#define depth_2d( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DShadow sampler_name
#define depth_2d_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DArrayShadow sampler_name
// multisample texture
#ifdef GLES
#define sample_texture_2dms( sampler_name, x, y, fragment ) texture( sampler_name, vec2(0.0, 0.0) )
#define texture_2dms( type, samples, sampler_name, sampler_index ) uniform sampler2D sampler_name
#define texture_cube_array( sampler_name, sampler_index ) uniform int sampler_name
#else
#define sample_texture_2dms( sampler_name, x, y, fragment ) texelFetch( sampler_name, ivec2( x, y ), fragment )
#define texture_2dms( type, samples, sampler_name, sampler_index ) _tex_binding(sampler_index) uniform sampler2DMS sampler_name
#define texture_cube_array( sampler_name, sampler_index ) _tex_binding(sampler_index) uniform samplerCubeArray sampler_name
#endif
// compute
#ifndef GLES
#define texture_2d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2D image_name
#define texture_2d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2D image_name
#define texture_2d_w( image_name, layout_index ) texture2d_rw(image_name, layout_index)
#define texture_3d_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image3D image_name
#define texture_3d_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image3D image_name
#define texture_3d_w( image_name, layout_index ) texture3d_rw(image_name, layout_index)
#define texture_2d_array_rw( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform image2DArray image_name
#define texture_2d_array_r( image_name, layout_index ) layout (_compute_tex_binding(layout_index), rgba8) uniform readonly image2DArray image_name
#define texture_2d_array_w( image_name, layout_index ) texture2d_array_rw(image_name, layout_index)
#define read_texture( image_name, coord ) imageLoad(image_name, coord)
#define write_texture( image_name, value, coord ) imageStore(image_name, coord, value)
#define read_texture_array( image_name, coord, slice ) imageLoad(image_name, ivec3(coord.xy, slice))
#define write_texture_array( image_name, value, coord, slice ) imageStore(image_name, ivec3(coord.xy, slice), value)
#define structured_buffer(type, name, index) layout(std430, binding = index) buffer name { type data[]; };
#endif
// sampler
#define sample_texture( sampler_name, V ) texture( sampler_name, V )
#define sample_texture_level( sampler_name, V, l ) textureLod( sampler_name, V, l )
#define sample_texture_grad( sampler_name, V, vddx, vddy ) textureGrad( sampler_name, V, vddx, vddy )
#define sample_depth_compare( name, tc, compare_value ) texture( name, vec3(tc.xy, compare_value) )
#define sample_texture_array( sampler_name, V, a ) texture( sampler_name, vec3(V, a) )
#define sample_texture_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec3(V, a), l )
#define sample_depth_compare_array( name, tc, a, compare_value ) texture( name, vec4(tc.xy, a, compare_value) )
// cube arrays are not supoorted on webgl / gles 3.0-
#ifdef PMFX_TEXTURE_CUBE_ARRAY
#define sample_texture_cube_array_level( sampler_name, V, a, l ) textureLod( sampler_name, vec4(V, a), l )
#define sample_texture_cube_array( sampler_name, V, a ) texture( sampler_name, vec4(V, a))
#else
#define sample_texture_cube_array_level( sampler_name, V, a, l ) vec4(0.0, 0.0, 0.0, 0.0)
#define sample_texture_cube_array( sampler_name, V, a ) vec4(0.0, 0.0, 0.0, 0.0)
#endif
// matrix
#define to_3x3( M4 ) float3x3(M4)
#define from_columns_3x3(A, B, C) (transpose(float3x3(A, B, C)))
#define from_rows_3x3(A, B, C) (float3x3(A, B, C))
#define unpack_vb_instance_mat( mat, r0, r1, r2, r3 ) mat[0] = r0; mat[1] = r1; mat[2] = r2; mat[3] = r3;
#define to_data_matrix(mat) mat
// clip
#define remap_z_clip_space( d ) d // gl clip space is -1 to 1, and this is normalised device coordinate
#define remap_depth( d ) (d = d * 0.5 + 0.5)
#define remap_ndc_ray( r ) float2(r.x, r.y)
#define depth_ps_output gl_FragDepth
// atomics
#define atomic_load(atomic, original) original = atomicCounter(atomic)
#define atomic_store(atomic, value) atomic = value
#define atomic_increment(atomic, original) original = atomicCounterIncrement(atomic)
#define atomic_decrement(atomic, original) original = atomicCounterDecrement(atomic)
#define atomic_add(atomic, value, original) original = atomicCounterAdd(atomic, value)
#define atomic_subtract(atomic, value, original) original = atomicCounterSubtract(atomic, value)
#define atomic_min(atomic, value, original) original = atomicCounterMin(atomic, value)
#define atomic_max(atomic, value, original) original = atomicCounterMax(atomic, value)
#define atomic_and(atomic, value, original) original = atomicCounterAnd(atomic, value)
#define atomic_or(atomic, value, original) original = atomicCounterOr(atomic, value)
#define atomic_xor(atomic, value, original) original = atomicCounterXor(atomic, value)
#define atomic_exchange(atomic, value, original) original = atomicCounterExchange(atomic, value)
#define chebyshev_normalize( V ) (V.xyz / max( max(abs(V.x), abs(V.y)), abs(V.z) ))
#define max3(v) max(max(v.x, v.y),v.z)
#define max4(v) max(max(max(v.x, v.y),v.z), v.w)
#define PI 3.14159265358979323846264
layout(location = 0) in float4 position_vs_input;
layout(location = 1) in float4 colour_vs_input;
out float4 colour_vs_output;
uniform float v_flip;
struct vs_input_3d
{
    float4 position;
    float4 colour;
};
struct vs_output
{
    float4 position;
    float4 colour;
};
layout (std140) uniform per_pass_view
{
    float4x4 view_projection_matrix;
    float4x4 view_matrix;
};
void main()
{
    //assign vs_input_3d struct from glsl inputs
    vs_input_3d _input;
    _input.position = position_vs_input;
    _input.colour = colour_vs_input;
    vs_output _output;
    _output.position = mul( _input.position, view_projection_matrix );
    _output.colour = _input.colour;
    //assign glsl global outputs from structs
    gl_Position = _output.position;
    gl_Position.y *= v_flip;
    colour_vs_output = _output.colour;
}
{
    "cmdline": "../third_party/pmbuild/scripts/pmfx-shader/build_pmfx.py -shader_platform gles -shader_version 300 -i assets/shaders ../assets/shaders -o build/web/data/pmfx/glsl -h shader_structs -t temp/shaders -v_flip -source ",
    "files": [
        {
            "name": "/Users/alex.dixon/dev/pmtech/third_party/pmbuild/scripts/pmfx-shader/build_pmfx.py",
            "timestamp": 1608637107.3205462
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/third_party/pmbuild/scripts/pmfx-shader/platform/pmfx.h",
            "timestamp": 1605953217.8167121
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/third_party/pmbuild/scripts/pmfx-shader/platform/glsl.h",
            "timestamp": 1608635330.6987193
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/examples/../assets/shaders/debug.pmfx",
            "timestamp": 1608572067.2022042
        }
    ],
    "techniques": [
        {
            "vs": "vs_main_2d",
            "ps": "ps_main",
            "name": "debug_2d",
            "texture_sampler_bindings": [
                {
                    "name": "texture_0",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "texture_msaa",
                    "data_type": "float4",
                    "fragments": "4",
                    "type": "texture_2dms",
                    "unit": 1
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_pass_view_2d",
                    "location": 1
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 8,
                    "element_size": 4,
                    "num_elements": 2,
                    "offset": 0
                },
                {
                    "name": "colour",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 8
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "colour",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "vs_file": "debug_2d.vsc",
            "ps_file": "debug_2d.psc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        },
        {
            "vs": "vs_main_3d",
            "ps": "ps_main",
            "name": "debug_3d",
            "texture_sampler_bindings": [
                {
                    "name": "texture_0",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "texture_msaa",
                    "data_type": "float4",
                    "fragments": "4",
                    "type": "texture_2dms",
                    "unit": 1
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_pass_view_2d",
                    "location": 1
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "colour",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "colour",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "vs_file": "debug_3d.vsc",
            "ps_file": "debug_2d.psc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        },
        {
            "vs": "vs_main_screen_quad",
            "ps": "ps_main_screen_quad",
            "name": "sceen_quad",
            "texture_sampler_bindings": [
                {
                    "name": "texture_0",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "texture_msaa",
                    "data_type": "float4",
                    "fragments": "4",
                    "type": "texture_2dms",
                    "unit": 1
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_pass_view_2d",
                    "location": 1
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "tex_coord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 8,
                    "element_size": 4,
                    "num_elements": 2,
                    "offset": 16
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "tex_coord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "vs_file": "sceen_quad.vsc",
            "ps_file": "sceen_quad.psc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        },
        {
            "vs": "vs_main_screen_quad",
            "ps": "ps_main_screen_quad_msaa",
            "name": "sceen_quad_msaa",
            "texture_sampler_bindings": [
                {
                    "name": "texture_0",
                    "data_type": "float4",
                    "fragments": 1,
                    "type": "texture_2d",
                    "unit": 0
                },
                {
                    "name": "texture_msaa",
                    "data_type": "float4",
                    "fragments": "4",
                    "type": "texture_2dms",
                    "unit": 1
                }
            ],
            "structured_buffers": [],
            "cbuffers": [
                {
                    "name": "per_pass_view",
                    "location": 0
                },
                {
                    "name": "per_pass_view_2d",
                    "location": 1
                }
            ],
            "vs_inputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 1,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "tex_coord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 8,
                    "element_size": 4,
                    "num_elements": 2,
                    "offset": 16
                }
            ],
            "instance_inputs": [],
            "vs_outputs": [
                {
                    "name": "position",
                    "semantic_index": 0,
                    "semantic_id": 0,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 0
                },
                {
                    "name": "tex_coord",
                    "semantic_index": 0,
                    "semantic_id": 2,
                    "size": 16,
                    "element_size": 4,
                    "num_elements": 4,
                    "offset": 16
                }
            ],
            "vs_file": "sceen_quad.vsc",
            "ps_file": "sceen_quad_msaa.psc",
            "permutations": {},
            "permutation_id": 0,
            "permutation_option_mask": 0
        }
    ],
    "failures": {}
}            1                                                                                                                                                                                                                                                                     (   @   @   @   @   4   4         0                            `              light_4n0M           floor[8   cube=T   default_material$}   wall_l>/   wall_rP   pillar_1y>   pillar_2Q   pillar_3   pillar_4AQx	   bunny.objKc
   sdf_shadowQ@c   volume_sdf_materialy)n   light_1kZ   tyra.obj   light_2l   node_13ro
   cubestack1Mg   cubestackshape1N}4   redchecker01_mat

   cubestack2d   cubestackshape2um   bluechecker01_matd
   cubestack3tc   cubestackshape3V
   singlecube:|   singlecubeshape>(   singlesphere-:   singlesphereshape'   sphere1U   cylinder   light_3'	   primitivef   data/models/bunny.pmmG9   data/models/tyra.pmm<R   data/models/TestGeometryNew.pmm_   forward_renderA)   forward_litS    data/textures/sdf-shadow-128.ddsdg!   data/textures/defaults/albedo.ddsB   wrap_linear2.!   data/textures/defaults/normal.ddsz   data/textures/defaults/spec.dds{F0    data/textures/defaults/black.dds`   data/textures/redchecker01.dds"v{   data/textures/bluechecker01.dds(K   model_viewer_camera^}%   volume_rasteriser_camera?   ^}%0g AA                  ?  pB(?=  zD(	B^}%0g AA                  ?  pB(?=  zD(	B?                              ?    9?          pB                                                                                                                                                     (       (       (       (       (       (       (       (                       (                       (       *       *       (       (              (       (               n0M[8>/Py>QAQxKcQ@ckZl    Mgdtc:|-:    1U'    =T=T=T=T=T=T=T:)=T    {sy        ts.ZO*    1U        $}$}$}$}$}$}$}$}        $}        bis"bis"bis    $}$}      `          `          `          `          `  	      0  `  	      P  `  	      p  `  	        `  
        `          `           `  	         `        P  `          `          `          `          `           `          `        @  `        `  `  	        `          `          `          `           `           `        @  `        `  `          `          `  
        `          `          `  	      0  `        `  `          `          `          `          `         #  `           `        P  `        p  `  	        `          `        @#  `        `#  `        #  `        #  `        #  `        #  `         #  `         #  `        @#  `          `        `#  `        @  `        p  `        #  `        #  `        #  `        #  `         #  `        0  `        @#  `        `#  `          `                                    	   
                                        @  @  pA              ?  ?  ?  ?                        ?  pA  ?  pA  @  @                 ?   A  @  ?   A  @   @              ?  ?  @   A    ?                ?  ?  ?  ?  @  ?                ?   @   @   @  @  @@  @              ?   @  @@   @    ?  @              ?  @@  ?  @@@4@      B4    ^no?  ?  ?  ?      @                 ?33SA33SA33SA  p  @@AA              ?  ?  ?  ?k@m/    ;q|?    *>  ?  ?  ?g  ?|A              ?  ?  ?  ?                                        R0@"w@    }    p?  ?  ?  ?      ?jJ     X>    ~<z?  ?  ?  ?      ?        <>    <p?  ?  ?  ?`-w0@@    }    p?  ?  ?  ?`-w0_@r@    }    p?  ?  ?  ?                                         @@U@@              ?  ?  ?  ?>Um@@@T@              ?   ?   ?   ?  @?              ?  ?  ?  ?  ?        ]@      ?      @          ?  pA              ?  pA                  ?                pA                  ?   A          @      @      @          ?                 ?  ?           A      @      @           A   @              ?  ?                ?      ?          ?                ?   @          @       @      ?           @                ?   @          @      @@      @@           @  @              ?  @@                ?      ?          @@  @              ???    y)@      ?    4@y)?    ??                ?33SA                33SA      @        33SA                 ?  ?          p      ?      @@          ?FA              ?<q    ~>      ?    k@~    <qm/              ?  ?              ?      ?          ?8A              ?                                                                oD?    $R      ?    0@$?    oD?"w@              ?j4i?    3>          ?      ?3    j4i?jJ              ?B?    %?          ?      ?%    B?                  ?oD?    $`-w      ?    0@$?    oD?@              ?oD?    $`-w      ?    0_@$?    oD?r@              ?                                                                  ?         @@      ?    U@          ?@              ?   ?        >Um@       ?    @@           ?T@              ?  ?              ?      @          ?&?              ?  ?        ]@      ?      @          ?  pA              ?  pA                  ?                pA                  ?   A          @      @      @          ?                 ?  ?           A      @      @           A   @              ?  ?                ?      ?          ?                ?   @          @       @      ?           @                ?   @          @      @@      @@           @  @              ?  @@                ?      ?          @@  @              ???    y)@      ?    4@y)?    ??                ?33SA                33SA      @        33SA                 ?  ?          p      ?      @@          ?FA              ?<q    ~>      ?    k@~    <qm/              ?  ?              ?      ?          ?8A              ?                                                                oD?    $R      ?    0@$?    oD?"w@              ?v?    y      ?    0_@>    v?Kj@              ?w$h?    >y      ?    @    w$h?Kj@              ?oD?    $`-w      ?    0@$?    oD?@              ?oD?    $`-w      ?    0_@$?    oD?r@              ?                                                                  ?         @@      ?    U@          ?@              ?   ?        >Um@       ?    @@           ?T@              ?  ?              ?      @          ?&?              ?                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ?  ?  ?t@  @@  `A]@  @  A?        ?  ?  ?  p     p  pA      pAA        ?  ?  ?  0      0  @  `A  P*A        ?  ?  ?  A        0A  `A   AP*A        ?  ?  ?          `  @@  `F&@        ?  ?  ?  @@      @  @   @        ?  ?  ?  @@      @@  @  @  @{@        ?  ?  ?          @      @   A|@g5|e.?X/@?q@Y~@^P@@S5LJ@        ?  ?  ?33Sff33[33SAA33KAA        ?  ?  ?     @FA  `  @FA?S\Wo*xW?(?
@]T@?@~dT05@SA@        ?  ?  ?    8A	w   @8A?                                                                ?   ?   ?A`?l@@?@L@?            ?   ?   ?i0?@l@@?@@ax?            ?   ?   ?i0@l@@?@@3?            ?   ?   ?`?&@J0?@F9@?          ?   ?  ?0?@2@J0@*@?                                                            ?  ?  ? @@U@(Y@ @@U@@?        ?  ?  ?>UM@@@T@@@@T@]?        ?  ?  ?  @LlS?  @4@?   _w?{HF?>B            ?     ?.;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ?      ?B            ?     ?.;                                                             ?!?    B            ?     ?.;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ?    p>B            ?     ?.;                                                                                                                                                                                                                                                                                                                                                                                                                                        7   8   $        P                           7   8   $        P                           7   8   $        P                           7   8   $        P                           7   8   $        P                           7   8   $        P                           7   8   $        P                             / /   P                                                                                                                             '	 '	   P                                                                                                                             $   $     P                             $   $     P                             $   $     P                             $   $     P                                   P                                                                           ;   <          P                           9   :      B     P                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               pb   r                              ?                                                                                                                                                                                                                                                                                                                                                                                                                                                    pb   r                              ?                                                                                                                                                                                                                                                                                                                                                                                                                                                    pb   r                              ?                                                                                                                    pb   r                              ?                                                                                                                    pb   r                              ?                                                                                                                    pb   r                              ?                                                                                                                    pb   r                              ?                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              G                                                                                                                                                                                                                 pA                  ?                pA                  ?  ?                            =               ?              =        ?     ?   A          @      @      @          ?                 ?   @                               >             %I>                ?    >     A  ?  ?           A      @      @           A   @              ?  @@                              ?             %I>                 >            ?  ?                ?      ?          ?                ?  @                            *?             *?              *?   UUU@  UUU@  ?   @          @       @      ?           @                ?  @                               ?             >              >         @  ?   @          @      @@      @@           @  @              ?  @                               ?             >                 ?             ?  @@                ?      ?          @@  @              ?  @                            >               ?              >   UU?  UU  ???    y)@      ?    4@y)?    ??                ?   A                            ??   y)        ?       y)?   ??   I4q@  ?33SA                33SA      @        33SA                 ?  A                            &=             &=              &=      &=  ?                                                                                                                                                                <q    ~>      ?    k@~    <qm/              ?  0A                            8q   {>         ?       {   8q   Wkk  ?                                                                                                                                                                                                                                                                                                                                oD?    $R      ?    0@$?    oD?"w@              ?  `A                            mD?   $        ?       $?   mD?    @0[  ?v?    y      ?    0_@>    v?Kj@              ?  pA                            v?           ?       >   v?   @/_`"  ?w$h?    >y      ?    @    w$h?Kj@              ?  A                            w$h?   >        ?          w$h?   t@$(  ?oD?    $`-w      ?    0@$?    oD?@              ?  A                            mD?   $        ?       $?   mD?   o0  ?oD?    $`-w      ?    0_@$?    oD?r@              ?  A                            mD?   $        ?       $?   mD?   wd/_`  ?                                                                                                                                                                  ?         @@      ?    U@          ?@              ?  A                              ?               ?                ?    @U  ?   ?        >Um@       ?    @@           ?T@              ?  A                               @                @                 @   >U@PTH  ?                                                                                                                                                                        
                  0              H             `   0          x   H             `             x                             	                  
        (                 8           (             (    (          h                P             h                                    (                                        (                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ?  ?  ?  ?   ?   ?>                                                                                                                                                                                                                                      ?  ?  ?  ?   ?   ?>                                                                                                                                                                                                                                      ?  ?  ?  ?   ?   ?>                                                                                                                                                                                                                                      ?  ?  ?  ?   ?   ?>                                                                                                                                                                                                                                      ?  ?  ?  ?   ?   ?>                                                                                                                                                                                                                                      ?  ?  ?  ?   ?   ?>                                                                                                                                                                                                                                      ?  ?  ?  ?   ?   ?>                                                                                                                                                                                                                                    >      ?  ?+>   ?>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    t>  ?      ?aP?>>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ?  ?  ?  ?   ?   ?>                                                                                                                                                                                                                                      ?  ?  ?  ?   ?   ?>                                                                                                                                                                                                                                      ?  ?  ?  ?   ?   ?>                                                                                                                                                                                                                                      ?  ?  ?  ?   ?   ?>                                                                                                                                                                                                                                      ?  ?  ?  ?   ?   ?>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ?    >  ?E=2,?>                                                                                                                                                                                                                                    >z?E8? ?<  ?=lG?>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    $}    @V$  `          `           ?   ?   ?   ?   ?   ?   ?   ?   mA?  A?    B  @@FB?       I?  ??    FB?A?     ??@?          @@                                                                                                                A)Sxxxxxx3   4   5   6   $}     S$  `           `           ?   ?   ?   ?   ?   ?   ?   ?   mA?  A?    B  @@FB?       I?  ??    FB?A?     ??@?          @@                                                                                                                A)Sxxxxxx3   4   5   6   $}     S$  `          `           ?   ?   ?   ?   ?   ?   ?   ?   mA?  A?    B  @@FB?       I?  ??    FB?A?     ??@?          @@                                                                                                                A)Sxxxxxx3   4   5   6   $}    `U$  `        `  `           ?   ?   ?   ?   ?   ?   ?   ?   mA?  A?    B  @@FB?       I?  ??    FB?A?     ??@?          @@                                                                                                                A)Sxxxxxx3   4   5   6   $}    V$  `        @  `           ?   ?   ?   ?   ?   ?   ?   ?   mA?  A?    B  @@FB?       I?  ??    FB?A?     ??@?          @@                                                                                                                A)Sxxxxxx3   4   5   6   $}     V$  `        p  `           ?   ?   ?   ?   ?   ?   ?   ?   mA?  A?    B  @@FB?       I?  ??    FB?A?     ??@?          @@                                                                                                                A)Sxxxxxx3   4   5   6   $}    `V$  `          `           ?   ?   ?   ?   ?   ?   ?   ?   mA?  A?    B  @@FB?       I?  ??    FB?A?     ??@?          @@                                                                                                                A)Sxxxxxx3   4   5   6   $}     C$  `        `  `           ?   ?   ?   ?   ?   ?   ?   ?   mA?  A?    B  @@FB?       I?  ??    FB?A?     ??@?          @@                                                                                                                A)Sxxxxxx3   4   5   6           @[ `         /  `        alex.dixon/dev/pmtech/examples/../tools/build_shaders.py",
            "timestamp": 1532548831.2847075
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/examples/../tools/_shader_macros.h",
            "timestamp": 1526939666.7142532
 .6xxxx7   x                                                                                                                                                                                                                                                                                                                                                                                       $}     T$  `        P  `           ?   ?   ?   ?   ?   ?   ?   ?   mA?  A?    B  @@FB?       I?  ??    FB?A?     ??@?          @@                                                                                                                A)Sxxxxxx3   4   5   6                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   bis     V$  `          `          ?  ?  ?BA   ?   ?   ?   ?                                                                                                                                                                                                                                A)Sxxxxxx  4   5   5   6   6   "    `T$  `          `          ?  ?  ?  A   ?   ?   ?   ?847075
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/examples/../tools/_shader_macros.h",
            "timestamp": 1526939666.7142532
        },
        {
            "name": "/Users/alex.dixon/dev/pA)Sxxxxxx  4   5   5   6   6   bis    `R$  `          `          ?  ?  ?BA   ?   ?   ?   ?                                                                                                                                                                                                                                A)Sxxxxxx  4   5   5   6   6   "     U$  `          `          ?  ?  ?  A   ?   ?   ?   ?847075
        },
        {
            "name": "/Users/alex.dixon/dev/pmtech/examples/../tools/_shader_macros.h",
            "timestamp": 1526939666.7142532
        },
        {
            "name": "/Users/alex.dixon/dev/pA)Sxxxxxx  4   5   5   6   6   bis    R$  `          `          ?  ?  ?BA   ?   ?   ?   ?                                                                                                                                                                                                                                A)Sxxxxxx  4   5   5   6   6                                                                                                                                                                                                                                                                                                                                                                   $}    @R$  `          `           ?   ?   ?   ?   ?   ?   ?   ?   mA?  A?    B  @@FB?       I?  ??    FB?A?     ??@?          @@                                                                                                                A)Sxxxxxx3   4   5   6   $}    Q$  `          `           ?   ?   ?   ?   ?   ?   ?   ?   mA?  A?    B  @@FB?       I?  ??    FB?A?     ??@?          @@                                                                                                                A)Sxxxxxx3   4   5   6                                                                                                                                                                                                                                                                                                                                                                                                                                             J                                                                                                                                                                                                                                                                                                           B2.3       J   0  z2.4      J   0  {F02.5      J   0  `2.6      J   0                                                                                                  B2.3       J   0  z2.4      J   0  {F02.5      J   0  `2.6      J   0                                                                                                  B2.3       J   0  z2.4      J   0  {F02.5      J   0  `2.6      J   0                                                                                                  B2.3       J   0  z2.4      J   0  {F02.5      J   0  `2.6      J   0                                                                                                  B2.3       J   0  z2.4      J   0  {F02.5      J   0  `2.6      J   0                                                                                                  B2.3       J   0  z2.4      J   0  {F02.5      J   0  `2.6      J   0                                                                                                  B2.3       J   0  z2.4      J   0  {F02.5      J   0  `2.6      J   0                                                                                                  B2.3       J   0  z2.4      J   0  {F02.5      J   0  `2.6      J   0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  B2.3       J   0  z2.4      J   0  {F02.5      J   0  `2.6      J   0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  "v{2.      J   0  z2.4      J   0  {F02.5      J   0  {F02.5      J   0                                                                                                  (K2.      J   0  z2.4      J   0  {F02.5      J   0  {F02.5      J   0                                                                                                  "v{2.      J   0  z2.4      J   0  {F02.5      J   0  {F02.5      J   0                                                                                                  (K2.      J   0  z2.4      J   0  {F02.5      J   0  {F02.5      J   0                                                                                                  "v{2.      J   0  z2.4      J   0  {F02.5      J   0  {F02.5      J   0                                                                                                                                                                                                                                                                                                  B2.3       J   0  z2.4      J   0  {F02.5      J   0  `2.6      J   0                                                                                                  B2.3       J   0  z2.4      J   0  {F02.5      J   0  `2.6      J   0                                                                                                                                                                                                                                                                                                                                                                              n0M        [8=T$}>/=T$}P=T$}y>=T$}Q=T$}=T$}AQx=T$}KcKc$}Q@c    y)nkZ        $}l        ro        MgN}4
dumdtcV
:|>(d-:'
            1U1U$}$}'           f=T   f=T   f=T   f=T   f=T   f=T   f=T    G9Kc    <R    _N}4    _um    _V    _>(    _'   f1U   f                                                                                            $}A)S$}A)S$}A)S$}A)S$}A)S$}A)S$}A)S$}A)S$}A)S
A)SdA)S
A)SdA)S
A)S$}A)S$}A)SdgB2.z2.{F02.`2.                                B2.z2.{F02.`2.                                B2.z2.{F02.`2.                                B2.z2.{F02.`2.                                B2.z2.{F02.`2.                                B2.z2.{F02.`2.                                B2.z2.{F02.`2.                                B2.z2.{F02.`2.                                B2.z2.{F02.`2.                                "v{2.z2.{F02.{F02.                                (K2.z2.{F02.{F02.                                "v{2.z2.{F02.{F02.                                (K2.z2.{F02.{F02.                                "v{2.z2.{F02.{F02.                                B2.z2.{F02.`2.                                B2.z2.{F02.`2.                                ^}%^}%?   	      #          #                                                                                                                                                                                                                                                              (   @   @   @   @   4   4         0                            `           (   (   (         lucy.objTy|   winged_victoryr   default_material$}   data/models/lucy.pmmQ   forward_renderA)   forward_litS!   data/textures/defaults/albedo.ddsB   wrap_linear2.!   data/textures/defaults/normal.ddsz   data/textures/defaults/spec.dds{F0    data/textures/defaults/black.dds`           volume_rasteriser_camera?   ?                              ?                  pB      )       Ty|*$}Py   `  	       z   `        $  `                                      ?L=L=L=L=                L=                L=                  ?L=                L=                L=                  ?                                                                                                                                WN=pBnC1HaBUpyz%;&&@uA94@BA                                                                    P   ~         P                                               0U p  
.                               ?                                                                                                                                                      L=                L=                L=                  ?                                  A               A                A               ?        l                           ?  ?  ?  ?   ?>pec.dds                                                                                                                                                                                                                                 $}     $  `        v   `           ?   ?   ?   ?   ?   ?   ?   ?        }
            ]                  size": 4,
                    "num_elements": 2,
                    "offset": 16
                }
            ] ze": 4,
            |    um_elements": 2,
                    "A)S2.2.2.2.2.2.<   =   >   ?                   B2.<       f      z2.=      f      {F02.>      f      `2.?      f                                                                                                                                    ?  ?  ?  ?                                                                                    Ty|r$}    Qr    $}A)SB2.z2.{F02.`2.                                ?